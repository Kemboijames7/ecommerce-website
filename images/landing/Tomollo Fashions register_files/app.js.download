(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // vendor/topbar.js
  var require_topbar = __commonJS({
    "vendor/topbar.js"(exports, module) {
      (function(window2, document2) {
        "use strict";
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x = 0; x < vendors.length && !window2.requestAnimationFrame; ++x) {
            window2.requestAnimationFrame = window2[vendors[x] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x] + "CancelAnimationFrame"] || window2[vendors[x] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame)
            window2.requestAnimationFrame = function(callback2, element) {
              var currTime = (/* @__PURE__ */ new Date()).getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = window2.setTimeout(function() {
                callback2(currTime + timeToCall);
              }, timeToCall);
              lastTime = currTime + timeToCall;
              return id;
            };
          if (!window2.cancelAnimationFrame)
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
        })();
        var canvas, currentProgress, showing, progressTimerId = null, fadeTimerId = null, delayTimerId = null, addEvent = function(elem, type, handler) {
          if (elem.addEventListener)
            elem.addEventListener(type, handler, false);
          else if (elem.attachEvent)
            elem.attachEvent("on" + type, handler);
          else
            elem["on" + type] = handler;
        }, options = {
          autoRun: true,
          barThickness: 3,
          barColors: {
            0: "rgba(26,  188, 156, .9)",
            ".25": "rgba(52,  152, 219, .9)",
            ".50": "rgba(241, 196, 15,  .9)",
            ".75": "rgba(230, 126, 34,  .9)",
            "1.0": "rgba(211, 84,  0,   .9)"
          },
          shadowBlur: 10,
          shadowColor: "rgba(0,   0,   0,   .6)",
          className: null
        }, repaint = function() {
          canvas.width = window2.innerWidth;
          canvas.height = options.barThickness * 5;
          var ctx = canvas.getContext("2d");
          ctx.shadowBlur = options.shadowBlur;
          ctx.shadowColor = options.shadowColor;
          var lineGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          for (var stop in options.barColors)
            lineGradient.addColorStop(stop, options.barColors[stop]);
          ctx.lineWidth = options.barThickness;
          ctx.beginPath();
          ctx.moveTo(0, options.barThickness / 2);
          ctx.lineTo(
            Math.ceil(currentProgress * canvas.width),
            options.barThickness / 2
          );
          ctx.strokeStyle = lineGradient;
          ctx.stroke();
        }, createCanvas = function() {
          canvas = document2.createElement("canvas");
          var style = canvas.style;
          style.position = "fixed";
          style.top = style.left = style.right = style.margin = style.padding = 0;
          style.zIndex = 100001;
          style.display = "none";
          if (options.className)
            canvas.classList.add(options.className);
          document2.body.appendChild(canvas);
          addEvent(window2, "resize", repaint);
        }, topbar2 = {
          config: function(opts) {
            for (var key in opts)
              if (options.hasOwnProperty(key))
                options[key] = opts[key];
          },
          show: function(delay) {
            if (showing)
              return;
            if (delay) {
              if (delayTimerId)
                return;
              delayTimerId = setTimeout(() => topbar2.show(), delay);
            } else {
              showing = true;
              if (fadeTimerId !== null)
                window2.cancelAnimationFrame(fadeTimerId);
              if (!canvas)
                createCanvas();
              canvas.style.opacity = 1;
              canvas.style.display = "block";
              topbar2.progress(0);
              if (options.autoRun) {
                (function loop() {
                  progressTimerId = window2.requestAnimationFrame(loop);
                  topbar2.progress(
                    "+" + 0.05 * Math.pow(1 - Math.sqrt(currentProgress), 2)
                  );
                })();
              }
            }
          },
          progress: function(to2) {
            if (typeof to2 === "undefined")
              return currentProgress;
            if (typeof to2 === "string") {
              to2 = (to2.indexOf("+") >= 0 || to2.indexOf("-") >= 0 ? currentProgress : 0) + parseFloat(to2);
            }
            currentProgress = to2 > 1 ? 1 : to2;
            repaint();
            return currentProgress;
          },
          hide: function() {
            clearTimeout(delayTimerId);
            delayTimerId = null;
            if (!showing)
              return;
            showing = false;
            if (progressTimerId != null) {
              window2.cancelAnimationFrame(progressTimerId);
              progressTimerId = null;
            }
            (function loop() {
              if (topbar2.progress("+.1") >= 1) {
                canvas.style.opacity -= 0.05;
                if (canvas.style.opacity <= 0.05) {
                  canvas.style.display = "none";
                  fadeTimerId = null;
                  return;
                }
              }
              fadeTimerId = window2.requestAnimationFrame(loop);
            })();
          }
        };
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = topbar2;
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            return topbar2;
          });
        } else {
          this.topbar = topbar2;
        }
      }).call(exports, window, document);
    }
  });

  // ../deps/phoenix_html/priv/static/phoenix_html.js
  (function() {
    var PolyfillEvent = eventConstructor();
    function eventConstructor() {
      if (typeof window.CustomEvent === "function")
        return window.CustomEvent;
      function CustomEvent2(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: void 0 };
        var evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      }
      CustomEvent2.prototype = window.Event.prototype;
      return CustomEvent2;
    }
    function buildHiddenInput(name, value) {
      var input = document.createElement("input");
      input.type = "hidden";
      input.name = name;
      input.value = value;
      return input;
    }
    function handleClick(element, targetModifierKey) {
      var to2 = element.getAttribute("data-to"), method = buildHiddenInput("_method", element.getAttribute("data-method")), csrf = buildHiddenInput("_csrf_token", element.getAttribute("data-csrf")), form = document.createElement("form"), submit = document.createElement("input"), target = element.getAttribute("target");
      form.method = element.getAttribute("data-method") === "get" ? "get" : "post";
      form.action = to2;
      form.style.display = "none";
      if (target)
        form.target = target;
      else if (targetModifierKey)
        form.target = "_blank";
      form.appendChild(csrf);
      form.appendChild(method);
      document.body.appendChild(form);
      submit.type = "submit";
      form.appendChild(submit);
      submit.click();
    }
    window.addEventListener("click", function(e) {
      var element = e.target;
      if (e.defaultPrevented)
        return;
      while (element && element.getAttribute) {
        var phoenixLinkEvent = new PolyfillEvent("phoenix.link.click", {
          "bubbles": true,
          "cancelable": true
        });
        if (!element.dispatchEvent(phoenixLinkEvent)) {
          e.preventDefault();
          e.stopImmediatePropagation();
          return false;
        }
        if (element.getAttribute("data-method") && element.getAttribute("data-to")) {
          handleClick(element, e.metaKey || e.shiftKey);
          e.preventDefault();
          return false;
        } else {
          element = element.parentNode;
        }
      }
    }, false);
    window.addEventListener("phoenix.link.click", function(e) {
      var message = e.target.getAttribute("data-confirm");
      if (message && !window.confirm(message)) {
        e.preventDefault();
      }
    }, false);
  })();

  // ../deps/phoenix/priv/static/phoenix.mjs
  var closure = (value) => {
    if (typeof value === "function") {
      return value;
    } else {
      let closure22 = function() {
        return value;
      };
      return closure22;
    }
  };
  var globalSelf = typeof self !== "undefined" ? self : null;
  var phxWindow = typeof window !== "undefined" ? window : null;
  var global = globalSelf || phxWindow || global;
  var DEFAULT_VSN = "2.0.0";
  var SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };
  var DEFAULT_TIMEOUT = 1e4;
  var WS_CLOSE_NORMAL = 1e3;
  var CHANNEL_STATES = {
    closed: "closed",
    errored: "errored",
    joined: "joined",
    joining: "joining",
    leaving: "leaving"
  };
  var CHANNEL_EVENTS = {
    close: "phx_close",
    error: "phx_error",
    join: "phx_join",
    reply: "phx_reply",
    leave: "phx_leave"
  };
  var TRANSPORTS = {
    longpoll: "longpoll",
    websocket: "websocket"
  };
  var XHR_STATES = {
    complete: 4
  };
  var Push = class {
    constructor(channel, event, payload, timeout) {
      this.channel = channel;
      this.event = event;
      this.payload = payload || function() {
        return {};
      };
      this.receivedResp = null;
      this.timeout = timeout;
      this.timeoutTimer = null;
      this.recHooks = [];
      this.sent = false;
    }
    /**
     *
     * @param {number} timeout
     */
    resend(timeout) {
      this.timeout = timeout;
      this.reset();
      this.send();
    }
    /**
     *
     */
    send() {
      if (this.hasReceived("timeout")) {
        return;
      }
      this.startTimeout();
      this.sent = true;
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload(),
        ref: this.ref,
        join_ref: this.channel.joinRef()
      });
    }
    /**
     *
     * @param {*} status
     * @param {*} callback
     */
    receive(status, callback2) {
      if (this.hasReceived(status)) {
        callback2(this.receivedResp.response);
      }
      this.recHooks.push({ status, callback: callback2 });
      return this;
    }
    /**
     * @private
     */
    reset() {
      this.cancelRefEvent();
      this.ref = null;
      this.refEvent = null;
      this.receivedResp = null;
      this.sent = false;
    }
    /**
     * @private
     */
    matchReceive({ status, response, _ref }) {
      this.recHooks.filter((h) => h.status === status).forEach((h) => h.callback(response));
    }
    /**
     * @private
     */
    cancelRefEvent() {
      if (!this.refEvent) {
        return;
      }
      this.channel.off(this.refEvent);
    }
    /**
     * @private
     */
    cancelTimeout() {
      clearTimeout(this.timeoutTimer);
      this.timeoutTimer = null;
    }
    /**
     * @private
     */
    startTimeout() {
      if (this.timeoutTimer) {
        this.cancelTimeout();
      }
      this.ref = this.channel.socket.makeRef();
      this.refEvent = this.channel.replyEventName(this.ref);
      this.channel.on(this.refEvent, (payload) => {
        this.cancelRefEvent();
        this.cancelTimeout();
        this.receivedResp = payload;
        this.matchReceive(payload);
      });
      this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout);
    }
    /**
     * @private
     */
    hasReceived(status) {
      return this.receivedResp && this.receivedResp.status === status;
    }
    /**
     * @private
     */
    trigger(status, response) {
      this.channel.trigger(this.refEvent, { status, response });
    }
  };
  var Timer = class {
    constructor(callback2, timerCalc) {
      this.callback = callback2;
      this.timerCalc = timerCalc;
      this.timer = null;
      this.tries = 0;
    }
    reset() {
      this.tries = 0;
      clearTimeout(this.timer);
    }
    /**
     * Cancels any previous scheduleTimeout and schedules callback
     */
    scheduleTimeout() {
      clearTimeout(this.timer);
      this.timer = setTimeout(() => {
        this.tries = this.tries + 1;
        this.callback();
      }, this.timerCalc(this.tries + 1));
    }
  };
  var Channel = class {
    constructor(topic, params, socket) {
      this.state = CHANNEL_STATES.closed;
      this.topic = topic;
      this.params = closure(params || {});
      this.socket = socket;
      this.bindings = [];
      this.bindingRef = 0;
      this.timeout = this.socket.timeout;
      this.joinedOnce = false;
      this.joinPush = new Push(this, CHANNEL_EVENTS.join, this.params, this.timeout);
      this.pushBuffer = [];
      this.stateChangeRefs = [];
      this.rejoinTimer = new Timer(() => {
        if (this.socket.isConnected()) {
          this.rejoin();
        }
      }, this.socket.rejoinAfterMs);
      this.stateChangeRefs.push(this.socket.onError(() => this.rejoinTimer.reset()));
      this.stateChangeRefs.push(
        this.socket.onOpen(() => {
          this.rejoinTimer.reset();
          if (this.isErrored()) {
            this.rejoin();
          }
        })
      );
      this.joinPush.receive("ok", () => {
        this.state = CHANNEL_STATES.joined;
        this.rejoinTimer.reset();
        this.pushBuffer.forEach((pushEvent) => pushEvent.send());
        this.pushBuffer = [];
      });
      this.joinPush.receive("error", () => {
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.onClose(() => {
        this.rejoinTimer.reset();
        if (this.socket.hasLogger())
          this.socket.log("channel", `close ${this.topic} ${this.joinRef()}`);
        this.state = CHANNEL_STATES.closed;
        this.socket.remove(this);
      });
      this.onError((reason) => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `error ${this.topic}`, reason);
        if (this.isJoining()) {
          this.joinPush.reset();
        }
        this.state = CHANNEL_STATES.errored;
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.joinPush.receive("timeout", () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `timeout ${this.topic} (${this.joinRef()})`, this.joinPush.timeout);
        let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), this.timeout);
        leavePush.send();
        this.state = CHANNEL_STATES.errored;
        this.joinPush.reset();
        if (this.socket.isConnected()) {
          this.rejoinTimer.scheduleTimeout();
        }
      });
      this.on(CHANNEL_EVENTS.reply, (payload, ref) => {
        this.trigger(this.replyEventName(ref), payload);
      });
    }
    /**
     * Join the channel
     * @param {integer} timeout
     * @returns {Push}
     */
    join(timeout = this.timeout) {
      if (this.joinedOnce) {
        throw new Error("tried to join multiple times. 'join' can only be called a single time per channel instance");
      } else {
        this.timeout = timeout;
        this.joinedOnce = true;
        this.rejoin();
        return this.joinPush;
      }
    }
    /**
     * Hook into channel close
     * @param {Function} callback
     */
    onClose(callback2) {
      this.on(CHANNEL_EVENTS.close, callback2);
    }
    /**
     * Hook into channel errors
     * @param {Function} callback
     */
    onError(callback2) {
      return this.on(CHANNEL_EVENTS.error, (reason) => callback2(reason));
    }
    /**
     * Subscribes on channel events
     *
     * Subscription returns a ref counter, which can be used later to
     * unsubscribe the exact event listener
     *
     * @example
     * const ref1 = channel.on("event", do_stuff)
     * const ref2 = channel.on("event", do_other_stuff)
     * channel.off("event", ref1)
     * // Since unsubscription, do_stuff won't fire,
     * // while do_other_stuff will keep firing on the "event"
     *
     * @param {string} event
     * @param {Function} callback
     * @returns {integer} ref
     */
    on(event, callback2) {
      let ref = this.bindingRef++;
      this.bindings.push({ event, ref, callback: callback2 });
      return ref;
    }
    /**
     * Unsubscribes off of channel events
     *
     * Use the ref returned from a channel.on() to unsubscribe one
     * handler, or pass nothing for the ref to unsubscribe all
     * handlers for the given event.
     *
     * @example
     * // Unsubscribe the do_stuff handler
     * const ref1 = channel.on("event", do_stuff)
     * channel.off("event", ref1)
     *
     * // Unsubscribe all handlers from event
     * channel.off("event")
     *
     * @param {string} event
     * @param {integer} ref
     */
    off(event, ref) {
      this.bindings = this.bindings.filter((bind) => {
        return !(bind.event === event && (typeof ref === "undefined" || ref === bind.ref));
      });
    }
    /**
     * @private
     */
    canPush() {
      return this.socket.isConnected() && this.isJoined();
    }
    /**
     * Sends a message `event` to phoenix with the payload `payload`.
     * Phoenix receives this in the `handle_in(event, payload, socket)`
     * function. if phoenix replies or it times out (default 10000ms),
     * then optionally the reply can be received.
     *
     * @example
     * channel.push("event")
     *   .receive("ok", payload => console.log("phoenix replied:", payload))
     *   .receive("error", err => console.log("phoenix errored", err))
     *   .receive("timeout", () => console.log("timed out pushing"))
     * @param {string} event
     * @param {Object} payload
     * @param {number} [timeout]
     * @returns {Push}
     */
    push(event, payload, timeout = this.timeout) {
      payload = payload || {};
      if (!this.joinedOnce) {
        throw new Error(`tried to push '${event}' to '${this.topic}' before joining. Use channel.join() before pushing events`);
      }
      let pushEvent = new Push(this, event, function() {
        return payload;
      }, timeout);
      if (this.canPush()) {
        pushEvent.send();
      } else {
        pushEvent.startTimeout();
        this.pushBuffer.push(pushEvent);
      }
      return pushEvent;
    }
    /** Leaves the channel
     *
     * Unsubscribes from server events, and
     * instructs channel to terminate on server
     *
     * Triggers onClose() hooks
     *
     * To receive leave acknowledgements, use the `receive`
     * hook to bind to the server ack, ie:
     *
     * @example
     * channel.leave().receive("ok", () => alert("left!") )
     *
     * @param {integer} timeout
     * @returns {Push}
     */
    leave(timeout = this.timeout) {
      this.rejoinTimer.reset();
      this.joinPush.cancelTimeout();
      this.state = CHANNEL_STATES.leaving;
      let onClose = () => {
        if (this.socket.hasLogger())
          this.socket.log("channel", `leave ${this.topic}`);
        this.trigger(CHANNEL_EVENTS.close, "leave");
      };
      let leavePush = new Push(this, CHANNEL_EVENTS.leave, closure({}), timeout);
      leavePush.receive("ok", () => onClose()).receive("timeout", () => onClose());
      leavePush.send();
      if (!this.canPush()) {
        leavePush.trigger("ok", {});
      }
      return leavePush;
    }
    /**
     * Overridable message hook
     *
     * Receives all events for specialized message handling
     * before dispatching to the channel callbacks.
     *
     * Must return the payload, modified or unmodified
     * @param {string} event
     * @param {Object} payload
     * @param {integer} ref
     * @returns {Object}
     */
    onMessage(_event, payload, _ref) {
      return payload;
    }
    /**
     * @private
     */
    isMember(topic, event, payload, joinRef) {
      if (this.topic !== topic) {
        return false;
      }
      if (joinRef && joinRef !== this.joinRef()) {
        if (this.socket.hasLogger())
          this.socket.log("channel", "dropping outdated message", { topic, event, payload, joinRef });
        return false;
      } else {
        return true;
      }
    }
    /**
     * @private
     */
    joinRef() {
      return this.joinPush.ref;
    }
    /**
     * @private
     */
    rejoin(timeout = this.timeout) {
      if (this.isLeaving()) {
        return;
      }
      this.socket.leaveOpenTopic(this.topic);
      this.state = CHANNEL_STATES.joining;
      this.joinPush.resend(timeout);
    }
    /**
     * @private
     */
    trigger(event, payload, ref, joinRef) {
      let handledPayload = this.onMessage(event, payload, ref, joinRef);
      if (payload && !handledPayload) {
        throw new Error("channel onMessage callbacks must return the payload, modified or unmodified");
      }
      let eventBindings = this.bindings.filter((bind) => bind.event === event);
      for (let i = 0; i < eventBindings.length; i++) {
        let bind = eventBindings[i];
        bind.callback(handledPayload, ref, joinRef || this.joinRef());
      }
    }
    /**
     * @private
     */
    replyEventName(ref) {
      return `chan_reply_${ref}`;
    }
    /**
     * @private
     */
    isClosed() {
      return this.state === CHANNEL_STATES.closed;
    }
    /**
     * @private
     */
    isErrored() {
      return this.state === CHANNEL_STATES.errored;
    }
    /**
     * @private
     */
    isJoined() {
      return this.state === CHANNEL_STATES.joined;
    }
    /**
     * @private
     */
    isJoining() {
      return this.state === CHANNEL_STATES.joining;
    }
    /**
     * @private
     */
    isLeaving() {
      return this.state === CHANNEL_STATES.leaving;
    }
  };
  var Ajax = class {
    static request(method, endPoint, accept, body, timeout, ontimeout, callback2) {
      if (global.XDomainRequest) {
        let req = new global.XDomainRequest();
        return this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback2);
      } else {
        let req = new global.XMLHttpRequest();
        return this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback2);
      }
    }
    static xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback2) {
      req.timeout = timeout;
      req.open(method, endPoint);
      req.onload = () => {
        let response = this.parseJSON(req.responseText);
        callback2 && callback2(response);
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.onprogress = () => {
      };
      req.send(body);
      return req;
    }
    static xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback2) {
      req.open(method, endPoint, true);
      req.timeout = timeout;
      req.setRequestHeader("Content-Type", accept);
      req.onerror = () => callback2 && callback2(null);
      req.onreadystatechange = () => {
        if (req.readyState === XHR_STATES.complete && callback2) {
          let response = this.parseJSON(req.responseText);
          callback2(response);
        }
      };
      if (ontimeout) {
        req.ontimeout = ontimeout;
      }
      req.send(body);
      return req;
    }
    static parseJSON(resp) {
      if (!resp || resp === "") {
        return null;
      }
      try {
        return JSON.parse(resp);
      } catch (e) {
        console && console.log("failed to parse JSON response", resp);
        return null;
      }
    }
    static serialize(obj, parentKey) {
      let queryStr = [];
      for (var key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) {
          continue;
        }
        let paramKey = parentKey ? `${parentKey}[${key}]` : key;
        let paramVal = obj[key];
        if (typeof paramVal === "object") {
          queryStr.push(this.serialize(paramVal, paramKey));
        } else {
          queryStr.push(encodeURIComponent(paramKey) + "=" + encodeURIComponent(paramVal));
        }
      }
      return queryStr.join("&");
    }
    static appendParams(url, params) {
      if (Object.keys(params).length === 0) {
        return url;
      }
      let prefix = url.match(/\?/) ? "&" : "?";
      return `${url}${prefix}${this.serialize(params)}`;
    }
  };
  var arrayBufferToBase64 = (buffer) => {
    let binary = "";
    let bytes = new Uint8Array(buffer);
    let len = bytes.byteLength;
    for (let i = 0; i < len; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  };
  var LongPoll = class {
    constructor(endPoint) {
      this.endPoint = null;
      this.token = null;
      this.skipHeartbeat = true;
      this.reqs = /* @__PURE__ */ new Set();
      this.awaitingBatchAck = false;
      this.currentBatch = null;
      this.currentBatchTimer = null;
      this.batchBuffer = [];
      this.onopen = function() {
      };
      this.onerror = function() {
      };
      this.onmessage = function() {
      };
      this.onclose = function() {
      };
      this.pollEndpoint = this.normalizeEndpoint(endPoint);
      this.readyState = SOCKET_STATES.connecting;
      setTimeout(() => this.poll(), 0);
    }
    normalizeEndpoint(endPoint) {
      return endPoint.replace("ws://", "http://").replace("wss://", "https://").replace(new RegExp("(.*)/" + TRANSPORTS.websocket), "$1/" + TRANSPORTS.longpoll);
    }
    endpointURL() {
      return Ajax.appendParams(this.pollEndpoint, { token: this.token });
    }
    closeAndRetry(code, reason, wasClean) {
      this.close(code, reason, wasClean);
      this.readyState = SOCKET_STATES.connecting;
    }
    ontimeout() {
      this.onerror("timeout");
      this.closeAndRetry(1005, "timeout", false);
    }
    isActive() {
      return this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting;
    }
    poll() {
      this.ajax("GET", "application/json", null, () => this.ontimeout(), (resp) => {
        if (resp) {
          var { status, token, messages } = resp;
          this.token = token;
        } else {
          status = 0;
        }
        switch (status) {
          case 200:
            messages.forEach((msg) => {
              setTimeout(() => this.onmessage({ data: msg }), 0);
            });
            this.poll();
            break;
          case 204:
            this.poll();
            break;
          case 410:
            this.readyState = SOCKET_STATES.open;
            this.onopen({});
            this.poll();
            break;
          case 403:
            this.onerror(403);
            this.close(1008, "forbidden", false);
            break;
          case 0:
          case 500:
            this.onerror(500);
            this.closeAndRetry(1011, "internal server error", 500);
            break;
          default:
            throw new Error(`unhandled poll status ${status}`);
        }
      });
    }
    // we collect all pushes within the current event loop by
    // setTimeout 0, which optimizes back-to-back procedural
    // pushes against an empty buffer
    send(body) {
      if (typeof body !== "string") {
        body = arrayBufferToBase64(body);
      }
      if (this.currentBatch) {
        this.currentBatch.push(body);
      } else if (this.awaitingBatchAck) {
        this.batchBuffer.push(body);
      } else {
        this.currentBatch = [body];
        this.currentBatchTimer = setTimeout(() => {
          this.batchSend(this.currentBatch);
          this.currentBatch = null;
        }, 0);
      }
    }
    batchSend(messages) {
      this.awaitingBatchAck = true;
      this.ajax("POST", "application/x-ndjson", messages.join("\n"), () => this.onerror("timeout"), (resp) => {
        this.awaitingBatchAck = false;
        if (!resp || resp.status !== 200) {
          this.onerror(resp && resp.status);
          this.closeAndRetry(1011, "internal server error", false);
        } else if (this.batchBuffer.length > 0) {
          this.batchSend(this.batchBuffer);
          this.batchBuffer = [];
        }
      });
    }
    close(code, reason, wasClean) {
      for (let req of this.reqs) {
        req.abort();
      }
      this.readyState = SOCKET_STATES.closed;
      let opts = Object.assign({ code: 1e3, reason: void 0, wasClean: true }, { code, reason, wasClean });
      this.batchBuffer = [];
      clearTimeout(this.currentBatchTimer);
      this.currentBatchTimer = null;
      if (typeof CloseEvent !== "undefined") {
        this.onclose(new CloseEvent("close", opts));
      } else {
        this.onclose(opts);
      }
    }
    ajax(method, contentType, body, onCallerTimeout, callback2) {
      let req;
      let ontimeout = () => {
        this.reqs.delete(req);
        onCallerTimeout();
      };
      req = Ajax.request(method, this.endpointURL(), contentType, body, this.timeout, ontimeout, (resp) => {
        this.reqs.delete(req);
        if (this.isActive()) {
          callback2(resp);
        }
      });
      this.reqs.add(req);
    }
  };
  var serializer_default = {
    HEADER_LENGTH: 1,
    META_LENGTH: 4,
    KINDS: { push: 0, reply: 1, broadcast: 2 },
    encode(msg, callback2) {
      if (msg.payload.constructor === ArrayBuffer) {
        return callback2(this.binaryEncode(msg));
      } else {
        let payload = [msg.join_ref, msg.ref, msg.topic, msg.event, msg.payload];
        return callback2(JSON.stringify(payload));
      }
    },
    decode(rawPayload, callback2) {
      if (rawPayload.constructor === ArrayBuffer) {
        return callback2(this.binaryDecode(rawPayload));
      } else {
        let [join_ref, ref, topic, event, payload] = JSON.parse(rawPayload);
        return callback2({ join_ref, ref, topic, event, payload });
      }
    },
    // private
    binaryEncode(message) {
      let { join_ref, ref, event, topic, payload } = message;
      let metaLength = this.META_LENGTH + join_ref.length + ref.length + topic.length + event.length;
      let header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);
      let view = new DataView(header);
      let offset = 0;
      view.setUint8(offset++, this.KINDS.push);
      view.setUint8(offset++, join_ref.length);
      view.setUint8(offset++, ref.length);
      view.setUint8(offset++, topic.length);
      view.setUint8(offset++, event.length);
      Array.from(join_ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(ref, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(topic, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      Array.from(event, (char) => view.setUint8(offset++, char.charCodeAt(0)));
      var combined = new Uint8Array(header.byteLength + payload.byteLength);
      combined.set(new Uint8Array(header), 0);
      combined.set(new Uint8Array(payload), header.byteLength);
      return combined.buffer;
    },
    binaryDecode(buffer) {
      let view = new DataView(buffer);
      let kind = view.getUint8(0);
      let decoder = new TextDecoder();
      switch (kind) {
        case this.KINDS.push:
          return this.decodePush(buffer, view, decoder);
        case this.KINDS.reply:
          return this.decodeReply(buffer, view, decoder);
        case this.KINDS.broadcast:
          return this.decodeBroadcast(buffer, view, decoder);
      }
    },
    decodePush(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let topicSize = view.getUint8(2);
      let eventSize = view.getUint8(3);
      let offset = this.HEADER_LENGTH + this.META_LENGTH - 1;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: joinRef, ref: null, topic, event, payload: data };
    },
    decodeReply(buffer, view, decoder) {
      let joinRefSize = view.getUint8(1);
      let refSize = view.getUint8(2);
      let topicSize = view.getUint8(3);
      let eventSize = view.getUint8(4);
      let offset = this.HEADER_LENGTH + this.META_LENGTH;
      let joinRef = decoder.decode(buffer.slice(offset, offset + joinRefSize));
      offset = offset + joinRefSize;
      let ref = decoder.decode(buffer.slice(offset, offset + refSize));
      offset = offset + refSize;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      let payload = { status: event, response: data };
      return { join_ref: joinRef, ref, topic, event: CHANNEL_EVENTS.reply, payload };
    },
    decodeBroadcast(buffer, view, decoder) {
      let topicSize = view.getUint8(1);
      let eventSize = view.getUint8(2);
      let offset = this.HEADER_LENGTH + 2;
      let topic = decoder.decode(buffer.slice(offset, offset + topicSize));
      offset = offset + topicSize;
      let event = decoder.decode(buffer.slice(offset, offset + eventSize));
      offset = offset + eventSize;
      let data = buffer.slice(offset, buffer.byteLength);
      return { join_ref: null, ref: null, topic, event, payload: data };
    }
  };
  var Socket = class {
    constructor(endPoint, opts = {}) {
      this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };
      this.channels = [];
      this.sendBuffer = [];
      this.ref = 0;
      this.timeout = opts.timeout || DEFAULT_TIMEOUT;
      this.transport = opts.transport || global.WebSocket || LongPoll;
      this.primaryPassedHealthCheck = false;
      this.longPollFallbackMs = opts.longPollFallbackMs;
      this.fallbackTimer = null;
      this.sessionStore = opts.sessionStorage || global && global.sessionStorage;
      this.establishedConnections = 0;
      this.defaultEncoder = serializer_default.encode.bind(serializer_default);
      this.defaultDecoder = serializer_default.decode.bind(serializer_default);
      this.closeWasClean = false;
      this.binaryType = opts.binaryType || "arraybuffer";
      this.connectClock = 1;
      if (this.transport !== LongPoll) {
        this.encode = opts.encode || this.defaultEncoder;
        this.decode = opts.decode || this.defaultDecoder;
      } else {
        this.encode = this.defaultEncoder;
        this.decode = this.defaultDecoder;
      }
      let awaitingConnectionOnPageShow = null;
      if (phxWindow && phxWindow.addEventListener) {
        phxWindow.addEventListener("pagehide", (_e) => {
          if (this.conn) {
            this.disconnect();
            awaitingConnectionOnPageShow = this.connectClock;
          }
        });
        phxWindow.addEventListener("pageshow", (_e) => {
          if (awaitingConnectionOnPageShow === this.connectClock) {
            awaitingConnectionOnPageShow = null;
            this.connect();
          }
        });
      }
      this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 3e4;
      this.rejoinAfterMs = (tries) => {
        if (opts.rejoinAfterMs) {
          return opts.rejoinAfterMs(tries);
        } else {
          return [1e3, 2e3, 5e3][tries - 1] || 1e4;
        }
      };
      this.reconnectAfterMs = (tries) => {
        if (opts.reconnectAfterMs) {
          return opts.reconnectAfterMs(tries);
        } else {
          return [10, 50, 100, 150, 200, 250, 500, 1e3, 2e3][tries - 1] || 5e3;
        }
      };
      this.logger = opts.logger || null;
      if (!this.logger && opts.debug) {
        this.logger = (kind, msg, data) => {
          console.log(`${kind}: ${msg}`, data);
        };
      }
      this.longpollerTimeout = opts.longpollerTimeout || 2e4;
      this.params = closure(opts.params || {});
      this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`;
      this.vsn = opts.vsn || DEFAULT_VSN;
      this.heartbeatTimeoutTimer = null;
      this.heartbeatTimer = null;
      this.pendingHeartbeatRef = null;
      this.reconnectTimer = new Timer(() => {
        this.teardown(() => this.connect());
      }, this.reconnectAfterMs);
    }
    /**
     * Returns the LongPoll transport reference
     */
    getLongPollTransport() {
      return LongPoll;
    }
    /**
     * Disconnects and replaces the active transport
     *
     * @param {Function} newTransport - The new transport class to instantiate
     *
     */
    replaceTransport(newTransport) {
      this.connectClock++;
      this.closeWasClean = true;
      clearTimeout(this.fallbackTimer);
      this.reconnectTimer.reset();
      if (this.conn) {
        this.conn.close();
        this.conn = null;
      }
      this.transport = newTransport;
    }
    /**
     * Returns the socket protocol
     *
     * @returns {string}
     */
    protocol() {
      return location.protocol.match(/^https/) ? "wss" : "ws";
    }
    /**
     * The fully qualified socket url
     *
     * @returns {string}
     */
    endPointURL() {
      let uri = Ajax.appendParams(
        Ajax.appendParams(this.endPoint, this.params()),
        { vsn: this.vsn }
      );
      if (uri.charAt(0) !== "/") {
        return uri;
      }
      if (uri.charAt(1) === "/") {
        return `${this.protocol()}:${uri}`;
      }
      return `${this.protocol()}://${location.host}${uri}`;
    }
    /**
     * Disconnects the socket
     *
     * See https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes for valid status codes.
     *
     * @param {Function} callback - Optional callback which is called after socket is disconnected.
     * @param {integer} code - A status code for disconnection (Optional).
     * @param {string} reason - A textual description of the reason to disconnect. (Optional)
     */
    disconnect(callback2, code, reason) {
      this.connectClock++;
      this.closeWasClean = true;
      clearTimeout(this.fallbackTimer);
      this.reconnectTimer.reset();
      this.teardown(callback2, code, reason);
    }
    /**
     *
     * @param {Object} params - The params to send when connecting, for example `{user_id: userToken}`
     *
     * Passing params to connect is deprecated; pass them in the Socket constructor instead:
     * `new Socket("/socket", {params: {user_id: userToken}})`.
     */
    connect(params) {
      if (params) {
        console && console.log("passing params to connect is deprecated. Instead pass :params to the Socket constructor");
        this.params = closure(params);
      }
      if (this.conn) {
        return;
      }
      if (this.longPollFallbackMs && this.transport !== LongPoll) {
        this.connectWithFallback(LongPoll, this.longPollFallbackMs);
      } else {
        this.transportConnect();
      }
    }
    /**
     * Logs the message. Override `this.logger` for specialized logging. noops by default
     * @param {string} kind
     * @param {string} msg
     * @param {Object} data
     */
    log(kind, msg, data) {
      this.logger && this.logger(kind, msg, data);
    }
    /**
     * Returns true if a logger has been set on this socket.
     */
    hasLogger() {
      return this.logger !== null;
    }
    /**
     * Registers callbacks for connection open events
     *
     * @example socket.onOpen(function(){ console.info("the socket was opened") })
     *
     * @param {Function} callback
     */
    onOpen(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.open.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection close events
     * @param {Function} callback
     */
    onClose(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.close.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection error events
     *
     * @example socket.onError(function(error){ alert("An error occurred") })
     *
     * @param {Function} callback
     */
    onError(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.error.push([ref, callback2]);
      return ref;
    }
    /**
     * Registers callbacks for connection message events
     * @param {Function} callback
     */
    onMessage(callback2) {
      let ref = this.makeRef();
      this.stateChangeCallbacks.message.push([ref, callback2]);
      return ref;
    }
    /**
     * Pings the server and invokes the callback with the RTT in milliseconds
     * @param {Function} callback
     *
     * Returns true if the ping was pushed or false if unable to be pushed.
     */
    ping(callback2) {
      if (!this.isConnected()) {
        return false;
      }
      let ref = this.makeRef();
      let startTime = Date.now();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref });
      let onMsgRef = this.onMessage((msg) => {
        if (msg.ref === ref) {
          this.off([onMsgRef]);
          callback2(Date.now() - startTime);
        }
      });
      return true;
    }
    /**
     * @private
     */
    transportConnect() {
      this.connectClock++;
      this.closeWasClean = false;
      this.conn = new this.transport(this.endPointURL());
      this.conn.binaryType = this.binaryType;
      this.conn.timeout = this.longpollerTimeout;
      this.conn.onopen = () => this.onConnOpen();
      this.conn.onerror = (error) => this.onConnError(error);
      this.conn.onmessage = (event) => this.onConnMessage(event);
      this.conn.onclose = (event) => this.onConnClose(event);
    }
    getSession(key) {
      return this.sessionStore && this.sessionStore.getItem(key);
    }
    storeSession(key, val) {
      this.sessionStore && this.sessionStore.setItem(key, val);
    }
    connectWithFallback(fallbackTransport, fallbackThreshold = 2500) {
      clearTimeout(this.fallbackTimer);
      let established = false;
      let primaryTransport = true;
      let openRef, errorRef;
      let fallback = (reason) => {
        this.log("transport", `falling back to ${fallbackTransport.name}...`, reason);
        this.off([openRef, errorRef]);
        primaryTransport = false;
        this.replaceTransport(fallbackTransport);
        this.transportConnect();
      };
      if (this.getSession(`phx:fallback:${fallbackTransport.name}`)) {
        return fallback("memorized");
      }
      this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
      errorRef = this.onError((reason) => {
        this.log("transport", "error", reason);
        if (primaryTransport && !established) {
          clearTimeout(this.fallbackTimer);
          fallback(reason);
        }
      });
      this.onOpen(() => {
        established = true;
        if (!primaryTransport) {
          if (!this.primaryPassedHealthCheck) {
            this.storeSession(`phx:fallback:${fallbackTransport.name}`, "true");
          }
          return this.log("transport", `established ${fallbackTransport.name} fallback`);
        }
        clearTimeout(this.fallbackTimer);
        this.fallbackTimer = setTimeout(fallback, fallbackThreshold);
        this.ping((rtt) => {
          this.log("transport", "connected to primary after", rtt);
          this.primaryPassedHealthCheck = true;
          clearTimeout(this.fallbackTimer);
        });
      });
      this.transportConnect();
    }
    clearHeartbeats() {
      clearTimeout(this.heartbeatTimer);
      clearTimeout(this.heartbeatTimeoutTimer);
    }
    onConnOpen() {
      if (this.hasLogger())
        this.log("transport", `${this.transport.name} connected to ${this.endPointURL()}`);
      this.closeWasClean = false;
      this.establishedConnections++;
      this.flushSendBuffer();
      this.reconnectTimer.reset();
      this.resetHeartbeat();
      this.stateChangeCallbacks.open.forEach(([, callback2]) => callback2());
    }
    /**
     * @private
     */
    heartbeatTimeout() {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
        if (this.hasLogger()) {
          this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
        }
        this.triggerChanError();
        this.closeWasClean = false;
        this.teardown(() => this.reconnectTimer.scheduleTimeout(), WS_CLOSE_NORMAL, "heartbeat timeout");
      }
    }
    resetHeartbeat() {
      if (this.conn && this.conn.skipHeartbeat) {
        return;
      }
      this.pendingHeartbeatRef = null;
      this.clearHeartbeats();
      this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    }
    teardown(callback2, code, reason) {
      if (!this.conn) {
        return callback2 && callback2();
      }
      this.waitForBufferDone(() => {
        if (this.conn) {
          if (code) {
            this.conn.close(code, reason || "");
          } else {
            this.conn.close();
          }
        }
        this.waitForSocketClosed(() => {
          if (this.conn) {
            this.conn.onopen = function() {
            };
            this.conn.onerror = function() {
            };
            this.conn.onmessage = function() {
            };
            this.conn.onclose = function() {
            };
            this.conn = null;
          }
          callback2 && callback2();
        });
      });
    }
    waitForBufferDone(callback2, tries = 1) {
      if (tries === 5 || !this.conn || !this.conn.bufferedAmount) {
        callback2();
        return;
      }
      setTimeout(() => {
        this.waitForBufferDone(callback2, tries + 1);
      }, 150 * tries);
    }
    waitForSocketClosed(callback2, tries = 1) {
      if (tries === 5 || !this.conn || this.conn.readyState === SOCKET_STATES.closed) {
        callback2();
        return;
      }
      setTimeout(() => {
        this.waitForSocketClosed(callback2, tries + 1);
      }, 150 * tries);
    }
    onConnClose(event) {
      let closeCode = event && event.code;
      if (this.hasLogger())
        this.log("transport", "close", event);
      this.triggerChanError();
      this.clearHeartbeats();
      if (!this.closeWasClean && closeCode !== 1e3) {
        this.reconnectTimer.scheduleTimeout();
      }
      this.stateChangeCallbacks.close.forEach(([, callback2]) => callback2(event));
    }
    /**
     * @private
     */
    onConnError(error) {
      if (this.hasLogger())
        this.log("transport", error);
      let transportBefore = this.transport;
      let establishedBefore = this.establishedConnections;
      this.stateChangeCallbacks.error.forEach(([, callback2]) => {
        callback2(error, transportBefore, establishedBefore);
      });
      if (transportBefore === this.transport || establishedBefore > 0) {
        this.triggerChanError();
      }
    }
    /**
     * @private
     */
    triggerChanError() {
      this.channels.forEach((channel) => {
        if (!(channel.isErrored() || channel.isLeaving() || channel.isClosed())) {
          channel.trigger(CHANNEL_EVENTS.error);
        }
      });
    }
    /**
     * @returns {string}
     */
    connectionState() {
      switch (this.conn && this.conn.readyState) {
        case SOCKET_STATES.connecting:
          return "connecting";
        case SOCKET_STATES.open:
          return "open";
        case SOCKET_STATES.closing:
          return "closing";
        default:
          return "closed";
      }
    }
    /**
     * @returns {boolean}
     */
    isConnected() {
      return this.connectionState() === "open";
    }
    /**
     * @private
     *
     * @param {Channel}
     */
    remove(channel) {
      this.off(channel.stateChangeRefs);
      this.channels = this.channels.filter((c) => c !== channel);
    }
    /**
     * Removes `onOpen`, `onClose`, `onError,` and `onMessage` registrations.
     *
     * @param {refs} - list of refs returned by calls to
     *                 `onOpen`, `onClose`, `onError,` and `onMessage`
     */
    off(refs) {
      for (let key in this.stateChangeCallbacks) {
        this.stateChangeCallbacks[key] = this.stateChangeCallbacks[key].filter(([ref]) => {
          return refs.indexOf(ref) === -1;
        });
      }
    }
    /**
     * Initiates a new channel for the given topic
     *
     * @param {string} topic
     * @param {Object} chanParams - Parameters for the channel
     * @returns {Channel}
     */
    channel(topic, chanParams = {}) {
      let chan = new Channel(topic, chanParams, this);
      this.channels.push(chan);
      return chan;
    }
    /**
     * @param {Object} data
     */
    push(data) {
      if (this.hasLogger()) {
        let { topic, event, payload, ref, join_ref } = data;
        this.log("push", `${topic} ${event} (${join_ref}, ${ref})`, payload);
      }
      if (this.isConnected()) {
        this.encode(data, (result) => this.conn.send(result));
      } else {
        this.sendBuffer.push(() => this.encode(data, (result) => this.conn.send(result)));
      }
    }
    /**
     * Return the next message ref, accounting for overflows
     * @returns {string}
     */
    makeRef() {
      let newRef = this.ref + 1;
      if (newRef === this.ref) {
        this.ref = 0;
      } else {
        this.ref = newRef;
      }
      return this.ref.toString();
    }
    sendHeartbeat() {
      if (this.pendingHeartbeatRef && !this.isConnected()) {
        return;
      }
      this.pendingHeartbeatRef = this.makeRef();
      this.push({ topic: "phoenix", event: "heartbeat", payload: {}, ref: this.pendingHeartbeatRef });
      this.heartbeatTimeoutTimer = setTimeout(() => this.heartbeatTimeout(), this.heartbeatIntervalMs);
    }
    flushSendBuffer() {
      if (this.isConnected() && this.sendBuffer.length > 0) {
        this.sendBuffer.forEach((callback2) => callback2());
        this.sendBuffer = [];
      }
    }
    onConnMessage(rawMessage) {
      this.decode(rawMessage.data, (msg) => {
        let { topic, event, payload, ref, join_ref } = msg;
        if (ref && ref === this.pendingHeartbeatRef) {
          this.clearHeartbeats();
          this.pendingHeartbeatRef = null;
          this.heartbeatTimer = setTimeout(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
        }
        if (this.hasLogger())
          this.log("receive", `${payload.status || ""} ${topic} ${event} ${ref && "(" + ref + ")" || ""}`, payload);
        for (let i = 0; i < this.channels.length; i++) {
          const channel = this.channels[i];
          if (!channel.isMember(topic, event, payload, join_ref)) {
            continue;
          }
          channel.trigger(event, payload, ref, join_ref);
        }
        for (let i = 0; i < this.stateChangeCallbacks.message.length; i++) {
          let [, callback2] = this.stateChangeCallbacks.message[i];
          callback2(msg);
        }
      });
    }
    leaveOpenTopic(topic) {
      let dupChannel = this.channels.find((c) => c.topic === topic && (c.isJoined() || c.isJoining()));
      if (dupChannel) {
        if (this.hasLogger())
          this.log("transport", `leaving duplicate topic "${topic}"`);
        dupChannel.leave();
      }
    }
  };

  // ../deps/phoenix_live_view/priv/static/phoenix_live_view.esm.js
  var CONSECUTIVE_RELOADS = "consecutive-reloads";
  var MAX_RELOADS = 10;
  var RELOAD_JITTER_MIN = 5e3;
  var RELOAD_JITTER_MAX = 1e4;
  var FAILSAFE_JITTER = 3e4;
  var PHX_EVENT_CLASSES = [
    "phx-click-loading",
    "phx-change-loading",
    "phx-submit-loading",
    "phx-keydown-loading",
    "phx-keyup-loading",
    "phx-blur-loading",
    "phx-focus-loading",
    "phx-hook-loading"
  ];
  var PHX_COMPONENT = "data-phx-component";
  var PHX_LIVE_LINK = "data-phx-link";
  var PHX_TRACK_STATIC = "track-static";
  var PHX_LINK_STATE = "data-phx-link-state";
  var PHX_REF_LOADING = "data-phx-ref-loading";
  var PHX_REF_SRC = "data-phx-ref-src";
  var PHX_REF_LOCK = "data-phx-ref-lock";
  var PHX_TRACK_UPLOADS = "track-uploads";
  var PHX_UPLOAD_REF = "data-phx-upload-ref";
  var PHX_PREFLIGHTED_REFS = "data-phx-preflighted-refs";
  var PHX_DONE_REFS = "data-phx-done-refs";
  var PHX_DROP_TARGET = "drop-target";
  var PHX_ACTIVE_ENTRY_REFS = "data-phx-active-refs";
  var PHX_LIVE_FILE_UPDATED = "phx:live-file:updated";
  var PHX_SKIP = "data-phx-skip";
  var PHX_MAGIC_ID = "data-phx-id";
  var PHX_PRUNE = "data-phx-prune";
  var PHX_CONNECTED_CLASS = "phx-connected";
  var PHX_LOADING_CLASS = "phx-loading";
  var PHX_ERROR_CLASS = "phx-error";
  var PHX_CLIENT_ERROR_CLASS = "phx-client-error";
  var PHX_SERVER_ERROR_CLASS = "phx-server-error";
  var PHX_PARENT_ID = "data-phx-parent-id";
  var PHX_MAIN = "data-phx-main";
  var PHX_ROOT_ID = "data-phx-root-id";
  var PHX_VIEWPORT_TOP = "viewport-top";
  var PHX_VIEWPORT_BOTTOM = "viewport-bottom";
  var PHX_TRIGGER_ACTION = "trigger-action";
  var PHX_HAS_FOCUSED = "phx-has-focused";
  var FOCUSABLE_INPUTS = ["text", "textarea", "number", "email", "password", "search", "tel", "url", "date", "time", "datetime-local", "color", "range"];
  var CHECKABLE_INPUTS = ["checkbox", "radio"];
  var PHX_HAS_SUBMITTED = "phx-has-submitted";
  var PHX_SESSION = "data-phx-session";
  var PHX_VIEW_SELECTOR = `[${PHX_SESSION}]`;
  var PHX_STICKY = "data-phx-sticky";
  var PHX_STATIC = "data-phx-static";
  var PHX_READONLY = "data-phx-readonly";
  var PHX_DISABLED = "data-phx-disabled";
  var PHX_DISABLE_WITH = "disable-with";
  var PHX_DISABLE_WITH_RESTORE = "data-phx-disable-with-restore";
  var PHX_HOOK = "hook";
  var PHX_DEBOUNCE = "debounce";
  var PHX_THROTTLE = "throttle";
  var PHX_UPDATE = "update";
  var PHX_STREAM = "stream";
  var PHX_STREAM_REF = "data-phx-stream";
  var PHX_KEY = "key";
  var PHX_PRIVATE = "phxPrivate";
  var PHX_AUTO_RECOVER = "auto-recover";
  var PHX_LV_DEBUG = "phx:live-socket:debug";
  var PHX_LV_PROFILE = "phx:live-socket:profiling";
  var PHX_LV_LATENCY_SIM = "phx:live-socket:latency-sim";
  var PHX_LV_HISTORY_POSITION = "phx:nav-history-position";
  var PHX_PROGRESS = "progress";
  var PHX_MOUNTED = "mounted";
  var PHX_RELOAD_STATUS = "__phoenix_reload_status__";
  var LOADER_TIMEOUT = 1;
  var MAX_CHILD_JOIN_ATTEMPTS = 3;
  var BEFORE_UNLOAD_LOADER_TIMEOUT = 200;
  var DISCONNECTED_TIMEOUT = 500;
  var BINDING_PREFIX = "phx-";
  var PUSH_TIMEOUT = 3e4;
  var DEBOUNCE_TRIGGER = "debounce-trigger";
  var THROTTLED = "throttled";
  var DEBOUNCE_PREV_KEY = "debounce-prev-key";
  var DEFAULTS = {
    debounce: 300,
    throttle: 300
  };
  var PHX_PENDING_ATTRS = [PHX_REF_LOADING, PHX_REF_SRC, PHX_REF_LOCK];
  var DYNAMICS = "d";
  var STATIC = "s";
  var ROOT = "r";
  var COMPONENTS = "c";
  var EVENTS = "e";
  var REPLY = "r";
  var TITLE = "t";
  var TEMPLATES = "p";
  var STREAM = "stream";
  var EntryUploader = class {
    constructor(entry, config, liveSocket2) {
      let { chunk_size, chunk_timeout } = config;
      this.liveSocket = liveSocket2;
      this.entry = entry;
      this.offset = 0;
      this.chunkSize = chunk_size;
      this.chunkTimeout = chunk_timeout;
      this.chunkTimer = null;
      this.errored = false;
      this.uploadChannel = liveSocket2.channel(`lvu:${entry.ref}`, { token: entry.metadata() });
    }
    error(reason) {
      if (this.errored) {
        return;
      }
      this.uploadChannel.leave();
      this.errored = true;
      clearTimeout(this.chunkTimer);
      this.entry.error(reason);
    }
    upload() {
      this.uploadChannel.onError((reason) => this.error(reason));
      this.uploadChannel.join().receive("ok", (_data) => this.readNextChunk()).receive("error", (reason) => this.error(reason));
    }
    isDone() {
      return this.offset >= this.entry.file.size;
    }
    readNextChunk() {
      let reader = new window.FileReader();
      let blob = this.entry.file.slice(this.offset, this.chunkSize + this.offset);
      reader.onload = (e) => {
        if (e.target.error === null) {
          this.offset += e.target.result.byteLength;
          this.pushChunk(e.target.result);
        } else {
          return logError("Read error: " + e.target.error);
        }
      };
      reader.readAsArrayBuffer(blob);
    }
    pushChunk(chunk) {
      if (!this.uploadChannel.isJoined()) {
        return;
      }
      this.uploadChannel.push("chunk", chunk, this.chunkTimeout).receive("ok", () => {
        this.entry.progress(this.offset / this.entry.file.size * 100);
        if (!this.isDone()) {
          this.chunkTimer = setTimeout(() => this.readNextChunk(), this.liveSocket.getLatencySim() || 0);
        }
      }).receive("error", ({ reason }) => this.error(reason));
    }
  };
  var logError = (msg, obj) => console.error && console.error(msg, obj);
  var isCid = (cid) => {
    let type = typeof cid;
    return type === "number" || type === "string" && /^(0|[1-9]\d*)$/.test(cid);
  };
  function detectDuplicateIds() {
    let ids = /* @__PURE__ */ new Set();
    let elems = document.querySelectorAll("*[id]");
    for (let i = 0, len = elems.length; i < len; i++) {
      if (ids.has(elems[i].id)) {
        console.error(`Multiple IDs detected: ${elems[i].id}. Ensure unique element ids.`);
      } else {
        ids.add(elems[i].id);
      }
    }
  }
  function detectInvalidStreamInserts(inserts) {
    const errors = /* @__PURE__ */ new Set();
    Object.keys(inserts).forEach((id) => {
      const streamEl = document.getElementById(id);
      if (streamEl && streamEl.parentElement && streamEl.parentElement.getAttribute("phx-update") !== "stream") {
        errors.add(`The stream container with id "${streamEl.parentElement.id}" is missing the phx-update="stream" attribute. Ensure it is set for streams to work properly.`);
      }
    });
    errors.forEach((error) => console.error(error));
  }
  var debug = (view, kind, msg, obj) => {
    if (view.liveSocket.isDebugEnabled()) {
      console.log(`${view.id} ${kind}: ${msg} - `, obj);
    }
  };
  var closure2 = (val) => typeof val === "function" ? val : function() {
    return val;
  };
  var clone = (obj) => {
    return JSON.parse(JSON.stringify(obj));
  };
  var closestPhxBinding = (el, binding, borderEl) => {
    do {
      if (el.matches(`[${binding}]`) && !el.disabled) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1 && !(borderEl && borderEl.isSameNode(el) || el.matches(PHX_VIEW_SELECTOR)));
    return null;
  };
  var isObject = (obj) => {
    return obj !== null && typeof obj === "object" && !(obj instanceof Array);
  };
  var isEqualObj = (obj1, obj2) => JSON.stringify(obj1) === JSON.stringify(obj2);
  var isEmpty = (obj) => {
    for (let x in obj) {
      return false;
    }
    return true;
  };
  var maybe = (el, callback2) => el && callback2(el);
  var channelUploader = function(entries, onError, resp, liveSocket2) {
    entries.forEach((entry) => {
      let entryUploader = new EntryUploader(entry, resp.config, liveSocket2);
      entryUploader.upload();
    });
  };
  var Browser = {
    canPushState() {
      return typeof history.pushState !== "undefined";
    },
    dropLocal(localStorage, namespace, subkey) {
      return localStorage.removeItem(this.localKey(namespace, subkey));
    },
    updateLocal(localStorage, namespace, subkey, initial, func) {
      let current = this.getLocal(localStorage, namespace, subkey);
      let key = this.localKey(namespace, subkey);
      let newVal = current === null ? initial : func(current);
      localStorage.setItem(key, JSON.stringify(newVal));
      return newVal;
    },
    getLocal(localStorage, namespace, subkey) {
      return JSON.parse(localStorage.getItem(this.localKey(namespace, subkey)));
    },
    updateCurrentState(callback2) {
      if (!this.canPushState()) {
        return;
      }
      history.replaceState(callback2(history.state || {}), "", window.location.href);
    },
    pushState(kind, meta, to2) {
      if (this.canPushState()) {
        if (to2 !== window.location.href) {
          if (meta.type == "redirect" && meta.scroll) {
            let currentState = history.state || {};
            currentState.scroll = meta.scroll;
            history.replaceState(currentState, "", window.location.href);
          }
          delete meta.scroll;
          history[kind + "State"](meta, "", to2 || null);
          window.requestAnimationFrame(() => {
            let hashEl = this.getHashTargetEl(window.location.hash);
            if (hashEl) {
              hashEl.scrollIntoView();
            } else if (meta.type === "redirect") {
              window.scroll(0, 0);
            }
          });
        }
      } else {
        this.redirect(to2);
      }
    },
    setCookie(name, value, maxAgeSeconds) {
      let expires = typeof maxAgeSeconds === "number" ? ` max-age=${maxAgeSeconds};` : "";
      document.cookie = `${name}=${value};${expires} path=/`;
    },
    getCookie(name) {
      return document.cookie.replace(new RegExp(`(?:(?:^|.*;s*)${name}s*=s*([^;]*).*$)|^.*$`), "$1");
    },
    deleteCookie(name) {
      document.cookie = `${name}=; max-age=-1; path=/`;
    },
    redirect(toURL, flash) {
      if (flash) {
        this.setCookie("__phoenix_flash__", flash, 60);
      }
      window.location = toURL;
    },
    localKey(namespace, subkey) {
      return `${namespace}-${subkey}`;
    },
    getHashTargetEl(maybeHash) {
      let hash = maybeHash.toString().substring(1);
      if (hash === "") {
        return;
      }
      return document.getElementById(hash) || document.querySelector(`a[name="${hash}"]`);
    }
  };
  var browser_default = Browser;
  var DOM = {
    byId(id) {
      return document.getElementById(id) || logError(`no id found for ${id}`);
    },
    removeClass(el, className) {
      el.classList.remove(className);
      if (el.classList.length === 0) {
        el.removeAttribute("class");
      }
    },
    all(node, query, callback2) {
      if (!node) {
        return [];
      }
      let array = Array.from(node.querySelectorAll(query));
      return callback2 ? array.forEach(callback2) : array;
    },
    childNodeLength(html) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return template.content.childElementCount;
    },
    isUploadInput(el) {
      return el.type === "file" && el.getAttribute(PHX_UPLOAD_REF) !== null;
    },
    isAutoUpload(inputEl) {
      return inputEl.hasAttribute("data-phx-auto-upload");
    },
    findUploadInputs(node) {
      const formId = node.id;
      const inputsOutsideForm = this.all(document, `input[type="file"][${PHX_UPLOAD_REF}][form="${formId}"]`);
      return this.all(node, `input[type="file"][${PHX_UPLOAD_REF}]`).concat(inputsOutsideForm);
    },
    findComponentNodeList(node, cid) {
      return this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node);
    },
    isPhxDestroyed(node) {
      return node.id && DOM.private(node, "destroyed") ? true : false;
    },
    wantsNewTab(e) {
      let wantsNewTab = e.ctrlKey || e.shiftKey || e.metaKey || e.button && e.button === 1;
      let isDownload = e.target instanceof HTMLAnchorElement && e.target.hasAttribute("download");
      let isTargetBlank = e.target.hasAttribute("target") && e.target.getAttribute("target").toLowerCase() === "_blank";
      let isTargetNamedTab = e.target.hasAttribute("target") && !e.target.getAttribute("target").startsWith("_");
      return wantsNewTab || isTargetBlank || isDownload || isTargetNamedTab;
    },
    isUnloadableFormSubmit(e) {
      let isDialogSubmit = e.target && e.target.getAttribute("method") === "dialog" || e.submitter && e.submitter.getAttribute("formmethod") === "dialog";
      if (isDialogSubmit) {
        return false;
      } else {
        return !e.defaultPrevented && !this.wantsNewTab(e);
      }
    },
    isNewPageClick(e, currentLocation) {
      let href = e.target instanceof HTMLAnchorElement ? e.target.getAttribute("href") : null;
      let url;
      if (e.defaultPrevented || href === null || this.wantsNewTab(e)) {
        return false;
      }
      if (href.startsWith("mailto:") || href.startsWith("tel:")) {
        return false;
      }
      if (e.target.isContentEditable) {
        return false;
      }
      try {
        url = new URL(href);
      } catch (e2) {
        try {
          url = new URL(href, currentLocation);
        } catch (e3) {
          return true;
        }
      }
      if (url.host === currentLocation.host && url.protocol === currentLocation.protocol) {
        if (url.pathname === currentLocation.pathname && url.search === currentLocation.search) {
          return url.hash === "" && !url.href.endsWith("#");
        }
      }
      return url.protocol.startsWith("http");
    },
    markPhxChildDestroyed(el) {
      if (this.isPhxChild(el)) {
        el.setAttribute(PHX_SESSION, "");
      }
      this.putPrivate(el, "destroyed", true);
    },
    findPhxChildrenInFragment(html, parentId) {
      let template = document.createElement("template");
      template.innerHTML = html;
      return this.findPhxChildren(template.content, parentId);
    },
    isIgnored(el, phxUpdate) {
      return (el.getAttribute(phxUpdate) || el.getAttribute("data-phx-update")) === "ignore";
    },
    isPhxUpdate(el, phxUpdate, updateTypes) {
      return el.getAttribute && updateTypes.indexOf(el.getAttribute(phxUpdate)) >= 0;
    },
    findPhxSticky(el) {
      return this.all(el, `[${PHX_STICKY}]`);
    },
    findPhxChildren(el, parentId) {
      return this.all(el, `${PHX_VIEW_SELECTOR}[${PHX_PARENT_ID}="${parentId}"]`);
    },
    findExistingParentCIDs(node, cids) {
      let parentCids = /* @__PURE__ */ new Set();
      let childrenCids = /* @__PURE__ */ new Set();
      cids.forEach((cid) => {
        this.filterWithinSameLiveView(this.all(node, `[${PHX_COMPONENT}="${cid}"]`), node).forEach((parent) => {
          parentCids.add(cid);
          this.filterWithinSameLiveView(this.all(parent, `[${PHX_COMPONENT}]`), parent).map((el) => parseInt(el.getAttribute(PHX_COMPONENT))).forEach((childCID) => childrenCids.add(childCID));
        });
      });
      childrenCids.forEach((childCid) => parentCids.delete(childCid));
      return parentCids;
    },
    filterWithinSameLiveView(nodes, parent) {
      if (parent.querySelector(PHX_VIEW_SELECTOR)) {
        return nodes.filter((el) => this.withinSameLiveView(el, parent));
      } else {
        return nodes;
      }
    },
    withinSameLiveView(node, parent) {
      while (node = node.parentNode) {
        if (node.isSameNode(parent)) {
          return true;
        }
        if (node.getAttribute(PHX_SESSION) !== null) {
          return false;
        }
      }
    },
    private(el, key) {
      return el[PHX_PRIVATE] && el[PHX_PRIVATE][key];
    },
    deletePrivate(el, key) {
      el[PHX_PRIVATE] && delete el[PHX_PRIVATE][key];
    },
    putPrivate(el, key, value) {
      if (!el[PHX_PRIVATE]) {
        el[PHX_PRIVATE] = {};
      }
      el[PHX_PRIVATE][key] = value;
    },
    updatePrivate(el, key, defaultVal, updateFunc) {
      let existing = this.private(el, key);
      if (existing === void 0) {
        this.putPrivate(el, key, updateFunc(defaultVal));
      } else {
        this.putPrivate(el, key, updateFunc(existing));
      }
    },
    syncPendingAttrs(fromEl, toEl) {
      if (!fromEl.hasAttribute(PHX_REF_SRC)) {
        return;
      }
      PHX_EVENT_CLASSES.forEach((className) => {
        fromEl.classList.contains(className) && toEl.classList.add(className);
      });
      PHX_PENDING_ATTRS.filter((attr) => fromEl.hasAttribute(attr)).forEach((attr) => {
        toEl.setAttribute(attr, fromEl.getAttribute(attr));
      });
    },
    copyPrivates(target, source) {
      if (source[PHX_PRIVATE]) {
        target[PHX_PRIVATE] = source[PHX_PRIVATE];
      }
    },
    putTitle(str) {
      let titleEl = document.querySelector("title");
      if (titleEl) {
        let { prefix, suffix, default: defaultTitle } = titleEl.dataset;
        let isEmpty2 = typeof str !== "string" || str.trim() === "";
        if (isEmpty2 && typeof defaultTitle !== "string") {
          return;
        }
        let inner = isEmpty2 ? defaultTitle : str;
        document.title = `${prefix || ""}${inner || ""}${suffix || ""}`;
      } else {
        document.title = str;
      }
    },
    debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, callback2) {
      let debounce2 = el.getAttribute(phxDebounce);
      let throttle = el.getAttribute(phxThrottle);
      if (debounce2 === "") {
        debounce2 = defaultDebounce;
      }
      if (throttle === "") {
        throttle = defaultThrottle;
      }
      let value = debounce2 || throttle;
      switch (value) {
        case null:
          return callback2();
        case "blur":
          this.incCycle(el, "debounce-blur-cycle", () => {
            if (asyncFilter()) {
              callback2();
            }
          });
          if (this.once(el, "debounce-blur")) {
            el.addEventListener("blur", () => this.triggerCycle(el, "debounce-blur-cycle"));
          }
          return;
        default:
          let timeout = parseInt(value);
          let trigger = () => throttle ? this.deletePrivate(el, THROTTLED) : callback2();
          let currentCycle = this.incCycle(el, DEBOUNCE_TRIGGER, trigger);
          if (isNaN(timeout)) {
            return logError(`invalid throttle/debounce value: ${value}`);
          }
          if (throttle) {
            let newKeyDown = false;
            if (event.type === "keydown") {
              let prevKey = this.private(el, DEBOUNCE_PREV_KEY);
              this.putPrivate(el, DEBOUNCE_PREV_KEY, event.key);
              newKeyDown = prevKey !== event.key;
            }
            if (!newKeyDown && this.private(el, THROTTLED)) {
              return false;
            } else {
              callback2();
              const t = setTimeout(() => {
                if (asyncFilter()) {
                  this.triggerCycle(el, DEBOUNCE_TRIGGER);
                }
              }, timeout);
              this.putPrivate(el, THROTTLED, t);
            }
          } else {
            setTimeout(() => {
              if (asyncFilter()) {
                this.triggerCycle(el, DEBOUNCE_TRIGGER, currentCycle);
              }
            }, timeout);
          }
          let form = el.form;
          if (form && this.once(form, "bind-debounce")) {
            form.addEventListener("submit", () => {
              Array.from(new FormData(form).entries(), ([name]) => {
                let input = form.querySelector(`[name="${name}"]`);
                this.incCycle(input, DEBOUNCE_TRIGGER);
                this.deletePrivate(input, THROTTLED);
              });
            });
          }
          if (this.once(el, "bind-debounce")) {
            el.addEventListener("blur", () => {
              clearTimeout(this.private(el, THROTTLED));
              this.triggerCycle(el, DEBOUNCE_TRIGGER);
            });
          }
      }
    },
    triggerCycle(el, key, currentCycle) {
      let [cycle, trigger] = this.private(el, key);
      if (!currentCycle) {
        currentCycle = cycle;
      }
      if (currentCycle === cycle) {
        this.incCycle(el, key);
        trigger();
      }
    },
    once(el, key) {
      if (this.private(el, key) === true) {
        return false;
      }
      this.putPrivate(el, key, true);
      return true;
    },
    incCycle(el, key, trigger = function() {
    }) {
      let [currentCycle] = this.private(el, key) || [0, trigger];
      currentCycle++;
      this.putPrivate(el, key, [currentCycle, trigger]);
      return currentCycle;
    },
    // maintains or adds privately used hook information
    // fromEl and toEl can be the same element in the case of a newly added node
    // fromEl and toEl can be any HTML node type, so we need to check if it's an element node
    maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom) {
      if (fromEl.hasAttribute && fromEl.hasAttribute("data-phx-hook") && !toEl.hasAttribute("data-phx-hook")) {
        toEl.setAttribute("data-phx-hook", fromEl.getAttribute("data-phx-hook"));
      }
      if (toEl.hasAttribute && (toEl.hasAttribute(phxViewportTop) || toEl.hasAttribute(phxViewportBottom))) {
        toEl.setAttribute("data-phx-hook", "Phoenix.InfiniteScroll");
      }
    },
    putCustomElHook(el, hook) {
      if (el.isConnected) {
        el.setAttribute("data-phx-hook", "");
      } else {
        console.error(`
        hook attached to non-connected DOM element
        ensure you are calling createHook within your connectedCallback. ${el.outerHTML}
      `);
      }
      this.putPrivate(el, "custom-el-hook", hook);
    },
    getCustomElHook(el) {
      return this.private(el, "custom-el-hook");
    },
    isUsedInput(el) {
      return el.nodeType === Node.ELEMENT_NODE && (this.private(el, PHX_HAS_FOCUSED) || this.private(el, PHX_HAS_SUBMITTED));
    },
    resetForm(form) {
      Array.from(form.elements).forEach((input) => {
        this.deletePrivate(input, PHX_HAS_FOCUSED);
        this.deletePrivate(input, PHX_HAS_SUBMITTED);
      });
    },
    isPhxChild(node) {
      return node.getAttribute && node.getAttribute(PHX_PARENT_ID);
    },
    isPhxSticky(node) {
      return node.getAttribute && node.getAttribute(PHX_STICKY) !== null;
    },
    isChildOfAny(el, parents) {
      return !!parents.find((parent) => parent.contains(el));
    },
    firstPhxChild(el) {
      return this.isPhxChild(el) ? el : this.all(el, `[${PHX_PARENT_ID}]`)[0];
    },
    dispatchEvent(target, name, opts = {}) {
      let defaultBubble = true;
      let isUploadTarget = target.nodeName === "INPUT" && target.type === "file";
      if (isUploadTarget && name === "click") {
        defaultBubble = false;
      }
      let bubbles = opts.bubbles === void 0 ? defaultBubble : !!opts.bubbles;
      let eventOpts = { bubbles, cancelable: true, detail: opts.detail || {} };
      let event = name === "click" ? new MouseEvent("click", eventOpts) : new CustomEvent(name, eventOpts);
      target.dispatchEvent(event);
    },
    cloneNode(node, html) {
      if (typeof html === "undefined") {
        return node.cloneNode(true);
      } else {
        let cloned = node.cloneNode(false);
        cloned.innerHTML = html;
        return cloned;
      }
    },
    // merge attributes from source to target
    // if an element is ignored, we only merge data attributes
    // including removing data attributes that are no longer in the source
    mergeAttrs(target, source, opts = {}) {
      let exclude = new Set(opts.exclude || []);
      let isIgnored = opts.isIgnored;
      let sourceAttrs = source.attributes;
      for (let i = sourceAttrs.length - 1; i >= 0; i--) {
        let name = sourceAttrs[i].name;
        if (!exclude.has(name)) {
          const sourceValue = source.getAttribute(name);
          if (target.getAttribute(name) !== sourceValue && (!isIgnored || isIgnored && name.startsWith("data-"))) {
            target.setAttribute(name, sourceValue);
          }
        } else {
          if (name === "value" && target.value === source.value) {
            target.setAttribute("value", source.getAttribute(name));
          }
        }
      }
      let targetAttrs = target.attributes;
      for (let i = targetAttrs.length - 1; i >= 0; i--) {
        let name = targetAttrs[i].name;
        if (isIgnored) {
          if (name.startsWith("data-") && !source.hasAttribute(name) && !PHX_PENDING_ATTRS.includes(name)) {
            target.removeAttribute(name);
          }
        } else {
          if (!source.hasAttribute(name)) {
            target.removeAttribute(name);
          }
        }
      }
    },
    mergeFocusedInput(target, source) {
      if (!(target instanceof HTMLSelectElement)) {
        DOM.mergeAttrs(target, source, { exclude: ["value"] });
      }
      if (source.readOnly) {
        target.setAttribute("readonly", true);
      } else {
        target.removeAttribute("readonly");
      }
    },
    hasSelectionRange(el) {
      return el.setSelectionRange && (el.type === "text" || el.type === "textarea");
    },
    restoreFocus(focused, selectionStart, selectionEnd) {
      if (focused instanceof HTMLSelectElement) {
        focused.focus();
      }
      if (!DOM.isTextualInput(focused)) {
        return;
      }
      let wasFocused = focused.matches(":focus");
      if (!wasFocused) {
        focused.focus();
      }
      if (this.hasSelectionRange(focused)) {
        focused.setSelectionRange(selectionStart, selectionEnd);
      }
    },
    isFormInput(el) {
      return /^(?:input|select|textarea)$/i.test(el.tagName) && el.type !== "button";
    },
    syncAttrsToProps(el) {
      if (el instanceof HTMLInputElement && CHECKABLE_INPUTS.indexOf(el.type.toLocaleLowerCase()) >= 0) {
        el.checked = el.getAttribute("checked") !== null;
      }
    },
    isTextualInput(el) {
      return FOCUSABLE_INPUTS.indexOf(el.type) >= 0;
    },
    isNowTriggerFormExternal(el, phxTriggerExternal) {
      return el.getAttribute && el.getAttribute(phxTriggerExternal) !== null && document.body.contains(el);
    },
    cleanChildNodes(container, phxUpdate) {
      if (DOM.isPhxUpdate(container, phxUpdate, ["append", "prepend"])) {
        let toRemove = [];
        container.childNodes.forEach((childNode) => {
          if (!childNode.id) {
            let isEmptyTextNode = childNode.nodeType === Node.TEXT_NODE && childNode.nodeValue.trim() === "";
            if (!isEmptyTextNode && childNode.nodeType !== Node.COMMENT_NODE) {
              logError(`only HTML element tags with an id are allowed inside containers with phx-update.

removing illegal node: "${(childNode.outerHTML || childNode.nodeValue).trim()}"

`);
            }
            toRemove.push(childNode);
          }
        });
        toRemove.forEach((childNode) => childNode.remove());
      }
    },
    replaceRootContainer(container, tagName, attrs) {
      let retainedAttrs = /* @__PURE__ */ new Set(["id", PHX_SESSION, PHX_STATIC, PHX_MAIN, PHX_ROOT_ID]);
      if (container.tagName.toLowerCase() === tagName.toLowerCase()) {
        Array.from(container.attributes).filter((attr) => !retainedAttrs.has(attr.name.toLowerCase())).forEach((attr) => container.removeAttribute(attr.name));
        Object.keys(attrs).filter((name) => !retainedAttrs.has(name.toLowerCase())).forEach((attr) => container.setAttribute(attr, attrs[attr]));
        return container;
      } else {
        let newContainer = document.createElement(tagName);
        Object.keys(attrs).forEach((attr) => newContainer.setAttribute(attr, attrs[attr]));
        retainedAttrs.forEach((attr) => newContainer.setAttribute(attr, container.getAttribute(attr)));
        newContainer.innerHTML = container.innerHTML;
        container.replaceWith(newContainer);
        return newContainer;
      }
    },
    getSticky(el, name, defaultVal) {
      let op = (DOM.private(el, "sticky") || []).find(([existingName]) => name === existingName);
      if (op) {
        let [_name, _op, stashedResult] = op;
        return stashedResult;
      } else {
        return typeof defaultVal === "function" ? defaultVal() : defaultVal;
      }
    },
    deleteSticky(el, name) {
      this.updatePrivate(el, "sticky", [], (ops) => {
        return ops.filter(([existingName, _]) => existingName !== name);
      });
    },
    putSticky(el, name, op) {
      let stashedResult = op(el);
      this.updatePrivate(el, "sticky", [], (ops) => {
        let existingIndex = ops.findIndex(([existingName]) => name === existingName);
        if (existingIndex >= 0) {
          ops[existingIndex] = [name, op, stashedResult];
        } else {
          ops.push([name, op, stashedResult]);
        }
        return ops;
      });
    },
    applyStickyOperations(el) {
      let ops = DOM.private(el, "sticky");
      if (!ops) {
        return;
      }
      ops.forEach(([name, op, _stashed]) => this.putSticky(el, name, op));
    },
    isLocked(el) {
      return el.hasAttribute && el.hasAttribute(PHX_REF_LOCK);
    }
  };
  var dom_default = DOM;
  var UploadEntry = class {
    static isActive(fileEl, file) {
      let isNew = file._phxRef === void 0;
      let activeRefs = fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      let isActive = activeRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return file.size > 0 && (isNew || isActive);
    }
    static isPreflighted(fileEl, file) {
      let preflightedRefs = fileEl.getAttribute(PHX_PREFLIGHTED_REFS).split(",");
      let isPreflighted = preflightedRefs.indexOf(LiveUploader.genFileRef(file)) >= 0;
      return isPreflighted && this.isActive(fileEl, file);
    }
    static isPreflightInProgress(file) {
      return file._preflightInProgress === true;
    }
    static markPreflightInProgress(file) {
      file._preflightInProgress = true;
    }
    constructor(fileEl, file, view, autoUpload) {
      this.ref = LiveUploader.genFileRef(file);
      this.fileEl = fileEl;
      this.file = file;
      this.view = view;
      this.meta = null;
      this._isCancelled = false;
      this._isDone = false;
      this._progress = 0;
      this._lastProgressSent = -1;
      this._onDone = function() {
      };
      this._onElUpdated = this.onElUpdated.bind(this);
      this.fileEl.addEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.autoUpload = autoUpload;
    }
    metadata() {
      return this.meta;
    }
    progress(progress) {
      this._progress = Math.floor(progress);
      if (this._progress > this._lastProgressSent) {
        if (this._progress >= 100) {
          this._progress = 100;
          this._lastProgressSent = 100;
          this._isDone = true;
          this.view.pushFileProgress(this.fileEl, this.ref, 100, () => {
            LiveUploader.untrackFile(this.fileEl, this.file);
            this._onDone();
          });
        } else {
          this._lastProgressSent = this._progress;
          this.view.pushFileProgress(this.fileEl, this.ref, this._progress);
        }
      }
    }
    isCancelled() {
      return this._isCancelled;
    }
    cancel() {
      this.file._preflightInProgress = false;
      this._isCancelled = true;
      this._isDone = true;
      this._onDone();
    }
    isDone() {
      return this._isDone;
    }
    error(reason = "failed") {
      this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
      this.view.pushFileProgress(this.fileEl, this.ref, { error: reason });
      if (!this.isAutoUpload()) {
        LiveUploader.clearFiles(this.fileEl);
      }
    }
    isAutoUpload() {
      return this.autoUpload;
    }
    //private
    onDone(callback2) {
      this._onDone = () => {
        this.fileEl.removeEventListener(PHX_LIVE_FILE_UPDATED, this._onElUpdated);
        callback2();
      };
    }
    onElUpdated() {
      let activeRefs = this.fileEl.getAttribute(PHX_ACTIVE_ENTRY_REFS).split(",");
      if (activeRefs.indexOf(this.ref) === -1) {
        LiveUploader.untrackFile(this.fileEl, this.file);
        this.cancel();
      }
    }
    toPreflightPayload() {
      return {
        last_modified: this.file.lastModified,
        name: this.file.name,
        relative_path: this.file.webkitRelativePath,
        size: this.file.size,
        type: this.file.type,
        ref: this.ref,
        meta: typeof this.file.meta === "function" ? this.file.meta() : void 0
      };
    }
    uploader(uploaders) {
      if (this.meta.uploader) {
        let callback2 = uploaders[this.meta.uploader] || logError(`no uploader configured for ${this.meta.uploader}`);
        return { name: this.meta.uploader, callback: callback2 };
      } else {
        return { name: "channel", callback: channelUploader };
      }
    }
    zipPostFlight(resp) {
      this.meta = resp.entries[this.ref];
      if (!this.meta) {
        logError(`no preflight upload response returned with ref ${this.ref}`, { input: this.fileEl, response: resp });
      }
    }
  };
  var liveUploaderFileRef = 0;
  var LiveUploader = class _LiveUploader {
    static genFileRef(file) {
      let ref = file._phxRef;
      if (ref !== void 0) {
        return ref;
      } else {
        file._phxRef = (liveUploaderFileRef++).toString();
        return file._phxRef;
      }
    }
    static getEntryDataURL(inputEl, ref, callback2) {
      let file = this.activeFiles(inputEl).find((file2) => this.genFileRef(file2) === ref);
      callback2(URL.createObjectURL(file));
    }
    static hasUploadsInProgress(formEl) {
      let active = 0;
      dom_default.findUploadInputs(formEl).forEach((input) => {
        if (input.getAttribute(PHX_PREFLIGHTED_REFS) !== input.getAttribute(PHX_DONE_REFS)) {
          active++;
        }
      });
      return active > 0;
    }
    static serializeUploads(inputEl) {
      let files = this.activeFiles(inputEl);
      let fileData = {};
      files.forEach((file) => {
        let entry = { path: inputEl.name };
        let uploadRef = inputEl.getAttribute(PHX_UPLOAD_REF);
        fileData[uploadRef] = fileData[uploadRef] || [];
        entry.ref = this.genFileRef(file);
        entry.last_modified = file.lastModified;
        entry.name = file.name || entry.ref;
        entry.relative_path = file.webkitRelativePath;
        entry.type = file.type;
        entry.size = file.size;
        if (typeof file.meta === "function") {
          entry.meta = file.meta();
        }
        fileData[uploadRef].push(entry);
      });
      return fileData;
    }
    static clearFiles(inputEl) {
      inputEl.value = null;
      inputEl.removeAttribute(PHX_UPLOAD_REF);
      dom_default.putPrivate(inputEl, "files", []);
    }
    static untrackFile(inputEl, file) {
      dom_default.putPrivate(inputEl, "files", dom_default.private(inputEl, "files").filter((f) => !Object.is(f, file)));
    }
    static trackFiles(inputEl, files, dataTransfer) {
      if (inputEl.getAttribute("multiple") !== null) {
        let newFiles = files.filter((file) => !this.activeFiles(inputEl).find((f) => Object.is(f, file)));
        dom_default.updatePrivate(inputEl, "files", [], (existing) => existing.concat(newFiles));
        inputEl.value = null;
      } else {
        if (dataTransfer && dataTransfer.files.length > 0) {
          inputEl.files = dataTransfer.files;
        }
        dom_default.putPrivate(inputEl, "files", files);
      }
    }
    static activeFileInputs(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((el) => el.files && this.activeFiles(el).length > 0);
    }
    static activeFiles(input) {
      return (dom_default.private(input, "files") || []).filter((f) => UploadEntry.isActive(input, f));
    }
    static inputsAwaitingPreflight(formEl) {
      let fileInputs = dom_default.findUploadInputs(formEl);
      return Array.from(fileInputs).filter((input) => this.filesAwaitingPreflight(input).length > 0);
    }
    static filesAwaitingPreflight(input) {
      return this.activeFiles(input).filter((f) => !UploadEntry.isPreflighted(input, f) && !UploadEntry.isPreflightInProgress(f));
    }
    static markPreflightInProgress(entries) {
      entries.forEach((entry) => UploadEntry.markPreflightInProgress(entry.file));
    }
    constructor(inputEl, view, onComplete) {
      this.autoUpload = dom_default.isAutoUpload(inputEl);
      this.view = view;
      this.onComplete = onComplete;
      this._entries = Array.from(_LiveUploader.filesAwaitingPreflight(inputEl) || []).map((file) => new UploadEntry(inputEl, file, view, this.autoUpload));
      _LiveUploader.markPreflightInProgress(this._entries);
      this.numEntriesInProgress = this._entries.length;
    }
    isAutoUpload() {
      return this.autoUpload;
    }
    entries() {
      return this._entries;
    }
    initAdapterUpload(resp, onError, liveSocket2) {
      this._entries = this._entries.map((entry) => {
        if (entry.isCancelled()) {
          this.numEntriesInProgress--;
          if (this.numEntriesInProgress === 0) {
            this.onComplete();
          }
        } else {
          entry.zipPostFlight(resp);
          entry.onDone(() => {
            this.numEntriesInProgress--;
            if (this.numEntriesInProgress === 0) {
              this.onComplete();
            }
          });
        }
        return entry;
      });
      let groupedEntries = this._entries.reduce((acc, entry) => {
        if (!entry.meta) {
          return acc;
        }
        let { name, callback: callback2 } = entry.uploader(liveSocket2.uploaders);
        acc[name] = acc[name] || { callback: callback2, entries: [] };
        acc[name].entries.push(entry);
        return acc;
      }, {});
      for (let name in groupedEntries) {
        let { callback: callback2, entries } = groupedEntries[name];
        callback2(entries, onError, resp, liveSocket2);
      }
    }
  };
  var ARIA = {
    anyOf(instance, classes) {
      return classes.find((name) => instance instanceof name);
    },
    isFocusable(el, interactiveOnly) {
      return el instanceof HTMLAnchorElement && el.rel !== "ignore" || el instanceof HTMLAreaElement && el.href !== void 0 || !el.disabled && this.anyOf(el, [HTMLInputElement, HTMLSelectElement, HTMLTextAreaElement, HTMLButtonElement]) || el instanceof HTMLIFrameElement || (el.tabIndex > 0 || !interactiveOnly && el.getAttribute("tabindex") !== null && el.getAttribute("aria-hidden") !== "true");
    },
    attemptFocus(el, interactiveOnly) {
      if (this.isFocusable(el, interactiveOnly)) {
        try {
          el.focus();
        } catch (e) {
        }
      }
      return !!document.activeElement && document.activeElement.isSameNode(el);
    },
    focusFirstInteractive(el) {
      let child = el.firstElementChild;
      while (child) {
        if (this.attemptFocus(child, true) || this.focusFirstInteractive(child, true)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusFirst(el) {
      let child = el.firstElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusFirst(child)) {
          return true;
        }
        child = child.nextElementSibling;
      }
    },
    focusLast(el) {
      let child = el.lastElementChild;
      while (child) {
        if (this.attemptFocus(child) || this.focusLast(child)) {
          return true;
        }
        child = child.previousElementSibling;
      }
    }
  };
  var aria_default = ARIA;
  var Hooks = {
    LiveFileUpload: {
      activeRefs() {
        return this.el.getAttribute(PHX_ACTIVE_ENTRY_REFS);
      },
      preflightedRefs() {
        return this.el.getAttribute(PHX_PREFLIGHTED_REFS);
      },
      mounted() {
        this.preflightedWas = this.preflightedRefs();
      },
      updated() {
        let newPreflights = this.preflightedRefs();
        if (this.preflightedWas !== newPreflights) {
          this.preflightedWas = newPreflights;
          if (newPreflights === "") {
            this.__view().cancelSubmit(this.el.form);
          }
        }
        if (this.activeRefs() === "") {
          this.el.value = null;
        }
        this.el.dispatchEvent(new CustomEvent(PHX_LIVE_FILE_UPDATED));
      }
    },
    LiveImgPreview: {
      mounted() {
        this.ref = this.el.getAttribute("data-phx-entry-ref");
        this.inputEl = document.getElementById(this.el.getAttribute(PHX_UPLOAD_REF));
        LiveUploader.getEntryDataURL(this.inputEl, this.ref, (url) => {
          this.url = url;
          this.el.src = url;
        });
      },
      destroyed() {
        URL.revokeObjectURL(this.url);
      }
    },
    FocusWrap: {
      mounted() {
        this.focusStart = this.el.firstElementChild;
        this.focusEnd = this.el.lastElementChild;
        this.focusStart.addEventListener("focus", (e) => {
          if (!e.relatedTarget || !this.el.contains(e.relatedTarget)) {
            const nextFocus = e.target.nextElementSibling;
            aria_default.attemptFocus(nextFocus) || aria_default.focusFirst(nextFocus);
          } else {
            aria_default.focusLast(this.el);
          }
        });
        this.focusEnd.addEventListener("focus", (e) => {
          if (!e.relatedTarget || !this.el.contains(e.relatedTarget)) {
            const nextFocus = e.target.previousElementSibling;
            aria_default.attemptFocus(nextFocus) || aria_default.focusLast(nextFocus);
          } else {
            aria_default.focusFirst(this.el);
          }
        });
        this.el.addEventListener("phx:show-end", () => this.el.focus());
        if (window.getComputedStyle(this.el).display !== "none") {
          aria_default.focusFirst(this.el);
        }
      }
    }
  };
  var findScrollContainer = (el) => {
    if (["HTML", "BODY"].indexOf(el.nodeName.toUpperCase()) >= 0)
      return null;
    if (["scroll", "auto"].indexOf(getComputedStyle(el).overflowY) >= 0)
      return el;
    return findScrollContainer(el.parentElement);
  };
  var scrollTop = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.scrollTop;
    } else {
      return document.documentElement.scrollTop || document.body.scrollTop;
    }
  };
  var bottom = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.getBoundingClientRect().bottom;
    } else {
      return window.innerHeight || document.documentElement.clientHeight;
    }
  };
  var top = (scrollContainer) => {
    if (scrollContainer) {
      return scrollContainer.getBoundingClientRect().top;
    } else {
      return 0;
    }
  };
  var isAtViewportTop = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);
  };
  var isAtViewportBottom = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return Math.ceil(rect.bottom) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.bottom) <= bottom(scrollContainer);
  };
  var isWithinViewport = (el, scrollContainer) => {
    let rect = el.getBoundingClientRect();
    return Math.ceil(rect.top) >= top(scrollContainer) && Math.ceil(rect.left) >= 0 && Math.floor(rect.top) <= bottom(scrollContainer);
  };
  Hooks.InfiniteScroll = {
    mounted() {
      this.scrollContainer = findScrollContainer(this.el);
      let scrollBefore = scrollTop(this.scrollContainer);
      let topOverran = false;
      let throttleInterval = 500;
      let pendingOp = null;
      let onTopOverrun = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => true;
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id, _overran: true }, () => {
          pendingOp = null;
        });
      });
      let onFirstChildAtTop = this.throttle(throttleInterval, (topEvent, firstChild) => {
        pendingOp = () => firstChild.scrollIntoView({ block: "start" });
        this.liveSocket.execJSHookPush(this.el, topEvent, { id: firstChild.id }, () => {
          pendingOp = null;
          window.requestAnimationFrame(() => {
            if (!isWithinViewport(firstChild, this.scrollContainer)) {
              firstChild.scrollIntoView({ block: "start" });
            }
          });
        });
      });
      let onLastChildAtBottom = this.throttle(throttleInterval, (bottomEvent, lastChild) => {
        pendingOp = () => lastChild.scrollIntoView({ block: "end" });
        this.liveSocket.execJSHookPush(this.el, bottomEvent, { id: lastChild.id }, () => {
          pendingOp = null;
          window.requestAnimationFrame(() => {
            if (!isWithinViewport(lastChild, this.scrollContainer)) {
              lastChild.scrollIntoView({ block: "end" });
            }
          });
        });
      });
      this.onScroll = (_e) => {
        let scrollNow = scrollTop(this.scrollContainer);
        if (pendingOp) {
          scrollBefore = scrollNow;
          return pendingOp();
        }
        let rect = this.el.getBoundingClientRect();
        let topEvent = this.el.getAttribute(this.liveSocket.binding("viewport-top"));
        let bottomEvent = this.el.getAttribute(this.liveSocket.binding("viewport-bottom"));
        let lastChild = this.el.lastElementChild;
        let firstChild = this.el.firstElementChild;
        let isScrollingUp = scrollNow < scrollBefore;
        let isScrollingDown = scrollNow > scrollBefore;
        if (isScrollingUp && topEvent && !topOverran && rect.top >= 0) {
          topOverran = true;
          onTopOverrun(topEvent, firstChild);
        } else if (isScrollingDown && topOverran && rect.top <= 0) {
          topOverran = false;
        }
        if (topEvent && isScrollingUp && isAtViewportTop(firstChild, this.scrollContainer)) {
          onFirstChildAtTop(topEvent, firstChild);
        } else if (bottomEvent && isScrollingDown && isAtViewportBottom(lastChild, this.scrollContainer)) {
          onLastChildAtBottom(bottomEvent, lastChild);
        }
        scrollBefore = scrollNow;
      };
      if (this.scrollContainer) {
        this.scrollContainer.addEventListener("scroll", this.onScroll);
      } else {
        window.addEventListener("scroll", this.onScroll);
      }
    },
    destroyed() {
      if (this.scrollContainer) {
        this.scrollContainer.removeEventListener("scroll", this.onScroll);
      } else {
        window.removeEventListener("scroll", this.onScroll);
      }
    },
    throttle(interval, callback2) {
      let lastCallAt = 0;
      let timer;
      return (...args) => {
        let now = Date.now();
        let remainingTime = interval - (now - lastCallAt);
        if (remainingTime <= 0 || remainingTime > interval) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          lastCallAt = now;
          callback2(...args);
        } else if (!timer) {
          timer = setTimeout(() => {
            lastCallAt = Date.now();
            timer = null;
            callback2(...args);
          }, remainingTime);
        }
      };
    }
  };
  var hooks_default = Hooks;
  var ElementRef = class {
    static onUnlock(el, callback2) {
      if (!dom_default.isLocked(el) && !el.closest(`[${PHX_REF_LOCK}]`)) {
        return callback2();
      }
      const closestLock = el.closest(`[${PHX_REF_LOCK}]`);
      const ref = closestLock.closest(`[${PHX_REF_LOCK}]`).getAttribute(PHX_REF_LOCK);
      closestLock.addEventListener(`phx:undo-lock:${ref}`, () => {
        callback2();
      }, { once: true });
    }
    constructor(el) {
      this.el = el;
      this.loadingRef = el.hasAttribute(PHX_REF_LOADING) ? parseInt(el.getAttribute(PHX_REF_LOADING), 10) : null;
      this.lockRef = el.hasAttribute(PHX_REF_LOCK) ? parseInt(el.getAttribute(PHX_REF_LOCK), 10) : null;
    }
    // public
    maybeUndo(ref, phxEvent, eachCloneCallback) {
      if (!this.isWithin(ref)) {
        return;
      }
      this.undoLocks(ref, phxEvent, eachCloneCallback);
      this.undoLoading(ref, phxEvent);
      if (this.isFullyResolvedBy(ref)) {
        this.el.removeAttribute(PHX_REF_SRC);
      }
    }
    // private
    isWithin(ref) {
      return !(this.loadingRef !== null && this.loadingRef > ref && (this.lockRef !== null && this.lockRef > ref));
    }
    // Check for cloned PHX_REF_LOCK element that has been morphed behind
    // the scenes while this element was locked in the DOM.
    // When we apply the cloned tree to the active DOM element, we must
    //
    //   1. execute pending mounted hooks for nodes now in the DOM
    //   2. undo any ref inside the cloned tree that has since been ack'd
    undoLocks(ref, phxEvent, eachCloneCallback) {
      if (!this.isLockUndoneBy(ref)) {
        return;
      }
      let clonedTree = dom_default.private(this.el, PHX_REF_LOCK);
      if (clonedTree) {
        eachCloneCallback(clonedTree);
        dom_default.deletePrivate(this.el, PHX_REF_LOCK);
      }
      this.el.removeAttribute(PHX_REF_LOCK);
      let opts = { detail: { ref, event: phxEvent }, bubbles: true, cancelable: false };
      this.el.dispatchEvent(new CustomEvent(`phx:undo-lock:${this.lockRef}`, opts));
    }
    undoLoading(ref, phxEvent) {
      if (!this.isLoadingUndoneBy(ref)) {
        if (this.canUndoLoading(ref) && this.el.classList.contains("phx-submit-loading")) {
          this.el.classList.remove("phx-change-loading");
        }
        return;
      }
      if (this.canUndoLoading(ref)) {
        this.el.removeAttribute(PHX_REF_LOADING);
        let disabledVal = this.el.getAttribute(PHX_DISABLED);
        let readOnlyVal = this.el.getAttribute(PHX_READONLY);
        if (readOnlyVal !== null) {
          this.el.readOnly = readOnlyVal === "true" ? true : false;
          this.el.removeAttribute(PHX_READONLY);
        }
        if (disabledVal !== null) {
          this.el.disabled = disabledVal === "true" ? true : false;
          this.el.removeAttribute(PHX_DISABLED);
        }
        let disableRestore = this.el.getAttribute(PHX_DISABLE_WITH_RESTORE);
        if (disableRestore !== null) {
          this.el.innerText = disableRestore;
          this.el.removeAttribute(PHX_DISABLE_WITH_RESTORE);
        }
        let opts = { detail: { ref, event: phxEvent }, bubbles: true, cancelable: false };
        this.el.dispatchEvent(new CustomEvent(`phx:undo-loading:${this.loadingRef}`, opts));
      }
      PHX_EVENT_CLASSES.forEach((name) => {
        if (name !== "phx-submit-loading" || this.canUndoLoading(ref)) {
          dom_default.removeClass(this.el, name);
        }
      });
    }
    isLoadingUndoneBy(ref) {
      return this.loadingRef === null ? false : this.loadingRef <= ref;
    }
    isLockUndoneBy(ref) {
      return this.lockRef === null ? false : this.lockRef <= ref;
    }
    isFullyResolvedBy(ref) {
      return (this.loadingRef === null || this.loadingRef <= ref) && (this.lockRef === null || this.lockRef <= ref);
    }
    // only remove the phx-submit-loading class if we are not locked
    canUndoLoading(ref) {
      return this.lockRef === null || this.lockRef <= ref;
    }
  };
  var DOMPostMorphRestorer = class {
    constructor(containerBefore, containerAfter, updateType) {
      let idsBefore = /* @__PURE__ */ new Set();
      let idsAfter = new Set([...containerAfter.children].map((child) => child.id));
      let elementsToModify = [];
      Array.from(containerBefore.children).forEach((child) => {
        if (child.id) {
          idsBefore.add(child.id);
          if (idsAfter.has(child.id)) {
            let previousElementId = child.previousElementSibling && child.previousElementSibling.id;
            elementsToModify.push({ elementId: child.id, previousElementId });
          }
        }
      });
      this.containerId = containerAfter.id;
      this.updateType = updateType;
      this.elementsToModify = elementsToModify;
      this.elementIdsToAdd = [...idsAfter].filter((id) => !idsBefore.has(id));
    }
    // We do the following to optimize append/prepend operations:
    //   1) Track ids of modified elements & of new elements
    //   2) All the modified elements are put back in the correct position in the DOM tree
    //      by storing the id of their previous sibling
    //   3) New elements are going to be put in the right place by morphdom during append.
    //      For prepend, we move them to the first position in the container
    perform() {
      let container = dom_default.byId(this.containerId);
      this.elementsToModify.forEach((elementToModify) => {
        if (elementToModify.previousElementId) {
          maybe(document.getElementById(elementToModify.previousElementId), (previousElem) => {
            maybe(document.getElementById(elementToModify.elementId), (elem) => {
              let isInRightPlace = elem.previousElementSibling && elem.previousElementSibling.id == previousElem.id;
              if (!isInRightPlace) {
                previousElem.insertAdjacentElement("afterend", elem);
              }
            });
          });
        } else {
          maybe(document.getElementById(elementToModify.elementId), (elem) => {
            let isInRightPlace = elem.previousElementSibling == null;
            if (!isInRightPlace) {
              container.insertAdjacentElement("afterbegin", elem);
            }
          });
        }
      });
      if (this.updateType == "prepend") {
        this.elementIdsToAdd.reverse().forEach((elemId) => {
          maybe(document.getElementById(elemId), (elem) => container.insertAdjacentElement("afterbegin", elem));
        });
      }
    }
  };
  var DOCUMENT_FRAGMENT_NODE = 11;
  function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
      attr = toNodeAttrs[i];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      attrValue = attr.value;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attr.prefix === "xmlns") {
            attrName = attr.name;
          }
          fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = fromNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          fromNode.setAttribute(attrName, attrValue);
        }
      }
    }
    var fromNodeAttrs = fromNode.attributes;
    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
      attr = fromNodeAttrs[d];
      attrName = attr.name;
      attrNamespaceURI = attr.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attr.localName || attrName;
        if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          fromNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!toNode.hasAttribute(attrName)) {
          fromNode.removeAttribute(attrName);
        }
      }
    }
  }
  var range;
  var NS_XHTML = "http://www.w3.org/1999/xhtml";
  var doc = typeof document === "undefined" ? void 0 : document;
  var HAS_TEMPLATE_SUPPORT = !!doc && "content" in doc.createElement("template");
  var HAS_RANGE_SUPPORT = !!doc && doc.createRange && "createContextualFragment" in doc.createRange();
  function createFragmentFromTemplate(str) {
    var template = doc.createElement("template");
    template.innerHTML = str;
    return template.content.childNodes[0];
  }
  function createFragmentFromRange(str) {
    if (!range) {
      range = doc.createRange();
      range.selectNode(doc.body);
    }
    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
  }
  function createFragmentFromWrap(str) {
    var fragment = doc.createElement("body");
    fragment.innerHTML = str;
    return fragment.childNodes[0];
  }
  function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }
    return createFragmentFromWrap(str);
  }
  function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;
    if (fromNodeName === toNodeName) {
      return true;
    }
    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);
    if (fromCodeStart <= 90 && toCodeStart >= 97) {
      return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) {
      return toNodeName === fromNodeName.toUpperCase();
    } else {
      return false;
    }
  }
  function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ? doc.createElement(name) : doc.createElementNS(namespaceURI, name);
  }
  function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
      var nextChild = curChild.nextSibling;
      toEl.appendChild(curChild);
      curChild = nextChild;
    }
    return toEl;
  }
  function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
      fromEl[name] = toEl[name];
      if (fromEl[name]) {
        fromEl.setAttribute(name, "");
      } else {
        fromEl.removeAttribute(name);
      }
    }
  }
  var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
      var parentNode = fromEl.parentNode;
      if (parentNode) {
        var parentName = parentNode.nodeName.toUpperCase();
        if (parentName === "OPTGROUP") {
          parentNode = parentNode.parentNode;
          parentName = parentNode && parentNode.nodeName.toUpperCase();
        }
        if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
          if (fromEl.hasAttribute("selected") && !toEl.selected) {
            fromEl.setAttribute("selected", "selected");
            fromEl.removeAttribute("selected");
          }
          parentNode.selectedIndex = -1;
        }
      }
      syncBooleanAttrProp(fromEl, toEl, "selected");
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
      syncBooleanAttrProp(fromEl, toEl, "checked");
      syncBooleanAttrProp(fromEl, toEl, "disabled");
      if (fromEl.value !== toEl.value) {
        fromEl.value = toEl.value;
      }
      if (!toEl.hasAttribute("value")) {
        fromEl.removeAttribute("value");
      }
    },
    TEXTAREA: function(fromEl, toEl) {
      var newValue = toEl.value;
      if (fromEl.value !== newValue) {
        fromEl.value = newValue;
      }
      var firstChild = fromEl.firstChild;
      if (firstChild) {
        var oldValue = firstChild.nodeValue;
        if (oldValue == newValue || !newValue && oldValue == fromEl.placeholder) {
          return;
        }
        firstChild.nodeValue = newValue;
      }
    },
    SELECT: function(fromEl, toEl) {
      if (!toEl.hasAttribute("multiple")) {
        var selectedIndex = -1;
        var i = 0;
        var curChild = fromEl.firstChild;
        var optgroup;
        var nodeName;
        while (curChild) {
          nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
          if (nodeName === "OPTGROUP") {
            optgroup = curChild;
            curChild = optgroup.firstChild;
          } else {
            if (nodeName === "OPTION") {
              if (curChild.hasAttribute("selected")) {
                selectedIndex = i;
                break;
              }
              i++;
            }
            curChild = curChild.nextSibling;
            if (!curChild && optgroup) {
              curChild = optgroup.nextSibling;
              optgroup = null;
            }
          }
        }
        fromEl.selectedIndex = selectedIndex;
      }
    }
  };
  var ELEMENT_NODE = 1;
  var DOCUMENT_FRAGMENT_NODE$1 = 11;
  var TEXT_NODE = 3;
  var COMMENT_NODE = 8;
  function noop() {
  }
  function defaultGetNodeKey(node) {
    if (node) {
      return node.getAttribute && node.getAttribute("id") || node.id;
    }
  }
  function morphdomFactory(morphAttrs2) {
    return function morphdom2(fromNode, toNode, options) {
      if (!options) {
        options = {};
      }
      if (typeof toNode === "string") {
        if (fromNode.nodeName === "#document" || fromNode.nodeName === "HTML" || fromNode.nodeName === "BODY") {
          var toNodeHtml = toNode;
          toNode = doc.createElement("html");
          toNode.innerHTML = toNodeHtml;
        } else {
          toNode = toElement(toNode);
        }
      } else if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
        toNode = toNode.firstElementChild;
      }
      var getNodeKey = options.getNodeKey || defaultGetNodeKey;
      var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
      var onNodeAdded = options.onNodeAdded || noop;
      var onBeforeElUpdated = options.onBeforeElUpdated || noop;
      var onElUpdated = options.onElUpdated || noop;
      var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
      var onNodeDiscarded = options.onNodeDiscarded || noop;
      var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
      var skipFromChildren = options.skipFromChildren || noop;
      var addChild = options.addChild || function(parent, child) {
        return parent.appendChild(child);
      };
      var childrenOnly = options.childrenOnly === true;
      var fromNodesLookup = /* @__PURE__ */ Object.create(null);
      var keyedRemovalList = [];
      function addKeyedRemoval(key) {
        keyedRemovalList.push(key);
      }
      function walkDiscardedChildNodes(node, skipKeyedNodes) {
        if (node.nodeType === ELEMENT_NODE) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = void 0;
            if (skipKeyedNodes && (key = getNodeKey(curChild))) {
              addKeyedRemoval(key);
            } else {
              onNodeDiscarded(curChild);
              if (curChild.firstChild) {
                walkDiscardedChildNodes(curChild, skipKeyedNodes);
              }
            }
            curChild = curChild.nextSibling;
          }
        }
      }
      function removeNode(node, parentNode, skipKeyedNodes) {
        if (onBeforeNodeDiscarded(node) === false) {
          return;
        }
        if (parentNode) {
          parentNode.removeChild(node);
        }
        onNodeDiscarded(node);
        walkDiscardedChildNodes(node, skipKeyedNodes);
      }
      function indexTree(node) {
        if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
          var curChild = node.firstChild;
          while (curChild) {
            var key = getNodeKey(curChild);
            if (key) {
              fromNodesLookup[key] = curChild;
            }
            indexTree(curChild);
            curChild = curChild.nextSibling;
          }
        }
      }
      indexTree(fromNode);
      function handleNodeAdded(el) {
        onNodeAdded(el);
        var curChild = el.firstChild;
        while (curChild) {
          var nextSibling = curChild.nextSibling;
          var key = getNodeKey(curChild);
          if (key) {
            var unmatchedFromEl = fromNodesLookup[key];
            if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
              curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
              morphEl(unmatchedFromEl, curChild);
            } else {
              handleNodeAdded(curChild);
            }
          } else {
            handleNodeAdded(curChild);
          }
          curChild = nextSibling;
        }
      }
      function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
        while (curFromNodeChild) {
          var fromNextSibling = curFromNodeChild.nextSibling;
          if (curFromNodeKey = getNodeKey(curFromNodeChild)) {
            addKeyedRemoval(curFromNodeKey);
          } else {
            removeNode(
              curFromNodeChild,
              fromEl,
              true
              /* skip keyed nodes */
            );
          }
          curFromNodeChild = fromNextSibling;
        }
      }
      function morphEl(fromEl, toEl, childrenOnly2) {
        var toElKey = getNodeKey(toEl);
        if (toElKey) {
          delete fromNodesLookup[toElKey];
        }
        if (!childrenOnly2) {
          var beforeUpdateResult = onBeforeElUpdated(fromEl, toEl);
          if (beforeUpdateResult === false) {
            return;
          } else if (beforeUpdateResult instanceof HTMLElement) {
            fromEl = beforeUpdateResult;
            indexTree(fromEl);
          }
          morphAttrs2(fromEl, toEl);
          onElUpdated(fromEl);
          if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
            return;
          }
        }
        if (fromEl.nodeName !== "TEXTAREA") {
          morphChildren(fromEl, toEl);
        } else {
          specialElHandlers.TEXTAREA(fromEl, toEl);
        }
      }
      function morphChildren(fromEl, toEl) {
        var skipFrom = skipFromChildren(fromEl, toEl);
        var curToNodeChild = toEl.firstChild;
        var curFromNodeChild = fromEl.firstChild;
        var curToNodeKey;
        var curFromNodeKey;
        var fromNextSibling;
        var toNextSibling;
        var matchingFromEl;
        outer:
          while (curToNodeChild) {
            toNextSibling = curToNodeChild.nextSibling;
            curToNodeKey = getNodeKey(curToNodeChild);
            while (!skipFrom && curFromNodeChild) {
              fromNextSibling = curFromNodeChild.nextSibling;
              if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              curFromNodeKey = getNodeKey(curFromNodeChild);
              var curFromNodeType = curFromNodeChild.nodeType;
              var isCompatible = void 0;
              if (curFromNodeType === curToNodeChild.nodeType) {
                if (curFromNodeType === ELEMENT_NODE) {
                  if (curToNodeKey) {
                    if (curToNodeKey !== curFromNodeKey) {
                      if (matchingFromEl = fromNodesLookup[curToNodeKey]) {
                        if (fromNextSibling === matchingFromEl) {
                          isCompatible = false;
                        } else {
                          fromEl.insertBefore(matchingFromEl, curFromNodeChild);
                          if (curFromNodeKey) {
                            addKeyedRemoval(curFromNodeKey);
                          } else {
                            removeNode(
                              curFromNodeChild,
                              fromEl,
                              true
                              /* skip keyed nodes */
                            );
                          }
                          curFromNodeChild = matchingFromEl;
                          curFromNodeKey = getNodeKey(curFromNodeChild);
                        }
                      } else {
                        isCompatible = false;
                      }
                    }
                  } else if (curFromNodeKey) {
                    isCompatible = false;
                  }
                  isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                  if (isCompatible) {
                    morphEl(curFromNodeChild, curToNodeChild);
                  }
                } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                  isCompatible = true;
                  if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                  }
                }
              }
              if (isCompatible) {
                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
                continue outer;
              }
              if (curFromNodeKey) {
                addKeyedRemoval(curFromNodeKey);
              } else {
                removeNode(
                  curFromNodeChild,
                  fromEl,
                  true
                  /* skip keyed nodes */
                );
              }
              curFromNodeChild = fromNextSibling;
            }
            if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
              if (!skipFrom) {
                addChild(fromEl, matchingFromEl);
              }
              morphEl(matchingFromEl, curToNodeChild);
            } else {
              var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
              if (onBeforeNodeAddedResult !== false) {
                if (onBeforeNodeAddedResult) {
                  curToNodeChild = onBeforeNodeAddedResult;
                }
                if (curToNodeChild.actualize) {
                  curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                }
                addChild(fromEl, curToNodeChild);
                handleNodeAdded(curToNodeChild);
              }
            }
            curToNodeChild = toNextSibling;
            curFromNodeChild = fromNextSibling;
          }
        cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);
        var specialElHandler = specialElHandlers[fromEl.nodeName];
        if (specialElHandler) {
          specialElHandler(fromEl, toEl);
        }
      }
      var morphedNode = fromNode;
      var morphedNodeType = morphedNode.nodeType;
      var toNodeType = toNode.nodeType;
      if (!childrenOnly) {
        if (morphedNodeType === ELEMENT_NODE) {
          if (toNodeType === ELEMENT_NODE) {
            if (!compareNodeNames(fromNode, toNode)) {
              onNodeDiscarded(fromNode);
              morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
            }
          } else {
            morphedNode = toNode;
          }
        } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) {
          if (toNodeType === morphedNodeType) {
            if (morphedNode.nodeValue !== toNode.nodeValue) {
              morphedNode.nodeValue = toNode.nodeValue;
            }
            return morphedNode;
          } else {
            morphedNode = toNode;
          }
        }
      }
      if (morphedNode === toNode) {
        onNodeDiscarded(fromNode);
      } else {
        if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
          return;
        }
        morphEl(morphedNode, toNode, childrenOnly);
        if (keyedRemovalList) {
          for (var i = 0, len = keyedRemovalList.length; i < len; i++) {
            var elToRemove = fromNodesLookup[keyedRemovalList[i]];
            if (elToRemove) {
              removeNode(elToRemove, elToRemove.parentNode, false);
            }
          }
        }
      }
      if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
        if (morphedNode.actualize) {
          morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
        }
        fromNode.parentNode.replaceChild(morphedNode, fromNode);
      }
      return morphedNode;
    };
  }
  var morphdom = morphdomFactory(morphAttrs);
  var morphdom_esm_default = morphdom;
  var DOMPatch = class {
    constructor(view, container, id, html, streams, targetCID, opts = {}) {
      this.view = view;
      this.liveSocket = view.liveSocket;
      this.container = container;
      this.id = id;
      this.rootID = view.root.id;
      this.html = html;
      this.streams = streams;
      this.streamInserts = {};
      this.streamComponentRestore = {};
      this.targetCID = targetCID;
      this.cidPatch = isCid(this.targetCID);
      this.pendingRemoves = [];
      this.phxRemove = this.liveSocket.binding("remove");
      this.targetContainer = this.isCIDPatch() ? this.targetCIDContainer(html) : container;
      this.callbacks = {
        beforeadded: [],
        beforeupdated: [],
        beforephxChildAdded: [],
        afteradded: [],
        afterupdated: [],
        afterdiscarded: [],
        afterphxChildAdded: [],
        aftertransitionsDiscarded: []
      };
      this.withChildren = opts.withChildren || opts.undoRef || false;
      this.undoRef = opts.undoRef;
    }
    before(kind, callback2) {
      this.callbacks[`before${kind}`].push(callback2);
    }
    after(kind, callback2) {
      this.callbacks[`after${kind}`].push(callback2);
    }
    trackBefore(kind, ...args) {
      this.callbacks[`before${kind}`].forEach((callback2) => callback2(...args));
    }
    trackAfter(kind, ...args) {
      this.callbacks[`after${kind}`].forEach((callback2) => callback2(...args));
    }
    markPrunableContentForRemoval() {
      let phxUpdate = this.liveSocket.binding(PHX_UPDATE);
      dom_default.all(this.container, `[${phxUpdate}=append] > *, [${phxUpdate}=prepend] > *`, (el) => {
        el.setAttribute(PHX_PRUNE, "");
      });
    }
    perform(isJoinPatch) {
      let { view, liveSocket: liveSocket2, html, container, targetContainer } = this;
      if (this.isCIDPatch() && !targetContainer) {
        return;
      }
      let focused = liveSocket2.getActiveElement();
      let { selectionStart, selectionEnd } = focused && dom_default.hasSelectionRange(focused) ? focused : {};
      let phxUpdate = liveSocket2.binding(PHX_UPDATE);
      let phxViewportTop = liveSocket2.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = liveSocket2.binding(PHX_VIEWPORT_BOTTOM);
      let phxTriggerExternal = liveSocket2.binding(PHX_TRIGGER_ACTION);
      let added = [];
      let updates = [];
      let appendPrependUpdates = [];
      let externalFormTriggered = null;
      function morph(targetContainer2, source, withChildren = this.withChildren) {
        let morphCallbacks = {
          // normally, we are running with childrenOnly, as the patch HTML for a LV
          // does not include the LV attrs (data-phx-session, etc.)
          // when we are patching a live component, we do want to patch the root element as well;
          // another case is the recursive patch of a stream item that was kept on reset (-> onBeforeNodeAdded)
          childrenOnly: targetContainer2.getAttribute(PHX_COMPONENT) === null && !withChildren,
          getNodeKey: (node) => {
            if (dom_default.isPhxDestroyed(node)) {
              return null;
            }
            if (isJoinPatch) {
              return node.id;
            }
            return node.id || node.getAttribute && node.getAttribute(PHX_MAGIC_ID);
          },
          // skip indexing from children when container is stream
          skipFromChildren: (from2) => {
            return from2.getAttribute(phxUpdate) === PHX_STREAM;
          },
          // tell morphdom how to add a child
          addChild: (parent, child) => {
            let { ref, streamAt } = this.getStreamInsert(child);
            if (ref === void 0) {
              return parent.appendChild(child);
            }
            this.setStreamRef(child, ref);
            if (streamAt === 0) {
              parent.insertAdjacentElement("afterbegin", child);
            } else if (streamAt === -1) {
              let lastChild = parent.lastElementChild;
              if (lastChild && !lastChild.hasAttribute(PHX_STREAM_REF)) {
                let nonStreamChild = Array.from(parent.children).find((c) => !c.hasAttribute(PHX_STREAM_REF));
                parent.insertBefore(child, nonStreamChild);
              } else {
                parent.appendChild(child);
              }
            } else if (streamAt > 0) {
              let sibling = Array.from(parent.children)[streamAt];
              parent.insertBefore(child, sibling);
            }
          },
          onBeforeNodeAdded: (el) => {
            dom_default.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);
            this.trackBefore("added", el);
            let morphedEl = el;
            if (this.streamComponentRestore[el.id]) {
              morphedEl = this.streamComponentRestore[el.id];
              delete this.streamComponentRestore[el.id];
              morph.call(this, morphedEl, el, true);
            }
            return morphedEl;
          },
          onNodeAdded: (el) => {
            if (el.getAttribute) {
              this.maybeReOrderStream(el, true);
            }
            if (el instanceof HTMLImageElement && el.srcset) {
              el.srcset = el.srcset;
            } else if (el instanceof HTMLVideoElement && el.autoplay) {
              el.play();
            }
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            if (dom_default.isPhxChild(el) && view.ownsElement(el) || dom_default.isPhxSticky(el) && view.ownsElement(el.parentNode)) {
              this.trackAfter("phxChildAdded", el);
            }
            added.push(el);
          },
          onNodeDiscarded: (el) => this.onNodeDiscarded(el),
          onBeforeNodeDiscarded: (el) => {
            if (el.getAttribute && el.getAttribute(PHX_PRUNE) !== null) {
              return true;
            }
            if (el.parentElement !== null && el.id && dom_default.isPhxUpdate(el.parentElement, phxUpdate, [PHX_STREAM, "append", "prepend"])) {
              return false;
            }
            if (this.maybePendingRemove(el)) {
              return false;
            }
            if (this.skipCIDSibling(el)) {
              return false;
            }
            return true;
          },
          onElUpdated: (el) => {
            if (dom_default.isNowTriggerFormExternal(el, phxTriggerExternal)) {
              externalFormTriggered = el;
            }
            updates.push(el);
            this.maybeReOrderStream(el, false);
          },
          onBeforeElUpdated: (fromEl, toEl) => {
            if (fromEl.id && fromEl.isSameNode(targetContainer2) && fromEl.id !== toEl.id) {
              morphCallbacks.onNodeDiscarded(fromEl);
              fromEl.replaceWith(toEl);
              return morphCallbacks.onNodeAdded(toEl);
            }
            dom_default.syncPendingAttrs(fromEl, toEl);
            dom_default.maintainPrivateHooks(fromEl, toEl, phxViewportTop, phxViewportBottom);
            dom_default.cleanChildNodes(toEl, phxUpdate);
            if (this.skipCIDSibling(toEl)) {
              this.maybeReOrderStream(fromEl);
              return false;
            }
            if (dom_default.isPhxSticky(fromEl)) {
              [PHX_SESSION, PHX_STATIC, PHX_ROOT_ID].map((attr) => [attr, fromEl.getAttribute(attr), toEl.getAttribute(attr)]).forEach(([attr, fromVal, toVal]) => {
                if (toVal && fromVal !== toVal) {
                  fromEl.setAttribute(attr, toVal);
                }
              });
              return false;
            }
            if (dom_default.isIgnored(fromEl, phxUpdate) || fromEl.form && fromEl.form.isSameNode(externalFormTriggered)) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeAttrs(fromEl, toEl, { isIgnored: dom_default.isIgnored(fromEl, phxUpdate) });
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (fromEl.type === "number" && (fromEl.validity && fromEl.validity.badInput)) {
              return false;
            }
            let isFocusedFormEl = focused && fromEl.isSameNode(focused) && dom_default.isFormInput(fromEl);
            let focusedSelectChanged = isFocusedFormEl && this.isChangedSelect(fromEl, toEl);
            if (fromEl.hasAttribute(PHX_REF_SRC) && fromEl.getAttribute(PHX_REF_LOCK) != this.undoRef) {
              if (dom_default.isUploadInput(fromEl)) {
                dom_default.mergeAttrs(fromEl, toEl, { isIgnored: true });
                this.trackBefore("updated", fromEl, toEl);
                updates.push(fromEl);
              }
              dom_default.applyStickyOperations(fromEl);
              let isLocked = fromEl.hasAttribute(PHX_REF_LOCK);
              let clone22 = isLocked ? dom_default.private(fromEl, PHX_REF_LOCK) || fromEl.cloneNode(true) : null;
              if (clone22) {
                dom_default.putPrivate(fromEl, PHX_REF_LOCK, clone22);
                if (!isFocusedFormEl) {
                  fromEl = clone22;
                }
              }
            }
            if (dom_default.isPhxChild(toEl)) {
              let prevSession = fromEl.getAttribute(PHX_SESSION);
              dom_default.mergeAttrs(fromEl, toEl, { exclude: [PHX_STATIC] });
              if (prevSession !== "") {
                fromEl.setAttribute(PHX_SESSION, prevSession);
              }
              fromEl.setAttribute(PHX_ROOT_ID, this.rootID);
              dom_default.applyStickyOperations(fromEl);
              return false;
            }
            if (this.undoRef && dom_default.private(toEl, PHX_REF_LOCK)) {
              dom_default.putPrivate(fromEl, PHX_REF_LOCK, dom_default.private(toEl, PHX_REF_LOCK));
            }
            dom_default.copyPrivates(toEl, fromEl);
            if (isFocusedFormEl && fromEl.type !== "hidden" && !focusedSelectChanged) {
              this.trackBefore("updated", fromEl, toEl);
              dom_default.mergeFocusedInput(fromEl, toEl);
              dom_default.syncAttrsToProps(fromEl);
              updates.push(fromEl);
              dom_default.applyStickyOperations(fromEl);
              return false;
            } else {
              if (focusedSelectChanged) {
                fromEl.blur();
              }
              if (dom_default.isPhxUpdate(toEl, phxUpdate, ["append", "prepend"])) {
                appendPrependUpdates.push(new DOMPostMorphRestorer(fromEl, toEl, toEl.getAttribute(phxUpdate)));
              }
              dom_default.syncAttrsToProps(toEl);
              dom_default.applyStickyOperations(toEl);
              this.trackBefore("updated", fromEl, toEl);
              return fromEl;
            }
          }
        };
        morphdom_esm_default(targetContainer2, source, morphCallbacks);
      }
      this.trackBefore("added", container);
      this.trackBefore("updated", container, container);
      liveSocket2.time("morphdom", () => {
        this.streams.forEach(([ref, inserts, deleteIds, reset]) => {
          inserts.forEach(([key, streamAt, limit]) => {
            this.streamInserts[key] = { ref, streamAt, limit, reset };
          });
          if (reset !== void 0) {
            dom_default.all(container, `[${PHX_STREAM_REF}="${ref}"]`, (child) => {
              this.removeStreamChildElement(child);
            });
          }
          deleteIds.forEach((id) => {
            let child = container.querySelector(`[id="${id}"]`);
            if (child) {
              this.removeStreamChildElement(child);
            }
          });
        });
        if (isJoinPatch) {
          dom_default.all(this.container, `[${phxUpdate}=${PHX_STREAM}]`, (el) => {
            Array.from(el.children).forEach((child) => {
              this.removeStreamChildElement(child);
            });
          });
        }
        morph.call(this, targetContainer, html);
      });
      if (liveSocket2.isDebugEnabled()) {
        detectDuplicateIds();
        detectInvalidStreamInserts(this.streamInserts);
        Array.from(document.querySelectorAll("input[name=id]")).forEach((node) => {
          if (node.form) {
            console.error('Detected an input with name="id" inside a form! This will cause problems when patching the DOM.\n', node);
          }
        });
      }
      if (appendPrependUpdates.length > 0) {
        liveSocket2.time("post-morph append/prepend restoration", () => {
          appendPrependUpdates.forEach((update) => update.perform());
        });
      }
      liveSocket2.silenceEvents(() => dom_default.restoreFocus(focused, selectionStart, selectionEnd));
      dom_default.dispatchEvent(document, "phx:update");
      added.forEach((el) => this.trackAfter("added", el));
      updates.forEach((el) => this.trackAfter("updated", el));
      this.transitionPendingRemoves();
      if (externalFormTriggered) {
        liveSocket2.unload();
        Object.getPrototypeOf(externalFormTriggered).submit.call(externalFormTriggered);
      }
      return true;
    }
    onNodeDiscarded(el) {
      if (dom_default.isPhxChild(el) || dom_default.isPhxSticky(el)) {
        this.liveSocket.destroyViewByEl(el);
      }
      this.trackAfter("discarded", el);
    }
    maybePendingRemove(node) {
      if (node.getAttribute && node.getAttribute(this.phxRemove) !== null) {
        this.pendingRemoves.push(node);
        return true;
      } else {
        return false;
      }
    }
    removeStreamChildElement(child) {
      if (!this.view.ownsElement(child)) {
        return;
      }
      if (this.streamInserts[child.id]) {
        this.streamComponentRestore[child.id] = child;
        child.remove();
      } else {
        if (!this.maybePendingRemove(child)) {
          child.remove();
          this.onNodeDiscarded(child);
        }
      }
    }
    getStreamInsert(el) {
      let insert = el.id ? this.streamInserts[el.id] : {};
      return insert || {};
    }
    setStreamRef(el, ref) {
      dom_default.putSticky(el, PHX_STREAM_REF, (el2) => el2.setAttribute(PHX_STREAM_REF, ref));
    }
    maybeReOrderStream(el, isNew) {
      let { ref, streamAt, reset } = this.getStreamInsert(el);
      if (streamAt === void 0) {
        return;
      }
      this.setStreamRef(el, ref);
      if (!reset && !isNew) {
        return;
      }
      if (!el.parentElement) {
        return;
      }
      if (streamAt === 0) {
        el.parentElement.insertBefore(el, el.parentElement.firstElementChild);
      } else if (streamAt > 0) {
        let children = Array.from(el.parentElement.children);
        let oldIndex = children.indexOf(el);
        if (streamAt >= children.length - 1) {
          el.parentElement.appendChild(el);
        } else {
          let sibling = children[streamAt];
          if (oldIndex > streamAt) {
            el.parentElement.insertBefore(el, sibling);
          } else {
            el.parentElement.insertBefore(el, sibling.nextElementSibling);
          }
        }
      }
      this.maybeLimitStream(el);
    }
    maybeLimitStream(el) {
      let { limit } = this.getStreamInsert(el);
      let children = limit !== null && Array.from(el.parentElement.children);
      if (limit && limit < 0 && children.length > limit * -1) {
        children.slice(0, children.length + limit).forEach((child) => this.removeStreamChildElement(child));
      } else if (limit && limit >= 0 && children.length > limit) {
        children.slice(limit).forEach((child) => this.removeStreamChildElement(child));
      }
    }
    transitionPendingRemoves() {
      let { pendingRemoves, liveSocket: liveSocket2 } = this;
      if (pendingRemoves.length > 0) {
        liveSocket2.transitionRemoves(pendingRemoves, () => {
          pendingRemoves.forEach((el) => {
            let child = dom_default.firstPhxChild(el);
            if (child) {
              liveSocket2.destroyViewByEl(child);
            }
            el.remove();
          });
          this.trackAfter("transitionsDiscarded", pendingRemoves);
        });
      }
    }
    isChangedSelect(fromEl, toEl) {
      if (!(fromEl instanceof HTMLSelectElement) || fromEl.multiple) {
        return false;
      }
      if (fromEl.options.length !== toEl.options.length) {
        return true;
      }
      toEl.value = fromEl.value;
      return !fromEl.isEqualNode(toEl);
    }
    isCIDPatch() {
      return this.cidPatch;
    }
    skipCIDSibling(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.hasAttribute(PHX_SKIP);
    }
    targetCIDContainer(html) {
      if (!this.isCIDPatch()) {
        return;
      }
      let [first, ...rest] = dom_default.findComponentNodeList(this.container, this.targetCID);
      if (rest.length === 0 && dom_default.childNodeLength(html) === 1) {
        return first;
      } else {
        return first && first.parentNode;
      }
    }
    indexOf(parent, child) {
      return Array.from(parent.children).indexOf(child);
    }
  };
  var VOID_TAGS = /* @__PURE__ */ new Set([
    "area",
    "base",
    "br",
    "col",
    "command",
    "embed",
    "hr",
    "img",
    "input",
    "keygen",
    "link",
    "meta",
    "param",
    "source",
    "track",
    "wbr"
  ]);
  var quoteChars = /* @__PURE__ */ new Set(["'", '"']);
  var modifyRoot = (html, attrs, clearInnerHTML) => {
    let i = 0;
    let insideComment = false;
    let beforeTag, afterTag, tag, tagNameEndsAt, id, newHTML;
    let lookahead = html.match(/^(\s*(?:<!--.*?-->\s*)*)<([^\s\/>]+)/);
    if (lookahead === null) {
      throw new Error(`malformed html ${html}`);
    }
    i = lookahead[0].length;
    beforeTag = lookahead[1];
    tag = lookahead[2];
    tagNameEndsAt = i;
    for (i; i < html.length; i++) {
      if (html.charAt(i) === ">") {
        break;
      }
      if (html.charAt(i) === "=") {
        let isId = html.slice(i - 3, i) === " id";
        i++;
        let char = html.charAt(i);
        if (quoteChars.has(char)) {
          let attrStartsAt = i;
          i++;
          for (i; i < html.length; i++) {
            if (html.charAt(i) === char) {
              break;
            }
          }
          if (isId) {
            id = html.slice(attrStartsAt + 1, i);
            break;
          }
        }
      }
    }
    let closeAt = html.length - 1;
    insideComment = false;
    while (closeAt >= beforeTag.length + tag.length) {
      let char = html.charAt(closeAt);
      if (insideComment) {
        if (char === "-" && html.slice(closeAt - 3, closeAt) === "<!-") {
          insideComment = false;
          closeAt -= 4;
        } else {
          closeAt -= 1;
        }
      } else if (char === ">" && html.slice(closeAt - 2, closeAt) === "--") {
        insideComment = true;
        closeAt -= 3;
      } else if (char === ">") {
        break;
      } else {
        closeAt -= 1;
      }
    }
    afterTag = html.slice(closeAt + 1, html.length);
    let attrsStr = Object.keys(attrs).map((attr) => attrs[attr] === true ? attr : `${attr}="${attrs[attr]}"`).join(" ");
    if (clearInnerHTML) {
      let idAttrStr = id ? ` id="${id}"` : "";
      if (VOID_TAGS.has(tag)) {
        newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}/>`;
      } else {
        newHTML = `<${tag}${idAttrStr}${attrsStr === "" ? "" : " "}${attrsStr}></${tag}>`;
      }
    } else {
      let rest = html.slice(tagNameEndsAt, closeAt + 1);
      newHTML = `<${tag}${attrsStr === "" ? "" : " "}${attrsStr}${rest}`;
    }
    return [newHTML, beforeTag, afterTag];
  };
  var Rendered = class {
    static extract(diff) {
      let { [REPLY]: reply, [EVENTS]: events, [TITLE]: title } = diff;
      delete diff[REPLY];
      delete diff[EVENTS];
      delete diff[TITLE];
      return { diff, title, reply: reply || null, events: events || [] };
    }
    constructor(viewId, rendered) {
      this.viewId = viewId;
      this.rendered = {};
      this.magicId = 0;
      this.mergeDiff(rendered);
    }
    parentViewId() {
      return this.viewId;
    }
    toString(onlyCids) {
      let [str, streams] = this.recursiveToString(this.rendered, this.rendered[COMPONENTS], onlyCids, true, {});
      return [str, streams];
    }
    recursiveToString(rendered, components = rendered[COMPONENTS], onlyCids, changeTracking, rootAttrs) {
      onlyCids = onlyCids ? new Set(onlyCids) : null;
      let output = { buffer: "", components, onlyCids, streams: /* @__PURE__ */ new Set() };
      this.toOutputBuffer(rendered, null, output, changeTracking, rootAttrs);
      return [output.buffer, output.streams];
    }
    componentCIDs(diff) {
      return Object.keys(diff[COMPONENTS] || {}).map((i) => parseInt(i));
    }
    isComponentOnlyDiff(diff) {
      if (!diff[COMPONENTS]) {
        return false;
      }
      return Object.keys(diff).length === 1;
    }
    getComponent(diff, cid) {
      return diff[COMPONENTS][cid];
    }
    resetRender(cid) {
      if (this.rendered[COMPONENTS][cid]) {
        this.rendered[COMPONENTS][cid].reset = true;
      }
    }
    mergeDiff(diff) {
      let newc = diff[COMPONENTS];
      let cache = {};
      delete diff[COMPONENTS];
      this.rendered = this.mutableMerge(this.rendered, diff);
      this.rendered[COMPONENTS] = this.rendered[COMPONENTS] || {};
      if (newc) {
        let oldc = this.rendered[COMPONENTS];
        for (let cid in newc) {
          newc[cid] = this.cachedFindComponent(cid, newc[cid], oldc, newc, cache);
        }
        for (let cid in newc) {
          oldc[cid] = newc[cid];
        }
        diff[COMPONENTS] = newc;
      }
    }
    cachedFindComponent(cid, cdiff, oldc, newc, cache) {
      if (cache[cid]) {
        return cache[cid];
      } else {
        let ndiff, stat, scid = cdiff[STATIC];
        if (isCid(scid)) {
          let tdiff;
          if (scid > 0) {
            tdiff = this.cachedFindComponent(scid, newc[scid], oldc, newc, cache);
          } else {
            tdiff = oldc[-scid];
          }
          stat = tdiff[STATIC];
          ndiff = this.cloneMerge(tdiff, cdiff, true);
          ndiff[STATIC] = stat;
        } else {
          ndiff = cdiff[STATIC] !== void 0 || oldc[cid] === void 0 ? cdiff : this.cloneMerge(oldc[cid], cdiff, false);
        }
        cache[cid] = ndiff;
        return ndiff;
      }
    }
    mutableMerge(target, source) {
      if (source[STATIC] !== void 0) {
        return source;
      } else {
        this.doMutableMerge(target, source);
        return target;
      }
    }
    doMutableMerge(target, source) {
      for (let key in source) {
        let val = source[key];
        let targetVal = target[key];
        let isObjVal = isObject(val);
        if (isObjVal && val[STATIC] === void 0 && isObject(targetVal)) {
          this.doMutableMerge(targetVal, val);
        } else {
          target[key] = val;
        }
      }
      if (target[ROOT]) {
        target.newRender = true;
      }
    }
    // Merges cid trees together, copying statics from source tree.
    //
    // The `pruneMagicId` is passed to control pruning the magicId of the
    // target. We must always prune the magicId when we are sharing statics
    // from another component. If not pruning, we replicate the logic from
    // mutableMerge, where we set newRender to true if there is a root
    // (effectively forcing the new version to be rendered instead of skipped)
    //
    cloneMerge(target, source, pruneMagicId) {
      let merged = __spreadValues(__spreadValues({}, target), source);
      for (let key in merged) {
        let val = source[key];
        let targetVal = target[key];
        if (isObject(val) && val[STATIC] === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, val, pruneMagicId);
        } else if (val === void 0 && isObject(targetVal)) {
          merged[key] = this.cloneMerge(targetVal, {}, pruneMagicId);
        }
      }
      if (pruneMagicId) {
        delete merged.magicId;
        delete merged.newRender;
      } else if (target[ROOT]) {
        merged.newRender = true;
      }
      return merged;
    }
    componentToString(cid) {
      let [str, streams] = this.recursiveCIDToString(this.rendered[COMPONENTS], cid, null);
      let [strippedHTML, _before, _after] = modifyRoot(str, {});
      return [strippedHTML, streams];
    }
    pruneCIDs(cids) {
      cids.forEach((cid) => delete this.rendered[COMPONENTS][cid]);
    }
    // private
    get() {
      return this.rendered;
    }
    isNewFingerprint(diff = {}) {
      return !!diff[STATIC];
    }
    templateStatic(part, templates) {
      if (typeof part === "number") {
        return templates[part];
      } else {
        return part;
      }
    }
    nextMagicID() {
      this.magicId++;
      return `m${this.magicId}-${this.parentViewId()}`;
    }
    // Converts rendered tree to output buffer.
    //
    // changeTracking controls if we can apply the PHX_SKIP optimization.
    // It is disabled for comprehensions since we must re-render the entire collection
    // and no individual element is tracked inside the comprehension.
    toOutputBuffer(rendered, templates, output, changeTracking, rootAttrs = {}) {
      if (rendered[DYNAMICS]) {
        return this.comprehensionToBuffer(rendered, templates, output);
      }
      let { [STATIC]: statics } = rendered;
      statics = this.templateStatic(statics, templates);
      let isRoot = rendered[ROOT];
      let prevBuffer = output.buffer;
      if (isRoot) {
        output.buffer = "";
      }
      if (changeTracking && isRoot && !rendered.magicId) {
        rendered.newRender = true;
        rendered.magicId = this.nextMagicID();
      }
      output.buffer += statics[0];
      for (let i = 1; i < statics.length; i++) {
        this.dynamicToBuffer(rendered[i - 1], templates, output, changeTracking);
        output.buffer += statics[i];
      }
      if (isRoot) {
        let skip2 = false;
        let attrs;
        if (changeTracking || rendered.magicId) {
          skip2 = changeTracking && !rendered.newRender;
          attrs = __spreadValues({ [PHX_MAGIC_ID]: rendered.magicId }, rootAttrs);
        } else {
          attrs = rootAttrs;
        }
        if (skip2) {
          attrs[PHX_SKIP] = true;
        }
        let [newRoot, commentBefore, commentAfter] = modifyRoot(output.buffer, attrs, skip2);
        rendered.newRender = false;
        output.buffer = prevBuffer + commentBefore + newRoot + commentAfter;
      }
    }
    comprehensionToBuffer(rendered, templates, output) {
      let { [DYNAMICS]: dynamics, [STATIC]: statics, [STREAM]: stream } = rendered;
      let [_ref, _inserts, deleteIds, reset] = stream || [null, {}, [], null];
      statics = this.templateStatic(statics, templates);
      let compTemplates = templates || rendered[TEMPLATES];
      for (let d = 0; d < dynamics.length; d++) {
        let dynamic = dynamics[d];
        output.buffer += statics[0];
        for (let i = 1; i < statics.length; i++) {
          let changeTracking = false;
          this.dynamicToBuffer(dynamic[i - 1], compTemplates, output, changeTracking);
          output.buffer += statics[i];
        }
      }
      if (stream !== void 0 && (rendered[DYNAMICS].length > 0 || deleteIds.length > 0 || reset)) {
        delete rendered[STREAM];
        rendered[DYNAMICS] = [];
        output.streams.add(stream);
      }
    }
    dynamicToBuffer(rendered, templates, output, changeTracking) {
      if (typeof rendered === "number") {
        let [str, streams] = this.recursiveCIDToString(output.components, rendered, output.onlyCids);
        output.buffer += str;
        output.streams = /* @__PURE__ */ new Set([...output.streams, ...streams]);
      } else if (isObject(rendered)) {
        this.toOutputBuffer(rendered, templates, output, changeTracking, {});
      } else {
        output.buffer += rendered;
      }
    }
    recursiveCIDToString(components, cid, onlyCids) {
      let component = components[cid] || logError(`no component for CID ${cid}`, components);
      let attrs = { [PHX_COMPONENT]: cid };
      let skip2 = onlyCids && !onlyCids.has(cid);
      component.newRender = !skip2;
      component.magicId = `c${cid}-${this.parentViewId()}`;
      let changeTracking = !component.reset;
      let [html, streams] = this.recursiveToString(component, components, onlyCids, changeTracking, attrs);
      delete component.reset;
      return [html, streams];
    }
  };
  var focusStack = [];
  var default_transition_time = 200;
  var JS = {
    // private
    exec(e, eventType, phxEvent, view, sourceEl, defaults2) {
      let [defaultKind, defaultArgs] = defaults2 || [null, { callback: defaults2 && defaults2.callback }];
      let commands = phxEvent.charAt(0) === "[" ? JSON.parse(phxEvent) : [[defaultKind, defaultArgs]];
      commands.forEach(([kind, args]) => {
        if (kind === defaultKind) {
          args = __spreadValues(__spreadValues({}, defaultArgs), args);
          args.callback = args.callback || defaultArgs.callback;
        }
        this.filterToEls(view.liveSocket, sourceEl, args).forEach((el) => {
          this[`exec_${kind}`](e, eventType, phxEvent, view, sourceEl, el, args);
        });
      });
    },
    isVisible(el) {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length > 0);
    },
    // returns true if any part of the element is inside the viewport
    isInViewport(el) {
      const rect = el.getBoundingClientRect();
      const windowHeight = window.innerHeight || document.documentElement.clientHeight;
      const windowWidth = window.innerWidth || document.documentElement.clientWidth;
      return rect.right > 0 && rect.bottom > 0 && rect.left < windowWidth && rect.top < windowHeight;
    },
    // private
    // commands
    exec_exec(e, eventType, phxEvent, view, sourceEl, el, { attr, to: to2 }) {
      let encodedJS = el.getAttribute(attr);
      if (!encodedJS) {
        throw new Error(`expected ${attr} to contain JS command on "${to2}"`);
      }
      view.liveSocket.execJS(el, encodedJS, eventType);
    },
    exec_dispatch(e, eventType, phxEvent, view, sourceEl, el, { event, detail, bubbles }) {
      detail = detail || {};
      detail.dispatcher = sourceEl;
      dom_default.dispatchEvent(el, event, { detail, bubbles });
    },
    exec_push(e, eventType, phxEvent, view, sourceEl, el, args) {
      let { event, data, target, page_loading, loading, value, dispatcher, callback: callback2 } = args;
      let pushOpts = { loading, value, target, page_loading: !!page_loading };
      let targetSrc = eventType === "change" && dispatcher ? dispatcher : sourceEl;
      let phxTarget = target || targetSrc.getAttribute(view.binding("target")) || targetSrc;
      const handler = (targetView, targetCtx) => {
        if (!targetView.isConnected()) {
          return;
        }
        if (eventType === "change") {
          let { newCid, _target } = args;
          _target = _target || (dom_default.isFormInput(sourceEl) ? sourceEl.name : void 0);
          if (_target) {
            pushOpts._target = _target;
          }
          targetView.pushInput(sourceEl, targetCtx, newCid, event || phxEvent, pushOpts, callback2);
        } else if (eventType === "submit") {
          let { submitter } = args;
          targetView.submitForm(sourceEl, targetCtx, event || phxEvent, submitter, pushOpts, callback2);
        } else {
          targetView.pushEvent(eventType, sourceEl, targetCtx, event || phxEvent, data, pushOpts, callback2);
        }
      };
      if (args.targetView && args.targetCtx) {
        handler(args.targetView, args.targetCtx);
      } else {
        view.withinTargets(phxTarget, handler);
      }
    },
    exec_navigate(e, eventType, phxEvent, view, sourceEl, el, { href, replace }) {
      view.liveSocket.historyRedirect(e, href, replace ? "replace" : "push", null, sourceEl);
    },
    exec_patch(e, eventType, phxEvent, view, sourceEl, el, { href, replace }) {
      view.liveSocket.pushHistoryPatch(e, href, replace ? "replace" : "push", sourceEl);
    },
    exec_focus(e, eventType, phxEvent, view, sourceEl, el) {
      aria_default.attemptFocus(el);
      window.requestAnimationFrame(() => {
        window.requestAnimationFrame(() => aria_default.attemptFocus(el));
      });
    },
    exec_focus_first(e, eventType, phxEvent, view, sourceEl, el) {
      aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el);
      window.requestAnimationFrame(() => {
        window.requestAnimationFrame(() => aria_default.focusFirstInteractive(el) || aria_default.focusFirst(el));
      });
    },
    exec_push_focus(e, eventType, phxEvent, view, sourceEl, el) {
      focusStack.push(el || sourceEl);
    },
    exec_pop_focus(_e, _eventType, _phxEvent, _view, _sourceEl, _el) {
      const el = focusStack.pop();
      if (el) {
        el.focus();
        window.requestAnimationFrame(() => {
          window.requestAnimationFrame(() => el.focus());
        });
      }
    },
    exec_add_class(e, eventType, phxEvent, view, sourceEl, el, { names: names2, transition, time, blocking }) {
      this.addOrRemoveClasses(el, names2, [], transition, time, view, blocking);
    },
    exec_remove_class(e, eventType, phxEvent, view, sourceEl, el, { names: names2, transition, time, blocking }) {
      this.addOrRemoveClasses(el, [], names2, transition, time, view, blocking);
    },
    exec_toggle_class(e, eventType, phxEvent, view, sourceEl, el, { names: names2, transition, time, blocking }) {
      this.toggleClasses(el, names2, transition, time, view, blocking);
    },
    exec_toggle_attr(e, eventType, phxEvent, view, sourceEl, el, { attr: [attr, val1, val2] }) {
      this.toggleAttr(el, attr, val1, val2);
    },
    exec_transition(e, eventType, phxEvent, view, sourceEl, el, { time, transition, blocking }) {
      this.addOrRemoveClasses(el, [], [], transition, time, view, blocking);
    },
    exec_toggle(e, eventType, phxEvent, view, sourceEl, el, { display, ins, outs, time, blocking }) {
      this.toggle(eventType, view, el, display, ins, outs, time, blocking);
    },
    exec_show(e, eventType, phxEvent, view, sourceEl, el, { display, transition, time, blocking }) {
      this.show(eventType, view, el, display, transition, time, blocking);
    },
    exec_hide(e, eventType, phxEvent, view, sourceEl, el, { display, transition, time, blocking }) {
      this.hide(eventType, view, el, display, transition, time, blocking);
    },
    exec_set_attr(e, eventType, phxEvent, view, sourceEl, el, { attr: [attr, val] }) {
      this.setOrRemoveAttrs(el, [[attr, val]], []);
    },
    exec_remove_attr(e, eventType, phxEvent, view, sourceEl, el, { attr }) {
      this.setOrRemoveAttrs(el, [], [attr]);
    },
    // utils for commands
    show(eventType, view, el, display, transition, time, blocking) {
      if (!this.isVisible(el)) {
        this.toggle(eventType, view, el, display, transition, null, time, blocking);
      }
    },
    hide(eventType, view, el, display, transition, time, blocking) {
      if (this.isVisible(el)) {
        this.toggle(eventType, view, el, display, null, transition, time, blocking);
      }
    },
    toggle(eventType, view, el, display, ins, outs, time, blocking) {
      time = time || default_transition_time;
      let [inClasses, inStartClasses, inEndClasses] = ins || [[], [], []];
      let [outClasses, outStartClasses, outEndClasses] = outs || [[], [], []];
      if (inClasses.length > 0 || outClasses.length > 0) {
        if (this.isVisible(el)) {
          let onStart = () => {
            this.addOrRemoveClasses(el, outStartClasses, inClasses.concat(inStartClasses).concat(inEndClasses));
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, outClasses, []);
              window.requestAnimationFrame(() => this.addOrRemoveClasses(el, outEndClasses, outStartClasses));
            });
          };
          let onEnd = () => {
            this.addOrRemoveClasses(el, [], outClasses.concat(outEndClasses));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          };
          el.dispatchEvent(new Event("phx:hide-start"));
          if (blocking === false) {
            onStart();
            setTimeout(onEnd, time);
          } else {
            view.transition(time, onStart, onEnd);
          }
        } else {
          if (eventType === "remove") {
            return;
          }
          let onStart = () => {
            this.addOrRemoveClasses(el, inStartClasses, outClasses.concat(outStartClasses).concat(outEndClasses));
            const stickyDisplay = display || this.defaultDisplay(el);
            window.requestAnimationFrame(() => {
              this.addOrRemoveClasses(el, inClasses, []);
              window.requestAnimationFrame(() => {
                dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
                this.addOrRemoveClasses(el, inEndClasses, inStartClasses);
              });
            });
          };
          let onEnd = () => {
            this.addOrRemoveClasses(el, [], inClasses.concat(inEndClasses));
            el.dispatchEvent(new Event("phx:show-end"));
          };
          el.dispatchEvent(new Event("phx:show-start"));
          if (blocking === false) {
            onStart();
            setTimeout(onEnd, time);
          } else {
            view.transition(time, onStart, onEnd);
          }
        }
      } else {
        if (this.isVisible(el)) {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:hide-start"));
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = "none");
            el.dispatchEvent(new Event("phx:hide-end"));
          });
        } else {
          window.requestAnimationFrame(() => {
            el.dispatchEvent(new Event("phx:show-start"));
            let stickyDisplay = display || this.defaultDisplay(el);
            dom_default.putSticky(el, "toggle", (currentEl) => currentEl.style.display = stickyDisplay);
            el.dispatchEvent(new Event("phx:show-end"));
          });
        }
      }
    },
    toggleClasses(el, classes, transition, time, view, blocking) {
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let newAdds = classes.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let newRemoves = classes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        this.addOrRemoveClasses(el, newAdds, newRemoves, transition, time, view, blocking);
      });
    },
    toggleAttr(el, attr, val1, val2) {
      if (el.hasAttribute(attr)) {
        if (val2 !== void 0) {
          if (el.getAttribute(attr) === val1) {
            this.setOrRemoveAttrs(el, [[attr, val2]], []);
          } else {
            this.setOrRemoveAttrs(el, [[attr, val1]], []);
          }
        } else {
          this.setOrRemoveAttrs(el, [], [attr]);
        }
      } else {
        this.setOrRemoveAttrs(el, [[attr, val1]], []);
      }
    },
    addOrRemoveClasses(el, adds, removes, transition, time, view, blocking) {
      time = time || default_transition_time;
      let [transitionRun, transitionStart, transitionEnd] = transition || [[], [], []];
      if (transitionRun.length > 0) {
        let onStart = () => {
          this.addOrRemoveClasses(el, transitionStart, [].concat(transitionRun).concat(transitionEnd));
          window.requestAnimationFrame(() => {
            this.addOrRemoveClasses(el, transitionRun, []);
            window.requestAnimationFrame(() => this.addOrRemoveClasses(el, transitionEnd, transitionStart));
          });
        };
        let onDone = () => this.addOrRemoveClasses(el, adds.concat(transitionEnd), removes.concat(transitionRun).concat(transitionStart));
        if (blocking === false) {
          onStart();
          setTimeout(onDone, time);
        } else {
          view.transition(time, onStart, onDone);
        }
        return;
      }
      window.requestAnimationFrame(() => {
        let [prevAdds, prevRemoves] = dom_default.getSticky(el, "classes", [[], []]);
        let keepAdds = adds.filter((name) => prevAdds.indexOf(name) < 0 && !el.classList.contains(name));
        let keepRemoves = removes.filter((name) => prevRemoves.indexOf(name) < 0 && el.classList.contains(name));
        let newAdds = prevAdds.filter((name) => removes.indexOf(name) < 0).concat(keepAdds);
        let newRemoves = prevRemoves.filter((name) => adds.indexOf(name) < 0).concat(keepRemoves);
        dom_default.putSticky(el, "classes", (currentEl) => {
          currentEl.classList.remove(...newRemoves);
          currentEl.classList.add(...newAdds);
          return [newAdds, newRemoves];
        });
      });
    },
    setOrRemoveAttrs(el, sets, removes) {
      let [prevSets, prevRemoves] = dom_default.getSticky(el, "attrs", [[], []]);
      let alteredAttrs = sets.map(([attr, _val]) => attr).concat(removes);
      let newSets = prevSets.filter(([attr, _val]) => !alteredAttrs.includes(attr)).concat(sets);
      let newRemoves = prevRemoves.filter((attr) => !alteredAttrs.includes(attr)).concat(removes);
      dom_default.putSticky(el, "attrs", (currentEl) => {
        newRemoves.forEach((attr) => currentEl.removeAttribute(attr));
        newSets.forEach(([attr, val]) => currentEl.setAttribute(attr, val));
        return [newSets, newRemoves];
      });
    },
    hasAllClasses(el, classes) {
      return classes.every((name) => el.classList.contains(name));
    },
    isToggledOut(el, outClasses) {
      return !this.isVisible(el) || this.hasAllClasses(el, outClasses);
    },
    filterToEls(liveSocket2, sourceEl, { to: to2 }) {
      let defaultQuery = () => {
        if (typeof to2 === "string") {
          return document.querySelectorAll(to2);
        } else if (to2.closest) {
          let toEl = sourceEl.closest(to2.closest);
          return toEl ? [toEl] : [];
        } else if (to2.inner) {
          return sourceEl.querySelectorAll(to2.inner);
        }
      };
      return to2 ? liveSocket2.jsQuerySelectorAll(sourceEl, to2, defaultQuery) : [sourceEl];
    },
    defaultDisplay(el) {
      return { tr: "table-row", td: "table-cell" }[el.tagName.toLowerCase()] || "block";
    },
    transitionClasses(val) {
      if (!val) {
        return null;
      }
      let [trans, tStart, tEnd] = Array.isArray(val) ? val : [val.split(" "), [], []];
      trans = Array.isArray(trans) ? trans : trans.split(" ");
      tStart = Array.isArray(tStart) ? tStart : tStart.split(" ");
      tEnd = Array.isArray(tEnd) ? tEnd : tEnd.split(" ");
      return [trans, tStart, tEnd];
    }
  };
  var js_default = JS;
  var HOOK_ID = "hookId";
  var viewHookID = 1;
  var ViewHook = class {
    static makeID() {
      return viewHookID++;
    }
    static elementID(el) {
      return dom_default.private(el, HOOK_ID);
    }
    constructor(view, el, callbacks) {
      this.el = el;
      this.__attachView(view);
      this.__callbacks = callbacks;
      this.__listeners = /* @__PURE__ */ new Set();
      this.__isDisconnected = false;
      dom_default.putPrivate(this.el, HOOK_ID, this.constructor.makeID());
      for (let key in this.__callbacks) {
        this[key] = this.__callbacks[key];
      }
    }
    __attachView(view) {
      if (view) {
        this.__view = () => view;
        this.liveSocket = view.liveSocket;
      } else {
        this.__view = () => {
          throw new Error(`hook not yet attached to a live view: ${this.el.outerHTML}`);
        };
        this.liveSocket = null;
      }
    }
    __mounted() {
      this.mounted && this.mounted();
    }
    __updated() {
      this.updated && this.updated();
    }
    __beforeUpdate() {
      this.beforeUpdate && this.beforeUpdate();
    }
    __destroyed() {
      this.destroyed && this.destroyed();
      dom_default.deletePrivate(this.el, HOOK_ID);
    }
    __reconnected() {
      if (this.__isDisconnected) {
        this.__isDisconnected = false;
        this.reconnected && this.reconnected();
      }
    }
    __disconnected() {
      this.__isDisconnected = true;
      this.disconnected && this.disconnected();
    }
    /**
     * Binds the hook to JS commands.
     *
     * @param {ViewHook} hook - The ViewHook instance to bind.
     *
     * @returns {Object} An object with methods to manipulate the DOM and execute JavaScript.
     */
    js() {
      let hook = this;
      return {
        /**
         * Executes encoded JavaScript in the context of the hook element.
         *
         * @param {string} encodedJS - The encoded JavaScript string to execute.
         */
        exec(encodedJS) {
          hook.__view().liveSocket.execJS(hook.el, encodedJS, "hook");
        },
        /**
         * Shows an element.
         *
         * @param {HTMLElement} el - The element to show.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.display] - The CSS display value to set. Defaults "block".
         * @param {string} [opts.transition] - The CSS transition classes to set when showing.
         * @param {number} [opts.time] - The transition duration in milliseconds. Defaults 200.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *  Defaults `true`.
         */
        show(el, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el);
          js_default.show("hook", owner, el, opts.display, opts.transition, opts.time, opts.blocking);
        },
        /**
         * Hides an element.
         *
         * @param {HTMLElement} el - The element to hide.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set when hiding.
         * @param {number} [opts.time] - The transition duration in milliseconds. Defaults 200.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        hide(el, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el);
          js_default.hide("hook", owner, el, null, opts.transition, opts.time, opts.blocking);
        },
        /**
         * Toggles the visibility of an element.
         *
         * @param {HTMLElement} el - The element to toggle.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.display] - The CSS display value to set. Defaults "block".
         * @param {string} [opts.in] - The CSS transition classes for showing.
         *   Accepts either the string of classes to apply when toggling in, or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-0", "opacity-100"]
         *
         * @param {string} [opts.out] - The CSS transition classes for hiding.
         *   Accepts either string of classes to apply when toggling out, or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         *
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        toggle(el, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el);
          opts.in = js_default.transitionClasses(opts.in);
          opts.out = js_default.transitionClasses(opts.out);
          js_default.toggle("hook", owner, el, opts.display, opts.in, opts.out, opts.time, opts.blocking);
        },
        /**
         * Adds CSS classes to an element.
         *
         * @param {HTMLElement} el - The element to add classes to.
         * @param {string|string[]} names - The class name(s) to add.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition property to set.
         *   Accepts a string of classes to apply when adding classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-0", "opacity-100"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        addClass(el, names2, opts = {}) {
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el);
          js_default.addOrRemoveClasses(el, names2, [], opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Removes CSS classes from an element.
         *
         * @param {HTMLElement} el - The element to remove classes from.
         * @param {string|string[]} names - The class name(s) to remove.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set.
         *   Accepts a string of classes to apply when removing classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        removeClass(el, names2, opts = {}) {
          opts.transition = js_default.transitionClasses(opts.transition);
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el);
          js_default.addOrRemoveClasses(el, [], names2, opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Toggles CSS classes on an element.
         *
         * @param {HTMLElement} el - The element to toggle classes on.
         * @param {string|string[]} names - The class name(s) to toggle.
         * @param {Object} [opts={}] - Optional settings.
         * @param {string} [opts.transition] - The CSS transition classes to set.
         *   Accepts a string of classes to apply when toggling classes or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        toggleClass(el, names2, opts = {}) {
          opts.transition = js_default.transitionClasses(opts.transition);
          names2 = Array.isArray(names2) ? names2 : names2.split(" ");
          let owner = hook.__view().liveSocket.owner(el);
          js_default.toggleClasses(el, names2, opts.transition, opts.time, owner, opts.blocking);
        },
        /**
         * Applies a CSS transition to an element.
         *
         * @param {HTMLElement} el - The element to apply the transition to.
         * @param {string|string[]} transition - The transition class(es) to apply.
         *   Accepts a string of classes to apply when transitioning or
         *   a 3-tuple containing the transition class, the class to apply
         *   to start the transition, and the ending transition class, such as:
         *
         *       ["ease-out duration-300", "opacity-100", "opacity-0"]
         *
         * @param {Object} [opts={}] - Optional settings.
         * @param {number} [opts.time] - The transition duration in milliseconds.
         * @param {boolean} [opts.blocking] - The boolean flag to block the UI during the transition.
         *   Defaults `true`.
         */
        transition(el, transition, opts = {}) {
          let owner = hook.__view().liveSocket.owner(el);
          js_default.addOrRemoveClasses(el, [], [], js_default.transitionClasses(transition), opts.time, owner, opts.blocking);
        },
        /**
         * Sets an attribute on an element.
         *
         * @param {HTMLElement} el - The element to set the attribute on.
         * @param {string} attr - The attribute name to set.
         * @param {string} val - The value to set for the attribute.
         */
        setAttribute(el, attr, val) {
          js_default.setOrRemoveAttrs(el, [[attr, val]], []);
        },
        /**
         * Removes an attribute from an element.
         *
         * @param {HTMLElement} el - The element to remove the attribute from.
         * @param {string} attr - The attribute name to remove.
         */
        removeAttribute(el, attr) {
          js_default.setOrRemoveAttrs(el, [], [attr]);
        },
        /**
         * Toggles an attribute on an element between two values.
         *
         * @param {HTMLElement} el - The element to toggle the attribute on.
         * @param {string} attr - The attribute name to toggle.
         * @param {string} val1 - The first value to toggle between.
         * @param {string} val2 - The second value to toggle between.
         */
        toggleAttribute(el, attr, val1, val2) {
          js_default.toggleAttr(el, attr, val1, val2);
        }
      };
    }
    pushEvent(event, payload = {}, onReply) {
      if (onReply === void 0) {
        return new Promise((resolve2, reject) => {
          try {
            const ref = this.__view().pushHookEvent(this.el, null, event, payload, (reply, _ref) => resolve2(reply));
            if (ref === false) {
              reject(new Error("unable to push hook event. LiveView not connected"));
            }
          } catch (error) {
            reject(error);
          }
        });
      }
      return this.__view().pushHookEvent(this.el, null, event, payload, onReply);
    }
    pushEventTo(phxTarget, event, payload = {}, onReply) {
      if (onReply === void 0) {
        return new Promise((resolve2, reject) => {
          try {
            this.__view().withinTargets(phxTarget, (view, targetCtx) => {
              const ref = view.pushHookEvent(this.el, targetCtx, event, payload, (reply, _ref) => resolve2(reply));
              if (ref === false) {
                reject(new Error("unable to push hook event. LiveView not connected"));
              }
            });
          } catch (error) {
            reject(error);
          }
        });
      }
      return this.__view().withinTargets(phxTarget, (view, targetCtx) => {
        return view.pushHookEvent(this.el, targetCtx, event, payload, onReply);
      });
    }
    handleEvent(event, callback2) {
      let callbackRef = (customEvent, bypass) => bypass ? event : callback2(customEvent.detail);
      window.addEventListener(`phx:${event}`, callbackRef);
      this.__listeners.add(callbackRef);
      return callbackRef;
    }
    removeHandleEvent(callbackRef) {
      let event = callbackRef(null, true);
      window.removeEventListener(`phx:${event}`, callbackRef);
      this.__listeners.delete(callbackRef);
    }
    upload(name, files) {
      return this.__view().dispatchUploads(null, name, files);
    }
    uploadTo(phxTarget, name, files) {
      return this.__view().withinTargets(phxTarget, (view, targetCtx) => {
        view.dispatchUploads(targetCtx, name, files);
      });
    }
    __cleanup__() {
      this.__listeners.forEach((callbackRef) => this.removeHandleEvent(callbackRef));
    }
  };
  var prependFormDataKey = (key, prefix) => {
    let isArray2 = key.endsWith("[]");
    let baseKey = isArray2 ? key.slice(0, -2) : key;
    baseKey = baseKey.replace(/([^\[\]]+)(\]?$)/, `${prefix}$1$2`);
    if (isArray2) {
      baseKey += "[]";
    }
    return baseKey;
  };
  var serializeForm = (form, opts, onlyNames = []) => {
    const { submitter } = opts;
    let injectedElement;
    if (submitter && submitter.name) {
      const input = document.createElement("input");
      input.type = "hidden";
      const formId = submitter.getAttribute("form");
      if (formId) {
        input.setAttribute("form", formId);
      }
      input.name = submitter.name;
      input.value = submitter.value;
      submitter.parentElement.insertBefore(input, submitter);
      injectedElement = input;
    }
    const formData = new FormData(form);
    const toRemove = [];
    formData.forEach((val, key, _index) => {
      if (val instanceof File) {
        toRemove.push(key);
      }
    });
    toRemove.forEach((key) => formData.delete(key));
    const params = new URLSearchParams();
    const { inputsUnused, onlyHiddenInputs } = Array.from(form.elements).reduce((acc, input) => {
      const { inputsUnused: inputsUnused2, onlyHiddenInputs: onlyHiddenInputs2 } = acc;
      const key = input.name;
      if (!key) {
        return acc;
      }
      if (inputsUnused2[key] === void 0) {
        inputsUnused2[key] = true;
      }
      if (onlyHiddenInputs2[key] === void 0) {
        onlyHiddenInputs2[key] = true;
      }
      const isUsed = dom_default.private(input, PHX_HAS_FOCUSED) || dom_default.private(input, PHX_HAS_SUBMITTED);
      const isHidden = input.type === "hidden";
      inputsUnused2[key] = inputsUnused2[key] && !isUsed;
      onlyHiddenInputs2[key] = onlyHiddenInputs2[key] && isHidden;
      return acc;
    }, { inputsUnused: {}, onlyHiddenInputs: {} });
    for (let [key, val] of formData.entries()) {
      if (onlyNames.length === 0 || onlyNames.indexOf(key) >= 0) {
        let isUnused = inputsUnused[key];
        let hidden = onlyHiddenInputs[key];
        if (isUnused && !(submitter && submitter.name == key) && !hidden) {
          params.append(prependFormDataKey(key, "_unused_"), "");
        }
        params.append(key, val);
      }
    }
    if (submitter && injectedElement) {
      submitter.parentElement.removeChild(injectedElement);
    }
    return params.toString();
  };
  var View = class _View {
    static closestView(el) {
      let liveViewEl = el.closest(PHX_VIEW_SELECTOR);
      return liveViewEl ? dom_default.private(liveViewEl, "view") : null;
    }
    constructor(el, liveSocket2, parentView, flash, liveReferer) {
      this.isDead = false;
      this.liveSocket = liveSocket2;
      this.flash = flash;
      this.parent = parentView;
      this.root = parentView ? parentView.root : this;
      this.el = el;
      dom_default.putPrivate(this.el, "view", this);
      this.id = this.el.id;
      this.ref = 0;
      this.lastAckRef = null;
      this.childJoins = 0;
      this.loaderTimer = null;
      this.disconnectedTimer = null;
      this.pendingDiffs = [];
      this.pendingForms = /* @__PURE__ */ new Set();
      this.redirect = false;
      this.href = null;
      this.joinCount = this.parent ? this.parent.joinCount - 1 : 0;
      this.joinAttempts = 0;
      this.joinPending = true;
      this.destroyed = false;
      this.joinCallback = function(onDone) {
        onDone && onDone();
      };
      this.stopCallback = function() {
      };
      this.pendingJoinOps = this.parent ? null : [];
      this.viewHooks = {};
      this.formSubmits = [];
      this.children = this.parent ? null : {};
      this.root.children[this.id] = {};
      this.formsForRecovery = {};
      this.channel = this.liveSocket.channel(`lv:${this.id}`, () => {
        let url = this.href && this.expandURL(this.href);
        return {
          redirect: this.redirect ? url : void 0,
          url: this.redirect ? void 0 : url || void 0,
          params: this.connectParams(liveReferer),
          session: this.getSession(),
          static: this.getStatic(),
          flash: this.flash
        };
      });
    }
    setHref(href) {
      this.href = href;
    }
    setRedirect(href) {
      this.redirect = true;
      this.href = href;
    }
    isMain() {
      return this.el.hasAttribute(PHX_MAIN);
    }
    connectParams(liveReferer) {
      let params = this.liveSocket.params(this.el);
      let manifest = dom_default.all(document, `[${this.binding(PHX_TRACK_STATIC)}]`).map((node) => node.src || node.href).filter((url) => typeof url === "string");
      if (manifest.length > 0) {
        params["_track_static"] = manifest;
      }
      params["_mounts"] = this.joinCount;
      params["_mount_attempts"] = this.joinAttempts;
      params["_live_referer"] = liveReferer;
      this.joinAttempts++;
      return params;
    }
    isConnected() {
      return this.channel.canPush();
    }
    getSession() {
      return this.el.getAttribute(PHX_SESSION);
    }
    getStatic() {
      let val = this.el.getAttribute(PHX_STATIC);
      return val === "" ? null : val;
    }
    destroy(callback2 = function() {
    }) {
      this.destroyAllChildren();
      this.destroyed = true;
      delete this.root.children[this.id];
      if (this.parent) {
        delete this.root.children[this.parent.id][this.id];
      }
      clearTimeout(this.loaderTimer);
      let onFinished = () => {
        callback2();
        for (let id in this.viewHooks) {
          this.destroyHook(this.viewHooks[id]);
        }
      };
      dom_default.markPhxChildDestroyed(this.el);
      this.log("destroyed", () => ["the child has been removed from the parent"]);
      this.channel.leave().receive("ok", onFinished).receive("error", onFinished).receive("timeout", onFinished);
    }
    setContainerClasses(...classes) {
      this.el.classList.remove(
        PHX_CONNECTED_CLASS,
        PHX_LOADING_CLASS,
        PHX_ERROR_CLASS,
        PHX_CLIENT_ERROR_CLASS,
        PHX_SERVER_ERROR_CLASS
      );
      this.el.classList.add(...classes);
    }
    showLoader(timeout) {
      clearTimeout(this.loaderTimer);
      if (timeout) {
        this.loaderTimer = setTimeout(() => this.showLoader(), timeout);
      } else {
        for (let id in this.viewHooks) {
          this.viewHooks[id].__disconnected();
        }
        this.setContainerClasses(PHX_LOADING_CLASS);
      }
    }
    execAll(binding) {
      dom_default.all(this.el, `[${binding}]`, (el) => this.liveSocket.execJS(el, el.getAttribute(binding)));
    }
    hideLoader() {
      clearTimeout(this.loaderTimer);
      clearTimeout(this.disconnectedTimer);
      this.setContainerClasses(PHX_CONNECTED_CLASS);
      this.execAll(this.binding("connected"));
    }
    triggerReconnected() {
      for (let id in this.viewHooks) {
        this.viewHooks[id].__reconnected();
      }
    }
    log(kind, msgCallback) {
      this.liveSocket.log(this, kind, msgCallback);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.liveSocket.transition(time, onStart, onDone);
    }
    // calls the callback with the view and target element for the given phxTarget
    // targets can be:
    //  * an element itself, then it is simply passed to liveSocket.owner;
    //  * a CID (Component ID), then we first search the component's element in the DOM
    //  * a selector, then we search the selector in the DOM and call the callback
    //    for each element found with the corresponding owner view
    withinTargets(phxTarget, callback2, dom = document, viewEl) {
      if (phxTarget instanceof HTMLElement || phxTarget instanceof SVGElement) {
        return this.liveSocket.owner(phxTarget, (view) => callback2(view, phxTarget));
      }
      if (isCid(phxTarget)) {
        let targets = dom_default.findComponentNodeList(viewEl || this.el, phxTarget);
        if (targets.length === 0) {
          logError(`no component found matching phx-target of ${phxTarget}`);
        } else {
          callback2(this, parseInt(phxTarget));
        }
      } else {
        let targets = Array.from(dom.querySelectorAll(phxTarget));
        if (targets.length === 0) {
          logError(`nothing found matching the phx-target selector "${phxTarget}"`);
        }
        targets.forEach((target) => this.liveSocket.owner(target, (view) => callback2(view, target)));
      }
    }
    applyDiff(type, rawDiff, callback2) {
      this.log(type, () => ["", clone(rawDiff)]);
      let { diff, reply, events, title } = Rendered.extract(rawDiff);
      callback2({ diff, reply, events });
      if (typeof title === "string" || type == "mount") {
        window.requestAnimationFrame(() => dom_default.putTitle(title));
      }
    }
    onJoin(resp) {
      let { rendered, container, liveview_version } = resp;
      if (container) {
        let [tag, attrs] = container;
        this.el = dom_default.replaceRootContainer(this.el, tag, attrs);
      }
      this.childJoins = 0;
      this.joinPending = true;
      this.flash = null;
      if (this.root === this) {
        this.formsForRecovery = this.getFormsForRecovery();
      }
      if (this.isMain() && window.history.state === null) {
        browser_default.pushState("replace", {
          type: "patch",
          id: this.id,
          position: this.liveSocket.currentHistoryPosition
        });
      }
      if (liveview_version !== this.liveSocket.version()) {
        console.error(`LiveView asset version mismatch. JavaScript version ${this.liveSocket.version()} vs. server ${liveview_version}. To avoid issues, please ensure that your assets use the same version as the server.`);
      }
      browser_default.dropLocal(this.liveSocket.localStorage, window.location.pathname, CONSECUTIVE_RELOADS);
      this.applyDiff("mount", rendered, ({ diff, events }) => {
        this.rendered = new Rendered(this.id, diff);
        let [html, streams] = this.renderContainer(null, "join");
        this.dropPendingRefs();
        this.joinCount++;
        this.joinAttempts = 0;
        this.maybeRecoverForms(html, () => {
          this.onJoinComplete(resp, html, streams, events);
        });
      });
    }
    dropPendingRefs() {
      dom_default.all(document, `[${PHX_REF_SRC}="${this.refSrc()}"]`, (el) => {
        el.removeAttribute(PHX_REF_LOADING);
        el.removeAttribute(PHX_REF_SRC);
        el.removeAttribute(PHX_REF_LOCK);
      });
    }
    onJoinComplete({ live_patch }, html, streams, events) {
      if (this.joinCount > 1 || this.parent && !this.parent.isJoinPending()) {
        return this.applyJoinPatch(live_patch, html, streams, events);
      }
      let newChildren = dom_default.findPhxChildrenInFragment(html, this.id).filter((toEl) => {
        let fromEl = toEl.id && this.el.querySelector(`[id="${toEl.id}"]`);
        let phxStatic = fromEl && fromEl.getAttribute(PHX_STATIC);
        if (phxStatic) {
          toEl.setAttribute(PHX_STATIC, phxStatic);
        }
        if (fromEl) {
          fromEl.setAttribute(PHX_ROOT_ID, this.root.id);
        }
        return this.joinChild(toEl);
      });
      if (newChildren.length === 0) {
        if (this.parent) {
          this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events)]);
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
          this.applyJoinPatch(live_patch, html, streams, events);
        }
      } else {
        this.root.pendingJoinOps.push([this, () => this.applyJoinPatch(live_patch, html, streams, events)]);
      }
    }
    attachTrueDocEl() {
      this.el = dom_default.byId(this.id);
      this.el.setAttribute(PHX_ROOT_ID, this.root.id);
    }
    // this is invoked for dead and live views, so we must filter by
    // by owner to ensure we aren't duplicating hooks across disconnect
    // and connected states. This also handles cases where hooks exist
    // in a root layout with a LV in the body
    execNewMounted(parent = this.el) {
      let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
      let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
      dom_default.all(parent, `[${phxViewportTop}], [${phxViewportBottom}]`, (hookEl) => {
        if (this.ownsElement(hookEl)) {
          dom_default.maintainPrivateHooks(hookEl, hookEl, phxViewportTop, phxViewportBottom);
          this.maybeAddNewHook(hookEl);
        }
      });
      dom_default.all(parent, `[${this.binding(PHX_HOOK)}], [data-phx-${PHX_HOOK}]`, (hookEl) => {
        if (this.ownsElement(hookEl)) {
          this.maybeAddNewHook(hookEl);
        }
      });
      dom_default.all(parent, `[${this.binding(PHX_MOUNTED)}]`, (el) => {
        if (this.ownsElement(el)) {
          this.maybeMounted(el);
        }
      });
    }
    applyJoinPatch(live_patch, html, streams, events) {
      this.attachTrueDocEl();
      let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
      patch.markPrunableContentForRemoval();
      this.performPatch(patch, false, true);
      this.joinNewChildren();
      this.execNewMounted();
      this.joinPending = false;
      this.liveSocket.dispatchEvents(events);
      this.applyPendingUpdates();
      if (live_patch) {
        let { kind, to: to2 } = live_patch;
        this.liveSocket.historyPatch(to2, kind);
      }
      this.hideLoader();
      if (this.joinCount > 1) {
        this.triggerReconnected();
      }
      this.stopCallback();
    }
    triggerBeforeUpdateHook(fromEl, toEl) {
      this.liveSocket.triggerDOM("onBeforeElUpdated", [fromEl, toEl]);
      let hook = this.getHook(fromEl);
      let isIgnored = hook && dom_default.isIgnored(fromEl, this.binding(PHX_UPDATE));
      if (hook && !fromEl.isEqualNode(toEl) && !(isIgnored && isEqualObj(fromEl.dataset, toEl.dataset))) {
        hook.__beforeUpdate();
        return hook;
      }
    }
    maybeMounted(el) {
      let phxMounted = el.getAttribute(this.binding(PHX_MOUNTED));
      let hasBeenInvoked = phxMounted && dom_default.private(el, "mounted");
      if (phxMounted && !hasBeenInvoked) {
        this.liveSocket.execJS(el, phxMounted);
        dom_default.putPrivate(el, "mounted", true);
      }
    }
    maybeAddNewHook(el) {
      let newHook = this.addHook(el);
      if (newHook) {
        newHook.__mounted();
      }
    }
    performPatch(patch, pruneCids, isJoinPatch = false) {
      let removedEls = [];
      let phxChildrenAdded = false;
      let updatedHookIds = /* @__PURE__ */ new Set();
      this.liveSocket.triggerDOM("onPatchStart", [patch.targetContainer]);
      patch.after("added", (el) => {
        this.liveSocket.triggerDOM("onNodeAdded", [el]);
        let phxViewportTop = this.binding(PHX_VIEWPORT_TOP);
        let phxViewportBottom = this.binding(PHX_VIEWPORT_BOTTOM);
        dom_default.maintainPrivateHooks(el, el, phxViewportTop, phxViewportBottom);
        this.maybeAddNewHook(el);
        if (el.getAttribute) {
          this.maybeMounted(el);
        }
      });
      patch.after("phxChildAdded", (el) => {
        if (dom_default.isPhxSticky(el)) {
          this.liveSocket.joinRootViews();
        } else {
          phxChildrenAdded = true;
        }
      });
      patch.before("updated", (fromEl, toEl) => {
        let hook = this.triggerBeforeUpdateHook(fromEl, toEl);
        if (hook) {
          updatedHookIds.add(fromEl.id);
        }
      });
      patch.after("updated", (el) => {
        if (updatedHookIds.has(el.id)) {
          this.getHook(el).__updated();
        }
      });
      patch.after("discarded", (el) => {
        if (el.nodeType === Node.ELEMENT_NODE) {
          removedEls.push(el);
        }
      });
      patch.after("transitionsDiscarded", (els) => this.afterElementsRemoved(els, pruneCids));
      patch.perform(isJoinPatch);
      this.afterElementsRemoved(removedEls, pruneCids);
      this.liveSocket.triggerDOM("onPatchEnd", [patch.targetContainer]);
      return phxChildrenAdded;
    }
    afterElementsRemoved(elements2, pruneCids) {
      let destroyedCIDs = [];
      elements2.forEach((parent) => {
        let components = dom_default.all(parent, `[${PHX_COMPONENT}]`);
        let hooks = dom_default.all(parent, `[${this.binding(PHX_HOOK)}], [data-phx-hook]`);
        components.concat(parent).forEach((el) => {
          let cid = this.componentID(el);
          if (isCid(cid) && destroyedCIDs.indexOf(cid) === -1) {
            destroyedCIDs.push(cid);
          }
        });
        hooks.concat(parent).forEach((hookEl) => {
          let hook = this.getHook(hookEl);
          hook && this.destroyHook(hook);
        });
      });
      if (pruneCids) {
        this.maybePushComponentsDestroyed(destroyedCIDs);
      }
    }
    joinNewChildren() {
      dom_default.findPhxChildren(this.el, this.id).forEach((el) => this.joinChild(el));
    }
    maybeRecoverForms(html, callback2) {
      const phxChange = this.binding("change");
      const oldForms = this.root.formsForRecovery;
      let template = document.createElement("template");
      template.innerHTML = html;
      const rootEl = template.content.firstElementChild;
      rootEl.id = this.id;
      rootEl.setAttribute(PHX_ROOT_ID, this.root.id);
      rootEl.setAttribute(PHX_SESSION, this.getSession());
      rootEl.setAttribute(PHX_STATIC, this.getStatic());
      rootEl.setAttribute(PHX_PARENT_ID, this.parent ? this.parent.id : null);
      const formsToRecover = (
        // we go over all forms in the new DOM; because this is only the HTML for the current
        // view, we can be sure that all forms are owned by this view:
        dom_default.all(template.content, "form").filter((newForm) => newForm.id && oldForms[newForm.id]).filter((newForm) => !this.pendingForms.has(newForm.id)).filter((newForm) => oldForms[newForm.id].getAttribute(phxChange) === newForm.getAttribute(phxChange)).map((newForm) => {
          return [oldForms[newForm.id], newForm];
        })
      );
      if (formsToRecover.length === 0) {
        return callback2();
      }
      formsToRecover.forEach(([oldForm, newForm], i) => {
        this.pendingForms.add(newForm.id);
        this.pushFormRecovery(oldForm, newForm, template.content.firstElementChild, () => {
          this.pendingForms.delete(newForm.id);
          if (i === formsToRecover.length - 1) {
            callback2();
          }
        });
      });
    }
    getChildById(id) {
      return this.root.children[this.id][id];
    }
    getDescendentByEl(el) {
      var _a;
      if (el.id === this.id) {
        return this;
      } else {
        return (_a = this.children[el.getAttribute(PHX_PARENT_ID)]) == null ? void 0 : _a[el.id];
      }
    }
    destroyDescendent(id) {
      for (let parentId in this.root.children) {
        for (let childId in this.root.children[parentId]) {
          if (childId === id) {
            return this.root.children[parentId][childId].destroy();
          }
        }
      }
    }
    joinChild(el) {
      let child = this.getChildById(el.id);
      if (!child) {
        let view = new _View(el, this.liveSocket, this);
        this.root.children[this.id][view.id] = view;
        view.join();
        this.childJoins++;
        return true;
      }
    }
    isJoinPending() {
      return this.joinPending;
    }
    ackJoin(_child) {
      this.childJoins--;
      if (this.childJoins === 0) {
        if (this.parent) {
          this.parent.ackJoin(this);
        } else {
          this.onAllChildJoinsComplete();
        }
      }
    }
    onAllChildJoinsComplete() {
      this.pendingForms.clear();
      this.formsForRecovery = {};
      this.joinCallback(() => {
        this.pendingJoinOps.forEach(([view, op]) => {
          if (!view.isDestroyed()) {
            op();
          }
        });
        this.pendingJoinOps = [];
      });
    }
    update(diff, events) {
      if (this.isJoinPending() || this.liveSocket.hasPendingLink() && this.root.isMain()) {
        return this.pendingDiffs.push({ diff, events });
      }
      this.rendered.mergeDiff(diff);
      let phxChildrenAdded = false;
      if (this.rendered.isComponentOnlyDiff(diff)) {
        this.liveSocket.time("component patch complete", () => {
          let parentCids = dom_default.findExistingParentCIDs(this.el, this.rendered.componentCIDs(diff));
          parentCids.forEach((parentCID) => {
            if (this.componentPatch(this.rendered.getComponent(diff, parentCID), parentCID)) {
              phxChildrenAdded = true;
            }
          });
        });
      } else if (!isEmpty(diff)) {
        this.liveSocket.time("full patch complete", () => {
          let [html, streams] = this.renderContainer(diff, "update");
          let patch = new DOMPatch(this, this.el, this.id, html, streams, null);
          phxChildrenAdded = this.performPatch(patch, true);
        });
      }
      this.liveSocket.dispatchEvents(events);
      if (phxChildrenAdded) {
        this.joinNewChildren();
      }
    }
    renderContainer(diff, kind) {
      return this.liveSocket.time(`toString diff (${kind})`, () => {
        let tag = this.el.tagName;
        let cids = diff ? this.rendered.componentCIDs(diff) : null;
        let [html, streams] = this.rendered.toString(cids);
        return [`<${tag}>${html}</${tag}>`, streams];
      });
    }
    componentPatch(diff, cid) {
      if (isEmpty(diff))
        return false;
      let [html, streams] = this.rendered.componentToString(cid);
      let patch = new DOMPatch(this, this.el, this.id, html, streams, cid);
      let childrenAdded = this.performPatch(patch, true);
      return childrenAdded;
    }
    getHook(el) {
      return this.viewHooks[ViewHook.elementID(el)];
    }
    addHook(el) {
      let hookElId = ViewHook.elementID(el);
      if (el.getAttribute && !this.ownsElement(el)) {
        return;
      }
      if (hookElId && !this.viewHooks[hookElId]) {
        let hook = dom_default.getCustomElHook(el) || logError(`no hook found for custom element: ${el.id}`);
        this.viewHooks[hookElId] = hook;
        hook.__attachView(this);
        return hook;
      } else if (hookElId || !el.getAttribute) {
        return;
      } else {
        let hookName = el.getAttribute(`data-phx-${PHX_HOOK}`) || el.getAttribute(this.binding(PHX_HOOK));
        let callbacks = this.liveSocket.getHookCallbacks(hookName);
        if (callbacks) {
          if (!el.id) {
            logError(`no DOM ID for hook "${hookName}". Hooks require a unique ID on each element.`, el);
          }
          let hook = new ViewHook(this, el, callbacks);
          this.viewHooks[ViewHook.elementID(hook.el)] = hook;
          return hook;
        } else if (hookName !== null) {
          logError(`unknown hook found for "${hookName}"`, el);
        }
      }
    }
    destroyHook(hook) {
      const hookId = ViewHook.elementID(hook.el);
      hook.__destroyed();
      hook.__cleanup__();
      delete this.viewHooks[hookId];
    }
    applyPendingUpdates() {
      if (this.liveSocket.hasPendingLink() && this.root.isMain()) {
        return;
      }
      this.pendingDiffs.forEach(({ diff, events }) => this.update(diff, events));
      this.pendingDiffs = [];
      this.eachChild((child) => child.applyPendingUpdates());
    }
    eachChild(callback2) {
      let children = this.root.children[this.id] || {};
      for (let id in children) {
        callback2(this.getChildById(id));
      }
    }
    onChannel(event, cb) {
      this.liveSocket.onChannel(this.channel, event, (resp) => {
        if (this.isJoinPending()) {
          this.root.pendingJoinOps.push([this, () => cb(resp)]);
        } else {
          this.liveSocket.requestDOMUpdate(() => cb(resp));
        }
      });
    }
    bindChannel() {
      this.liveSocket.onChannel(this.channel, "diff", (rawDiff) => {
        this.liveSocket.requestDOMUpdate(() => {
          this.applyDiff("update", rawDiff, ({ diff, events }) => this.update(diff, events));
        });
      });
      this.onChannel("redirect", ({ to: to2, flash }) => this.onRedirect({ to: to2, flash }));
      this.onChannel("live_patch", (redir) => this.onLivePatch(redir));
      this.onChannel("live_redirect", (redir) => this.onLiveRedirect(redir));
      this.channel.onError((reason) => this.onError(reason));
      this.channel.onClose((reason) => this.onClose(reason));
    }
    destroyAllChildren() {
      this.eachChild((child) => child.destroy());
    }
    onLiveRedirect(redir) {
      let { to: to2, kind, flash } = redir;
      let url = this.expandURL(to2);
      let e = new CustomEvent("phx:server-navigate", { detail: { to: to2, kind, flash } });
      this.liveSocket.historyRedirect(e, url, kind, flash);
    }
    onLivePatch(redir) {
      let { to: to2, kind } = redir;
      this.href = this.expandURL(to2);
      this.liveSocket.historyPatch(to2, kind);
    }
    expandURL(to2) {
      return to2.startsWith("/") ? `${window.location.protocol}//${window.location.host}${to2}` : to2;
    }
    onRedirect({ to: to2, flash, reloadToken }) {
      this.liveSocket.redirect(to2, flash, reloadToken);
    }
    isDestroyed() {
      return this.destroyed;
    }
    joinDead() {
      this.isDead = true;
    }
    joinPush() {
      this.joinPush = this.joinPush || this.channel.join();
      return this.joinPush;
    }
    join(callback2) {
      this.showLoader(this.liveSocket.loaderTimeout);
      this.bindChannel();
      if (this.isMain()) {
        this.stopCallback = this.liveSocket.withPageLoading({ to: this.href, kind: "initial" });
      }
      this.joinCallback = (onDone) => {
        onDone = onDone || function() {
        };
        callback2 ? callback2(this.joinCount, onDone) : onDone();
      };
      this.wrapPush(() => this.channel.join(), {
        ok: (resp) => this.liveSocket.requestDOMUpdate(() => this.onJoin(resp)),
        error: (error) => this.onJoinError(error),
        timeout: () => this.onJoinError({ reason: "timeout" })
      });
    }
    onJoinError(resp) {
      if (resp.reason === "reload") {
        this.log("error", () => [`failed mount with ${resp.status}. Falling back to page reload`, resp]);
        this.onRedirect({ to: this.root.href, reloadToken: resp.token });
        return;
      } else if (resp.reason === "unauthorized" || resp.reason === "stale") {
        this.log("error", () => ["unauthorized live_redirect. Falling back to page request", resp]);
        this.onRedirect({ to: this.root.href });
        return;
      }
      if (resp.redirect || resp.live_redirect) {
        this.joinPending = false;
        this.channel.leave();
      }
      if (resp.redirect) {
        return this.onRedirect(resp.redirect);
      }
      if (resp.live_redirect) {
        return this.onLiveRedirect(resp.live_redirect);
      }
      this.log("error", () => ["unable to join", resp]);
      if (this.isMain()) {
        this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
        if (this.liveSocket.isConnected()) {
          this.liveSocket.reloadWithJitter(this);
        }
      } else {
        if (this.joinAttempts >= MAX_CHILD_JOIN_ATTEMPTS) {
          this.root.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
          this.log("error", () => [`giving up trying to mount after ${MAX_CHILD_JOIN_ATTEMPTS} tries`, resp]);
          this.destroy();
        }
        let trueChildEl = dom_default.byId(this.el.id);
        if (trueChildEl) {
          dom_default.mergeAttrs(trueChildEl, this.el);
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
          this.el = trueChildEl;
        } else {
          this.destroy();
        }
      }
    }
    onClose(reason) {
      if (this.isDestroyed()) {
        return;
      }
      if (this.isMain() && this.liveSocket.hasPendingLink() && reason !== "leave") {
        return this.liveSocket.reloadWithJitter(this);
      }
      this.destroyAllChildren();
      this.liveSocket.dropActiveElement(this);
      if (document.activeElement) {
        document.activeElement.blur();
      }
      if (this.liveSocket.isUnloaded()) {
        this.showLoader(BEFORE_UNLOAD_LOADER_TIMEOUT);
      }
    }
    onError(reason) {
      this.onClose(reason);
      if (this.liveSocket.isConnected()) {
        this.log("error", () => ["view crashed", reason]);
      }
      if (!this.liveSocket.isUnloaded()) {
        if (this.liveSocket.isConnected()) {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_SERVER_ERROR_CLASS]);
        } else {
          this.displayError([PHX_LOADING_CLASS, PHX_ERROR_CLASS, PHX_CLIENT_ERROR_CLASS]);
        }
      }
    }
    displayError(classes) {
      if (this.isMain()) {
        dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: { to: this.href, kind: "error" } });
      }
      this.showLoader();
      this.setContainerClasses(...classes);
      this.delayedDisconnected();
    }
    delayedDisconnected() {
      this.disconnectedTimer = setTimeout(() => {
        this.execAll(this.binding("disconnected"));
      }, this.liveSocket.disconnectedTimeout);
    }
    wrapPush(callerPush, receives) {
      let latency = this.liveSocket.getLatencySim();
      let withLatency = latency ? (cb) => setTimeout(() => !this.isDestroyed() && cb(), latency) : (cb) => !this.isDestroyed() && cb();
      withLatency(() => {
        callerPush().receive("ok", (resp) => withLatency(() => receives.ok && receives.ok(resp))).receive("error", (reason) => withLatency(() => receives.error && receives.error(reason))).receive("timeout", () => withLatency(() => receives.timeout && receives.timeout()));
      });
    }
    pushWithReply(refGenerator, event, payload) {
      if (!this.isConnected()) {
        return Promise.reject({ error: "noconnection" });
      }
      let [ref, [el], opts] = refGenerator ? refGenerator() : [null, [], {}];
      let oldJoinCount = this.joinCount;
      let onLoadingDone = function() {
      };
      if (opts.page_loading) {
        onLoadingDone = this.liveSocket.withPageLoading({ kind: "element", target: el });
      }
      if (typeof payload.cid !== "number") {
        delete payload.cid;
      }
      return new Promise((resolve2, reject) => {
        this.wrapPush(() => this.channel.push(event, payload, PUSH_TIMEOUT), {
          ok: (resp) => {
            if (ref !== null) {
              this.lastAckRef = ref;
            }
            let finish = (hookReply) => {
              if (resp.redirect) {
                this.onRedirect(resp.redirect);
              }
              if (resp.live_patch) {
                this.onLivePatch(resp.live_patch);
              }
              if (resp.live_redirect) {
                this.onLiveRedirect(resp.live_redirect);
              }
              onLoadingDone();
              resolve2({ resp, reply: hookReply });
            };
            if (resp.diff) {
              this.liveSocket.requestDOMUpdate(() => {
                this.applyDiff("update", resp.diff, ({ diff, reply, events }) => {
                  if (ref !== null) {
                    this.undoRefs(ref, payload.event);
                  }
                  this.update(diff, events);
                  finish(reply);
                });
              });
            } else {
              if (ref !== null) {
                this.undoRefs(ref, payload.event);
              }
              finish(null);
            }
          },
          error: (reason) => reject({ error: reason }),
          timeout: () => {
            reject({ timeout: true });
            if (this.joinCount === oldJoinCount) {
              this.liveSocket.reloadWithJitter(this, () => {
                this.log("timeout", () => ["received timeout while communicating with server. Falling back to hard refresh for recovery"]);
              });
            }
          }
        });
      });
    }
    undoRefs(ref, phxEvent, onlyEls) {
      if (!this.isConnected()) {
        return;
      }
      let selector = `[${PHX_REF_SRC}="${this.refSrc()}"]`;
      if (onlyEls) {
        onlyEls = new Set(onlyEls);
        dom_default.all(document, selector, (parent) => {
          if (onlyEls && !onlyEls.has(parent)) {
            return;
          }
          dom_default.all(parent, selector, (child) => this.undoElRef(child, ref, phxEvent));
          this.undoElRef(parent, ref, phxEvent);
        });
      } else {
        dom_default.all(document, selector, (el) => this.undoElRef(el, ref, phxEvent));
      }
    }
    undoElRef(el, ref, phxEvent) {
      let elRef = new ElementRef(el);
      elRef.maybeUndo(ref, phxEvent, (clonedTree) => {
        let patch = new DOMPatch(this, el, this.id, clonedTree, [], null, { undoRef: ref });
        const phxChildrenAdded = this.performPatch(patch, true);
        dom_default.all(el, `[${PHX_REF_SRC}="${this.refSrc()}"]`, (child) => this.undoElRef(child, ref, phxEvent));
        if (phxChildrenAdded) {
          this.joinNewChildren();
        }
      });
    }
    refSrc() {
      return this.el.id;
    }
    putRef(elements2, phxEvent, eventType, opts = {}) {
      let newRef = this.ref++;
      let disableWith = this.binding(PHX_DISABLE_WITH);
      if (opts.loading) {
        let loadingEls = dom_default.all(document, opts.loading).map((el) => {
          return { el, lock: true, loading: true };
        });
        elements2 = elements2.concat(loadingEls);
      }
      for (let { el, lock, loading } of elements2) {
        if (!lock && !loading) {
          throw new Error("putRef requires lock or loading");
        }
        el.setAttribute(PHX_REF_SRC, this.refSrc());
        if (loading) {
          el.setAttribute(PHX_REF_LOADING, newRef);
        }
        if (lock) {
          el.setAttribute(PHX_REF_LOCK, newRef);
        }
        if (!loading || opts.submitter && !(el === opts.submitter || el === opts.form)) {
          continue;
        }
        let lockCompletePromise = new Promise((resolve2) => {
          el.addEventListener(`phx:undo-lock:${newRef}`, () => resolve2(detail), { once: true });
        });
        let loadingCompletePromise = new Promise((resolve2) => {
          el.addEventListener(`phx:undo-loading:${newRef}`, () => resolve2(detail), { once: true });
        });
        el.classList.add(`phx-${eventType}-loading`);
        let disableText = el.getAttribute(disableWith);
        if (disableText !== null) {
          if (!el.getAttribute(PHX_DISABLE_WITH_RESTORE)) {
            el.setAttribute(PHX_DISABLE_WITH_RESTORE, el.innerText);
          }
          if (disableText !== "") {
            el.innerText = disableText;
          }
          el.setAttribute(PHX_DISABLED, el.getAttribute(PHX_DISABLED) || el.disabled);
          el.setAttribute("disabled", "");
        }
        let detail = {
          event: phxEvent,
          eventType,
          ref: newRef,
          isLoading: loading,
          isLocked: lock,
          lockElements: elements2.filter(({ lock: lock2 }) => lock2).map(({ el: el2 }) => el2),
          loadingElements: elements2.filter(({ loading: loading2 }) => loading2).map(({ el: el2 }) => el2),
          unlock: (els) => {
            els = Array.isArray(els) ? els : [els];
            this.undoRefs(newRef, phxEvent, els);
          },
          lockComplete: lockCompletePromise,
          loadingComplete: loadingCompletePromise,
          lock: (lockEl) => {
            return new Promise((resolve2) => {
              if (this.isAcked(newRef)) {
                return resolve2(detail);
              }
              lockEl.setAttribute(PHX_REF_LOCK, newRef);
              lockEl.setAttribute(PHX_REF_SRC, this.refSrc());
              lockEl.addEventListener(`phx:lock-stop:${newRef}`, () => resolve2(detail), { once: true });
            });
          }
        };
        el.dispatchEvent(new CustomEvent("phx:push", {
          detail,
          bubbles: true,
          cancelable: false
        }));
        if (phxEvent) {
          el.dispatchEvent(new CustomEvent(`phx:push:${phxEvent}`, {
            detail,
            bubbles: true,
            cancelable: false
          }));
        }
      }
      return [newRef, elements2.map(({ el }) => el), opts];
    }
    isAcked(ref) {
      return this.lastAckRef !== null && this.lastAckRef >= ref;
    }
    componentID(el) {
      let cid = el.getAttribute && el.getAttribute(PHX_COMPONENT);
      return cid ? parseInt(cid) : null;
    }
    targetComponentID(target, targetCtx, opts = {}) {
      if (isCid(targetCtx)) {
        return targetCtx;
      }
      let cidOrSelector = opts.target || target.getAttribute(this.binding("target"));
      if (isCid(cidOrSelector)) {
        return parseInt(cidOrSelector);
      } else if (targetCtx && (cidOrSelector !== null || opts.target)) {
        return this.closestComponentID(targetCtx);
      } else {
        return null;
      }
    }
    closestComponentID(targetCtx) {
      if (isCid(targetCtx)) {
        return targetCtx;
      } else if (targetCtx) {
        return maybe(targetCtx.closest(`[${PHX_COMPONENT}]`), (el) => this.ownsElement(el) && this.componentID(el));
      } else {
        return null;
      }
    }
    pushHookEvent(el, targetCtx, event, payload, onReply) {
      if (!this.isConnected()) {
        this.log("hook", () => ["unable to push hook event. LiveView not connected", event, payload]);
        return false;
      }
      let [ref, els, opts] = this.putRef([{ el, loading: true, lock: true }], event, "hook");
      this.pushWithReply(() => [ref, els, opts], "event", {
        type: "hook",
        event,
        value: payload,
        cid: this.closestComponentID(targetCtx)
      }).then(({ resp: _resp, reply: hookReply }) => onReply(hookReply, ref));
      return ref;
    }
    extractMeta(el, meta, value) {
      let prefix = this.binding("value-");
      for (let i = 0; i < el.attributes.length; i++) {
        if (!meta) {
          meta = {};
        }
        let name = el.attributes[i].name;
        if (name.startsWith(prefix)) {
          meta[name.replace(prefix, "")] = el.getAttribute(name);
        }
      }
      if (el.value !== void 0 && !(el instanceof HTMLFormElement)) {
        if (!meta) {
          meta = {};
        }
        meta.value = el.value;
        if (el.tagName === "INPUT" && CHECKABLE_INPUTS.indexOf(el.type) >= 0 && !el.checked) {
          delete meta.value;
        }
      }
      if (value) {
        if (!meta) {
          meta = {};
        }
        for (let key in value) {
          meta[key] = value[key];
        }
      }
      return meta;
    }
    pushEvent(type, el, targetCtx, phxEvent, meta, opts = {}, onReply) {
      this.pushWithReply(() => this.putRef([{ el, loading: true, lock: true }], phxEvent, type, opts), "event", {
        type,
        event: phxEvent,
        value: this.extractMeta(el, meta, opts.value),
        cid: this.targetComponentID(el, targetCtx, opts)
      }).then(({ reply }) => onReply && onReply(reply));
    }
    pushFileProgress(fileEl, entryRef, progress, onReply = function() {
    }) {
      this.liveSocket.withinOwners(fileEl.form, (view, targetCtx) => {
        view.pushWithReply(null, "progress", {
          event: fileEl.getAttribute(view.binding(PHX_PROGRESS)),
          ref: fileEl.getAttribute(PHX_UPLOAD_REF),
          entry_ref: entryRef,
          progress,
          cid: view.targetComponentID(fileEl.form, targetCtx)
        }).then(({ resp }) => onReply(resp));
      });
    }
    pushInput(inputEl, targetCtx, forceCid, phxEvent, opts, callback2) {
      if (!inputEl.form) {
        throw new Error("form events require the input to be inside a form");
      }
      let uploads;
      let cid = isCid(forceCid) ? forceCid : this.targetComponentID(inputEl.form, targetCtx, opts);
      let refGenerator = () => {
        return this.putRef([
          { el: inputEl, loading: true, lock: true },
          { el: inputEl.form, loading: true, lock: true }
        ], phxEvent, "change", opts);
      };
      let formData;
      let meta = this.extractMeta(inputEl.form, {}, opts.value);
      let serializeOpts = {};
      if (inputEl instanceof HTMLButtonElement) {
        serializeOpts.submitter = inputEl;
      }
      if (inputEl.getAttribute(this.binding("change"))) {
        formData = serializeForm(inputEl.form, serializeOpts, [inputEl.name]);
      } else {
        formData = serializeForm(inputEl.form, serializeOpts);
      }
      if (dom_default.isUploadInput(inputEl) && inputEl.files && inputEl.files.length > 0) {
        LiveUploader.trackFiles(inputEl, Array.from(inputEl.files));
      }
      uploads = LiveUploader.serializeUploads(inputEl);
      let event = {
        type: "form",
        event: phxEvent,
        value: formData,
        meta: __spreadValues({ _target: opts._target }, meta),
        uploads,
        cid
      };
      this.pushWithReply(refGenerator, "event", event).then(({ resp }) => {
        if (dom_default.isUploadInput(inputEl) && dom_default.isAutoUpload(inputEl)) {
          ElementRef.onUnlock(inputEl, () => {
            if (LiveUploader.filesAwaitingPreflight(inputEl).length > 0) {
              let [ref, _els] = refGenerator();
              this.undoRefs(ref, phxEvent, [inputEl.form]);
              this.uploadFiles(inputEl.form, phxEvent, targetCtx, ref, cid, (_uploads) => {
                callback2 && callback2(resp);
                this.triggerAwaitingSubmit(inputEl.form, phxEvent);
                this.undoRefs(ref, phxEvent);
              });
            }
          });
        } else {
          callback2 && callback2(resp);
        }
      });
    }
    triggerAwaitingSubmit(formEl, phxEvent) {
      let awaitingSubmit = this.getScheduledSubmit(formEl);
      if (awaitingSubmit) {
        let [_el, _ref, _opts, callback2] = awaitingSubmit;
        this.cancelSubmit(formEl, phxEvent);
        callback2();
      }
    }
    getScheduledSubmit(formEl) {
      return this.formSubmits.find(([el, _ref, _opts, _callback]) => el.isSameNode(formEl));
    }
    scheduleSubmit(formEl, ref, opts, callback2) {
      if (this.getScheduledSubmit(formEl)) {
        return true;
      }
      this.formSubmits.push([formEl, ref, opts, callback2]);
    }
    cancelSubmit(formEl, phxEvent) {
      this.formSubmits = this.formSubmits.filter(([el, ref, _opts, _callback]) => {
        if (el.isSameNode(formEl)) {
          this.undoRefs(ref, phxEvent);
          return false;
        } else {
          return true;
        }
      });
    }
    disableForm(formEl, phxEvent, opts = {}) {
      let filterIgnored = (el) => {
        let userIgnored = closestPhxBinding(el, `${this.binding(PHX_UPDATE)}=ignore`, el.form);
        return !(userIgnored || closestPhxBinding(el, "data-phx-update=ignore", el.form));
      };
      let filterDisables = (el) => {
        return el.hasAttribute(this.binding(PHX_DISABLE_WITH));
      };
      let filterButton = (el) => el.tagName == "BUTTON";
      let filterInput = (el) => ["INPUT", "TEXTAREA", "SELECT"].includes(el.tagName);
      let formElements = Array.from(formEl.elements);
      let disables = formElements.filter(filterDisables);
      let buttons = formElements.filter(filterButton).filter(filterIgnored);
      let inputs = formElements.filter(filterInput).filter(filterIgnored);
      buttons.forEach((button) => {
        button.setAttribute(PHX_DISABLED, button.disabled);
        button.disabled = true;
      });
      inputs.forEach((input) => {
        input.setAttribute(PHX_READONLY, input.readOnly);
        input.readOnly = true;
        if (input.files) {
          input.setAttribute(PHX_DISABLED, input.disabled);
          input.disabled = true;
        }
      });
      let formEls = disables.concat(buttons).concat(inputs).map((el) => {
        return { el, loading: true, lock: true };
      });
      let els = [{ el: formEl, loading: true, lock: false }].concat(formEls).reverse();
      return this.putRef(els, phxEvent, "submit", opts);
    }
    pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply) {
      let refGenerator = () => this.disableForm(formEl, phxEvent, __spreadProps(__spreadValues({}, opts), {
        form: formEl,
        submitter
      }));
      let cid = this.targetComponentID(formEl, targetCtx);
      if (LiveUploader.hasUploadsInProgress(formEl)) {
        let [ref, _els] = refGenerator();
        let push = () => this.pushFormSubmit(formEl, targetCtx, phxEvent, submitter, opts, onReply);
        return this.scheduleSubmit(formEl, ref, opts, push);
      } else if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
        let [ref, els] = refGenerator();
        let proxyRefGen = () => [ref, els, opts];
        this.uploadFiles(formEl, phxEvent, targetCtx, ref, cid, (_uploads) => {
          if (LiveUploader.inputsAwaitingPreflight(formEl).length > 0) {
            return this.undoRefs(ref, phxEvent);
          }
          let meta = this.extractMeta(formEl, {}, opts.value);
          let formData = serializeForm(formEl, { submitter });
          this.pushWithReply(proxyRefGen, "event", {
            type: "form",
            event: phxEvent,
            value: formData,
            meta,
            cid
          }).then(({ resp }) => onReply(resp));
        });
      } else if (!(formEl.hasAttribute(PHX_REF_SRC) && formEl.classList.contains("phx-submit-loading"))) {
        let meta = this.extractMeta(formEl, {}, opts.value);
        let formData = serializeForm(formEl, { submitter });
        this.pushWithReply(refGenerator, "event", {
          type: "form",
          event: phxEvent,
          value: formData,
          meta,
          cid
        }).then(({ resp }) => onReply(resp));
      }
    }
    uploadFiles(formEl, phxEvent, targetCtx, ref, cid, onComplete) {
      let joinCountAtUpload = this.joinCount;
      let inputEls = LiveUploader.activeFileInputs(formEl);
      let numFileInputsInProgress = inputEls.length;
      inputEls.forEach((inputEl) => {
        let uploader = new LiveUploader(inputEl, this, () => {
          numFileInputsInProgress--;
          if (numFileInputsInProgress === 0) {
            onComplete();
          }
        });
        let entries = uploader.entries().map((entry) => entry.toPreflightPayload());
        if (entries.length === 0) {
          numFileInputsInProgress--;
          return;
        }
        let payload = {
          ref: inputEl.getAttribute(PHX_UPLOAD_REF),
          entries,
          cid: this.targetComponentID(inputEl.form, targetCtx)
        };
        this.log("upload", () => ["sending preflight request", payload]);
        this.pushWithReply(null, "allow_upload", payload).then(({ resp }) => {
          this.log("upload", () => ["got preflight response", resp]);
          uploader.entries().forEach((entry) => {
            if (resp.entries && !resp.entries[entry.ref]) {
              this.handleFailedEntryPreflight(entry.ref, "failed preflight", uploader);
            }
          });
          if (resp.error || Object.keys(resp.entries).length === 0) {
            this.undoRefs(ref, phxEvent);
            let errors = resp.error || [];
            errors.map(([entry_ref, reason]) => {
              this.handleFailedEntryPreflight(entry_ref, reason, uploader);
            });
          } else {
            let onError = (callback2) => {
              this.channel.onError(() => {
                if (this.joinCount === joinCountAtUpload) {
                  callback2();
                }
              });
            };
            uploader.initAdapterUpload(resp, onError, this.liveSocket);
          }
        });
      });
    }
    handleFailedEntryPreflight(uploadRef, reason, uploader) {
      if (uploader.isAutoUpload()) {
        let entry = uploader.entries().find((entry2) => entry2.ref === uploadRef.toString());
        if (entry) {
          entry.cancel();
        }
      } else {
        uploader.entries().map((entry) => entry.cancel());
      }
      this.log("upload", () => [`error for entry ${uploadRef}`, reason]);
    }
    dispatchUploads(targetCtx, name, filesOrBlobs) {
      let targetElement = this.targetCtxElement(targetCtx) || this.el;
      let inputs = dom_default.findUploadInputs(targetElement).filter((el) => el.name === name);
      if (inputs.length === 0) {
        logError(`no live file inputs found matching the name "${name}"`);
      } else if (inputs.length > 1) {
        logError(`duplicate live file inputs found matching the name "${name}"`);
      } else {
        dom_default.dispatchEvent(inputs[0], PHX_TRACK_UPLOADS, { detail: { files: filesOrBlobs } });
      }
    }
    targetCtxElement(targetCtx) {
      if (isCid(targetCtx)) {
        let [target] = dom_default.findComponentNodeList(this.el, targetCtx);
        return target;
      } else if (targetCtx) {
        return targetCtx;
      } else {
        return null;
      }
    }
    pushFormRecovery(oldForm, newForm, templateDom, callback2) {
      const phxChange = this.binding("change");
      const phxTarget = newForm.getAttribute(this.binding("target")) || newForm;
      const phxEvent = newForm.getAttribute(this.binding(PHX_AUTO_RECOVER)) || newForm.getAttribute(this.binding("change"));
      const inputs = Array.from(oldForm.elements).filter((el) => dom_default.isFormInput(el) && el.name && !el.hasAttribute(phxChange));
      if (inputs.length === 0) {
        return;
      }
      inputs.forEach((input2) => input2.hasAttribute(PHX_UPLOAD_REF) && LiveUploader.clearFiles(input2));
      let input = inputs.find((el) => el.type !== "hidden") || inputs[0];
      let pending = 0;
      this.withinTargets(phxTarget, (targetView, targetCtx) => {
        const cid = this.targetComponentID(newForm, targetCtx);
        pending++;
        let e = new CustomEvent("phx:form-recovery", { detail: { sourceElement: oldForm } });
        js_default.exec(e, "change", phxEvent, this, input, ["push", {
          _target: input.name,
          targetView,
          targetCtx,
          newCid: cid,
          callback: () => {
            pending--;
            if (pending === 0) {
              callback2();
            }
          }
        }]);
      }, templateDom, templateDom);
    }
    pushLinkPatch(e, href, targetEl, callback2) {
      let linkRef = this.liveSocket.setPendingLink(href);
      let loading = e.isTrusted && e.type !== "popstate";
      let refGen = targetEl ? () => this.putRef([{ el: targetEl, loading, lock: true }], null, "click") : null;
      let fallback = () => this.liveSocket.redirect(window.location.href);
      let url = href.startsWith("/") ? `${location.protocol}//${location.host}${href}` : href;
      this.pushWithReply(refGen, "live_patch", { url }).then(
        ({ resp }) => {
          this.liveSocket.requestDOMUpdate(() => {
            if (resp.link_redirect) {
              this.liveSocket.replaceMain(href, null, callback2, linkRef);
            } else {
              if (this.liveSocket.commitPendingLink(linkRef)) {
                this.href = href;
              }
              this.applyPendingUpdates();
              callback2 && callback2(linkRef);
            }
          });
        },
        ({ error: _error, timeout: _timeout }) => fallback()
      );
    }
    getFormsForRecovery() {
      if (this.joinCount === 0) {
        return {};
      }
      let phxChange = this.binding("change");
      return dom_default.all(this.el, `form[${phxChange}]`).filter((form) => form.id).filter((form) => form.elements.length > 0).filter((form) => form.getAttribute(this.binding(PHX_AUTO_RECOVER)) !== "ignore").map((form) => form.cloneNode(true)).reduce((acc, form) => {
        acc[form.id] = form;
        return acc;
      }, {});
    }
    maybePushComponentsDestroyed(destroyedCIDs) {
      let willDestroyCIDs = destroyedCIDs.filter((cid) => {
        return dom_default.findComponentNodeList(this.el, cid).length === 0;
      });
      if (willDestroyCIDs.length > 0) {
        willDestroyCIDs.forEach((cid) => this.rendered.resetRender(cid));
        this.pushWithReply(null, "cids_will_destroy", { cids: willDestroyCIDs }).then(() => {
          this.liveSocket.requestDOMUpdate(() => {
            let completelyDestroyCIDs = willDestroyCIDs.filter((cid) => {
              return dom_default.findComponentNodeList(this.el, cid).length === 0;
            });
            if (completelyDestroyCIDs.length > 0) {
              this.pushWithReply(null, "cids_destroyed", { cids: completelyDestroyCIDs }).then(({ resp }) => {
                this.rendered.pruneCIDs(resp.cids);
              });
            }
          });
        });
      }
    }
    ownsElement(el) {
      let parentViewEl = el.closest(PHX_VIEW_SELECTOR);
      return el.getAttribute(PHX_PARENT_ID) === this.id || parentViewEl && parentViewEl.id === this.id || !parentViewEl && this.isDead;
    }
    submitForm(form, targetCtx, phxEvent, submitter, opts = {}) {
      dom_default.putPrivate(form, PHX_HAS_SUBMITTED, true);
      const inputs = Array.from(form.elements);
      inputs.forEach((input) => dom_default.putPrivate(input, PHX_HAS_SUBMITTED, true));
      this.liveSocket.blurActiveElement(this);
      this.pushFormSubmit(form, targetCtx, phxEvent, submitter, opts, () => {
        this.liveSocket.restorePreviouslyActiveFocus();
      });
    }
    binding(kind) {
      return this.liveSocket.binding(kind);
    }
  };
  var LiveSocket = class {
    constructor(url, phxSocket, opts = {}) {
      this.unloaded = false;
      if (!phxSocket || phxSocket.constructor.name === "Object") {
        throw new Error(`
      a phoenix Socket must be provided as the second argument to the LiveSocket constructor. For example:

          import {Socket} from "phoenix"
          import {LiveSocket} from "phoenix_live_view"
          let liveSocket = new LiveSocket("/live", Socket, {...})
      `);
      }
      this.socket = new phxSocket(url, opts);
      this.bindingPrefix = opts.bindingPrefix || BINDING_PREFIX;
      this.opts = opts;
      this.params = closure2(opts.params || {});
      this.viewLogger = opts.viewLogger;
      this.metadataCallbacks = opts.metadata || {};
      this.defaults = Object.assign(clone(DEFAULTS), opts.defaults || {});
      this.activeElement = null;
      this.prevActive = null;
      this.silenced = false;
      this.main = null;
      this.outgoingMainEl = null;
      this.clickStartedAtTarget = null;
      this.linkRef = 1;
      this.roots = {};
      this.href = window.location.href;
      this.pendingLink = null;
      this.currentLocation = clone(window.location);
      this.hooks = opts.hooks || {};
      this.uploaders = opts.uploaders || {};
      this.loaderTimeout = opts.loaderTimeout || LOADER_TIMEOUT;
      this.disconnectedTimeout = opts.disconnectedTimeout || DISCONNECTED_TIMEOUT;
      this.reloadWithJitterTimer = null;
      this.maxReloads = opts.maxReloads || MAX_RELOADS;
      this.reloadJitterMin = opts.reloadJitterMin || RELOAD_JITTER_MIN;
      this.reloadJitterMax = opts.reloadJitterMax || RELOAD_JITTER_MAX;
      this.failsafeJitter = opts.failsafeJitter || FAILSAFE_JITTER;
      this.localStorage = opts.localStorage || window.localStorage;
      this.sessionStorage = opts.sessionStorage || window.sessionStorage;
      this.boundTopLevelEvents = false;
      this.boundEventNames = /* @__PURE__ */ new Set();
      this.serverCloseRef = null;
      this.domCallbacks = Object.assign(
        {
          jsQuerySelectorAll: null,
          onPatchStart: closure2(),
          onPatchEnd: closure2(),
          onNodeAdded: closure2(),
          onBeforeElUpdated: closure2()
        },
        opts.dom || {}
      );
      this.transitions = new TransitionSet();
      this.currentHistoryPosition = parseInt(this.sessionStorage.getItem(PHX_LV_HISTORY_POSITION)) || 0;
      window.addEventListener("pagehide", (_e) => {
        this.unloaded = true;
      });
      this.socket.onOpen(() => {
        if (this.isUnloaded()) {
          window.location.reload();
        }
      });
    }
    // public
    version() {
      return "1.0.7";
    }
    isProfileEnabled() {
      return this.sessionStorage.getItem(PHX_LV_PROFILE) === "true";
    }
    isDebugEnabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "true";
    }
    isDebugDisabled() {
      return this.sessionStorage.getItem(PHX_LV_DEBUG) === "false";
    }
    enableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "true");
    }
    enableProfiling() {
      this.sessionStorage.setItem(PHX_LV_PROFILE, "true");
    }
    disableDebug() {
      this.sessionStorage.setItem(PHX_LV_DEBUG, "false");
    }
    disableProfiling() {
      this.sessionStorage.removeItem(PHX_LV_PROFILE);
    }
    enableLatencySim(upperBoundMs) {
      this.enableDebug();
      console.log("latency simulator enabled for the duration of this browser session. Call disableLatencySim() to disable");
      this.sessionStorage.setItem(PHX_LV_LATENCY_SIM, upperBoundMs);
    }
    disableLatencySim() {
      this.sessionStorage.removeItem(PHX_LV_LATENCY_SIM);
    }
    getLatencySim() {
      let str = this.sessionStorage.getItem(PHX_LV_LATENCY_SIM);
      return str ? parseInt(str) : null;
    }
    getSocket() {
      return this.socket;
    }
    connect() {
      if (window.location.hostname === "localhost" && !this.isDebugDisabled()) {
        this.enableDebug();
      }
      let doConnect = () => {
        this.resetReloadStatus();
        if (this.joinRootViews()) {
          this.bindTopLevelEvents();
          this.socket.connect();
        } else if (this.main) {
          this.socket.connect();
        } else {
          this.bindTopLevelEvents({ dead: true });
        }
        this.joinDeadView();
      };
      if (["complete", "loaded", "interactive"].indexOf(document.readyState) >= 0) {
        doConnect();
      } else {
        document.addEventListener("DOMContentLoaded", () => doConnect());
      }
    }
    disconnect(callback2) {
      clearTimeout(this.reloadWithJitterTimer);
      if (this.serverCloseRef) {
        this.socket.off(this.serverCloseRef);
        this.serverCloseRef = null;
      }
      this.socket.disconnect(callback2);
    }
    replaceTransport(transport) {
      clearTimeout(this.reloadWithJitterTimer);
      this.socket.replaceTransport(transport);
      this.connect();
    }
    execJS(el, encodedJS, eventType = null) {
      let e = new CustomEvent("phx:exec", { detail: { sourceElement: el } });
      this.owner(el, (view) => js_default.exec(e, eventType, encodedJS, view, el));
    }
    // private
    execJSHookPush(el, phxEvent, data, callback2) {
      this.withinOwners(el, (view) => {
        let e = new CustomEvent("phx:exec", { detail: { sourceElement: el } });
        js_default.exec(e, "hook", phxEvent, view, el, ["push", { data, callback: callback2 }]);
      });
    }
    unload() {
      if (this.unloaded) {
        return;
      }
      if (this.main && this.isConnected()) {
        this.log(this.main, "socket", () => ["disconnect for page nav"]);
      }
      this.unloaded = true;
      this.destroyAllViews();
      this.disconnect();
    }
    triggerDOM(kind, args) {
      this.domCallbacks[kind](...args);
    }
    time(name, func) {
      if (!this.isProfileEnabled() || !console.time) {
        return func();
      }
      console.time(name);
      let result = func();
      console.timeEnd(name);
      return result;
    }
    log(view, kind, msgCallback) {
      if (this.viewLogger) {
        let [msg, obj] = msgCallback();
        this.viewLogger(view, kind, msg, obj);
      } else if (this.isDebugEnabled()) {
        let [msg, obj] = msgCallback();
        debug(view, kind, msg, obj);
      }
    }
    requestDOMUpdate(callback2) {
      this.transitions.after(callback2);
    }
    transition(time, onStart, onDone = function() {
    }) {
      this.transitions.addTransition(time, onStart, onDone);
    }
    onChannel(channel, event, cb) {
      channel.on(event, (data) => {
        let latency = this.getLatencySim();
        if (!latency) {
          cb(data);
        } else {
          setTimeout(() => cb(data), latency);
        }
      });
    }
    reloadWithJitter(view, log) {
      clearTimeout(this.reloadWithJitterTimer);
      this.disconnect();
      let minMs = this.reloadJitterMin;
      let maxMs = this.reloadJitterMax;
      let afterMs = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
      let tries = browser_default.updateLocal(this.localStorage, window.location.pathname, CONSECUTIVE_RELOADS, 0, (count) => count + 1);
      if (tries >= this.maxReloads) {
        afterMs = this.failsafeJitter;
      }
      this.reloadWithJitterTimer = setTimeout(() => {
        if (view.isDestroyed() || view.isConnected()) {
          return;
        }
        view.destroy();
        log ? log() : this.log(view, "join", () => [`encountered ${tries} consecutive reloads`]);
        if (tries >= this.maxReloads) {
          this.log(view, "join", () => [`exceeded ${this.maxReloads} consecutive reloads. Entering failsafe mode`]);
        }
        if (this.hasPendingLink()) {
          window.location = this.pendingLink;
        } else {
          window.location.reload();
        }
      }, afterMs);
    }
    getHookCallbacks(name) {
      return name && name.startsWith("Phoenix.") ? hooks_default[name.split(".")[1]] : this.hooks[name];
    }
    isUnloaded() {
      return this.unloaded;
    }
    isConnected() {
      return this.socket.isConnected();
    }
    getBindingPrefix() {
      return this.bindingPrefix;
    }
    binding(kind) {
      return `${this.getBindingPrefix()}${kind}`;
    }
    channel(topic, params) {
      return this.socket.channel(topic, params);
    }
    joinDeadView() {
      let body = document.body;
      if (body && !this.isPhxView(body) && !this.isPhxView(document.firstElementChild)) {
        let view = this.newRootView(body);
        view.setHref(this.getHref());
        view.joinDead();
        if (!this.main) {
          this.main = view;
        }
        window.requestAnimationFrame(() => {
          var _a;
          view.execNewMounted();
          this.maybeScroll((_a = history.state) == null ? void 0 : _a.scroll);
        });
      }
    }
    joinRootViews() {
      let rootsFound = false;
      dom_default.all(document, `${PHX_VIEW_SELECTOR}:not([${PHX_PARENT_ID}])`, (rootEl) => {
        if (!this.getRootById(rootEl.id)) {
          let view = this.newRootView(rootEl);
          if (!dom_default.isPhxSticky(rootEl)) {
            view.setHref(this.getHref());
          }
          view.join();
          if (rootEl.hasAttribute(PHX_MAIN)) {
            this.main = view;
          }
        }
        rootsFound = true;
      });
      return rootsFound;
    }
    redirect(to2, flash, reloadToken) {
      if (reloadToken) {
        browser_default.setCookie(PHX_RELOAD_STATUS, reloadToken, 60);
      }
      this.unload();
      browser_default.redirect(to2, flash);
    }
    replaceMain(href, flash, callback2 = null, linkRef = this.setPendingLink(href)) {
      const liveReferer = this.currentLocation.href;
      this.outgoingMainEl = this.outgoingMainEl || this.main.el;
      const stickies = dom_default.findPhxSticky(document) || [];
      const removeEls = dom_default.all(this.outgoingMainEl, `[${this.binding("remove")}]`).filter((el) => !dom_default.isChildOfAny(el, stickies));
      const newMainEl = dom_default.cloneNode(this.outgoingMainEl, "");
      this.main.showLoader(this.loaderTimeout);
      this.main.destroy();
      this.main = this.newRootView(newMainEl, flash, liveReferer);
      this.main.setRedirect(href);
      this.transitionRemoves(removeEls);
      this.main.join((joinCount, onDone) => {
        if (joinCount === 1 && this.commitPendingLink(linkRef)) {
          this.requestDOMUpdate(() => {
            removeEls.forEach((el) => el.remove());
            stickies.forEach((el) => newMainEl.appendChild(el));
            this.outgoingMainEl.replaceWith(newMainEl);
            this.outgoingMainEl = null;
            callback2 && callback2(linkRef);
            onDone();
          });
        }
      });
    }
    transitionRemoves(elements2, callback2) {
      let removeAttr = this.binding("remove");
      let silenceEvents = (e) => {
        e.preventDefault();
        e.stopImmediatePropagation();
      };
      elements2.forEach((el) => {
        for (let event of this.boundEventNames) {
          el.addEventListener(event, silenceEvents, true);
        }
        this.execJS(el, el.getAttribute(removeAttr), "remove");
      });
      this.requestDOMUpdate(() => {
        elements2.forEach((el) => {
          for (let event of this.boundEventNames) {
            el.removeEventListener(event, silenceEvents, true);
          }
        });
        callback2 && callback2();
      });
    }
    isPhxView(el) {
      return el.getAttribute && el.getAttribute(PHX_SESSION) !== null;
    }
    newRootView(el, flash, liveReferer) {
      let view = new View(el, this, null, flash, liveReferer);
      this.roots[view.id] = view;
      return view;
    }
    owner(childEl, callback2) {
      let view = maybe(childEl.closest(PHX_VIEW_SELECTOR), (el) => this.getViewByEl(el)) || this.main;
      return view && callback2 ? callback2(view) : view;
    }
    withinOwners(childEl, callback2) {
      this.owner(childEl, (view) => callback2(view, childEl));
    }
    getViewByEl(el) {
      let rootId = el.getAttribute(PHX_ROOT_ID);
      return maybe(this.getRootById(rootId), (root) => root.getDescendentByEl(el));
    }
    getRootById(id) {
      return this.roots[id];
    }
    destroyAllViews() {
      for (let id in this.roots) {
        this.roots[id].destroy();
        delete this.roots[id];
      }
      this.main = null;
    }
    destroyViewByEl(el) {
      let root = this.getRootById(el.getAttribute(PHX_ROOT_ID));
      if (root && root.id === el.id) {
        root.destroy();
        delete this.roots[root.id];
      } else if (root) {
        root.destroyDescendent(el.id);
      }
    }
    getActiveElement() {
      return document.activeElement;
    }
    dropActiveElement(view) {
      if (this.prevActive && view.ownsElement(this.prevActive)) {
        this.prevActive = null;
      }
    }
    restorePreviouslyActiveFocus() {
      if (this.prevActive && this.prevActive !== document.body) {
        this.prevActive.focus();
      }
    }
    blurActiveElement() {
      this.prevActive = this.getActiveElement();
      if (this.prevActive !== document.body) {
        this.prevActive.blur();
      }
    }
    bindTopLevelEvents({ dead } = {}) {
      if (this.boundTopLevelEvents) {
        return;
      }
      this.boundTopLevelEvents = true;
      this.serverCloseRef = this.socket.onClose((event) => {
        if (event && event.code === 1e3 && this.main) {
          return this.reloadWithJitter(this.main);
        }
      });
      document.body.addEventListener("click", function() {
      });
      window.addEventListener("pageshow", (e) => {
        if (e.persisted) {
          this.getSocket().disconnect();
          this.withPageLoading({ to: window.location.href, kind: "redirect" });
          window.location.reload();
        }
      }, true);
      if (!dead) {
        this.bindNav();
      }
      this.bindClicks();
      if (!dead) {
        this.bindForms();
      }
      this.bind({ keyup: "keyup", keydown: "keydown" }, (e, type, view, targetEl, phxEvent, _phxTarget) => {
        let matchKey = targetEl.getAttribute(this.binding(PHX_KEY));
        let pressedKey = e.key && e.key.toLowerCase();
        if (matchKey && matchKey.toLowerCase() !== pressedKey) {
          return;
        }
        let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
        js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
      });
      this.bind({ blur: "focusout", focus: "focusin" }, (e, type, view, targetEl, phxEvent, phxTarget) => {
        if (!phxTarget) {
          let data = __spreadValues({ key: e.key }, this.eventMeta(type, e, targetEl));
          js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.bind({ blur: "blur", focus: "focus" }, (e, type, view, targetEl, phxEvent, phxTarget) => {
        if (phxTarget === "window") {
          let data = this.eventMeta(type, e, targetEl);
          js_default.exec(e, type, phxEvent, view, targetEl, ["push", { data }]);
        }
      });
      this.on("dragover", (e) => e.preventDefault());
      this.on("drop", (e) => {
        e.preventDefault();
        let dropTargetId = maybe(closestPhxBinding(e.target, this.binding(PHX_DROP_TARGET)), (trueTarget) => {
          return trueTarget.getAttribute(this.binding(PHX_DROP_TARGET));
        });
        let dropTarget = dropTargetId && document.getElementById(dropTargetId);
        let files = Array.from(e.dataTransfer.files || []);
        if (!dropTarget || dropTarget.disabled || files.length === 0 || !(dropTarget.files instanceof FileList)) {
          return;
        }
        LiveUploader.trackFiles(dropTarget, files, e.dataTransfer);
        dropTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
      this.on(PHX_TRACK_UPLOADS, (e) => {
        let uploadTarget = e.target;
        if (!dom_default.isUploadInput(uploadTarget)) {
          return;
        }
        let files = Array.from(e.detail.files || []).filter((f) => f instanceof File || f instanceof Blob);
        LiveUploader.trackFiles(uploadTarget, files);
        uploadTarget.dispatchEvent(new Event("input", { bubbles: true }));
      });
    }
    eventMeta(eventName, e, targetEl) {
      let callback2 = this.metadataCallbacks[eventName];
      return callback2 ? callback2(e, targetEl) : {};
    }
    setPendingLink(href) {
      this.linkRef++;
      this.pendingLink = href;
      this.resetReloadStatus();
      return this.linkRef;
    }
    // anytime we are navigating or connecting, drop reload cookie in case
    // we issue the cookie but the next request was interrupted and the server never dropped it
    resetReloadStatus() {
      browser_default.deleteCookie(PHX_RELOAD_STATUS);
    }
    commitPendingLink(linkRef) {
      if (this.linkRef !== linkRef) {
        return false;
      } else {
        this.href = this.pendingLink;
        this.pendingLink = null;
        return true;
      }
    }
    getHref() {
      return this.href;
    }
    hasPendingLink() {
      return !!this.pendingLink;
    }
    bind(events, callback2) {
      for (let event in events) {
        let browserEventName = events[event];
        this.on(browserEventName, (e) => {
          let binding = this.binding(event);
          let windowBinding = this.binding(`window-${event}`);
          let targetPhxEvent = e.target.getAttribute && e.target.getAttribute(binding);
          if (targetPhxEvent) {
            this.debounce(e.target, e, browserEventName, () => {
              this.withinOwners(e.target, (view) => {
                callback2(e, event, view, e.target, targetPhxEvent, null);
              });
            });
          } else {
            dom_default.all(document, `[${windowBinding}]`, (el) => {
              let phxEvent = el.getAttribute(windowBinding);
              this.debounce(el, e, browserEventName, () => {
                this.withinOwners(el, (view) => {
                  callback2(e, event, view, el, phxEvent, "window");
                });
              });
            });
          }
        });
      }
    }
    bindClicks() {
      this.on("mousedown", (e) => this.clickStartedAtTarget = e.target);
      this.bindClick("click", "click");
    }
    bindClick(eventName, bindingName) {
      let click = this.binding(bindingName);
      window.addEventListener(eventName, (e) => {
        let target = null;
        if (e.detail === 0)
          this.clickStartedAtTarget = e.target;
        let clickStartedAtTarget = this.clickStartedAtTarget || e.target;
        target = closestPhxBinding(e.target, click);
        this.dispatchClickAway(e, clickStartedAtTarget);
        this.clickStartedAtTarget = null;
        let phxEvent = target && target.getAttribute(click);
        if (!phxEvent) {
          if (dom_default.isNewPageClick(e, window.location)) {
            this.unload();
          }
          return;
        }
        if (target.getAttribute("href") === "#") {
          e.preventDefault();
        }
        if (target.hasAttribute(PHX_REF_SRC)) {
          return;
        }
        this.debounce(target, e, "click", () => {
          this.withinOwners(target, (view) => {
            js_default.exec(e, "click", phxEvent, view, target, ["push", { data: this.eventMeta("click", e, target) }]);
          });
        });
      }, false);
    }
    dispatchClickAway(e, clickStartedAt) {
      let phxClickAway = this.binding("click-away");
      dom_default.all(document, `[${phxClickAway}]`, (el) => {
        if (!(el.isSameNode(clickStartedAt) || el.contains(clickStartedAt))) {
          this.withinOwners(el, (view) => {
            let phxEvent = el.getAttribute(phxClickAway);
            if (js_default.isVisible(el) && js_default.isInViewport(el)) {
              js_default.exec(e, "click", phxEvent, view, el, ["push", { data: this.eventMeta("click", e, e.target) }]);
            }
          });
        }
      });
    }
    bindNav() {
      if (!browser_default.canPushState()) {
        return;
      }
      if (history.scrollRestoration) {
        history.scrollRestoration = "manual";
      }
      let scrollTimer = null;
      window.addEventListener("scroll", (_e) => {
        clearTimeout(scrollTimer);
        scrollTimer = setTimeout(() => {
          browser_default.updateCurrentState((state) => Object.assign(state, { scroll: window.scrollY }));
        }, 100);
      });
      window.addEventListener("popstate", (event) => {
        if (!this.registerNewLocation(window.location)) {
          return;
        }
        let { type, backType, id, scroll, position } = event.state || {};
        let href = window.location.href;
        let isForward = position > this.currentHistoryPosition;
        type = isForward ? type : backType || type;
        this.currentHistoryPosition = position || 0;
        this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
        dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: type === "patch", pop: true, direction: isForward ? "forward" : "backward" } });
        this.requestDOMUpdate(() => {
          const callback2 = () => {
            this.maybeScroll(scroll);
          };
          if (this.main.isConnected() && (type === "patch" && id === this.main.id)) {
            this.main.pushLinkPatch(event, href, null, callback2);
          } else {
            this.replaceMain(href, null, callback2);
          }
        });
      }, false);
      window.addEventListener("click", (e) => {
        let target = closestPhxBinding(e.target, PHX_LIVE_LINK);
        let type = target && target.getAttribute(PHX_LIVE_LINK);
        if (!type || !this.isConnected() || !this.main || dom_default.wantsNewTab(e)) {
          return;
        }
        let href = target.href instanceof SVGAnimatedString ? target.href.baseVal : target.href;
        let linkState = target.getAttribute(PHX_LINK_STATE);
        e.preventDefault();
        e.stopImmediatePropagation();
        if (this.pendingLink === href) {
          return;
        }
        this.requestDOMUpdate(() => {
          if (type === "patch") {
            this.pushHistoryPatch(e, href, linkState, target);
          } else if (type === "redirect") {
            this.historyRedirect(e, href, linkState, null, target);
          } else {
            throw new Error(`expected ${PHX_LIVE_LINK} to be "patch" or "redirect", got: ${type}`);
          }
          let phxClick = target.getAttribute(this.binding("click"));
          if (phxClick) {
            this.requestDOMUpdate(() => this.execJS(target, phxClick, "click"));
          }
        });
      }, false);
    }
    maybeScroll(scroll) {
      if (typeof scroll === "number") {
        requestAnimationFrame(() => {
          window.scrollTo(0, scroll);
        });
      }
    }
    dispatchEvent(event, payload = {}) {
      dom_default.dispatchEvent(window, `phx:${event}`, { detail: payload });
    }
    dispatchEvents(events) {
      events.forEach(([event, payload]) => this.dispatchEvent(event, payload));
    }
    withPageLoading(info, callback2) {
      dom_default.dispatchEvent(window, "phx:page-loading-start", { detail: info });
      let done = () => dom_default.dispatchEvent(window, "phx:page-loading-stop", { detail: info });
      return callback2 ? callback2(done) : done;
    }
    pushHistoryPatch(e, href, linkState, targetEl) {
      if (!this.isConnected() || !this.main.isMain()) {
        return browser_default.redirect(href);
      }
      this.withPageLoading({ to: href, kind: "patch" }, (done) => {
        this.main.pushLinkPatch(e, href, targetEl, (linkRef) => {
          this.historyPatch(href, linkState, linkRef);
          done();
        });
      });
    }
    historyPatch(href, linkState, linkRef = this.setPendingLink(href)) {
      if (!this.commitPendingLink(linkRef)) {
        return;
      }
      this.currentHistoryPosition++;
      this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
      browser_default.updateCurrentState((state) => __spreadProps(__spreadValues({}, state), { backType: "patch" }));
      browser_default.pushState(linkState, {
        type: "patch",
        id: this.main.id,
        position: this.currentHistoryPosition
      }, href);
      dom_default.dispatchEvent(window, "phx:navigate", { detail: { patch: true, href, pop: false, direction: "forward" } });
      this.registerNewLocation(window.location);
    }
    historyRedirect(e, href, linkState, flash, targetEl) {
      const clickLoading = targetEl && e.isTrusted && e.type !== "popstate";
      if (clickLoading) {
        targetEl.classList.add("phx-click-loading");
      }
      if (!this.isConnected() || !this.main.isMain()) {
        return browser_default.redirect(href, flash);
      }
      if (/^\/$|^\/[^\/]+.*$/.test(href)) {
        let { protocol, host } = window.location;
        href = `${protocol}//${host}${href}`;
      }
      let scroll = window.scrollY;
      this.withPageLoading({ to: href, kind: "redirect" }, (done) => {
        this.replaceMain(href, flash, (linkRef) => {
          if (linkRef === this.linkRef) {
            this.currentHistoryPosition++;
            this.sessionStorage.setItem(PHX_LV_HISTORY_POSITION, this.currentHistoryPosition.toString());
            browser_default.updateCurrentState((state) => __spreadProps(__spreadValues({}, state), { backType: "redirect" }));
            browser_default.pushState(linkState, {
              type: "redirect",
              id: this.main.id,
              scroll,
              position: this.currentHistoryPosition
            }, href);
            dom_default.dispatchEvent(window, "phx:navigate", { detail: { href, patch: false, pop: false, direction: "forward" } });
            this.registerNewLocation(window.location);
          }
          if (clickLoading) {
            targetEl.classList.remove("phx-click-loading");
          }
          done();
        });
      });
    }
    registerNewLocation(newLocation) {
      let { pathname, search } = this.currentLocation;
      if (pathname + search === newLocation.pathname + newLocation.search) {
        return false;
      } else {
        this.currentLocation = clone(newLocation);
        return true;
      }
    }
    bindForms() {
      let iterations = 0;
      let externalFormSubmitted = false;
      this.on("submit", (e) => {
        let phxSubmit = e.target.getAttribute(this.binding("submit"));
        let phxChange = e.target.getAttribute(this.binding("change"));
        if (!externalFormSubmitted && phxChange && !phxSubmit) {
          externalFormSubmitted = true;
          e.preventDefault();
          this.withinOwners(e.target, (view) => {
            view.disableForm(e.target);
            window.requestAnimationFrame(() => {
              if (dom_default.isUnloadableFormSubmit(e)) {
                this.unload();
              }
              e.target.submit();
            });
          });
        }
      });
      this.on("submit", (e) => {
        let phxEvent = e.target.getAttribute(this.binding("submit"));
        if (!phxEvent) {
          if (dom_default.isUnloadableFormSubmit(e)) {
            this.unload();
          }
          return;
        }
        e.preventDefault();
        e.target.disabled = true;
        this.withinOwners(e.target, (view) => {
          js_default.exec(e, "submit", phxEvent, view, e.target, ["push", { submitter: e.submitter }]);
        });
      });
      for (let type of ["change", "input"]) {
        this.on(type, (e) => {
          if (e instanceof CustomEvent && e.target.form === void 0) {
            if (e.detail && e.detail.dispatcher) {
              throw new Error(`dispatching a custom ${type} event is only supported on input elements inside a form`);
            }
            return;
          }
          let phxChange = this.binding("change");
          let input = e.target;
          if (e.isComposing) {
            const key = `composition-listener-${type}`;
            if (!dom_default.private(input, key)) {
              dom_default.putPrivate(input, key, true);
              input.addEventListener("compositionend", () => {
                input.dispatchEvent(new Event(type, { bubbles: true }));
                dom_default.deletePrivate(input, key);
              }, { once: true });
            }
            return;
          }
          let inputEvent = input.getAttribute(phxChange);
          let formEvent = input.form && input.form.getAttribute(phxChange);
          let phxEvent = inputEvent || formEvent;
          if (!phxEvent) {
            return;
          }
          if (input.type === "number" && input.validity && input.validity.badInput) {
            return;
          }
          let dispatcher = inputEvent ? input : input.form;
          let currentIterations = iterations;
          iterations++;
          let { at, type: lastType } = dom_default.private(input, "prev-iteration") || {};
          if (at === currentIterations - 1 && type === "change" && lastType === "input") {
            return;
          }
          dom_default.putPrivate(input, "prev-iteration", { at: currentIterations, type });
          this.debounce(input, e, type, () => {
            this.withinOwners(dispatcher, (view) => {
              dom_default.putPrivate(input, PHX_HAS_FOCUSED, true);
              js_default.exec(e, "change", phxEvent, view, input, ["push", { _target: e.target.name, dispatcher }]);
            });
          });
        });
      }
      this.on("reset", (e) => {
        let form = e.target;
        dom_default.resetForm(form);
        let input = Array.from(form.elements).find((el) => el.type === "reset");
        if (input) {
          window.requestAnimationFrame(() => {
            input.dispatchEvent(new Event("input", { bubbles: true, cancelable: false }));
          });
        }
      });
    }
    debounce(el, event, eventType, callback2) {
      if (eventType === "blur" || eventType === "focusout") {
        return callback2();
      }
      let phxDebounce = this.binding(PHX_DEBOUNCE);
      let phxThrottle = this.binding(PHX_THROTTLE);
      let defaultDebounce = this.defaults.debounce.toString();
      let defaultThrottle = this.defaults.throttle.toString();
      this.withinOwners(el, (view) => {
        let asyncFilter = () => !view.isDestroyed() && document.body.contains(el);
        dom_default.debounce(el, event, phxDebounce, defaultDebounce, phxThrottle, defaultThrottle, asyncFilter, () => {
          callback2();
        });
      });
    }
    silenceEvents(callback2) {
      this.silenced = true;
      callback2();
      this.silenced = false;
    }
    on(event, callback2) {
      this.boundEventNames.add(event);
      window.addEventListener(event, (e) => {
        if (!this.silenced) {
          callback2(e);
        }
      });
    }
    jsQuerySelectorAll(sourceEl, query, defaultQuery) {
      let all = this.domCallbacks.jsQuerySelectorAll;
      return all ? all(sourceEl, query, defaultQuery) : defaultQuery();
    }
  };
  var TransitionSet = class {
    constructor() {
      this.transitions = /* @__PURE__ */ new Set();
      this.pendingOps = [];
    }
    reset() {
      this.transitions.forEach((timer) => {
        clearTimeout(timer);
        this.transitions.delete(timer);
      });
      this.flushPendingOps();
    }
    after(callback2) {
      if (this.size() === 0) {
        callback2();
      } else {
        this.pushPendingOp(callback2);
      }
    }
    addTransition(time, onStart, onDone) {
      onStart();
      let timer = setTimeout(() => {
        this.transitions.delete(timer);
        onDone();
        this.flushPendingOps();
      }, time);
      this.transitions.add(timer);
    }
    pushPendingOp(op) {
      this.pendingOps.push(op);
    }
    size() {
      return this.transitions.size;
    }
    flushPendingOps() {
      if (this.size() > 0) {
        return;
      }
      let op = this.pendingOps.shift();
      if (op) {
        op();
        this.flushPendingOps();
      }
    }
  };

  // js/app.js
  var import_topbar = __toESM(require_topbar());

  // node_modules/@kurkle/color/dist/color.esm.js
  function round(v) {
    return v + 0.5 | 0;
  }
  var lim = (v, l, h) => Math.max(Math.min(v, h), l);
  function p2b(v) {
    return lim(round(v * 2.55), 0, 255);
  }
  function n2b(v) {
    return lim(round(v * 255), 0, 255);
  }
  function b2n(v) {
    return lim(round(v / 2.55) / 100, 0, 1);
  }
  function n2p(v) {
    return lim(round(v * 100), 0, 100);
  }
  var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
  var hex = [..."0123456789ABCDEF"];
  var h1 = (b) => hex[b & 15];
  var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
  var eq = (b) => (b & 240) >> 4 === (b & 15);
  var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
  function hexParse(str) {
    var len = str.length;
    var ret;
    if (str[0] === "#") {
      if (len === 4 || len === 5) {
        ret = {
          r: 255 & map$1[str[1]] * 17,
          g: 255 & map$1[str[2]] * 17,
          b: 255 & map$1[str[3]] * 17,
          a: len === 5 ? map$1[str[4]] * 17 : 255
        };
      } else if (len === 7 || len === 9) {
        ret = {
          r: map$1[str[1]] << 4 | map$1[str[2]],
          g: map$1[str[3]] << 4 | map$1[str[4]],
          b: map$1[str[5]] << 4 | map$1[str[6]],
          a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
        };
      }
    }
    return ret;
  }
  var alpha = (a, f) => a < 255 ? f(a) : "";
  function hexString(v) {
    var f = isShort(v) ? h1 : h2;
    return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
  }
  var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
  function hsl2rgbn(h, s, l) {
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return [f(0), f(8), f(4)];
  }
  function hsv2rgbn(h, s, v) {
    const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
    return [f(5), f(3), f(1)];
  }
  function hwb2rgbn(h, w, b) {
    const rgb = hsl2rgbn(h, 1, 0.5);
    let i;
    if (w + b > 1) {
      i = 1 / (w + b);
      w *= i;
      b *= i;
    }
    for (i = 0; i < 3; i++) {
      rgb[i] *= 1 - w - b;
      rgb[i] += w;
    }
    return rgb;
  }
  function hueValue(r, g, b, d, max) {
    if (r === max) {
      return (g - b) / d + (g < b ? 6 : 0);
    }
    if (g === max) {
      return (b - r) / d + 2;
    }
    return (r - g) / d + 4;
  }
  function rgb2hsl(v) {
    const range2 = 255;
    const r = v.r / range2;
    const g = v.g / range2;
    const b = v.b / range2;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;
    let h, s, d;
    if (max !== min) {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = hueValue(r, g, b, d, max);
      h = h * 60 + 0.5;
    }
    return [h | 0, s || 0, l];
  }
  function calln(f, a, b, c) {
    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
  }
  function hsl2rgb(h, s, l) {
    return calln(hsl2rgbn, h, s, l);
  }
  function hwb2rgb(h, w, b) {
    return calln(hwb2rgbn, h, w, b);
  }
  function hsv2rgb(h, s, v) {
    return calln(hsv2rgbn, h, s, v);
  }
  function hue(h) {
    return (h % 360 + 360) % 360;
  }
  function hueParse(str) {
    const m = HUE_RE.exec(str);
    let a = 255;
    let v;
    if (!m) {
      return;
    }
    if (m[5] !== v) {
      a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
    }
    const h = hue(+m[2]);
    const p1 = +m[3] / 100;
    const p2 = +m[4] / 100;
    if (m[1] === "hwb") {
      v = hwb2rgb(h, p1, p2);
    } else if (m[1] === "hsv") {
      v = hsv2rgb(h, p1, p2);
    } else {
      v = hsl2rgb(h, p1, p2);
    }
    return {
      r: v[0],
      g: v[1],
      b: v[2],
      a
    };
  }
  function rotate(v, deg) {
    var h = rgb2hsl(v);
    h[0] = hue(h[0] + deg);
    h = hsl2rgb(h);
    v.r = h[0];
    v.g = h[1];
    v.b = h[2];
  }
  function hslString(v) {
    if (!v) {
      return;
    }
    const a = rgb2hsl(v);
    const h = a[0];
    const s = n2p(a[1]);
    const l = n2p(a[2]);
    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
  }
  var map = {
    x: "dark",
    Z: "light",
    Y: "re",
    X: "blu",
    W: "gr",
    V: "medium",
    U: "slate",
    A: "ee",
    T: "ol",
    S: "or",
    B: "ra",
    C: "lateg",
    D: "ights",
    R: "in",
    Q: "turquois",
    E: "hi",
    P: "ro",
    O: "al",
    N: "le",
    M: "de",
    L: "yello",
    F: "en",
    K: "ch",
    G: "arks",
    H: "ea",
    I: "ightg",
    J: "wh"
  };
  var names$1 = {
    OiceXe: "f0f8ff",
    antiquewEte: "faebd7",
    aqua: "ffff",
    aquamarRe: "7fffd4",
    azuY: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "0",
    blanKedOmond: "ffebcd",
    Xe: "ff",
    XeviTet: "8a2be2",
    bPwn: "a52a2a",
    burlywood: "deb887",
    caMtXe: "5f9ea0",
    KartYuse: "7fff00",
    KocTate: "d2691e",
    cSO: "ff7f50",
    cSnflowerXe: "6495ed",
    cSnsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "ffff",
    xXe: "8b",
    xcyan: "8b8b",
    xgTMnPd: "b8860b",
    xWay: "a9a9a9",
    xgYF: "6400",
    xgYy: "a9a9a9",
    xkhaki: "bdb76b",
    xmagFta: "8b008b",
    xTivegYF: "556b2f",
    xSange: "ff8c00",
    xScEd: "9932cc",
    xYd: "8b0000",
    xsOmon: "e9967a",
    xsHgYF: "8fbc8f",
    xUXe: "483d8b",
    xUWay: "2f4f4f",
    xUgYy: "2f4f4f",
    xQe: "ced1",
    xviTet: "9400d3",
    dAppRk: "ff1493",
    dApskyXe: "bfff",
    dimWay: "696969",
    dimgYy: "696969",
    dodgerXe: "1e90ff",
    fiYbrick: "b22222",
    flSOwEte: "fffaf0",
    foYstWAn: "228b22",
    fuKsia: "ff00ff",
    gaRsbSo: "dcdcdc",
    ghostwEte: "f8f8ff",
    gTd: "ffd700",
    gTMnPd: "daa520",
    Way: "808080",
    gYF: "8000",
    gYFLw: "adff2f",
    gYy: "808080",
    honeyMw: "f0fff0",
    hotpRk: "ff69b4",
    RdianYd: "cd5c5c",
    Rdigo: "4b0082",
    ivSy: "fffff0",
    khaki: "f0e68c",
    lavFMr: "e6e6fa",
    lavFMrXsh: "fff0f5",
    lawngYF: "7cfc00",
    NmoncEffon: "fffacd",
    ZXe: "add8e6",
    ZcSO: "f08080",
    Zcyan: "e0ffff",
    ZgTMnPdLw: "fafad2",
    ZWay: "d3d3d3",
    ZgYF: "90ee90",
    ZgYy: "d3d3d3",
    ZpRk: "ffb6c1",
    ZsOmon: "ffa07a",
    ZsHgYF: "20b2aa",
    ZskyXe: "87cefa",
    ZUWay: "778899",
    ZUgYy: "778899",
    ZstAlXe: "b0c4de",
    ZLw: "ffffe0",
    lime: "ff00",
    limegYF: "32cd32",
    lRF: "faf0e6",
    magFta: "ff00ff",
    maPon: "800000",
    VaquamarRe: "66cdaa",
    VXe: "cd",
    VScEd: "ba55d3",
    VpurpN: "9370db",
    VsHgYF: "3cb371",
    VUXe: "7b68ee",
    VsprRggYF: "fa9a",
    VQe: "48d1cc",
    VviTetYd: "c71585",
    midnightXe: "191970",
    mRtcYam: "f5fffa",
    mistyPse: "ffe4e1",
    moccasR: "ffe4b5",
    navajowEte: "ffdead",
    navy: "80",
    Tdlace: "fdf5e6",
    Tive: "808000",
    TivedBb: "6b8e23",
    Sange: "ffa500",
    SangeYd: "ff4500",
    ScEd: "da70d6",
    pOegTMnPd: "eee8aa",
    pOegYF: "98fb98",
    pOeQe: "afeeee",
    pOeviTetYd: "db7093",
    papayawEp: "ffefd5",
    pHKpuff: "ffdab9",
    peru: "cd853f",
    pRk: "ffc0cb",
    plum: "dda0dd",
    powMrXe: "b0e0e6",
    purpN: "800080",
    YbeccapurpN: "663399",
    Yd: "ff0000",
    Psybrown: "bc8f8f",
    PyOXe: "4169e1",
    saddNbPwn: "8b4513",
    sOmon: "fa8072",
    sandybPwn: "f4a460",
    sHgYF: "2e8b57",
    sHshell: "fff5ee",
    siFna: "a0522d",
    silver: "c0c0c0",
    skyXe: "87ceeb",
    UXe: "6a5acd",
    UWay: "708090",
    UgYy: "708090",
    snow: "fffafa",
    sprRggYF: "ff7f",
    stAlXe: "4682b4",
    tan: "d2b48c",
    teO: "8080",
    tEstN: "d8bfd8",
    tomato: "ff6347",
    Qe: "40e0d0",
    viTet: "ee82ee",
    JHt: "f5deb3",
    wEte: "ffffff",
    wEtesmoke: "f5f5f5",
    Lw: "ffff00",
    LwgYF: "9acd32"
  };
  function unpack() {
    const unpacked = {};
    const keys = Object.keys(names$1);
    const tkeys = Object.keys(map);
    let i, j, k, ok, nk;
    for (i = 0; i < keys.length; i++) {
      ok = nk = keys[i];
      for (j = 0; j < tkeys.length; j++) {
        k = tkeys[j];
        nk = nk.replace(k, map[k]);
      }
      k = parseInt(names$1[ok], 16);
      unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
    }
    return unpacked;
  }
  var names;
  function nameParse(str) {
    if (!names) {
      names = unpack();
      names.transparent = [0, 0, 0, 0];
    }
    const a = names[str.toLowerCase()];
    return a && {
      r: a[0],
      g: a[1],
      b: a[2],
      a: a.length === 4 ? a[3] : 255
    };
  }
  var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
  function rgbParse(str) {
    const m = RGB_RE.exec(str);
    let a = 255;
    let r, g, b;
    if (!m) {
      return;
    }
    if (m[7] !== r) {
      const v = +m[7];
      a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
    }
    r = +m[1];
    g = +m[3];
    b = +m[5];
    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
    return {
      r,
      g,
      b,
      a
    };
  }
  function rgbString(v) {
    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
  }
  var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
  var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  function interpolate(rgb1, rgb2, t) {
    const r = from(b2n(rgb1.r));
    const g = from(b2n(rgb1.g));
    const b = from(b2n(rgb1.b));
    return {
      r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
      g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
      b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
      a: rgb1.a + t * (rgb2.a - rgb1.a)
    };
  }
  function modHSL(v, i, ratio) {
    if (v) {
      let tmp = rgb2hsl(v);
      tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
      tmp = hsl2rgb(tmp);
      v.r = tmp[0];
      v.g = tmp[1];
      v.b = tmp[2];
    }
  }
  function clone2(v, proto) {
    return v ? Object.assign(proto || {}, v) : v;
  }
  function fromObject(input) {
    var v = { r: 0, g: 0, b: 0, a: 255 };
    if (Array.isArray(input)) {
      if (input.length >= 3) {
        v = { r: input[0], g: input[1], b: input[2], a: 255 };
        if (input.length > 3) {
          v.a = n2b(input[3]);
        }
      }
    } else {
      v = clone2(input, { r: 0, g: 0, b: 0, a: 1 });
      v.a = n2b(v.a);
    }
    return v;
  }
  function functionParse(str) {
    if (str.charAt(0) === "r") {
      return rgbParse(str);
    }
    return hueParse(str);
  }
  var Color = class {
    constructor(input) {
      if (input instanceof Color) {
        return input;
      }
      const type = typeof input;
      let v;
      if (type === "object") {
        v = fromObject(input);
      } else if (type === "string") {
        v = hexParse(input) || nameParse(input) || functionParse(input);
      }
      this._rgb = v;
      this._valid = !!v;
    }
    get valid() {
      return this._valid;
    }
    get rgb() {
      var v = clone2(this._rgb);
      if (v) {
        v.a = b2n(v.a);
      }
      return v;
    }
    set rgb(obj) {
      this._rgb = fromObject(obj);
    }
    rgbString() {
      return this._valid ? rgbString(this._rgb) : void 0;
    }
    hexString() {
      return this._valid ? hexString(this._rgb) : void 0;
    }
    hslString() {
      return this._valid ? hslString(this._rgb) : void 0;
    }
    mix(color2, weight) {
      if (color2) {
        const c1 = this.rgb;
        const c2 = color2.rgb;
        let w2;
        const p = weight === w2 ? 0.5 : weight;
        const w = 2 * p - 1;
        const a = c1.a - c2.a;
        const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        w2 = 1 - w1;
        c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
        c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
        c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
        c1.a = p * c1.a + (1 - p) * c2.a;
        this.rgb = c1;
      }
      return this;
    }
    interpolate(color2, t) {
      if (color2) {
        this._rgb = interpolate(this._rgb, color2._rgb, t);
      }
      return this;
    }
    clone() {
      return new Color(this.rgb);
    }
    alpha(a) {
      this._rgb.a = n2b(a);
      return this;
    }
    clearer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 - ratio;
      return this;
    }
    greyscale() {
      const rgb = this._rgb;
      const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
      rgb.r = rgb.g = rgb.b = val;
      return this;
    }
    opaquer(ratio) {
      const rgb = this._rgb;
      rgb.a *= 1 + ratio;
      return this;
    }
    negate() {
      const v = this._rgb;
      v.r = 255 - v.r;
      v.g = 255 - v.g;
      v.b = 255 - v.b;
      return this;
    }
    lighten(ratio) {
      modHSL(this._rgb, 2, ratio);
      return this;
    }
    darken(ratio) {
      modHSL(this._rgb, 2, -ratio);
      return this;
    }
    saturate(ratio) {
      modHSL(this._rgb, 1, ratio);
      return this;
    }
    desaturate(ratio) {
      modHSL(this._rgb, 1, -ratio);
      return this;
    }
    rotate(deg) {
      rotate(this._rgb, deg);
      return this;
    }
  };

  // node_modules/chart.js/dist/chunks/helpers.segment.js
  function noop2() {
  }
  var uid = (() => {
    let id = 0;
    return () => id++;
  })();
  function isNullOrUndef(value) {
    return value === null || value === void 0;
  }
  function isArray(value) {
    if (Array.isArray && Array.isArray(value)) {
      return true;
    }
    const type = Object.prototype.toString.call(value);
    if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
      return true;
    }
    return false;
  }
  function isObject2(value) {
    return value !== null && Object.prototype.toString.call(value) === "[object Object]";
  }
  function isNumberFinite(value) {
    return (typeof value === "number" || value instanceof Number) && isFinite(+value);
  }
  function finiteOrDefault(value, defaultValue) {
    return isNumberFinite(value) ? value : defaultValue;
  }
  function valueOrDefault(value, defaultValue) {
    return typeof value === "undefined" ? defaultValue : value;
  }
  var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
  var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
  function callback(fn, args, thisArg) {
    if (fn && typeof fn.call === "function") {
      return fn.apply(thisArg, args);
    }
  }
  function each(loopable, fn, thisArg, reverse) {
    let i, len, keys;
    if (isArray(loopable)) {
      len = loopable.length;
      if (reverse) {
        for (i = len - 1; i >= 0; i--) {
          fn.call(thisArg, loopable[i], i);
        }
      } else {
        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[i], i);
        }
      }
    } else if (isObject2(loopable)) {
      keys = Object.keys(loopable);
      len = keys.length;
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[keys[i]], keys[i]);
      }
    }
  }
  function _elementsEqual(a0, a1) {
    let i, ilen, v0, v1;
    if (!a0 || !a1 || a0.length !== a1.length) {
      return false;
    }
    for (i = 0, ilen = a0.length; i < ilen; ++i) {
      v0 = a0[i];
      v1 = a1[i];
      if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
        return false;
      }
    }
    return true;
  }
  function clone3(source) {
    if (isArray(source)) {
      return source.map(clone3);
    }
    if (isObject2(source)) {
      const target = /* @__PURE__ */ Object.create(null);
      const keys = Object.keys(source);
      const klen = keys.length;
      let k = 0;
      for (; k < klen; ++k) {
        target[keys[k]] = clone3(source[keys[k]]);
      }
      return target;
    }
    return source;
  }
  function isValidKey(key) {
    return [
      "__proto__",
      "prototype",
      "constructor"
    ].indexOf(key) === -1;
  }
  function _merger(key, target, source, options) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      merge(tval, sval, options);
    } else {
      target[key] = clone3(sval);
    }
  }
  function merge(target, source, options) {
    const sources = isArray(source) ? source : [
      source
    ];
    const ilen = sources.length;
    if (!isObject2(target)) {
      return target;
    }
    options = options || {};
    const merger = options.merger || _merger;
    let current;
    for (let i = 0; i < ilen; ++i) {
      current = sources[i];
      if (!isObject2(current)) {
        continue;
      }
      const keys = Object.keys(current);
      for (let k = 0, klen = keys.length; k < klen; ++k) {
        merger(keys[k], target, current, options);
      }
    }
    return target;
  }
  function mergeIf(target, source) {
    return merge(target, source, {
      merger: _mergerIf
    });
  }
  function _mergerIf(key, target, source) {
    if (!isValidKey(key)) {
      return;
    }
    const tval = target[key];
    const sval = source[key];
    if (isObject2(tval) && isObject2(sval)) {
      mergeIf(tval, sval);
    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
      target[key] = clone3(sval);
    }
  }
  var keyResolvers = {
    // Chart.helpers.core resolveObjectKey should resolve empty key to root object
    "": (v) => v,
    // default resolvers
    x: (o) => o.x,
    y: (o) => o.y
  };
  function _splitKey(key) {
    const parts = key.split(".");
    const keys = [];
    let tmp = "";
    for (const part of parts) {
      tmp += part;
      if (tmp.endsWith("\\")) {
        tmp = tmp.slice(0, -1) + ".";
      } else {
        keys.push(tmp);
        tmp = "";
      }
    }
    return keys;
  }
  function _getKeyResolver(key) {
    const keys = _splitKey(key);
    return (obj) => {
      for (const k of keys) {
        if (k === "") {
          break;
        }
        obj = obj && obj[k];
      }
      return obj;
    };
  }
  function resolveObjectKey(obj, key) {
    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
    return resolver(obj);
  }
  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var defined = (value) => typeof value !== "undefined";
  var isFunction = (value) => typeof value === "function";
  var setsEqual = (a, b) => {
    if (a.size !== b.size) {
      return false;
    }
    for (const item of a) {
      if (!b.has(item)) {
        return false;
      }
    }
    return true;
  };
  function _isClickEvent(e) {
    return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
  }
  var PI = Math.PI;
  var TAU = 2 * PI;
  var PITAU = TAU + PI;
  var INFINITY = Number.POSITIVE_INFINITY;
  var RAD_PER_DEG = PI / 180;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  var log10 = Math.log10;
  var sign = Math.sign;
  function almostEquals(x, y, epsilon) {
    return Math.abs(x - y) < epsilon;
  }
  function niceNum(range2) {
    const roundedRange = Math.round(range2);
    range2 = almostEquals(range2, roundedRange, range2 / 1e3) ? roundedRange : range2;
    const niceRange = Math.pow(10, Math.floor(log10(range2)));
    const fraction = range2 / niceRange;
    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
    return niceFraction * niceRange;
  }
  function _factorize(value) {
    const result = [];
    const sqrt = Math.sqrt(value);
    let i;
    for (i = 1; i < sqrt; i++) {
      if (value % i === 0) {
        result.push(i);
        result.push(value / i);
      }
    }
    if (sqrt === (sqrt | 0)) {
      result.push(sqrt);
    }
    result.sort((a, b) => a - b).pop();
    return result;
  }
  function isNonPrimitive(n) {
    return typeof n === "symbol" || typeof n === "object" && n !== null && !(Symbol.toPrimitive in n || "toString" in n || "valueOf" in n);
  }
  function isNumber(n) {
    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
  }
  function almostWhole(x, epsilon) {
    const rounded = Math.round(x);
    return rounded - epsilon <= x && rounded + epsilon >= x;
  }
  function _setMinAndMaxByKey(array, target, property) {
    let i, ilen, value;
    for (i = 0, ilen = array.length; i < ilen; i++) {
      value = array[i][property];
      if (!isNaN(value)) {
        target.min = Math.min(target.min, value);
        target.max = Math.max(target.max, value);
      }
    }
  }
  function toRadians(degrees) {
    return degrees * (PI / 180);
  }
  function toDegrees(radians) {
    return radians * (180 / PI);
  }
  function _decimalPlaces(x) {
    if (!isNumberFinite(x)) {
      return;
    }
    let e = 1;
    let p = 0;
    while (Math.round(x * e) / e !== x) {
      e *= 10;
      p++;
    }
    return p;
  }
  function getAngleFromPoint(centrePoint, anglePoint) {
    const distanceFromXCenter = anglePoint.x - centrePoint.x;
    const distanceFromYCenter = anglePoint.y - centrePoint.y;
    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
    if (angle < -0.5 * PI) {
      angle += TAU;
    }
    return {
      angle,
      distance: radialDistanceFromCenter
    };
  }
  function distanceBetweenPoints(pt1, pt2) {
    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
  }
  function _angleDiff(a, b) {
    return (a - b + PITAU) % TAU - PI;
  }
  function _normalizeAngle(a) {
    return (a % TAU + TAU) % TAU;
  }
  function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
    const a = _normalizeAngle(angle);
    const s = _normalizeAngle(start);
    const e = _normalizeAngle(end);
    const angleToStart = _normalizeAngle(s - a);
    const angleToEnd = _normalizeAngle(e - a);
    const startToAngle = _normalizeAngle(a - s);
    const endToAngle = _normalizeAngle(a - e);
    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
  }
  function _limitValue(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function _int16Range(value) {
    return _limitValue(value, -32768, 32767);
  }
  function _isBetween(value, start, end, epsilon = 1e-6) {
    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
  }
  function _lookup(table, value, cmp) {
    cmp = cmp || ((index2) => table[index2] < value);
    let hi = table.length - 1;
    let lo = 0;
    let mid;
    while (hi - lo > 1) {
      mid = lo + hi >> 1;
      if (cmp(mid)) {
        lo = mid;
      } else {
        hi = mid;
      }
    }
    return {
      lo,
      hi
    };
  }
  var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
    const ti = table[index2][key];
    return ti < value || ti === value && table[index2 + 1][key] === value;
  } : (index2) => table[index2][key] < value);
  var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
  function _filterBetween(values, min, max) {
    let start = 0;
    let end = values.length;
    while (start < end && values[start] < min) {
      start++;
    }
    while (end > start && values[end - 1] > max) {
      end--;
    }
    return start > 0 || end < values.length ? values.slice(start, end) : values;
  }
  var arrayEvents = [
    "push",
    "pop",
    "shift",
    "splice",
    "unshift"
  ];
  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);
      return;
    }
    Object.defineProperty(array, "_chartjs", {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [
          listener
        ]
      }
    });
    arrayEvents.forEach((key) => {
      const method = "_onData" + _capitalize(key);
      const base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value(...args) {
          const res = base.apply(this, args);
          array._chartjs.listeners.forEach((object) => {
            if (typeof object[method] === "function") {
              object[method](...args);
            }
          });
          return res;
        }
      });
    });
  }
  function unlistenArrayEvents(array, listener) {
    const stub = array._chartjs;
    if (!stub) {
      return;
    }
    const listeners = stub.listeners;
    const index2 = listeners.indexOf(listener);
    if (index2 !== -1) {
      listeners.splice(index2, 1);
    }
    if (listeners.length > 0) {
      return;
    }
    arrayEvents.forEach((key) => {
      delete array[key];
    });
    delete array._chartjs;
  }
  function _arrayUnique(items) {
    const set2 = new Set(items);
    if (set2.size === items.length) {
      return items;
    }
    return Array.from(set2);
  }
  var requestAnimFrame = function() {
    if (typeof window === "undefined") {
      return function(callback2) {
        return callback2();
      };
    }
    return window.requestAnimationFrame;
  }();
  function throttled(fn, thisArg) {
    let argsToUse = [];
    let ticking = false;
    return function(...args) {
      argsToUse = args;
      if (!ticking) {
        ticking = true;
        requestAnimFrame.call(window, () => {
          ticking = false;
          fn.apply(thisArg, argsToUse);
        });
      }
    };
  }
  function debounce(fn, delay) {
    let timeout;
    return function(...args) {
      if (delay) {
        clearTimeout(timeout);
        timeout = setTimeout(fn, delay, args);
      } else {
        fn.apply(this, args);
      }
      return delay;
    };
  }
  var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
  var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
  var _textX = (align, left, right, rtl) => {
    const check = rtl ? "left" : "right";
    return align === check ? right : align === "center" ? (left + right) / 2 : left;
  };
  function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
    const pointCount = points.length;
    let start = 0;
    let count = pointCount;
    if (meta._sorted) {
      const { iScale, vScale, _parsed } = meta;
      const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
      const axis = iScale.axis;
      const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
      if (minDefined) {
        start = Math.min(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, axis, min).lo,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
        );
        if (spanGaps) {
          const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          start -= Math.max(0, distanceToDefinedLo);
        }
        start = _limitValue(start, 0, pointCount - 1);
      }
      if (maxDefined) {
        let end = Math.max(
          // @ts-expect-error Need to type _parsed
          _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
          // @ts-expect-error Need to fix types on _lookupByKey
          animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
        );
        if (spanGaps) {
          const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          end += Math.max(0, distanceToDefinedHi);
        }
        count = _limitValue(end, start, pointCount) - start;
      } else {
        count = pointCount - start;
      }
    }
    return {
      start,
      count
    };
  }
  function _scaleRangesChanged(meta) {
    const { xScale, yScale, _scaleRanges } = meta;
    const newRanges = {
      xmin: xScale.min,
      xmax: xScale.max,
      ymin: yScale.min,
      ymax: yScale.max
    };
    if (!_scaleRanges) {
      meta._scaleRanges = newRanges;
      return true;
    }
    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
    Object.assign(_scaleRanges, newRanges);
    return changed;
  }
  var atEdge = (t) => t === 0 || t === 1;
  var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
  var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
  var effects = {
    linear: (t) => t,
    easeInQuad: (t) => t * t,
    easeOutQuad: (t) => -t * (t - 2),
    easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
    easeInCubic: (t) => t * t * t,
    easeOutCubic: (t) => (t -= 1) * t * t + 1,
    easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
    easeInQuart: (t) => t * t * t * t,
    easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
    easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
    easeInQuint: (t) => t * t * t * t * t,
    easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
    easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
    easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
    easeOutSine: (t) => Math.sin(t * HALF_PI),
    easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
    easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
    easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
    easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
    easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
    easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
    easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
    easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
    easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
    easeInOutElastic(t) {
      const s = 0.1125;
      const p = 0.45;
      return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
    },
    easeInBack(t) {
      const s = 1.70158;
      return t * t * ((s + 1) * t - s);
    },
    easeOutBack(t) {
      const s = 1.70158;
      return (t -= 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack(t) {
      let s = 1.70158;
      if ((t /= 0.5) < 1) {
        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
      }
      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
    easeOutBounce(t) {
      const m = 7.5625;
      const d = 2.75;
      if (t < 1 / d) {
        return m * t * t;
      }
      if (t < 2 / d) {
        return m * (t -= 1.5 / d) * t + 0.75;
      }
      if (t < 2.5 / d) {
        return m * (t -= 2.25 / d) * t + 0.9375;
      }
      return m * (t -= 2.625 / d) * t + 0.984375;
    },
    easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
  };
  function isPatternOrGradient(value) {
    if (value && typeof value === "object") {
      const type = value.toString();
      return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
    }
    return false;
  }
  function color(value) {
    return isPatternOrGradient(value) ? value : new Color(value);
  }
  function getHoverColor(value) {
    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
  }
  var numbers = [
    "x",
    "y",
    "borderWidth",
    "radius",
    "tension"
  ];
  var colors = [
    "color",
    "borderColor",
    "backgroundColor"
  ];
  function applyAnimationsDefaults(defaults2) {
    defaults2.set("animation", {
      delay: void 0,
      duration: 1e3,
      easing: "easeOutQuart",
      fn: void 0,
      from: void 0,
      loop: void 0,
      to: void 0,
      type: void 0
    });
    defaults2.describe("animation", {
      _fallback: false,
      _indexable: false,
      _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
    });
    defaults2.set("animations", {
      colors: {
        type: "color",
        properties: colors
      },
      numbers: {
        type: "number",
        properties: numbers
      }
    });
    defaults2.describe("animations", {
      _fallback: "animation"
    });
    defaults2.set("transitions", {
      active: {
        animation: {
          duration: 400
        }
      },
      resize: {
        animation: {
          duration: 0
        }
      },
      show: {
        animations: {
          colors: {
            from: "transparent"
          },
          visible: {
            type: "boolean",
            duration: 0
          }
        }
      },
      hide: {
        animations: {
          colors: {
            to: "transparent"
          },
          visible: {
            type: "boolean",
            easing: "linear",
            fn: (v) => v | 0
          }
        }
      }
    });
  }
  function applyLayoutsDefaults(defaults2) {
    defaults2.set("layout", {
      autoPadding: true,
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    });
  }
  var intlCache = /* @__PURE__ */ new Map();
  function getNumberFormat(locale, options) {
    options = options || {};
    const cacheKey = locale + JSON.stringify(options);
    let formatter = intlCache.get(cacheKey);
    if (!formatter) {
      formatter = new Intl.NumberFormat(locale, options);
      intlCache.set(cacheKey, formatter);
    }
    return formatter;
  }
  function formatNumber(num, locale, options) {
    return getNumberFormat(locale, options).format(num);
  }
  var formatters = {
    values(value) {
      return isArray(value) ? value : "" + value;
    },
    numeric(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const locale = this.chart.options.locale;
      let notation;
      let delta = tickValue;
      if (ticks.length > 1) {
        const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
        if (maxTick < 1e-4 || maxTick > 1e15) {
          notation = "scientific";
        }
        delta = calculateDelta(tickValue, ticks);
      }
      const logDelta = log10(Math.abs(delta));
      const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
      const options = {
        notation,
        minimumFractionDigits: numDecimal,
        maximumFractionDigits: numDecimal
      };
      Object.assign(options, this.options.ticks.format);
      return formatNumber(tickValue, locale, options);
    },
    logarithmic(tickValue, index2, ticks) {
      if (tickValue === 0) {
        return "0";
      }
      const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
      if ([
        1,
        2,
        3,
        5,
        10,
        15
      ].includes(remain) || index2 > 0.8 * ticks.length) {
        return formatters.numeric.call(this, tickValue, index2, ticks);
      }
      return "";
    }
  };
  function calculateDelta(tickValue, ticks) {
    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
      delta = tickValue - Math.floor(tickValue);
    }
    return delta;
  }
  var Ticks = {
    formatters
  };
  function applyScaleDefaults(defaults2) {
    defaults2.set("scale", {
      display: true,
      offset: false,
      reverse: false,
      beginAtZero: false,
      bounds: "ticks",
      clip: true,
      grace: 0,
      grid: {
        display: true,
        lineWidth: 1,
        drawOnChartArea: true,
        drawTicks: true,
        tickLength: 8,
        tickWidth: (_ctx, options) => options.lineWidth,
        tickColor: (_ctx, options) => options.color,
        offset: false
      },
      border: {
        display: true,
        dash: [],
        dashOffset: 0,
        width: 1
      },
      title: {
        display: false,
        text: "",
        padding: {
          top: 4,
          bottom: 4
        }
      },
      ticks: {
        minRotation: 0,
        maxRotation: 50,
        mirror: false,
        textStrokeWidth: 0,
        textStrokeColor: "",
        padding: 3,
        display: true,
        autoSkip: true,
        autoSkipPadding: 3,
        labelOffset: 0,
        callback: Ticks.formatters.values,
        minor: {},
        major: {},
        align: "center",
        crossAlign: "near",
        showLabelBackdrop: false,
        backdropColor: "rgba(255, 255, 255, 0.75)",
        backdropPadding: 2
      }
    });
    defaults2.route("scale.ticks", "color", "", "color");
    defaults2.route("scale.grid", "color", "", "borderColor");
    defaults2.route("scale.border", "color", "", "borderColor");
    defaults2.route("scale.title", "color", "", "color");
    defaults2.describe("scale", {
      _fallback: false,
      _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
      _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
    });
    defaults2.describe("scales", {
      _fallback: "scale"
    });
    defaults2.describe("scale.ticks", {
      _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
      _indexable: (name) => name !== "backdropPadding"
    });
  }
  var overrides = /* @__PURE__ */ Object.create(null);
  var descriptors = /* @__PURE__ */ Object.create(null);
  function getScope$1(node, key) {
    if (!key) {
      return node;
    }
    const keys = key.split(".");
    for (let i = 0, n = keys.length; i < n; ++i) {
      const k = keys[i];
      node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
    }
    return node;
  }
  function set(root, scope, values) {
    if (typeof scope === "string") {
      return merge(getScope$1(root, scope), values);
    }
    return merge(getScope$1(root, ""), scope);
  }
  var Defaults = class {
    constructor(_descriptors2, _appliers) {
      this.animation = void 0;
      this.backgroundColor = "rgba(0,0,0,0.1)";
      this.borderColor = "rgba(0,0,0,0.1)";
      this.color = "#666";
      this.datasets = {};
      this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
      this.elements = {};
      this.events = [
        "mousemove",
        "mouseout",
        "click",
        "touchstart",
        "touchmove"
      ];
      this.font = {
        family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        size: 12,
        style: "normal",
        lineHeight: 1.2,
        weight: null
      };
      this.hover = {};
      this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
      this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
      this.hoverColor = (ctx, options) => getHoverColor(options.color);
      this.indexAxis = "x";
      this.interaction = {
        mode: "nearest",
        intersect: true,
        includeInvisible: false
      };
      this.maintainAspectRatio = true;
      this.onHover = null;
      this.onClick = null;
      this.parsing = true;
      this.plugins = {};
      this.responsive = true;
      this.scale = void 0;
      this.scales = {};
      this.showLine = true;
      this.drawActiveElementsOnTop = true;
      this.describe(_descriptors2);
      this.apply(_appliers);
    }
    set(scope, values) {
      return set(this, scope, values);
    }
    get(scope) {
      return getScope$1(this, scope);
    }
    describe(scope, values) {
      return set(descriptors, scope, values);
    }
    override(scope, values) {
      return set(overrides, scope, values);
    }
    route(scope, name, targetScope, targetName) {
      const scopeObject = getScope$1(this, scope);
      const targetScopeObject = getScope$1(this, targetScope);
      const privateName = "_" + name;
      Object.defineProperties(scopeObject, {
        [privateName]: {
          value: scopeObject[name],
          writable: true
        },
        [name]: {
          enumerable: true,
          get() {
            const local = this[privateName];
            const target = targetScopeObject[targetName];
            if (isObject2(local)) {
              return Object.assign({}, target, local);
            }
            return valueOrDefault(local, target);
          },
          set(value) {
            this[privateName] = value;
          }
        }
      });
    }
    apply(appliers) {
      appliers.forEach((apply) => apply(this));
    }
  };
  var defaults = /* @__PURE__ */ new Defaults({
    _scriptable: (name) => !name.startsWith("on"),
    _indexable: (name) => name !== "events",
    hover: {
      _fallback: "interaction"
    },
    interaction: {
      _scriptable: false,
      _indexable: false
    }
  }, [
    applyAnimationsDefaults,
    applyLayoutsDefaults,
    applyScaleDefaults
  ]);
  function toFontString(font) {
    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
      return null;
    }
    return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
  }
  function _measureText(ctx, data, gc, longest, string) {
    let textWidth = data[string];
    if (!textWidth) {
      textWidth = data[string] = ctx.measureText(string).width;
      gc.push(string);
    }
    if (textWidth > longest) {
      longest = textWidth;
    }
    return longest;
  }
  function _longestText(ctx, font, arrayOfThings, cache) {
    cache = cache || {};
    let data = cache.data = cache.data || {};
    let gc = cache.garbageCollect = cache.garbageCollect || [];
    if (cache.font !== font) {
      data = cache.data = {};
      gc = cache.garbageCollect = [];
      cache.font = font;
    }
    ctx.save();
    ctx.font = font;
    let longest = 0;
    const ilen = arrayOfThings.length;
    let i, j, jlen, thing, nestedThing;
    for (i = 0; i < ilen; i++) {
      thing = arrayOfThings[i];
      if (thing !== void 0 && thing !== null && !isArray(thing)) {
        longest = _measureText(ctx, data, gc, longest, thing);
      } else if (isArray(thing)) {
        for (j = 0, jlen = thing.length; j < jlen; j++) {
          nestedThing = thing[j];
          if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
            longest = _measureText(ctx, data, gc, longest, nestedThing);
          }
        }
      }
    }
    ctx.restore();
    const gcLen = gc.length / 2;
    if (gcLen > arrayOfThings.length) {
      for (i = 0; i < gcLen; i++) {
        delete data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
    return longest;
  }
  function _alignPixel(chart, pixel, width) {
    const devicePixelRatio = chart.currentDevicePixelRatio;
    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
  }
  function clearCanvas(canvas, ctx) {
    if (!ctx && !canvas) {
      return;
    }
    ctx = ctx || canvas.getContext("2d");
    ctx.save();
    ctx.resetTransform();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  }
  function drawPoint(ctx, options, x, y) {
    drawPointLegend(ctx, options, x, y, null);
  }
  function drawPointLegend(ctx, options, x, y, w) {
    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
    const style = options.pointStyle;
    const rotation = options.rotation;
    const radius = options.radius;
    let rad = (rotation || 0) * RAD_PER_DEG;
    if (style && typeof style === "object") {
      type = style.toString();
      if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rad);
        ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
        ctx.restore();
        return;
      }
    }
    if (isNaN(radius) || radius <= 0) {
      return;
    }
    ctx.beginPath();
    switch (style) {
      default:
        if (w) {
          ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
        } else {
          ctx.arc(x, y, radius, 0, TAU);
        }
        ctx.closePath();
        break;
      case "triangle":
        width = w ? w / 2 : radius;
        ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        rad += TWO_THIRDS_PI;
        ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
        ctx.closePath();
        break;
      case "rectRounded":
        cornerRadius = radius * 0.516;
        size = radius - cornerRadius;
        xOffset = Math.cos(rad + QUARTER_PI) * size;
        xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        yOffset = Math.sin(rad + QUARTER_PI) * size;
        yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
        ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
        ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
        ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
        ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
        ctx.closePath();
        break;
      case "rect":
        if (!rotation) {
          size = Math.SQRT1_2 * radius;
          width = w ? w / 2 : size;
          ctx.rect(x - width, y - size, 2 * width, 2 * size);
          break;
        }
        rad += QUARTER_PI;
      case "rectRot":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        ctx.closePath();
        break;
      case "crossRot":
        rad += QUARTER_PI;
      case "cross":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "star":
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        rad += QUARTER_PI;
        xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
        xOffset = Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
        ctx.moveTo(x - xOffsetW, y - yOffset);
        ctx.lineTo(x + xOffsetW, y + yOffset);
        ctx.moveTo(x + yOffsetW, y - xOffset);
        ctx.lineTo(x - yOffsetW, y + xOffset);
        break;
      case "line":
        xOffset = w ? w / 2 : Math.cos(rad) * radius;
        yOffset = Math.sin(rad) * radius;
        ctx.moveTo(x - xOffset, y - yOffset);
        ctx.lineTo(x + xOffset, y + yOffset);
        break;
      case "dash":
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
        break;
      case false:
        ctx.closePath();
        break;
    }
    ctx.fill();
    if (options.borderWidth > 0) {
      ctx.stroke();
    }
  }
  function _isPointInArea(point, area, margin) {
    margin = margin || 0.5;
    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
  }
  function clipArea(ctx, area) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
    ctx.clip();
  }
  function unclipArea(ctx) {
    ctx.restore();
  }
  function _steppedLineTo(ctx, previous, target, flip, mode) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    if (mode === "middle") {
      const midpoint = (previous.x + target.x) / 2;
      ctx.lineTo(midpoint, previous.y);
      ctx.lineTo(midpoint, target.y);
    } else if (mode === "after" !== !!flip) {
      ctx.lineTo(previous.x, target.y);
    } else {
      ctx.lineTo(target.x, previous.y);
    }
    ctx.lineTo(target.x, target.y);
  }
  function _bezierCurveTo(ctx, previous, target, flip) {
    if (!previous) {
      return ctx.lineTo(target.x, target.y);
    }
    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
  }
  function setRenderOpts(ctx, opts) {
    if (opts.translation) {
      ctx.translate(opts.translation[0], opts.translation[1]);
    }
    if (!isNullOrUndef(opts.rotation)) {
      ctx.rotate(opts.rotation);
    }
    if (opts.color) {
      ctx.fillStyle = opts.color;
    }
    if (opts.textAlign) {
      ctx.textAlign = opts.textAlign;
    }
    if (opts.textBaseline) {
      ctx.textBaseline = opts.textBaseline;
    }
  }
  function decorateText(ctx, x, y, line, opts) {
    if (opts.strikethrough || opts.underline) {
      const metrics = ctx.measureText(line);
      const left = x - metrics.actualBoundingBoxLeft;
      const right = x + metrics.actualBoundingBoxRight;
      const top2 = y - metrics.actualBoundingBoxAscent;
      const bottom2 = y + metrics.actualBoundingBoxDescent;
      const yDecoration = opts.strikethrough ? (top2 + bottom2) / 2 : bottom2;
      ctx.strokeStyle = ctx.fillStyle;
      ctx.beginPath();
      ctx.lineWidth = opts.decorationWidth || 2;
      ctx.moveTo(left, yDecoration);
      ctx.lineTo(right, yDecoration);
      ctx.stroke();
    }
  }
  function drawBackdrop(ctx, opts) {
    const oldColor = ctx.fillStyle;
    ctx.fillStyle = opts.color;
    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
    ctx.fillStyle = oldColor;
  }
  function renderText(ctx, text, x, y, font, opts = {}) {
    const lines = isArray(text) ? text : [
      text
    ];
    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
    let i, line;
    ctx.save();
    ctx.font = font.string;
    setRenderOpts(ctx, opts);
    for (i = 0; i < lines.length; ++i) {
      line = lines[i];
      if (opts.backdrop) {
        drawBackdrop(ctx, opts.backdrop);
      }
      if (stroke) {
        if (opts.strokeColor) {
          ctx.strokeStyle = opts.strokeColor;
        }
        if (!isNullOrUndef(opts.strokeWidth)) {
          ctx.lineWidth = opts.strokeWidth;
        }
        ctx.strokeText(line, x, y, opts.maxWidth);
      }
      ctx.fillText(line, x, y, opts.maxWidth);
      decorateText(ctx, x, y, line, opts);
      y += Number(font.lineHeight);
    }
    ctx.restore();
  }
  function addRoundedRectPath(ctx, rect) {
    const { x, y, w, h, radius } = rect;
    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
    ctx.lineTo(x, y + h - radius.bottomLeft);
    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
    ctx.lineTo(x + w - radius.bottomRight, y + h);
    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
    ctx.lineTo(x + w, y + radius.topRight);
    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
    ctx.lineTo(x + radius.topLeft, y);
  }
  var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
  var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
  function toLineHeight(value, size) {
    const matches = ("" + value).match(LINE_HEIGHT);
    if (!matches || matches[1] === "normal") {
      return size * 1.2;
    }
    value = +matches[2];
    switch (matches[3]) {
      case "px":
        return value;
      case "%":
        value /= 100;
        break;
    }
    return size * value;
  }
  var numberOrZero = (v) => +v || 0;
  function _readValueToProps(value, props) {
    const ret = {};
    const objProps = isObject2(props);
    const keys = objProps ? Object.keys(props) : props;
    const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
    for (const prop of keys) {
      ret[prop] = numberOrZero(read(prop));
    }
    return ret;
  }
  function toTRBL(value) {
    return _readValueToProps(value, {
      top: "y",
      right: "x",
      bottom: "y",
      left: "x"
    });
  }
  function toTRBLCorners(value) {
    return _readValueToProps(value, [
      "topLeft",
      "topRight",
      "bottomLeft",
      "bottomRight"
    ]);
  }
  function toPadding(value) {
    const obj = toTRBL(value);
    obj.width = obj.left + obj.right;
    obj.height = obj.top + obj.bottom;
    return obj;
  }
  function toFont(options, fallback) {
    options = options || {};
    fallback = fallback || defaults.font;
    let size = valueOrDefault(options.size, fallback.size);
    if (typeof size === "string") {
      size = parseInt(size, 10);
    }
    let style = valueOrDefault(options.style, fallback.style);
    if (style && !("" + style).match(FONT_STYLE)) {
      console.warn('Invalid font style specified: "' + style + '"');
      style = void 0;
    }
    const font = {
      family: valueOrDefault(options.family, fallback.family),
      lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
      size,
      style,
      weight: valueOrDefault(options.weight, fallback.weight),
      string: ""
    };
    font.string = toFontString(font);
    return font;
  }
  function resolve(inputs, context, index2, info) {
    let cacheable = true;
    let i, ilen, value;
    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
      value = inputs[i];
      if (value === void 0) {
        continue;
      }
      if (context !== void 0 && typeof value === "function") {
        value = value(context);
        cacheable = false;
      }
      if (index2 !== void 0 && isArray(value)) {
        value = value[index2 % value.length];
        cacheable = false;
      }
      if (value !== void 0) {
        if (info && !cacheable) {
          info.cacheable = false;
        }
        return value;
      }
    }
  }
  function _addGrace(minmax, grace, beginAtZero) {
    const { min, max } = minmax;
    const change = toDimension(grace, (max - min) / 2);
    const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
    return {
      min: keepZero(min, -Math.abs(change)),
      max: keepZero(max, change)
    };
  }
  function createContext(parentContext, context) {
    return Object.assign(Object.create(parentContext), context);
  }
  function _createResolver(scopes, prefixes = [
    ""
  ], rootScopes, fallback, getTarget = () => scopes[0]) {
    const finalRootScopes = rootScopes || scopes;
    if (typeof fallback === "undefined") {
      fallback = _resolve("_fallback", scopes);
    }
    const cache = {
      [Symbol.toStringTag]: "Object",
      _cacheable: true,
      _scopes: scopes,
      _rootScopes: finalRootScopes,
      _fallback: fallback,
      _getTarget: getTarget,
      override: (scope) => _createResolver([
        scope,
        ...scopes
      ], prefixes, finalRootScopes, fallback)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete target._keys;
        delete scopes[0][prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop) {
        return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(scopes[0]);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return getKeysFromAllScopes(target).includes(prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys(target) {
        return getKeysFromAllScopes(target);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        const storage = target._storage || (target._storage = getTarget());
        target[prop] = storage[prop] = value;
        delete target._keys;
        return true;
      }
    });
  }
  function _attachContext(proxy, context, subProxy, descriptorDefaults) {
    const cache = {
      _cacheable: false,
      _proxy: proxy,
      _context: context,
      _subProxy: subProxy,
      _stack: /* @__PURE__ */ new Set(),
      _descriptors: _descriptors(proxy, descriptorDefaults),
      setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
      override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
    };
    return new Proxy(cache, {
      /**
      * A trap for the delete operator.
      */
      deleteProperty(target, prop) {
        delete target[prop];
        delete proxy[prop];
        return true;
      },
      /**
      * A trap for getting property values.
      */
      get(target, prop, receiver) {
        return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
      },
      /**
      * A trap for Object.getOwnPropertyDescriptor.
      * Also used by Object.hasOwnProperty.
      */
      getOwnPropertyDescriptor(target, prop) {
        return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
          enumerable: true,
          configurable: true
        } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
      },
      /**
      * A trap for Object.getPrototypeOf.
      */
      getPrototypeOf() {
        return Reflect.getPrototypeOf(proxy);
      },
      /**
      * A trap for the in operator.
      */
      has(target, prop) {
        return Reflect.has(proxy, prop);
      },
      /**
      * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
      */
      ownKeys() {
        return Reflect.ownKeys(proxy);
      },
      /**
      * A trap for setting property values.
      */
      set(target, prop, value) {
        proxy[prop] = value;
        delete target[prop];
        return true;
      }
    });
  }
  function _descriptors(proxy, defaults2 = {
    scriptable: true,
    indexable: true
  }) {
    const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
    return {
      allKeys: _allKeys,
      scriptable: _scriptable,
      indexable: _indexable,
      isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
      isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
    };
  }
  var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
  var needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
  function _cached(target, prop, resolve2) {
    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
      return target[prop];
    }
    const value = resolve2();
    target[prop] = value;
    return value;
  }
  function _resolveWithContext(target, prop, receiver) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    let value = _proxy[prop];
    if (isFunction(value) && descriptors2.isScriptable(prop)) {
      value = _resolveScriptable(prop, value, target, receiver);
    }
    if (isArray(value) && value.length) {
      value = _resolveArray(prop, value, target, descriptors2.isIndexable);
    }
    if (needsSubResolver(prop, value)) {
      value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
    }
    return value;
  }
  function _resolveScriptable(prop, getValue, target, receiver) {
    const { _proxy, _context, _subProxy, _stack } = target;
    if (_stack.has(prop)) {
      throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
    }
    _stack.add(prop);
    let value = getValue(_context, _subProxy || receiver);
    _stack.delete(prop);
    if (needsSubResolver(prop, value)) {
      value = createSubResolver(_proxy._scopes, _proxy, prop, value);
    }
    return value;
  }
  function _resolveArray(prop, value, target, isIndexable) {
    const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
    if (typeof _context.index !== "undefined" && isIndexable(prop)) {
      return value[_context.index % value.length];
    } else if (isObject2(value[0])) {
      const arr = value;
      const scopes = _proxy._scopes.filter((s) => s !== arr);
      value = [];
      for (const item of arr) {
        const resolver = createSubResolver(scopes, _proxy, prop, item);
        value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
      }
    }
    return value;
  }
  function resolveFallback(fallback, prop, value) {
    return isFunction(fallback) ? fallback(prop, value) : fallback;
  }
  var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
  function addScopes(set2, parentScopes, key, parentFallback, value) {
    for (const parent of parentScopes) {
      const scope = getScope(key, parent);
      if (scope) {
        set2.add(scope);
        const fallback = resolveFallback(scope._fallback, key, value);
        if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
          return fallback;
        }
      } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
        return null;
      }
    }
    return false;
  }
  function createSubResolver(parentScopes, resolver, prop, value) {
    const rootScopes = resolver._rootScopes;
    const fallback = resolveFallback(resolver._fallback, prop, value);
    const allScopes = [
      ...parentScopes,
      ...rootScopes
    ];
    const set2 = /* @__PURE__ */ new Set();
    set2.add(value);
    let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
    if (key === null) {
      return false;
    }
    if (typeof fallback !== "undefined" && fallback !== prop) {
      key = addScopesFromKey(set2, allScopes, fallback, key, value);
      if (key === null) {
        return false;
      }
    }
    return _createResolver(Array.from(set2), [
      ""
    ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
  }
  function addScopesFromKey(set2, allScopes, key, fallback, item) {
    while (key) {
      key = addScopes(set2, allScopes, key, fallback, item);
    }
    return key;
  }
  function subGetTarget(resolver, prop, value) {
    const parent = resolver._getTarget();
    if (!(prop in parent)) {
      parent[prop] = {};
    }
    const target = parent[prop];
    if (isArray(target) && isObject2(value)) {
      return value;
    }
    return target || {};
  }
  function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
    let value;
    for (const prefix of prefixes) {
      value = _resolve(readKey(prefix, prop), scopes);
      if (typeof value !== "undefined") {
        return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
      }
    }
  }
  function _resolve(key, scopes) {
    for (const scope of scopes) {
      if (!scope) {
        continue;
      }
      const value = scope[key];
      if (typeof value !== "undefined") {
        return value;
      }
    }
  }
  function getKeysFromAllScopes(target) {
    let keys = target._keys;
    if (!keys) {
      keys = target._keys = resolveKeysFromAllScopes(target._scopes);
    }
    return keys;
  }
  function resolveKeysFromAllScopes(scopes) {
    const set2 = /* @__PURE__ */ new Set();
    for (const scope of scopes) {
      for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
        set2.add(key);
      }
    }
    return Array.from(set2);
  }
  function _parseObjectDataRadialScale(meta, data, start, count) {
    const { iScale } = meta;
    const { key = "r" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        r: iScale.parse(resolveObjectKey(item, key), index2)
      };
    }
    return parsed;
  }
  var EPSILON = Number.EPSILON || 1e-14;
  var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
  var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
  function splineCurve(firstPoint, middlePoint, afterPoint, t) {
    const previous = firstPoint.skip ? middlePoint : firstPoint;
    const current = middlePoint;
    const next = afterPoint.skip ? middlePoint : afterPoint;
    const d01 = distanceBetweenPoints(current, previous);
    const d12 = distanceBetweenPoints(next, current);
    let s01 = d01 / (d01 + d12);
    let s12 = d12 / (d01 + d12);
    s01 = isNaN(s01) ? 0 : s01;
    s12 = isNaN(s12) ? 0 : s12;
    const fa = t * s01;
    const fb = t * s12;
    return {
      previous: {
        x: current.x - fa * (next.x - previous.x),
        y: current.y - fa * (next.y - previous.y)
      },
      next: {
        x: current.x + fb * (next.x - previous.x),
        y: current.y + fb * (next.y - previous.y)
      }
    };
  }
  function monotoneAdjust(points, deltaK, mK) {
    const pointsLen = points.length;
    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen - 1; ++i) {
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent || !pointAfter) {
        continue;
      }
      if (almostEquals(deltaK[i], 0, EPSILON)) {
        mK[i] = mK[i + 1] = 0;
        continue;
      }
      alphaK = mK[i] / deltaK[i];
      betaK = mK[i + 1] / deltaK[i];
      squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
      if (squaredMagnitude <= 9) {
        continue;
      }
      tauK = 3 / Math.sqrt(squaredMagnitude);
      mK[i] = alphaK * tauK * deltaK[i];
      mK[i + 1] = betaK * tauK * deltaK[i];
    }
  }
  function monotoneCompute(points, mK, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    let delta, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (let i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      const iPixel = pointCurrent[indexAxis];
      const vPixel = pointCurrent[valueAxis];
      if (pointBefore) {
        delta = (iPixel - pointBefore[indexAxis]) / 3;
        pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
        pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
      }
      if (pointAfter) {
        delta = (pointAfter[indexAxis] - iPixel) / 3;
        pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
        pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
      }
    }
  }
  function splineCurveMonotone(points, indexAxis = "x") {
    const valueAxis = getValueAxis(indexAxis);
    const pointsLen = points.length;
    const deltaK = Array(pointsLen).fill(0);
    const mK = Array(pointsLen);
    let i, pointBefore, pointCurrent;
    let pointAfter = getPoint(points, 0);
    for (i = 0; i < pointsLen; ++i) {
      pointBefore = pointCurrent;
      pointCurrent = pointAfter;
      pointAfter = getPoint(points, i + 1);
      if (!pointCurrent) {
        continue;
      }
      if (pointAfter) {
        const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
        deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
      }
      mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
    }
    monotoneAdjust(points, deltaK, mK);
    monotoneCompute(points, mK, indexAxis);
  }
  function capControlPoint(pt, min, max) {
    return Math.max(Math.min(pt, max), min);
  }
  function capBezierPoints(points, area) {
    let i, ilen, point, inArea, inAreaPrev;
    let inAreaNext = _isPointInArea(points[0], area);
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      inAreaPrev = inArea;
      inArea = inAreaNext;
      inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
      if (!inArea) {
        continue;
      }
      point = points[i];
      if (inAreaPrev) {
        point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
        point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
      }
      if (inAreaNext) {
        point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
        point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
      }
    }
  }
  function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
    let i, ilen, point, controlPoints;
    if (options.spanGaps) {
      points = points.filter((pt) => !pt.skip);
    }
    if (options.cubicInterpolationMode === "monotone") {
      splineCurveMonotone(points, indexAxis);
    } else {
      let prev = loop ? points[points.length - 1] : points[0];
      for (i = 0, ilen = points.length; i < ilen; ++i) {
        point = points[i];
        controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
        point.cp1x = controlPoints.previous.x;
        point.cp1y = controlPoints.previous.y;
        point.cp2x = controlPoints.next.x;
        point.cp2y = controlPoints.next.y;
        prev = point;
      }
    }
    if (options.capBezierPoints) {
      capBezierPoints(points, area);
    }
  }
  function _isDomSupported() {
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function _getParentNode(domNode) {
    let parent = domNode.parentNode;
    if (parent && parent.toString() === "[object ShadowRoot]") {
      parent = parent.host;
    }
    return parent;
  }
  function parseMaxStyle(styleValue, node, parentProperty) {
    let valueInPixels;
    if (typeof styleValue === "string") {
      valueInPixels = parseInt(styleValue, 10);
      if (styleValue.indexOf("%") !== -1) {
        valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
      }
    } else {
      valueInPixels = styleValue;
    }
    return valueInPixels;
  }
  var getComputedStyle2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
  function getStyle(el, property) {
    return getComputedStyle2(el).getPropertyValue(property);
  }
  var positions = [
    "top",
    "right",
    "bottom",
    "left"
  ];
  function getPositionedStyle(styles, style, suffix) {
    const result = {};
    suffix = suffix ? "-" + suffix : "";
    for (let i = 0; i < 4; i++) {
      const pos = positions[i];
      result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
    }
    result.width = result.left + result.right;
    result.height = result.top + result.bottom;
    return result;
  }
  var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
  function getCanvasPosition(e, canvas) {
    const touches = e.touches;
    const source = touches && touches.length ? touches[0] : e;
    const { offsetX, offsetY } = source;
    let box = false;
    let x, y;
    if (useOffsetPos(offsetX, offsetY, e.target)) {
      x = offsetX;
      y = offsetY;
    } else {
      const rect = canvas.getBoundingClientRect();
      x = source.clientX - rect.left;
      y = source.clientY - rect.top;
      box = true;
    }
    return {
      x,
      y,
      box
    };
  }
  function getRelativePosition(event, chart) {
    if ("native" in event) {
      return event;
    }
    const { canvas, currentDevicePixelRatio } = chart;
    const style = getComputedStyle2(canvas);
    const borderBox = style.boxSizing === "border-box";
    const paddings = getPositionedStyle(style, "padding");
    const borders = getPositionedStyle(style, "border", "width");
    const { x, y, box } = getCanvasPosition(event, canvas);
    const xOffset = paddings.left + (box && borders.left);
    const yOffset = paddings.top + (box && borders.top);
    let { width, height } = chart;
    if (borderBox) {
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    return {
      x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
      y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
    };
  }
  function getContainerSize(canvas, width, height) {
    let maxWidth, maxHeight;
    if (width === void 0 || height === void 0) {
      const container = canvas && _getParentNode(canvas);
      if (!container) {
        width = canvas.clientWidth;
        height = canvas.clientHeight;
      } else {
        const rect = container.getBoundingClientRect();
        const containerStyle = getComputedStyle2(container);
        const containerBorder = getPositionedStyle(containerStyle, "border", "width");
        const containerPadding = getPositionedStyle(containerStyle, "padding");
        width = rect.width - containerPadding.width - containerBorder.width;
        height = rect.height - containerPadding.height - containerBorder.height;
        maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
        maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
      }
    }
    return {
      width,
      height,
      maxWidth: maxWidth || INFINITY,
      maxHeight: maxHeight || INFINITY
    };
  }
  var round1 = (v) => Math.round(v * 10) / 10;
  function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
    const style = getComputedStyle2(canvas);
    const margins = getPositionedStyle(style, "margin");
    const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
    const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
    let { width, height } = containerSize;
    if (style.boxSizing === "content-box") {
      const borders = getPositionedStyle(style, "border", "width");
      const paddings = getPositionedStyle(style, "padding");
      width -= paddings.width + borders.width;
      height -= paddings.height + borders.height;
    }
    width = Math.max(0, width - margins.width);
    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
    if (width && !height) {
      height = round1(width / 2);
    }
    const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
      height = containerSize.height;
      width = round1(Math.floor(height * aspectRatio));
    }
    return {
      width,
      height
    };
  }
  function retinaScale(chart, forceRatio, forceStyle) {
    const pixelRatio = forceRatio || 1;
    const deviceHeight = Math.floor(chart.height * pixelRatio);
    const deviceWidth = Math.floor(chart.width * pixelRatio);
    chart.height = Math.floor(chart.height);
    chart.width = Math.floor(chart.width);
    const canvas = chart.canvas;
    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
      canvas.style.height = `${chart.height}px`;
      canvas.style.width = `${chart.width}px`;
    }
    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
      chart.currentDevicePixelRatio = pixelRatio;
      canvas.height = deviceHeight;
      canvas.width = deviceWidth;
      chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
      return true;
    }
    return false;
  }
  var supportsEventListenerOptions = function() {
    let passiveSupported = false;
    try {
      const options = {
        get passive() {
          passiveSupported = true;
          return false;
        }
      };
      if (_isDomSupported()) {
        window.addEventListener("test", null, options);
        window.removeEventListener("test", null, options);
      }
    } catch (e) {
    }
    return passiveSupported;
  }();
  function readUsedSize(element, property) {
    const value = getStyle(element, property);
    const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? +matches[1] : void 0;
  }
  function _pointInLine(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: p1.y + t * (p2.y - p1.y)
    };
  }
  function _steppedInterpolation(p1, p2, t, mode) {
    return {
      x: p1.x + t * (p2.x - p1.x),
      y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
    };
  }
  function _bezierInterpolation(p1, p2, t, mode) {
    const cp1 = {
      x: p1.cp2x,
      y: p1.cp2y
    };
    const cp2 = {
      x: p2.cp1x,
      y: p2.cp1y
    };
    const a = _pointInLine(p1, cp1, t);
    const b = _pointInLine(cp1, cp2, t);
    const c = _pointInLine(cp2, p2, t);
    const d = _pointInLine(a, b, t);
    const e = _pointInLine(b, c, t);
    return _pointInLine(d, e, t);
  }
  var getRightToLeftAdapter = function(rectX, width) {
    return {
      x(x) {
        return rectX + rectX + width - x;
      },
      setWidth(w) {
        width = w;
      },
      textAlign(align) {
        if (align === "center") {
          return align;
        }
        return align === "right" ? "left" : "right";
      },
      xPlus(x, value) {
        return x - value;
      },
      leftForLtr(x, itemWidth) {
        return x - itemWidth;
      }
    };
  };
  var getLeftToRightAdapter = function() {
    return {
      x(x) {
        return x;
      },
      setWidth(w) {
      },
      textAlign(align) {
        return align;
      },
      xPlus(x, value) {
        return x + value;
      },
      leftForLtr(x, _itemWidth) {
        return x;
      }
    };
  };
  function getRtlAdapter(rtl, rectX, width) {
    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
  }
  function overrideTextDirection(ctx, direction) {
    let style, original;
    if (direction === "ltr" || direction === "rtl") {
      style = ctx.canvas.style;
      original = [
        style.getPropertyValue("direction"),
        style.getPropertyPriority("direction")
      ];
      style.setProperty("direction", direction, "important");
      ctx.prevTextDirection = original;
    }
  }
  function restoreTextDirection(ctx, original) {
    if (original !== void 0) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty("direction", original[0], original[1]);
    }
  }
  function propertyFn(property) {
    if (property === "angle") {
      return {
        between: _angleBetween,
        compare: _angleDiff,
        normalize: _normalizeAngle
      };
    }
    return {
      between: _isBetween,
      compare: (a, b) => a - b,
      normalize: (x) => x
    };
  }
  function normalizeSegment({ start, end, count, loop, style }) {
    return {
      start: start % count,
      end: end % count,
      loop: loop && (end - start + 1) % count === 0,
      style
    };
  }
  function getSegment(segment, points, bounds) {
    const { property, start: startBound, end: endBound } = bounds;
    const { between, normalize } = propertyFn(property);
    const count = points.length;
    let { start, end, loop } = segment;
    let i, ilen;
    if (loop) {
      start += count;
      end += count;
      for (i = 0, ilen = count; i < ilen; ++i) {
        if (!between(normalize(points[start % count][property]), startBound, endBound)) {
          break;
        }
        start--;
        end--;
      }
      start %= count;
      end %= count;
    }
    if (end < start) {
      end += count;
    }
    return {
      start,
      end,
      loop,
      style: segment.style
    };
  }
  function _boundSegment(segment, points, bounds) {
    if (!bounds) {
      return [
        segment
      ];
    }
    const { property, start: startBound, end: endBound } = bounds;
    const count = points.length;
    const { compare, between, normalize } = propertyFn(property);
    const { start, end, loop, style } = getSegment(segment, points, bounds);
    const result = [];
    let inside = false;
    let subStart = null;
    let value, point, prevValue;
    const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
    const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
    const shouldStart = () => inside || startIsBefore();
    const shouldStop = () => !inside || endIsBefore();
    for (let i = start, prev = start; i <= end; ++i) {
      point = points[i % count];
      if (point.skip) {
        continue;
      }
      value = normalize(point[property]);
      if (value === prevValue) {
        continue;
      }
      inside = between(value, startBound, endBound);
      if (subStart === null && shouldStart()) {
        subStart = compare(value, startBound) === 0 ? i : prev;
      }
      if (subStart !== null && shouldStop()) {
        result.push(normalizeSegment({
          start: subStart,
          end: i,
          loop,
          count,
          style
        }));
        subStart = null;
      }
      prev = i;
      prevValue = value;
    }
    if (subStart !== null) {
      result.push(normalizeSegment({
        start: subStart,
        end,
        loop,
        count,
        style
      }));
    }
    return result;
  }
  function _boundSegments(line, bounds) {
    const result = [];
    const segments = line.segments;
    for (let i = 0; i < segments.length; i++) {
      const sub = _boundSegment(segments[i], line.points, bounds);
      if (sub.length) {
        result.push(...sub);
      }
    }
    return result;
  }
  function findStartAndEnd(points, count, loop, spanGaps) {
    let start = 0;
    let end = count - 1;
    if (loop && !spanGaps) {
      while (start < count && !points[start].skip) {
        start++;
      }
    }
    while (start < count && points[start].skip) {
      start++;
    }
    start %= count;
    if (loop) {
      end += start;
    }
    while (end > start && points[end % count].skip) {
      end--;
    }
    end %= count;
    return {
      start,
      end
    };
  }
  function solidSegments(points, start, max, loop) {
    const count = points.length;
    const result = [];
    let last = start;
    let prev = points[start];
    let end;
    for (end = start + 1; end <= max; ++end) {
      const cur = points[end % count];
      if (cur.skip || cur.stop) {
        if (!prev.skip) {
          loop = false;
          result.push({
            start: start % count,
            end: (end - 1) % count,
            loop
          });
          start = last = cur.stop ? end : null;
        }
      } else {
        last = end;
        if (prev.skip) {
          start = end;
        }
      }
      prev = cur;
    }
    if (last !== null) {
      result.push({
        start: start % count,
        end: last % count,
        loop
      });
    }
    return result;
  }
  function _computeSegments(line, segmentOptions) {
    const points = line.points;
    const spanGaps = line.options.spanGaps;
    const count = points.length;
    if (!count) {
      return [];
    }
    const loop = !!line._loop;
    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
    if (spanGaps === true) {
      return splitByStyles(line, [
        {
          start,
          end,
          loop
        }
      ], points, segmentOptions);
    }
    const max = end < start ? end + count : end;
    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
  }
  function splitByStyles(line, segments, points, segmentOptions) {
    if (!segmentOptions || !segmentOptions.setContext || !points) {
      return segments;
    }
    return doSplitByStyles(line, segments, points, segmentOptions);
  }
  function doSplitByStyles(line, segments, points, segmentOptions) {
    const chartContext = line._chart.getContext();
    const baseStyle = readStyle(line.options);
    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
    const count = points.length;
    const result = [];
    let prevStyle = baseStyle;
    let start = segments[0].start;
    let i = start;
    function addStyle(s, e, l, st) {
      const dir = spanGaps ? -1 : 1;
      if (s === e) {
        return;
      }
      s += count;
      while (points[s % count].skip) {
        s -= dir;
      }
      while (points[e % count].skip) {
        e += dir;
      }
      if (s % count !== e % count) {
        result.push({
          start: s % count,
          end: e % count,
          loop: l,
          style: st
        });
        prevStyle = st;
        start = e % count;
      }
    }
    for (const segment of segments) {
      start = spanGaps ? start : segment.start;
      let prev = points[start % count];
      let style;
      for (i = start + 1; i <= segment.end; i++) {
        const pt = points[i % count];
        style = readStyle(segmentOptions.setContext(createContext(chartContext, {
          type: "segment",
          p0: prev,
          p1: pt,
          p0DataIndex: (i - 1) % count,
          p1DataIndex: i % count,
          datasetIndex
        })));
        if (styleChanged(style, prevStyle)) {
          addStyle(start, i - 1, segment.loop, prevStyle);
        }
        prev = pt;
        prevStyle = style;
      }
      if (start < i - 1) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
    }
    return result;
  }
  function readStyle(options) {
    return {
      backgroundColor: options.backgroundColor,
      borderCapStyle: options.borderCapStyle,
      borderDash: options.borderDash,
      borderDashOffset: options.borderDashOffset,
      borderJoinStyle: options.borderJoinStyle,
      borderWidth: options.borderWidth,
      borderColor: options.borderColor
    };
  }
  function styleChanged(style, prevStyle) {
    if (!prevStyle) {
      return false;
    }
    const cache = [];
    const replacer = function(key, value) {
      if (!isPatternOrGradient(value)) {
        return value;
      }
      if (!cache.includes(value)) {
        cache.push(value);
      }
      return cache.indexOf(value);
    };
    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
  }

  // node_modules/chart.js/dist/chart.js
  var Animator = class {
    constructor() {
      this._request = null;
      this._charts = /* @__PURE__ */ new Map();
      this._running = false;
      this._lastDate = void 0;
    }
    _notify(chart, anims, date, type) {
      const callbacks = anims.listeners[type];
      const numSteps = anims.duration;
      callbacks.forEach((fn) => fn({
        chart,
        initial: anims.initial,
        numSteps,
        currentStep: Math.min(date - anims.start, numSteps)
      }));
    }
    _refresh() {
      if (this._request) {
        return;
      }
      this._running = true;
      this._request = requestAnimFrame.call(window, () => {
        this._update();
        this._request = null;
        if (this._running) {
          this._refresh();
        }
      });
    }
    _update(date = Date.now()) {
      let remaining = 0;
      this._charts.forEach((anims, chart) => {
        if (!anims.running || !anims.items.length) {
          return;
        }
        const items = anims.items;
        let i = items.length - 1;
        let draw2 = false;
        let item;
        for (; i >= 0; --i) {
          item = items[i];
          if (item._active) {
            if (item._total > anims.duration) {
              anims.duration = item._total;
            }
            item.tick(date);
            draw2 = true;
          } else {
            items[i] = items[items.length - 1];
            items.pop();
          }
        }
        if (draw2) {
          chart.draw();
          this._notify(chart, anims, date, "progress");
        }
        if (!items.length) {
          anims.running = false;
          this._notify(chart, anims, date, "complete");
          anims.initial = false;
        }
        remaining += items.length;
      });
      this._lastDate = date;
      if (remaining === 0) {
        this._running = false;
      }
    }
    _getAnims(chart) {
      const charts = this._charts;
      let anims = charts.get(chart);
      if (!anims) {
        anims = {
          running: false,
          initial: true,
          items: [],
          listeners: {
            complete: [],
            progress: []
          }
        };
        charts.set(chart, anims);
      }
      return anims;
    }
    listen(chart, event, cb) {
      this._getAnims(chart).listeners[event].push(cb);
    }
    add(chart, items) {
      if (!items || !items.length) {
        return;
      }
      this._getAnims(chart).items.push(...items);
    }
    has(chart) {
      return this._getAnims(chart).items.length > 0;
    }
    start(chart) {
      const anims = this._charts.get(chart);
      if (!anims) {
        return;
      }
      anims.running = true;
      anims.start = Date.now();
      anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
      this._refresh();
    }
    running(chart) {
      if (!this._running) {
        return false;
      }
      const anims = this._charts.get(chart);
      if (!anims || !anims.running || !anims.items.length) {
        return false;
      }
      return true;
    }
    stop(chart) {
      const anims = this._charts.get(chart);
      if (!anims || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      for (; i >= 0; --i) {
        items[i].cancel();
      }
      anims.items = [];
      this._notify(chart, anims, Date.now(), "complete");
    }
    remove(chart) {
      return this._charts.delete(chart);
    }
  };
  var animator = /* @__PURE__ */ new Animator();
  var transparent = "transparent";
  var interpolators = {
    boolean(from2, to2, factor) {
      return factor > 0.5 ? to2 : from2;
    },
    color(from2, to2, factor) {
      const c0 = color(from2 || transparent);
      const c1 = c0.valid && color(to2 || transparent);
      return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
    },
    number(from2, to2, factor) {
      return from2 + (to2 - from2) * factor;
    }
  };
  var Animation = class {
    constructor(cfg, target, prop, to2) {
      const currentValue = target[prop];
      to2 = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      const from2 = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
      this._active = true;
      this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
      this._easing = effects[cfg.easing] || effects.linear;
      this._start = Math.floor(Date.now() + (cfg.delay || 0));
      this._duration = this._total = Math.floor(cfg.duration);
      this._loop = !!cfg.loop;
      this._target = target;
      this._prop = prop;
      this._from = from2;
      this._to = to2;
      this._promises = void 0;
    }
    active() {
      return this._active;
    }
    update(cfg, to2, date) {
      if (this._active) {
        this._notify(false);
        const currentValue = this._target[this._prop];
        const elapsed = date - this._start;
        const remain = this._duration - elapsed;
        this._start = date;
        this._duration = Math.floor(Math.max(remain, cfg.duration));
        this._total += elapsed;
        this._loop = !!cfg.loop;
        this._to = resolve([
          cfg.to,
          to2,
          currentValue,
          cfg.from
        ]);
        this._from = resolve([
          cfg.from,
          currentValue,
          to2
        ]);
      }
    }
    cancel() {
      if (this._active) {
        this.tick(Date.now());
        this._active = false;
        this._notify(false);
      }
    }
    tick(date) {
      const elapsed = date - this._start;
      const duration = this._duration;
      const prop = this._prop;
      const from2 = this._from;
      const loop = this._loop;
      const to2 = this._to;
      let factor;
      this._active = from2 !== to2 && (loop || elapsed < duration);
      if (!this._active) {
        this._target[prop] = to2;
        this._notify(true);
        return;
      }
      if (elapsed < 0) {
        this._target[prop] = from2;
        return;
      }
      factor = elapsed / duration % 2;
      factor = loop && factor > 1 ? 2 - factor : factor;
      factor = this._easing(Math.min(1, Math.max(0, factor)));
      this._target[prop] = this._fn(from2, to2, factor);
    }
    wait() {
      const promises = this._promises || (this._promises = []);
      return new Promise((res, rej) => {
        promises.push({
          res,
          rej
        });
      });
    }
    _notify(resolved) {
      const method = resolved ? "res" : "rej";
      const promises = this._promises || [];
      for (let i = 0; i < promises.length; i++) {
        promises[i][method]();
      }
    }
  };
  var Animations = class {
    constructor(chart, config) {
      this._chart = chart;
      this._properties = /* @__PURE__ */ new Map();
      this.configure(config);
    }
    configure(config) {
      if (!isObject2(config)) {
        return;
      }
      const animationOptions = Object.keys(defaults.animation);
      const animatedProps = this._properties;
      Object.getOwnPropertyNames(config).forEach((key) => {
        const cfg = config[key];
        if (!isObject2(cfg)) {
          return;
        }
        const resolved = {};
        for (const option of animationOptions) {
          resolved[option] = cfg[option];
        }
        (isArray(cfg.properties) && cfg.properties || [
          key
        ]).forEach((prop) => {
          if (prop === key || !animatedProps.has(prop)) {
            animatedProps.set(prop, resolved);
          }
        });
      });
    }
    _animateOptions(target, values) {
      const newOptions = values.options;
      const options = resolveTargetOptions(target, newOptions);
      if (!options) {
        return [];
      }
      const animations = this._createAnimations(options, newOptions);
      if (newOptions.$shared) {
        awaitAll(target.options.$animations, newOptions).then(() => {
          target.options = newOptions;
        }, () => {
        });
      }
      return animations;
    }
    _createAnimations(target, values) {
      const animatedProps = this._properties;
      const animations = [];
      const running = target.$animations || (target.$animations = {});
      const props = Object.keys(values);
      const date = Date.now();
      let i;
      for (i = props.length - 1; i >= 0; --i) {
        const prop = props[i];
        if (prop.charAt(0) === "$") {
          continue;
        }
        if (prop === "options") {
          animations.push(...this._animateOptions(target, values));
          continue;
        }
        const value = values[prop];
        let animation = running[prop];
        const cfg = animatedProps.get(prop);
        if (animation) {
          if (cfg && animation.active()) {
            animation.update(cfg, value, date);
            continue;
          } else {
            animation.cancel();
          }
        }
        if (!cfg || !cfg.duration) {
          target[prop] = value;
          continue;
        }
        running[prop] = animation = new Animation(cfg, target, prop, value);
        animations.push(animation);
      }
      return animations;
    }
    update(target, values) {
      if (this._properties.size === 0) {
        Object.assign(target, values);
        return;
      }
      const animations = this._createAnimations(target, values);
      if (animations.length) {
        animator.add(this._chart, animations);
        return true;
      }
    }
  };
  function awaitAll(animations, properties) {
    const running = [];
    const keys = Object.keys(properties);
    for (let i = 0; i < keys.length; i++) {
      const anim = animations[keys[i]];
      if (anim && anim.active()) {
        running.push(anim.wait());
      }
    }
    return Promise.all(running);
  }
  function resolveTargetOptions(target, newOptions) {
    if (!newOptions) {
      return;
    }
    let options = target.options;
    if (!options) {
      target.options = newOptions;
      return;
    }
    if (options.$shared) {
      target.options = options = Object.assign({}, options, {
        $shared: false,
        $animations: {}
      });
    }
    return options;
  }
  function scaleClip(scale, allowedOverflow) {
    const opts = scale && scale.options || {};
    const reverse = opts.reverse;
    const min = opts.min === void 0 ? allowedOverflow : 0;
    const max = opts.max === void 0 ? allowedOverflow : 0;
    return {
      start: reverse ? max : min,
      end: reverse ? min : max
    };
  }
  function defaultClip(xScale, yScale, allowedOverflow) {
    if (allowedOverflow === false) {
      return false;
    }
    const x = scaleClip(xScale, allowedOverflow);
    const y = scaleClip(yScale, allowedOverflow);
    return {
      top: y.end,
      right: x.end,
      bottom: y.start,
      left: x.start
    };
  }
  function toClip(value) {
    let t, r, b, l;
    if (isObject2(value)) {
      t = value.top;
      r = value.right;
      b = value.bottom;
      l = value.left;
    } else {
      t = r = b = l = value;
    }
    return {
      top: t,
      right: r,
      bottom: b,
      left: l,
      disabled: value === false
    };
  }
  function getSortedDatasetIndices(chart, filterVisible) {
    const keys = [];
    const metasets = chart._getSortedDatasetMetas(filterVisible);
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      keys.push(metasets[i].index);
    }
    return keys;
  }
  function applyStack(stack, value, dsIndex, options = {}) {
    const keys = stack.keys;
    const singleMode = options.mode === "single";
    let i, ilen, datasetIndex, otherValue;
    if (value === null) {
      return;
    }
    let found = false;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      datasetIndex = +keys[i];
      if (datasetIndex === dsIndex) {
        found = true;
        if (options.all) {
          continue;
        }
        break;
      }
      otherValue = stack.values[datasetIndex];
      if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
        value += otherValue;
      }
    }
    if (!found && !options.all) {
      return 0;
    }
    return value;
  }
  function convertObjectDataToArray(data, meta) {
    const { iScale, vScale } = meta;
    const iAxisKey = iScale.axis === "x" ? "x" : "y";
    const vAxisKey = vScale.axis === "x" ? "x" : "y";
    const keys = Object.keys(data);
    const adata = new Array(keys.length);
    let i, ilen, key;
    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      key = keys[i];
      adata[i] = {
        [iAxisKey]: key,
        [vAxisKey]: data[key]
      };
    }
    return adata;
  }
  function isStacked(scale, meta) {
    const stacked = scale && scale.options.stacked;
    return stacked || stacked === void 0 && meta.stack !== void 0;
  }
  function getStackKey(indexScale, valueScale, meta) {
    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
  }
  function getUserBounds(scale) {
    const { min, max, minDefined, maxDefined } = scale.getUserBounds();
    return {
      min: minDefined ? min : Number.NEGATIVE_INFINITY,
      max: maxDefined ? max : Number.POSITIVE_INFINITY
    };
  }
  function getOrCreateStack(stacks, stackKey, indexValue) {
    const subStack = stacks[stackKey] || (stacks[stackKey] = {});
    return subStack[indexValue] || (subStack[indexValue] = {});
  }
  function getLastIndexInStack(stack, vScale, positive, type) {
    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
      const value = stack[meta.index];
      if (positive && value > 0 || !positive && value < 0) {
        return meta.index;
      }
    }
    return null;
  }
  function updateStacks(controller, parsed) {
    const { chart, _cachedMeta: meta } = controller;
    const stacks = chart._stacks || (chart._stacks = {});
    const { iScale, vScale, index: datasetIndex } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const key = getStackKey(iScale, vScale, meta);
    const ilen = parsed.length;
    let stack;
    for (let i = 0; i < ilen; ++i) {
      const item = parsed[i];
      const { [iAxis]: index2, [vAxis]: value } = item;
      const itemStacks = item._stacks || (item._stacks = {});
      stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
      stack[datasetIndex] = value;
      stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
      stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
      const visualValues = stack._visualValues || (stack._visualValues = {});
      visualValues[datasetIndex] = value;
    }
  }
  function getFirstScaleId(chart, axis) {
    const scales2 = chart.scales;
    return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
  }
  function createDatasetContext(parent, index2) {
    return createContext(parent, {
      active: false,
      dataset: void 0,
      datasetIndex: index2,
      index: index2,
      mode: "default",
      type: "dataset"
    });
  }
  function createDataContext(parent, index2, element) {
    return createContext(parent, {
      active: false,
      dataIndex: index2,
      parsed: void 0,
      raw: void 0,
      element,
      index: index2,
      mode: "default",
      type: "data"
    });
  }
  function clearStacks(meta, items) {
    const datasetIndex = meta.controller.index;
    const axis = meta.vScale && meta.vScale.axis;
    if (!axis) {
      return;
    }
    items = items || meta._parsed;
    for (const parsed of items) {
      const stacks = parsed._stacks;
      if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
        return;
      }
      delete stacks[axis][datasetIndex];
      if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
        delete stacks[axis]._visualValues[datasetIndex];
      }
    }
  }
  var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
  var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
  var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
    keys: getSortedDatasetIndices(chart, true),
    values: null
  };
  var DatasetController = class {
    constructor(chart, datasetIndex) {
      this.chart = chart;
      this._ctx = chart.ctx;
      this.index = datasetIndex;
      this._cachedDataOpts = {};
      this._cachedMeta = this.getMeta();
      this._type = this._cachedMeta.type;
      this.options = void 0;
      this._parsing = false;
      this._data = void 0;
      this._objectData = void 0;
      this._sharedOptions = void 0;
      this._drawStart = void 0;
      this._drawCount = void 0;
      this.enableOptionSharing = false;
      this.supportsDecimation = false;
      this.$context = void 0;
      this._syncList = [];
      this.datasetElementType = new.target.datasetElementType;
      this.dataElementType = new.target.dataElementType;
      this.initialize();
    }
    initialize() {
      const meta = this._cachedMeta;
      this.configure();
      this.linkScales();
      meta._stacked = isStacked(meta.vScale, meta);
      this.addElements();
      if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
        console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
      }
    }
    updateIndex(datasetIndex) {
      if (this.index !== datasetIndex) {
        clearStacks(this._cachedMeta);
      }
      this.index = datasetIndex;
    }
    linkScales() {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
      const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
      const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
      const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
      const indexAxis = meta.indexAxis;
      const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
      const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
      meta.xScale = this.getScaleForId(xid);
      meta.yScale = this.getScaleForId(yid);
      meta.rScale = this.getScaleForId(rid);
      meta.iScale = this.getScaleForId(iid);
      meta.vScale = this.getScaleForId(vid);
    }
    getDataset() {
      return this.chart.data.datasets[this.index];
    }
    getMeta() {
      return this.chart.getDatasetMeta(this.index);
    }
    getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    }
    _getOtherScale(scale) {
      const meta = this._cachedMeta;
      return scale === meta.iScale ? meta.vScale : meta.iScale;
    }
    reset() {
      this._update("reset");
    }
    _destroy() {
      const meta = this._cachedMeta;
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
      if (meta._stacked) {
        clearStacks(meta);
      }
    }
    _dataCheck() {
      const dataset = this.getDataset();
      const data = dataset.data || (dataset.data = []);
      const _data = this._data;
      if (isObject2(data)) {
        const meta = this._cachedMeta;
        this._data = convertObjectDataToArray(data, meta);
      } else if (_data !== data) {
        if (_data) {
          unlistenArrayEvents(_data, this);
          const meta = this._cachedMeta;
          clearStacks(meta);
          meta._parsed = [];
        }
        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, this);
        }
        this._syncList = [];
        this._data = data;
      }
    }
    addElements() {
      const meta = this._cachedMeta;
      this._dataCheck();
      if (this.datasetElementType) {
        meta.dataset = new this.datasetElementType();
      }
    }
    buildOrUpdateElements(resetNewElements) {
      const meta = this._cachedMeta;
      const dataset = this.getDataset();
      let stackChanged = false;
      this._dataCheck();
      const oldStacked = meta._stacked;
      meta._stacked = isStacked(meta.vScale, meta);
      if (meta.stack !== dataset.stack) {
        stackChanged = true;
        clearStacks(meta);
        meta.stack = dataset.stack;
      }
      this._resyncElements(resetNewElements);
      if (stackChanged || oldStacked !== meta._stacked) {
        updateStacks(this, meta._parsed);
        meta._stacked = isStacked(meta.vScale, meta);
      }
    }
    configure() {
      const config = this.chart.config;
      const scopeKeys = config.datasetScopeKeys(this._type);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
      this.options = config.createResolver(scopes, this.getContext());
      this._parsing = this.options.parsing;
      this._cachedDataOpts = {};
    }
    parse(start, count) {
      const { _cachedMeta: meta, _data: data } = this;
      const { iScale, _stacked } = meta;
      const iAxis = iScale.axis;
      let sorted = start === 0 && count === data.length ? true : meta._sorted;
      let prev = start > 0 && meta._parsed[start - 1];
      let i, cur, parsed;
      if (this._parsing === false) {
        meta._parsed = data;
        meta._sorted = true;
        parsed = data;
      } else {
        if (isArray(data[start])) {
          parsed = this.parseArrayData(meta, data, start, count);
        } else if (isObject2(data[start])) {
          parsed = this.parseObjectData(meta, data, start, count);
        } else {
          parsed = this.parsePrimitiveData(meta, data, start, count);
        }
        const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
        for (i = 0; i < count; ++i) {
          meta._parsed[i + start] = cur = parsed[i];
          if (sorted) {
            if (isNotInOrderComparedToPrev()) {
              sorted = false;
            }
            prev = cur;
          }
        }
        meta._sorted = sorted;
      }
      if (_stacked) {
        updateStacks(this, parsed);
      }
    }
    parsePrimitiveData(meta, data, start, count) {
      const { iScale, vScale } = meta;
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const labels = iScale.getLabels();
      const singleScale = iScale === vScale;
      const parsed = new Array(count);
      let i, ilen, index2;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index2 = i + start;
        parsed[i] = {
          [iAxis]: singleScale || iScale.parse(labels[index2], index2),
          [vAxis]: vScale.parse(data[index2], index2)
        };
      }
      return parsed;
    }
    parseArrayData(meta, data, start, count) {
      const { xScale, yScale } = meta;
      const parsed = new Array(count);
      let i, ilen, index2, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index2 = i + start;
        item = data[index2];
        parsed[i] = {
          x: xScale.parse(item[0], index2),
          y: yScale.parse(item[1], index2)
        };
      }
      return parsed;
    }
    parseObjectData(meta, data, start, count) {
      const { xScale, yScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const parsed = new Array(count);
      let i, ilen, index2, item;
      for (i = 0, ilen = count; i < ilen; ++i) {
        index2 = i + start;
        item = data[index2];
        parsed[i] = {
          x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
          y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
        };
      }
      return parsed;
    }
    getParsed(index2) {
      return this._cachedMeta._parsed[index2];
    }
    getDataElement(index2) {
      return this._cachedMeta.data[index2];
    }
    applyStack(scale, parsed, mode) {
      const chart = this.chart;
      const meta = this._cachedMeta;
      const value = parsed[scale.axis];
      const stack = {
        keys: getSortedDatasetIndices(chart, true),
        values: parsed._stacks[scale.axis]._visualValues
      };
      return applyStack(stack, value, meta.index, {
        mode
      });
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      const parsedValue = parsed[scale.axis];
      let value = parsedValue === null ? NaN : parsedValue;
      const values = stack && parsed._stacks[scale.axis];
      if (stack && values) {
        stack.values = values;
        value = applyStack(stack, parsedValue, this._cachedMeta.index);
      }
      range2.min = Math.min(range2.min, value);
      range2.max = Math.max(range2.max, value);
    }
    getMinMax(scale, canStack) {
      const meta = this._cachedMeta;
      const _parsed = meta._parsed;
      const sorted = meta._sorted && scale === meta.iScale;
      const ilen = _parsed.length;
      const otherScale = this._getOtherScale(scale);
      const stack = createStack(canStack, meta, this.chart);
      const range2 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
      let i, parsed;
      function _skip() {
        parsed = _parsed[i];
        const otherValue = parsed[otherScale.axis];
        return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
      }
      for (i = 0; i < ilen; ++i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range2, scale, parsed, stack);
        if (sorted) {
          break;
        }
      }
      if (sorted) {
        for (i = ilen - 1; i >= 0; --i) {
          if (_skip()) {
            continue;
          }
          this.updateRangeFromParsed(range2, scale, parsed, stack);
          break;
        }
      }
      return range2;
    }
    getAllParsedValues(scale) {
      const parsed = this._cachedMeta._parsed;
      const values = [];
      let i, ilen, value;
      for (i = 0, ilen = parsed.length; i < ilen; ++i) {
        value = parsed[i][scale.axis];
        if (isNumberFinite(value)) {
          values.push(value);
        }
      }
      return values;
    }
    getMaxOverflow() {
      return false;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const vScale = meta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
        value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
      };
    }
    _update(mode) {
      const meta = this._cachedMeta;
      this.update(mode || "default");
      meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
    }
    update(mode) {
    }
    draw() {
      const ctx = this._ctx;
      const chart = this.chart;
      const meta = this._cachedMeta;
      const elements2 = meta.data || [];
      const area = chart.chartArea;
      const active = [];
      const start = this._drawStart || 0;
      const count = this._drawCount || elements2.length - start;
      const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
      let i;
      if (meta.dataset) {
        meta.dataset.draw(ctx, area, start, count);
      }
      for (i = start; i < start + count; ++i) {
        const element = elements2[i];
        if (element.hidden) {
          continue;
        }
        if (element.active && drawActiveElementsOnTop) {
          active.push(element);
        } else {
          element.draw(ctx, area);
        }
      }
      for (i = 0; i < active.length; ++i) {
        active[i].draw(ctx, area);
      }
    }
    getStyle(index2, active) {
      const mode = active ? "active" : "default";
      return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
    }
    getContext(index2, active, mode) {
      const dataset = this.getDataset();
      let context;
      if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
        const element = this._cachedMeta.data[index2];
        context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
        context.parsed = this.getParsed(index2);
        context.raw = dataset.data[index2];
        context.index = context.dataIndex = index2;
      } else {
        context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
        context.dataset = dataset;
        context.index = context.datasetIndex = this.index;
      }
      context.active = !!active;
      context.mode = mode;
      return context;
    }
    resolveDatasetElementOptions(mode) {
      return this._resolveElementOptions(this.datasetElementType.id, mode);
    }
    resolveDataElementOptions(index2, mode) {
      return this._resolveElementOptions(this.dataElementType.id, mode, index2);
    }
    _resolveElementOptions(elementType, mode = "default", index2) {
      const active = mode === "active";
      const cache = this._cachedDataOpts;
      const cacheKey = elementType + "-" + mode;
      const cached = cache[cacheKey];
      const sharing = this.enableOptionSharing && defined(index2);
      if (cached) {
        return cloneIfNotShared(cached, sharing);
      }
      const config = this.chart.config;
      const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
      const prefixes = active ? [
        `${elementType}Hover`,
        "hover",
        elementType,
        ""
      ] : [
        elementType,
        ""
      ];
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      const names2 = Object.keys(defaults.elements[elementType]);
      const context = () => this.getContext(index2, active, mode);
      const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
      if (values.$shared) {
        values.$shared = sharing;
        cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
      }
      return values;
    }
    _resolveAnimations(index2, transition, active) {
      const chart = this.chart;
      const cache = this._cachedDataOpts;
      const cacheKey = `animation-${transition}`;
      const cached = cache[cacheKey];
      if (cached) {
        return cached;
      }
      let options;
      if (chart.options.animation !== false) {
        const config = this.chart.config;
        const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
        options = config.createResolver(scopes, this.getContext(index2, active, transition));
      }
      const animations = new Animations(chart, options && options.animations);
      if (options && options._cacheable) {
        cache[cacheKey] = Object.freeze(animations);
      }
      return animations;
    }
    getSharedOptions(options) {
      if (!options.$shared) {
        return;
      }
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
    }
    includeOptions(mode, sharedOptions) {
      return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
    }
    _getSharedOptions(start, mode) {
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const previouslySharedOptions = this._sharedOptions;
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
      return {
        sharedOptions,
        includeOptions
      };
    }
    updateElement(element, index2, properties, mode) {
      if (isDirectUpdateMode(mode)) {
        Object.assign(element, properties);
      } else {
        this._resolveAnimations(index2, mode).update(element, properties);
      }
    }
    updateSharedOptions(sharedOptions, mode, newOptions) {
      if (sharedOptions && !isDirectUpdateMode(mode)) {
        this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
      }
    }
    _setStyle(element, index2, mode, active) {
      element.active = active;
      const options = this.getStyle(index2, active);
      this._resolveAnimations(index2, mode, active).update(element, {
        options: !active && this.getSharedOptions(options) || options
      });
    }
    removeHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", false);
    }
    setHoverStyle(element, datasetIndex, index2) {
      this._setStyle(element, index2, "active", true);
    }
    _removeDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", false);
      }
    }
    _setDatasetHoverStyle() {
      const element = this._cachedMeta.dataset;
      if (element) {
        this._setStyle(element, void 0, "active", true);
      }
    }
    _resyncElements(resetNewElements) {
      const data = this._data;
      const elements2 = this._cachedMeta.data;
      for (const [method, arg1, arg2] of this._syncList) {
        this[method](arg1, arg2);
      }
      this._syncList = [];
      const numMeta = elements2.length;
      const numData = data.length;
      const count = Math.min(numData, numMeta);
      if (count) {
        this.parse(0, count);
      }
      if (numData > numMeta) {
        this._insertElements(numMeta, numData - numMeta, resetNewElements);
      } else if (numData < numMeta) {
        this._removeElements(numData, numMeta - numData);
      }
    }
    _insertElements(start, count, resetNewElements = true) {
      const meta = this._cachedMeta;
      const data = meta.data;
      const end = start + count;
      let i;
      const move = (arr) => {
        arr.length += count;
        for (i = arr.length - 1; i >= end; i--) {
          arr[i] = arr[i - count];
        }
      };
      move(data);
      for (i = start; i < end; ++i) {
        data[i] = new this.dataElementType();
      }
      if (this._parsing) {
        move(meta._parsed);
      }
      this.parse(start, count);
      if (resetNewElements) {
        this.updateElements(data, start, count, "reset");
      }
    }
    updateElements(element, start, count, mode) {
    }
    _removeElements(start, count) {
      const meta = this._cachedMeta;
      if (this._parsing) {
        const removed = meta._parsed.splice(start, count);
        if (meta._stacked) {
          clearStacks(meta, removed);
        }
      }
      meta.data.splice(start, count);
    }
    _sync(args) {
      if (this._parsing) {
        this._syncList.push(args);
      } else {
        const [method, arg1, arg2] = args;
        this[method](arg1, arg2);
      }
      this.chart._dataChanges.push([
        this.index,
        ...args
      ]);
    }
    _onDataPush() {
      const count = arguments.length;
      this._sync([
        "_insertElements",
        this.getDataset().data.length - count,
        count
      ]);
    }
    _onDataPop() {
      this._sync([
        "_removeElements",
        this._cachedMeta.data.length - 1,
        1
      ]);
    }
    _onDataShift() {
      this._sync([
        "_removeElements",
        0,
        1
      ]);
    }
    _onDataSplice(start, count) {
      if (count) {
        this._sync([
          "_removeElements",
          start,
          count
        ]);
      }
      const newCount = arguments.length - 2;
      if (newCount) {
        this._sync([
          "_insertElements",
          start,
          newCount
        ]);
      }
    }
    _onDataUnshift() {
      this._sync([
        "_insertElements",
        0,
        arguments.length
      ]);
    }
  };
  __publicField(DatasetController, "defaults", {});
  __publicField(DatasetController, "datasetElementType", null);
  __publicField(DatasetController, "dataElementType", null);
  function getAllScaleValues(scale, type) {
    if (!scale._cache.$bar) {
      const visibleMetas = scale.getMatchingVisibleMetas(type);
      let values = [];
      for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
        values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
      }
      scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
    }
    return scale._cache.$bar;
  }
  function computeMinSampleSize(meta) {
    const scale = meta.iScale;
    const values = getAllScaleValues(scale, meta.type);
    let min = scale._length;
    let i, ilen, curr, prev;
    const updateMinAndPrev = () => {
      if (curr === 32767 || curr === -32768) {
        return;
      }
      if (defined(prev)) {
        min = Math.min(min, Math.abs(curr - prev) || min);
      }
      prev = curr;
    };
    for (i = 0, ilen = values.length; i < ilen; ++i) {
      curr = scale.getPixelForValue(values[i]);
      updateMinAndPrev();
    }
    prev = void 0;
    for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
      curr = scale.getPixelForTick(i);
      updateMinAndPrev();
    }
    return min;
  }
  function computeFitCategoryTraits(index2, ruler, options, stackCount) {
    const thickness = options.barThickness;
    let size, ratio;
    if (isNullOrUndef(thickness)) {
      size = ruler.min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      size = thickness * stackCount;
      ratio = 1;
    }
    return {
      chunk: size / stackCount,
      ratio,
      start: ruler.pixels[index2] - size / 2
    };
  }
  function computeFlexCategoryTraits(index2, ruler, options, stackCount) {
    const pixels = ruler.pixels;
    const curr = pixels[index2];
    let prev = index2 > 0 ? pixels[index2 - 1] : null;
    let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
    const percent = options.categoryPercentage;
    if (prev === null) {
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }
    if (next === null) {
      next = curr + curr - prev;
    }
    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    const size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / stackCount,
      ratio: options.barPercentage,
      start
    };
  }
  function parseFloatBar(entry, item, vScale, i) {
    const startValue = vScale.parse(entry[0], i);
    const endValue = vScale.parse(entry[1], i);
    const min = Math.min(startValue, endValue);
    const max = Math.max(startValue, endValue);
    let barStart = min;
    let barEnd = max;
    if (Math.abs(min) > Math.abs(max)) {
      barStart = max;
      barEnd = min;
    }
    item[vScale.axis] = barEnd;
    item._custom = {
      barStart,
      barEnd,
      start: startValue,
      end: endValue,
      min,
      max
    };
  }
  function parseValue(entry, item, vScale, i) {
    if (isArray(entry)) {
      parseFloatBar(entry, item, vScale, i);
    } else {
      item[vScale.axis] = vScale.parse(entry, i);
    }
    return item;
  }
  function parseArrayOrPrimitive(meta, data, start, count) {
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = [];
    let i, ilen, item, entry;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      entry = data[i];
      item = {};
      item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
      parsed.push(parseValue(entry, item, vScale, i));
    }
    return parsed;
  }
  function isFloatBar(custom) {
    return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
  }
  function barSign(size, vScale, actualBase) {
    if (size !== 0) {
      return sign(size);
    }
    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
  }
  function borderProps(properties) {
    let reverse, start, end, top2, bottom2;
    if (properties.horizontal) {
      reverse = properties.base > properties.x;
      start = "left";
      end = "right";
    } else {
      reverse = properties.base < properties.y;
      start = "bottom";
      end = "top";
    }
    if (reverse) {
      top2 = "end";
      bottom2 = "start";
    } else {
      top2 = "start";
      bottom2 = "end";
    }
    return {
      start,
      end,
      reverse,
      top: top2,
      bottom: bottom2
    };
  }
  function setBorderSkipped(properties, options, stack, index2) {
    let edge = options.borderSkipped;
    const res = {};
    if (!edge) {
      properties.borderSkipped = res;
      return;
    }
    if (edge === true) {
      properties.borderSkipped = {
        top: true,
        right: true,
        bottom: true,
        left: true
      };
      return;
    }
    const { start, end, reverse, top: top2, bottom: bottom2 } = borderProps(properties);
    if (edge === "middle" && stack) {
      properties.enableBorderRadius = true;
      if ((stack._top || 0) === index2) {
        edge = top2;
      } else if ((stack._bottom || 0) === index2) {
        edge = bottom2;
      } else {
        res[parseEdge(bottom2, start, end, reverse)] = true;
        edge = top2;
      }
    }
    res[parseEdge(edge, start, end, reverse)] = true;
    properties.borderSkipped = res;
  }
  function parseEdge(edge, a, b, reverse) {
    if (reverse) {
      edge = swap(edge, a, b);
      edge = startEnd(edge, b, a);
    } else {
      edge = startEnd(edge, a, b);
    }
    return edge;
  }
  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }
  function startEnd(v, start, end) {
    return v === "start" ? start : v === "end" ? end : v;
  }
  function setInflateAmount(properties, { inflateAmount }, ratio) {
    properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
  }
  var BarController = class extends DatasetController {
    parsePrimitiveData(meta, data, start, count) {
      return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseArrayData(meta, data, start, count) {
      return parseArrayOrPrimitive(meta, data, start, count);
    }
    parseObjectData(meta, data, start, count) {
      const { iScale, vScale } = meta;
      const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
      const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
      const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
      const parsed = [];
      let i, ilen, item, obj;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        obj = data[i];
        item = {};
        item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
        parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
      }
      return parsed;
    }
    updateRangeFromParsed(range2, scale, parsed, stack) {
      super.updateRangeFromParsed(range2, scale, parsed, stack);
      const custom = parsed._custom;
      if (custom && scale === this._cachedMeta.vScale) {
        range2.min = Math.min(range2.min, custom.min);
        range2.max = Math.max(range2.max, custom.max);
      }
    }
    getMaxOverflow() {
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const { iScale, vScale } = meta;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
      return {
        label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
        value
      };
    }
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
      const meta = this._cachedMeta;
      meta.stack = this.getDataset().stack;
    }
    update(mode) {
      const meta = this._cachedMeta;
      this.updateElements(meta.data, 0, meta.data.length, mode);
    }
    updateElements(bars, start, count, mode) {
      const reset = mode === "reset";
      const { index: index2, _cachedMeta: { vScale } } = this;
      const base = vScale.getBasePixel();
      const horizontal = vScale.isHorizontal();
      const ruler = this._getRuler();
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      for (let i = start; i < start + count; i++) {
        const parsed = this.getParsed(i);
        const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
          base,
          head: base
        } : this._calculateBarValuePixels(i);
        const ipixels = this._calculateBarIndexPixels(i, ruler);
        const stack = (parsed._stacks || {})[vScale.axis];
        const properties = {
          horizontal,
          base: vpixels.base,
          enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
          x: horizontal ? vpixels.head : ipixels.center,
          y: horizontal ? ipixels.center : vpixels.head,
          height: horizontal ? ipixels.size : Math.abs(vpixels.size),
          width: horizontal ? Math.abs(vpixels.size) : ipixels.size
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
        }
        const options = properties.options || bars[i].options;
        setBorderSkipped(properties, options, stack, index2);
        setInflateAmount(properties, options, ruler.ratio);
        this.updateElement(bars[i], i, properties, mode);
      }
    }
    _getStacks(last, dataIndex) {
      const { iScale } = this._cachedMeta;
      const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
      const stacked = iScale.options.stacked;
      const stacks = [];
      const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
      const iScaleValue = currentParsed && currentParsed[iScale.axis];
      const skipNull = (meta) => {
        const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
        const val = parsed && parsed[meta.vScale.axis];
        if (isNullOrUndef(val) || isNaN(val)) {
          return true;
        }
      };
      for (const meta of metasets) {
        if (dataIndex !== void 0 && skipNull(meta)) {
          continue;
        }
        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
          stacks.push(meta.stack);
        }
        if (meta.index === last) {
          break;
        }
      }
      if (!stacks.length) {
        stacks.push(void 0);
      }
      return stacks;
    }
    _getStackCount(index2) {
      return this._getStacks(void 0, index2).length;
    }
    _getStackIndex(datasetIndex, name, dataIndex) {
      const stacks = this._getStacks(datasetIndex, dataIndex);
      const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
      return index2 === -1 ? stacks.length - 1 : index2;
    }
    _getRuler() {
      const opts = this.options;
      const meta = this._cachedMeta;
      const iScale = meta.iScale;
      const pixels = [];
      let i, ilen;
      for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
        pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
      }
      const barThickness = opts.barThickness;
      const min = barThickness || computeMinSampleSize(meta);
      return {
        min,
        pixels,
        start: iScale._startPixel,
        end: iScale._endPixel,
        stackCount: this._getStackCount(),
        scale: iScale,
        grouped: opts.grouped,
        ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
      };
    }
    _calculateBarValuePixels(index2) {
      const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
      const actualBase = baseValue || 0;
      const parsed = this.getParsed(index2);
      const custom = parsed._custom;
      const floating = isFloatBar(custom);
      let value = parsed[vScale.axis];
      let start = 0;
      let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
      let head, size;
      if (length !== value) {
        start = length - value;
        length = value;
      }
      if (floating) {
        value = custom.barStart;
        length = custom.barEnd - custom.barStart;
        if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
          start = 0;
        }
        start += value;
      }
      const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
      let base = vScale.getPixelForValue(startValue);
      if (this.chart.getDataVisibility(index2)) {
        head = vScale.getPixelForValue(start + length);
      } else {
        head = base;
      }
      size = head - base;
      if (Math.abs(size) < minBarLength) {
        size = barSign(size, vScale, actualBase) * minBarLength;
        if (value === actualBase) {
          base -= size / 2;
        }
        const startPixel = vScale.getPixelForDecimal(0);
        const endPixel = vScale.getPixelForDecimal(1);
        const min = Math.min(startPixel, endPixel);
        const max = Math.max(startPixel, endPixel);
        base = Math.max(Math.min(base, max), min);
        head = base + size;
        if (_stacked && !floating) {
          parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
        }
      }
      if (base === vScale.getPixelForValue(actualBase)) {
        const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
        base += halfGrid;
        size -= halfGrid;
      }
      return {
        size,
        base,
        head,
        center: head + size / 2
      };
    }
    _calculateBarIndexPixels(index2, ruler) {
      const scale = ruler.scale;
      const options = this.options;
      const skipNull = options.skipNull;
      const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);
      let center, size;
      if (ruler.grouped) {
        const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
        const range2 = options.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);
        const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);
        center = range2.start + range2.chunk * stackIndex + range2.chunk / 2;
        size = Math.min(maxBarThickness, range2.chunk * range2.ratio);
      } else {
        center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
        size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
      }
      return {
        base: center - size / 2,
        head: center + size / 2,
        center,
        size
      };
    }
    draw() {
      const meta = this._cachedMeta;
      const vScale = meta.vScale;
      const rects = meta.data;
      const ilen = rects.length;
      let i = 0;
      for (; i < ilen; ++i) {
        if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
          rects[i].draw(this._ctx);
        }
      }
    }
  };
  __publicField(BarController, "id", "bar");
  __publicField(BarController, "defaults", {
    datasetElementType: false,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: true,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  });
  __publicField(BarController, "overrides", {
    scales: {
      _index_: {
        type: "category",
        offset: true,
        grid: {
          offset: true
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: true
      }
    }
  });
  var BubbleController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      super.initialize();
    }
    parsePrimitiveData(meta, data, start, count) {
      const parsed = super.parsePrimitiveData(meta, data, start, count);
      for (let i = 0; i < parsed.length; i++) {
        parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
      }
      return parsed;
    }
    parseArrayData(meta, data, start, count) {
      const parsed = super.parseArrayData(meta, data, start, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start + i];
        parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
      }
      return parsed;
    }
    parseObjectData(meta, data, start, count) {
      const parsed = super.parseObjectData(meta, data, start, count);
      for (let i = 0; i < parsed.length; i++) {
        const item = data[start + i];
        parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
      }
      return parsed;
    }
    getMaxOverflow() {
      const data = this._cachedMeta.data;
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      const r = parsed._custom;
      return {
        label: labels[index2] || "",
        value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
      };
    }
    update(mode) {
      const points = this._cachedMeta.data;
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      for (let i = start; i < start + count; i++) {
        const point = points[i];
        const parsed = !reset && this.getParsed(i);
        const properties = {};
        const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
        const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
        properties.skip = isNaN(iPixel) || isNaN(vPixel);
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
          if (reset) {
            properties.options.radius = 0;
          }
        }
        this.updateElement(point, i, properties, mode);
      }
    }
    resolveDataElementOptions(index2, mode) {
      const parsed = this.getParsed(index2);
      let values = super.resolveDataElementOptions(index2, mode);
      if (values.$shared) {
        values = Object.assign({}, values, {
          $shared: false
        });
      }
      const radius = values.radius;
      if (mode !== "active") {
        values.radius = 0;
      }
      values.radius += valueOrDefault(parsed && parsed._custom, radius);
      return values;
    }
  };
  __publicField(BubbleController, "id", "bubble");
  __publicField(BubbleController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "borderWidth",
          "radius"
        ]
      }
    }
  });
  __publicField(BubbleController, "overrides", {
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  function getRatioAndOffset(rotation, circumference, cutout) {
    let ratioX = 1;
    let ratioY = 1;
    let offsetX = 0;
    let offsetY = 0;
    if (circumference < TAU) {
      const startAngle = rotation;
      const endAngle = startAngle + circumference;
      const startX = Math.cos(startAngle);
      const startY = Math.sin(startAngle);
      const endX = Math.cos(endAngle);
      const endY = Math.sin(endAngle);
      const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
      const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
      const maxX = calcMax(0, startX, endX);
      const maxY = calcMax(HALF_PI, startY, endY);
      const minX = calcMin(PI, startX, endX);
      const minY = calcMin(PI + HALF_PI, startY, endY);
      ratioX = (maxX - minX) / 2;
      ratioY = (maxY - minY) / 2;
      offsetX = -(maxX + minX) / 2;
      offsetY = -(maxY + minY) / 2;
    }
    return {
      ratioX,
      ratioY,
      offsetX,
      offsetY
    };
  }
  var DoughnutController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.enableOptionSharing = true;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.offsetX = void 0;
      this.offsetY = void 0;
    }
    linkScales() {
    }
    parse(start, count) {
      const data = this.getDataset().data;
      const meta = this._cachedMeta;
      if (this._parsing === false) {
        meta._parsed = data;
      } else {
        let getter = (i2) => +data[i2];
        if (isObject2(data[start])) {
          const { key = "value" } = this._parsing;
          getter = (i2) => +resolveObjectKey(data[i2], key);
        }
        let i, ilen;
        for (i = start, ilen = start + count; i < ilen; ++i) {
          meta._parsed[i] = getter(i);
        }
      }
    }
    _getRotation() {
      return toRadians(this.options.rotation - 90);
    }
    _getCircumference() {
      return toRadians(this.options.circumference);
    }
    _getRotationExtents() {
      let min = TAU;
      let max = -TAU;
      for (let i = 0; i < this.chart.data.datasets.length; ++i) {
        if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
          const controller = this.chart.getDatasetMeta(i).controller;
          const rotation = controller._getRotation();
          const circumference = controller._getCircumference();
          min = Math.min(min, rotation);
          max = Math.max(max, rotation + circumference);
        }
      }
      return {
        rotation: min,
        circumference: max - min
      };
    }
    update(mode) {
      const chart = this.chart;
      const { chartArea } = chart;
      const meta = this._cachedMeta;
      const arcs = meta.data;
      const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
      const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
      const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
      const chartWeight = this._getRingWeight(this.index);
      const { circumference, rotation } = this._getRotationExtents();
      const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
      const maxWidth = (chartArea.width - spacing) / ratioX;
      const maxHeight = (chartArea.height - spacing) / ratioY;
      const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      const outerRadius = toDimension(this.options.radius, maxRadius);
      const innerRadius = Math.max(outerRadius * cutout, 0);
      const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
      this.offsetX = offsetX * outerRadius;
      this.offsetY = offsetY * outerRadius;
      meta.total = this.calculateTotal();
      this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
      this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    _circumference(i, reset) {
      const opts = this.options;
      const meta = this._cachedMeta;
      const circumference = this._getCircumference();
      if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
        return 0;
      }
      return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
    }
    updateElements(arcs, start, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const centerX = (chartArea.left + chartArea.right) / 2;
      const centerY = (chartArea.top + chartArea.bottom) / 2;
      const animateScale = reset && animationOpts.animateScale;
      const innerRadius = animateScale ? 0 : this.innerRadius;
      const outerRadius = animateScale ? 0 : this.outerRadius;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      let startAngle = this._getRotation();
      let i;
      for (i = 0; i < start; ++i) {
        startAngle += this._circumference(i, reset);
      }
      for (i = start; i < start + count; ++i) {
        const circumference = this._circumference(i, reset);
        const arc = arcs[i];
        const properties = {
          x: centerX + this.offsetX,
          y: centerY + this.offsetY,
          startAngle,
          endAngle: startAngle + circumference,
          circumference,
          outerRadius,
          innerRadius
        };
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
        }
        startAngle += circumference;
        this.updateElement(arc, i, properties, mode);
      }
    }
    calculateTotal() {
      const meta = this._cachedMeta;
      const metaData = meta.data;
      let total = 0;
      let i;
      for (i = 0; i < metaData.length; i++) {
        const value = meta._parsed[i];
        if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
          total += Math.abs(value);
        }
      }
      return total;
    }
    calculateCircumference(value) {
      const total = this._cachedMeta.total;
      if (total > 0 && !isNaN(value)) {
        return TAU * (Math.abs(value) / total);
      }
      return 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2], chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    getMaxBorderWidth(arcs) {
      let max = 0;
      const chart = this.chart;
      let i, ilen, meta, controller, options;
      if (!arcs) {
        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);
            arcs = meta.data;
            controller = meta.controller;
            break;
          }
        }
      }
      if (!arcs) {
        return 0;
      }
      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        options = controller.resolveDataElementOptions(i);
        if (options.borderAlign !== "inner") {
          max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
        }
      }
      return max;
    }
    getMaxOffset(arcs) {
      let max = 0;
      for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
        const options = this.resolveDataElementOptions(i);
        max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
      }
      return max;
    }
    _getRingWeightOffset(datasetIndex) {
      let ringWeightOffset = 0;
      for (let i = 0; i < datasetIndex; ++i) {
        if (this.chart.isDatasetVisible(i)) {
          ringWeightOffset += this._getRingWeight(i);
        }
      }
      return ringWeightOffset;
    }
    _getRingWeight(datasetIndex) {
      return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
    }
    _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
    }
  };
  __publicField(DoughnutController, "id", "doughnut");
  __publicField(DoughnutController, "defaults", {
    datasetElementType: false,
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: false
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  });
  __publicField(DoughnutController, "descriptors", {
    _scriptable: (name) => name !== "spacing",
    _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
  });
  __publicField(DoughnutController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    }
  });
  var LineController = class extends DatasetController {
    initialize() {
      this.enableOptionSharing = true;
      this.supportsDecimation = true;
      super.initialize();
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { dataset: line, data: points = [], _dataset } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options.borderWidth = 0;
      }
      options.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options
      }, mode);
      this.updateElements(points, start, count, mode);
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      const end = start + count;
      const pointsCount = points.length;
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i = 0; i < pointsCount; ++i) {
        const point = points[i];
        const properties = directUpdate ? point : {};
        if (i < start || i >= end) {
          properties.skip = true;
          continue;
        }
        const parsed = this.getParsed(i);
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      const data = meta.data || [];
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
    draw() {
      const meta = this._cachedMeta;
      meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
      super.draw();
    }
  };
  __publicField(LineController, "id", "line");
  __publicField(LineController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: true,
    spanGaps: false
  });
  __publicField(LineController, "overrides", {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  });
  var PolarAreaController = class extends DatasetController {
    constructor(chart, datasetIndex) {
      super(chart, datasetIndex);
      this.innerRadius = void 0;
      this.outerRadius = void 0;
    }
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const chart = this.chart;
      const labels = chart.data.labels || [];
      const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
      return {
        label: labels[index2] || "",
        value
      };
    }
    parseObjectData(meta, data, start, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
      const arcs = this._cachedMeta.data;
      this._updateRadius();
      this.updateElements(arcs, 0, arcs.length, mode);
    }
    getMinMax() {
      const meta = this._cachedMeta;
      const range2 = {
        min: Number.POSITIVE_INFINITY,
        max: Number.NEGATIVE_INFINITY
      };
      meta.data.forEach((element, index2) => {
        const parsed = this.getParsed(index2).r;
        if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
          if (parsed < range2.min) {
            range2.min = parsed;
          }
          if (parsed > range2.max) {
            range2.max = parsed;
          }
        }
      });
      return range2;
    }
    _updateRadius() {
      const chart = this.chart;
      const chartArea = chart.chartArea;
      const opts = chart.options;
      const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      const outerRadius = Math.max(minSize / 2, 0);
      const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
      this.outerRadius = outerRadius - radiusLength * this.index;
      this.innerRadius = this.outerRadius - radiusLength;
    }
    updateElements(arcs, start, count, mode) {
      const reset = mode === "reset";
      const chart = this.chart;
      const opts = chart.options;
      const animationOpts = opts.animation;
      const scale = this._cachedMeta.rScale;
      const centerX = scale.xCenter;
      const centerY = scale.yCenter;
      const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
      let angle = datasetStartAngle;
      let i;
      const defaultAngle = 360 / this.countVisibleElements();
      for (i = 0; i < start; ++i) {
        angle += this._computeAngle(i, mode, defaultAngle);
      }
      for (i = start; i < start + count; i++) {
        const arc = arcs[i];
        let startAngle = angle;
        let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
        let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
        angle = endAngle;
        if (reset) {
          if (animationOpts.animateScale) {
            outerRadius = 0;
          }
          if (animationOpts.animateRotate) {
            startAngle = endAngle = datasetStartAngle;
          }
        }
        const properties = {
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius,
          startAngle,
          endAngle,
          options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
        };
        this.updateElement(arc, i, properties, mode);
      }
    }
    countVisibleElements() {
      const meta = this._cachedMeta;
      let count = 0;
      meta.data.forEach((element, index2) => {
        if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
          count++;
        }
      });
      return count;
    }
    _computeAngle(index2, mode, defaultAngle) {
      return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
    }
  };
  __publicField(PolarAreaController, "id", "polarArea");
  __publicField(PolarAreaController, "defaults", {
    dataElementType: "arc",
    animation: {
      animateRotate: true,
      animateScale: true
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "startAngle",
          "endAngle",
          "innerRadius",
          "outerRadius"
        ]
      }
    },
    indexAxis: "r",
    startAngle: 0
  });
  __publicField(PolarAreaController, "overrides", {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(chart) {
            const data = chart.data;
            if (data.labels.length && data.datasets.length) {
              const { labels: { pointStyle, color: color2 } } = chart.legend.options;
              return data.labels.map((label, i) => {
                const meta = chart.getDatasetMeta(0);
                const style = meta.controller.getStyle(i);
                return {
                  text: label,
                  fillStyle: style.backgroundColor,
                  strokeStyle: style.borderColor,
                  fontColor: color2,
                  lineWidth: style.borderWidth,
                  pointStyle,
                  hidden: !chart.getDataVisibility(i),
                  index: i
                };
              });
            }
            return [];
          }
        },
        onClick(e, legendItem, legend) {
          legend.chart.toggleDataVisibility(legendItem.index);
          legend.chart.update();
        }
      }
    },
    scales: {
      r: {
        type: "radialLinear",
        angleLines: {
          display: false
        },
        beginAtZero: true,
        grid: {
          circular: true
        },
        pointLabels: {
          display: false
        },
        startAngle: 0
      }
    }
  });
  var PieController = class extends DoughnutController {
  };
  __publicField(PieController, "id", "pie");
  __publicField(PieController, "defaults", {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  });
  var RadarController = class extends DatasetController {
    getLabelAndValue(index2) {
      const vScale = this._cachedMeta.vScale;
      const parsed = this.getParsed(index2);
      return {
        label: vScale.getLabels()[index2],
        value: "" + vScale.getLabelForValue(parsed[vScale.axis])
      };
    }
    parseObjectData(meta, data, start, count) {
      return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
    }
    update(mode) {
      const meta = this._cachedMeta;
      const line = meta.dataset;
      const points = meta.data || [];
      const labels = meta.iScale.getLabels();
      line.points = points;
      if (mode !== "resize") {
        const options = this.resolveDatasetElementOptions(mode);
        if (!this.options.showLine) {
          options.borderWidth = 0;
        }
        const properties = {
          _loop: true,
          _fullLoop: labels.length === points.length,
          options
        };
        this.updateElement(line, void 0, properties, mode);
      }
      this.updateElements(points, 0, points.length, mode);
    }
    updateElements(points, start, count, mode) {
      const scale = this._cachedMeta.rScale;
      const reset = mode === "reset";
      for (let i = start; i < start + count; i++) {
        const point = points[i];
        const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
        const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
        const x = reset ? scale.xCenter : pointPosition.x;
        const y = reset ? scale.yCenter : pointPosition.y;
        const properties = {
          x,
          y,
          angle: pointPosition.angle,
          skip: isNaN(x) || isNaN(y),
          options
        };
        this.updateElement(point, i, properties, mode);
      }
    }
  };
  __publicField(RadarController, "id", "radar");
  __publicField(RadarController, "defaults", {
    datasetElementType: "line",
    dataElementType: "point",
    indexAxis: "r",
    showLine: true,
    elements: {
      line: {
        fill: "start"
      }
    }
  });
  __publicField(RadarController, "overrides", {
    aspectRatio: 1,
    scales: {
      r: {
        type: "radialLinear"
      }
    }
  });
  var ScatterController = class extends DatasetController {
    getLabelAndValue(index2) {
      const meta = this._cachedMeta;
      const labels = this.chart.data.labels || [];
      const { xScale, yScale } = meta;
      const parsed = this.getParsed(index2);
      const x = xScale.getLabelForValue(parsed.x);
      const y = yScale.getLabelForValue(parsed.y);
      return {
        label: labels[index2] || "",
        value: "(" + x + ", " + y + ")"
      };
    }
    update(mode) {
      const meta = this._cachedMeta;
      const { data: points = [] } = meta;
      const animationsDisabled = this.chart._animationsDisabled;
      let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
      this._drawStart = start;
      this._drawCount = count;
      if (_scaleRangesChanged(meta)) {
        start = 0;
        count = points.length;
      }
      if (this.options.showLine) {
        if (!this.datasetElementType) {
          this.addElements();
        }
        const { dataset: line, _dataset } = meta;
        line._chart = this.chart;
        line._datasetIndex = this.index;
        line._decimated = !!_dataset._decimated;
        line.points = points;
        const options = this.resolveDatasetElementOptions(mode);
        options.segment = this.options.segment;
        this.updateElement(line, void 0, {
          animated: !animationsDisabled,
          options
        }, mode);
      } else if (this.datasetElementType) {
        delete meta.dataset;
        this.datasetElementType = false;
      }
      this.updateElements(points, start, count, mode);
    }
    addElements() {
      const { showLine } = this.options;
      if (!this.datasetElementType && showLine) {
        this.datasetElementType = this.chart.registry.getElement("line");
      }
      super.addElements();
    }
    updateElements(points, start, count, mode) {
      const reset = mode === "reset";
      const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
      const firstOpts = this.resolveDataElementOptions(start, mode);
      const sharedOptions = this.getSharedOptions(firstOpts);
      const includeOptions = this.includeOptions(mode, sharedOptions);
      const iAxis = iScale.axis;
      const vAxis = vScale.axis;
      const { spanGaps, segment } = this.options;
      const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
      const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
      let prevParsed = start > 0 && this.getParsed(start - 1);
      for (let i = start; i < start + count; ++i) {
        const point = points[i];
        const parsed = this.getParsed(i);
        const properties = directUpdate ? point : {};
        const nullData = isNullOrUndef(parsed[vAxis]);
        const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
        const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
        properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
        properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
        if (segment) {
          properties.parsed = parsed;
          properties.raw = _dataset.data[i];
        }
        if (includeOptions) {
          properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        }
        if (!directUpdate) {
          this.updateElement(point, i, properties, mode);
        }
        prevParsed = parsed;
      }
      this.updateSharedOptions(sharedOptions, mode, firstOpts);
    }
    getMaxOverflow() {
      const meta = this._cachedMeta;
      const data = meta.data || [];
      if (!this.options.showLine) {
        let max = 0;
        for (let i = data.length - 1; i >= 0; --i) {
          max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
        }
        return max > 0 && max;
      }
      const dataset = meta.dataset;
      const border = dataset.options && dataset.options.borderWidth || 0;
      if (!data.length) {
        return border;
      }
      const firstPoint = data[0].size(this.resolveDataElementOptions(0));
      const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
      return Math.max(border, firstPoint, lastPoint) / 2;
    }
  };
  __publicField(ScatterController, "id", "scatter");
  __publicField(ScatterController, "defaults", {
    datasetElementType: false,
    dataElementType: "point",
    showLine: false,
    fill: false
  });
  __publicField(ScatterController, "overrides", {
    interaction: {
      mode: "point"
    },
    scales: {
      x: {
        type: "linear"
      },
      y: {
        type: "linear"
      }
    }
  });
  var controllers = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    BarController,
    BubbleController,
    DoughnutController,
    LineController,
    PieController,
    PolarAreaController,
    RadarController,
    ScatterController
  });
  function abstract() {
    throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
  }
  var DateAdapterBase = class {
    constructor(options) {
      __publicField(this, "options");
      this.options = options || {};
    }
    /**
    * Override default date adapter methods.
    * Accepts type parameter to define options type.
    * @example
    * Chart._adapters._date.override<{myAdapterOption: string}>({
    *   init() {
    *     console.log(this.options.myAdapterOption);
    *   }
    * })
    */
    static override(members) {
      Object.assign(DateAdapterBase.prototype, members);
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    init() {
    }
    formats() {
      return abstract();
    }
    parse() {
      return abstract();
    }
    format() {
      return abstract();
    }
    add() {
      return abstract();
    }
    diff() {
      return abstract();
    }
    startOf() {
      return abstract();
    }
    endOf() {
      return abstract();
    }
  };
  var adapters = {
    _date: DateAdapterBase
  };
  function binarySearch(metaset, axis, value, intersect) {
    const { controller, data, _sorted } = metaset;
    const iScale = controller._cachedMeta.iScale;
    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
    if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
      const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
      if (!intersect) {
        const result = lookupMethod(data, axis, value);
        if (spanGaps) {
          const { vScale } = controller._cachedMeta;
          const { _parsed } = metaset;
          const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          result.lo -= Math.max(0, distanceToDefinedLo);
          const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
          result.hi += Math.max(0, distanceToDefinedHi);
        }
        return result;
      } else if (controller._sharedOptions) {
        const el = data[0];
        const range2 = typeof el.getRange === "function" && el.getRange(axis);
        if (range2) {
          const start = lookupMethod(data, axis, value - range2);
          const end = lookupMethod(data, axis, value + range2);
          return {
            lo: start.lo,
            hi: end.hi
          };
        }
      }
    }
    return {
      lo: 0,
      hi: data.length - 1
    };
  }
  function evaluateInteractionItems(chart, axis, position, handler, intersect) {
    const metasets = chart.getSortedVisibleDatasetMetas();
    const value = position[axis];
    for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
      const { index: index2, data } = metasets[i];
      const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
      for (let j = lo; j <= hi; ++j) {
        const element = data[j];
        if (!element.skip) {
          handler(element, index2, j);
        }
      }
    }
  }
  function getDistanceMetricForAxis(axis) {
    const useX = axis.indexOf("x") !== -1;
    const useY = axis.indexOf("y") !== -1;
    return function(pt1, pt2) {
      const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }
  function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
    const items = [];
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return items;
    }
    const evaluationFunc = function(element, datasetIndex, index2) {
      if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
        return;
      }
      if (element.inRange(position.x, position.y, useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    };
    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
    return items;
  }
  function getNearestRadialItems(chart, position, axis, useFinalPosition) {
    let items = [];
    function evaluationFunc(element, datasetIndex, index2) {
      const { startAngle, endAngle } = element.getProps([
        "startAngle",
        "endAngle"
      ], useFinalPosition);
      const { angle } = getAngleFromPoint(element, {
        x: position.x,
        y: position.y
      });
      if (_angleBetween(angle, startAngle, endAngle)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    let items = [];
    const distanceMetric = getDistanceMetricForAxis(axis);
    let minDistance = Number.POSITIVE_INFINITY;
    function evaluationFunc(element, datasetIndex, index2) {
      const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
      if (intersect && !inRange2) {
        return;
      }
      const center = element.getCenterPoint(useFinalPosition);
      const pointInArea = !!includeInvisible || chart.isPointInArea(center);
      if (!pointInArea && !inRange2) {
        return;
      }
      const distance = distanceMetric(position, center);
      if (distance < minDistance) {
        items = [
          {
            element,
            datasetIndex,
            index: index2
          }
        ];
        minDistance = distance;
      } else if (distance === minDistance) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
      }
    }
    evaluateInteractionItems(chart, axis, position, evaluationFunc);
    return items;
  }
  function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
    if (!includeInvisible && !chart.isPointInArea(position)) {
      return [];
    }
    return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
  }
  function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
    const items = [];
    const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
    let intersectsItem = false;
    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
      if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
        items.push({
          element,
          datasetIndex,
          index: index2
        });
        intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
      }
    });
    if (intersect && !intersectsItem) {
      return [];
    }
    return items;
  }
  var Interaction = {
    evaluateInteractionItems,
    modes: {
      index(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "x";
        const includeInvisible = options.includeInvisible || false;
        const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        const elements2 = [];
        if (!items.length) {
          return [];
        }
        chart.getSortedVisibleDatasetMetas().forEach((meta) => {
          const index2 = items[0].index;
          const element = meta.data[index2];
          if (element && !element.skip) {
            elements2.push({
              element,
              datasetIndex: meta.index,
              index: index2
            });
          }
        });
        return elements2;
      },
      dataset(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
        if (items.length > 0) {
          const datasetIndex = items[0].datasetIndex;
          const data = chart.getDatasetMeta(datasetIndex).data;
          items = [];
          for (let i = 0; i < data.length; ++i) {
            items.push({
              element: data[i],
              datasetIndex,
              index: i
            });
          }
        }
        return items;
      },
      point(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
      },
      nearest(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const axis = options.axis || "xy";
        const includeInvisible = options.includeInvisible || false;
        return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
      },
      x(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
      },
      y(chart, e, options, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
      }
    }
  };
  var STATIC_POSITIONS = [
    "left",
    "top",
    "right",
    "bottom"
  ];
  function filterByPosition(array, position) {
    return array.filter((v) => v.pos === position);
  }
  function filterDynamicPositionByAxis(array, axis) {
    return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
  }
  function sortByWeight(array, reverse) {
    return array.sort((a, b) => {
      const v0 = reverse ? b : a;
      const v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }
  function wrapBoxes(boxes) {
    const layoutBoxes = [];
    let i, ilen, box, pos, stack, stackWeight;
    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
      box = boxes[i];
      ({ position: pos, options: { stack, stackWeight = 1 } } = box);
      layoutBoxes.push({
        index: i,
        box,
        pos,
        horizontal: box.isHorizontal(),
        weight: box.weight,
        stack: stack && pos + stack,
        stackWeight
      });
    }
    return layoutBoxes;
  }
  function buildStacks(layouts2) {
    const stacks = {};
    for (const wrap of layouts2) {
      const { stack, pos, stackWeight } = wrap;
      if (!stack || !STATIC_POSITIONS.includes(pos)) {
        continue;
      }
      const _stack = stacks[stack] || (stacks[stack] = {
        count: 0,
        placed: 0,
        weight: 0,
        size: 0
      });
      _stack.count++;
      _stack.weight += stackWeight;
    }
    return stacks;
  }
  function setLayoutDims(layouts2, params) {
    const stacks = buildStacks(layouts2);
    const { vBoxMaxWidth, hBoxMaxHeight } = params;
    let i, ilen, layout;
    for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
      layout = layouts2[i];
      const { fullSize } = layout.box;
      const stack = stacks[layout.stack];
      const factor = stack && layout.stackWeight / stack.weight;
      if (layout.horizontal) {
        layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
        layout.height = hBoxMaxHeight;
      } else {
        layout.width = vBoxMaxWidth;
        layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
      }
    }
    return stacks;
  }
  function buildLayoutBoxes(boxes) {
    const layoutBoxes = wrapBoxes(boxes);
    const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
    const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
    const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
    const top2 = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
    const bottom2 = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
    return {
      fullSize,
      leftAndTop: left.concat(top2),
      rightAndBottom: right.concat(centerVertical).concat(bottom2).concat(centerHorizontal),
      chartArea: filterByPosition(layoutBoxes, "chartArea"),
      vertical: left.concat(right).concat(centerVertical),
      horizontal: top2.concat(bottom2).concat(centerHorizontal)
    };
  }
  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }
  function updateMaxPadding(maxPadding, boxPadding) {
    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
  }
  function updateDims(chartArea, params, layout, stacks) {
    const { pos, box } = layout;
    const maxPadding = chartArea.maxPadding;
    if (!isObject2(pos)) {
      if (layout.size) {
        chartArea[pos] -= layout.size;
      }
      const stack = stacks[layout.stack] || {
        size: 0,
        count: 1
      };
      stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
      layout.size = stack.size / stack.count;
      chartArea[pos] += layout.size;
    }
    if (box.getPadding) {
      updateMaxPadding(maxPadding, box.getPadding());
    }
    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
    const widthChanged = newWidth !== chartArea.w;
    const heightChanged = newHeight !== chartArea.h;
    chartArea.w = newWidth;
    chartArea.h = newHeight;
    return layout.horizontal ? {
      same: widthChanged,
      other: heightChanged
    } : {
      same: heightChanged,
      other: widthChanged
    };
  }
  function handleMaxPadding(chartArea) {
    const maxPadding = chartArea.maxPadding;
    function updatePos(pos) {
      const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }
    chartArea.y += updatePos("top");
    chartArea.x += updatePos("left");
    updatePos("right");
    updatePos("bottom");
  }
  function getMargins(horizontal, chartArea) {
    const maxPadding = chartArea.maxPadding;
    function marginForPositions(positions2) {
      const margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions2.forEach((pos) => {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }
    return horizontal ? marginForPositions([
      "left",
      "right"
    ]) : marginForPositions([
      "top",
      "bottom"
    ]);
  }
  function fitBoxes(boxes, chartArea, params, stacks) {
    const refitBoxes = [];
    let i, ilen, layout, box, refit, changed;
    for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
      layout = boxes[i];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
      const { same, other } = updateDims(chartArea, params, layout, stacks);
      refit |= same && refitBoxes.length;
      changed = changed || other;
      if (!box.fullSize) {
        refitBoxes.push(layout);
      }
    }
    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
  }
  function setBoxDims(box, left, top2, width, height) {
    box.top = top2;
    box.left = left;
    box.right = left + width;
    box.bottom = top2 + height;
    box.width = width;
    box.height = height;
  }
  function placeBoxes(boxes, chartArea, params, stacks) {
    const userPadding = params.padding;
    let { x, y } = chartArea;
    for (const layout of boxes) {
      const box = layout.box;
      const stack = stacks[layout.stack] || {
        count: 1,
        placed: 0,
        weight: 1
      };
      const weight = layout.stackWeight / stack.weight || 1;
      if (layout.horizontal) {
        const width = chartArea.w * weight;
        const height = stack.size || box.height;
        if (defined(stack.start)) {
          y = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
        } else {
          setBoxDims(box, chartArea.left + stack.placed, y, width, height);
        }
        stack.start = y;
        stack.placed += width;
        y = box.bottom;
      } else {
        const height = chartArea.h * weight;
        const width = stack.size || box.width;
        if (defined(stack.start)) {
          x = stack.start;
        }
        if (box.fullSize) {
          setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
        } else {
          setBoxDims(box, x, chartArea.top + stack.placed, width, height);
        }
        stack.start = x;
        stack.placed += height;
        x = box.right;
      }
    }
    chartArea.x = x;
    chartArea.y = y;
  }
  var layouts = {
    addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      }
      item.fullSize = item.fullSize || false;
      item.position = item.position || "top";
      item.weight = item.weight || 0;
      item._layers = item._layers || function() {
        return [
          {
            z: 0,
            draw(chartArea) {
              item.draw(chartArea);
            }
          }
        ];
      };
      chart.boxes.push(item);
    },
    removeBox(chart, layoutItem) {
      const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
      if (index2 !== -1) {
        chart.boxes.splice(index2, 1);
      }
    },
    configure(chart, item, options) {
      item.fullSize = options.fullSize;
      item.position = options.position;
      item.weight = options.weight;
    },
    update(chart, width, height, minPadding) {
      if (!chart) {
        return;
      }
      const padding = toPadding(chart.options.layout.padding);
      const availableWidth = Math.max(width - padding.width, 0);
      const availableHeight = Math.max(height - padding.height, 0);
      const boxes = buildLayoutBoxes(chart.boxes);
      const verticalBoxes = boxes.vertical;
      const horizontalBoxes = boxes.horizontal;
      each(chart.boxes, (box) => {
        if (typeof box.beforeLayout === "function") {
          box.beforeLayout();
        }
      });
      const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
      const params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding,
        availableWidth,
        availableHeight,
        vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
        hBoxMaxHeight: availableHeight / 2
      });
      const maxPadding = Object.assign({}, padding);
      updateMaxPadding(maxPadding, toPadding(minPadding));
      const chartArea = Object.assign({
        maxPadding,
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
      fitBoxes(boxes.fullSize, chartArea, params, stacks);
      fitBoxes(verticalBoxes, chartArea, params, stacks);
      if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
        fitBoxes(verticalBoxes, chartArea, params, stacks);
      }
      handleMaxPadding(chartArea);
      placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h,
        height: chartArea.h,
        width: chartArea.w
      };
      each(boxes.chartArea, (layout) => {
        const box = layout.box;
        Object.assign(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h, {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        });
      });
    }
  };
  var BasePlatform = class {
    acquireContext(canvas, aspectRatio) {
    }
    releaseContext(context) {
      return false;
    }
    addEventListener(chart, type, listener) {
    }
    removeEventListener(chart, type, listener) {
    }
    getDevicePixelRatio() {
      return 1;
    }
    getMaximumSize(element, width, height, aspectRatio) {
      width = Math.max(0, width || element.width);
      height = height || element.height;
      return {
        width,
        height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
      };
    }
    isAttached(canvas) {
      return true;
    }
    updateConfig(config) {
    }
  };
  var BasicPlatform = class extends BasePlatform {
    acquireContext(item) {
      return item && item.getContext && item.getContext("2d") || null;
    }
    updateConfig(config) {
      config.options.animation = false;
    }
  };
  var EXPANDO_KEY = "$chartjs";
  var EVENT_TYPES = {
    touchstart: "mousedown",
    touchmove: "mousemove",
    touchend: "mouseup",
    pointerenter: "mouseenter",
    pointerdown: "mousedown",
    pointermove: "mousemove",
    pointerup: "mouseup",
    pointerleave: "mouseout",
    pointerout: "mouseout"
  };
  var isNullOrEmpty = (value) => value === null || value === "";
  function initCanvas(canvas, aspectRatio) {
    const style = canvas.style;
    const renderHeight = canvas.getAttribute("height");
    const renderWidth = canvas.getAttribute("width");
    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    };
    style.display = style.display || "block";
    style.boxSizing = style.boxSizing || "border-box";
    if (isNullOrEmpty(renderWidth)) {
      const displayWidth = readUsedSize(canvas, "width");
      if (displayWidth !== void 0) {
        canvas.width = displayWidth;
      }
    }
    if (isNullOrEmpty(renderHeight)) {
      if (canvas.style.height === "") {
        canvas.height = canvas.width / (aspectRatio || 2);
      } else {
        const displayHeight = readUsedSize(canvas, "height");
        if (displayHeight !== void 0) {
          canvas.height = displayHeight;
        }
      }
    }
    return canvas;
  }
  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;
  function addListener(node, type, listener) {
    if (node) {
      node.addEventListener(type, listener, eventListenerOptions);
    }
  }
  function removeListener(chart, type, listener) {
    if (chart && chart.canvas) {
      chart.canvas.removeEventListener(type, listener, eventListenerOptions);
    }
  }
  function fromNativeEvent(event, chart) {
    const type = EVENT_TYPES[event.type] || event.type;
    const { x, y } = getRelativePosition(event, chart);
    return {
      type,
      chart,
      native: event,
      x: x !== void 0 ? x : null,
      y: y !== void 0 ? y : null
    };
  }
  function nodeListContains(nodeList, canvas) {
    for (const node of nodeList) {
      if (node === canvas || node.contains(canvas)) {
        return true;
      }
    }
  }
  function createAttachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.addedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  function createDetachObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const observer = new MutationObserver((entries) => {
      let trigger = false;
      for (const entry of entries) {
        trigger = trigger || nodeListContains(entry.removedNodes, canvas);
        trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
      }
      if (trigger) {
        listener();
      }
    });
    observer.observe(document, {
      childList: true,
      subtree: true
    });
    return observer;
  }
  var drpListeningCharts = /* @__PURE__ */ new Map();
  var oldDevicePixelRatio = 0;
  function onWindowResize() {
    const dpr = window.devicePixelRatio;
    if (dpr === oldDevicePixelRatio) {
      return;
    }
    oldDevicePixelRatio = dpr;
    drpListeningCharts.forEach((resize, chart) => {
      if (chart.currentDevicePixelRatio !== dpr) {
        resize();
      }
    });
  }
  function listenDevicePixelRatioChanges(chart, resize) {
    if (!drpListeningCharts.size) {
      window.addEventListener("resize", onWindowResize);
    }
    drpListeningCharts.set(chart, resize);
  }
  function unlistenDevicePixelRatioChanges(chart) {
    drpListeningCharts.delete(chart);
    if (!drpListeningCharts.size) {
      window.removeEventListener("resize", onWindowResize);
    }
  }
  function createResizeObserver(chart, type, listener) {
    const canvas = chart.canvas;
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      return;
    }
    const resize = throttled((width, height) => {
      const w = container.clientWidth;
      listener(width, height);
      if (w < container.clientWidth) {
        listener();
      }
    }, window);
    const observer = new ResizeObserver((entries) => {
      const entry = entries[0];
      const width = entry.contentRect.width;
      const height = entry.contentRect.height;
      if (width === 0 && height === 0) {
        return;
      }
      resize(width, height);
    });
    observer.observe(container);
    listenDevicePixelRatioChanges(chart, resize);
    return observer;
  }
  function releaseObserver(chart, type, observer) {
    if (observer) {
      observer.disconnect();
    }
    if (type === "resize") {
      unlistenDevicePixelRatioChanges(chart);
    }
  }
  function createProxyAndListen(chart, type, listener) {
    const canvas = chart.canvas;
    const proxy = throttled((event) => {
      if (chart.ctx !== null) {
        listener(fromNativeEvent(event, chart));
      }
    }, chart);
    addListener(canvas, type, proxy);
    return proxy;
  }
  var DomPlatform = class extends BasePlatform {
    acquireContext(canvas, aspectRatio) {
      const context = canvas && canvas.getContext && canvas.getContext("2d");
      if (context && context.canvas === canvas) {
        initCanvas(canvas, aspectRatio);
        return context;
      }
      return null;
    }
    releaseContext(context) {
      const canvas = context.canvas;
      if (!canvas[EXPANDO_KEY]) {
        return false;
      }
      const initial = canvas[EXPANDO_KEY].initial;
      [
        "height",
        "width"
      ].forEach((prop) => {
        const value = initial[prop];
        if (isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      const style = initial.style || {};
      Object.keys(style).forEach((key) => {
        canvas.style[key] = style[key];
      });
      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
      return true;
    }
    addEventListener(chart, type, listener) {
      this.removeEventListener(chart, type);
      const proxies = chart.$proxies || (chart.$proxies = {});
      const handlers = {
        attach: createAttachObserver,
        detach: createDetachObserver,
        resize: createResizeObserver
      };
      const handler = handlers[type] || createProxyAndListen;
      proxies[type] = handler(chart, type, listener);
    }
    removeEventListener(chart, type) {
      const proxies = chart.$proxies || (chart.$proxies = {});
      const proxy = proxies[type];
      if (!proxy) {
        return;
      }
      const handlers = {
        attach: releaseObserver,
        detach: releaseObserver,
        resize: releaseObserver
      };
      const handler = handlers[type] || removeListener;
      handler(chart, type, proxy);
      proxies[type] = void 0;
    }
    getDevicePixelRatio() {
      return window.devicePixelRatio;
    }
    getMaximumSize(canvas, width, height, aspectRatio) {
      return getMaximumSize(canvas, width, height, aspectRatio);
    }
    isAttached(canvas) {
      const container = canvas && _getParentNode(canvas);
      return !!(container && container.isConnected);
    }
  };
  function _detectPlatform(canvas) {
    if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
      return BasicPlatform;
    }
    return DomPlatform;
  }
  var Element = class {
    constructor() {
      __publicField(this, "x");
      __publicField(this, "y");
      __publicField(this, "active", false);
      __publicField(this, "options");
      __publicField(this, "$animations");
    }
    tooltipPosition(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    hasValue() {
      return isNumber(this.x) && isNumber(this.y);
    }
    getProps(props, final) {
      const anims = this.$animations;
      if (!final || !anims) {
        return this;
      }
      const ret = {};
      props.forEach((prop) => {
        ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
      });
      return ret;
    }
  };
  __publicField(Element, "defaults", {});
  __publicField(Element, "defaultRoutes");
  function autoSkip(scale, ticks) {
    const tickOpts = scale.options.ticks;
    const determinedMaxTicks = determineMaxTicks(scale);
    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
    const numMajorIndices = majorIndices.length;
    const first = majorIndices[0];
    const last = majorIndices[numMajorIndices - 1];
    const newTicks = [];
    if (numMajorIndices > ticksLimit) {
      skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
      return newTicks;
    }
    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
    if (numMajorIndices > 0) {
      let i, ilen;
      const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
      skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
      for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
        skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
      }
      skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
      return newTicks;
    }
    skip(ticks, newTicks, spacing);
    return newTicks;
  }
  function determineMaxTicks(scale) {
    const offset = scale.options.offset;
    const tickLength = scale._tickSize();
    const maxScale = scale._length / tickLength + (offset ? 0 : 1);
    const maxChart = scale._maxLength / tickLength;
    return Math.floor(Math.min(maxScale, maxChart));
  }
  function calculateSpacing(majorIndices, ticks, ticksLimit) {
    const evenMajorSpacing = getEvenSpacing(majorIndices);
    const spacing = ticks.length / ticksLimit;
    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }
    const factors = _factorize(evenMajorSpacing);
    for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
      const factor = factors[i];
      if (factor > spacing) {
        return factor;
      }
    }
    return Math.max(spacing, 1);
  }
  function getMajorIndices(ticks) {
    const result = [];
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (ticks[i].major) {
        result.push(i);
      }
    }
    return result;
  }
  function skipMajors(ticks, newTicks, majorIndices, spacing) {
    let count = 0;
    let next = majorIndices[0];
    let i;
    spacing = Math.ceil(spacing);
    for (i = 0; i < ticks.length; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = majorIndices[count * spacing];
      }
    }
  }
  function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
    const start = valueOrDefault(majorStart, 0);
    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
    let count = 0;
    let length, i, next;
    spacing = Math.ceil(spacing);
    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }
    next = start;
    while (next < 0) {
      count++;
      next = Math.round(start + count * spacing);
    }
    for (i = Math.max(start, 0); i < end; i++) {
      if (i === next) {
        newTicks.push(ticks[i]);
        count++;
        next = Math.round(start + count * spacing);
      }
    }
  }
  function getEvenSpacing(arr) {
    const len = arr.length;
    let i, diff;
    if (len < 2) {
      return false;
    }
    for (diff = arr[0], i = 1; i < len; ++i) {
      if (arr[i] - arr[i - 1] !== diff) {
        return false;
      }
    }
    return diff;
  }
  var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
  var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
  var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
  function sample(arr, numItems) {
    const result = [];
    const increment = arr.length / numItems;
    const len = arr.length;
    let i = 0;
    for (; i < len; i += increment) {
      result.push(arr[Math.floor(i)]);
    }
    return result;
  }
  function getPixelForGridLine(scale, index2, offsetGridLines) {
    const length = scale.ticks.length;
    const validIndex2 = Math.min(index2, length - 1);
    const start = scale._startPixel;
    const end = scale._endPixel;
    const epsilon = 1e-6;
    let lineValue = scale.getPixelForTick(validIndex2);
    let offset;
    if (offsetGridLines) {
      if (length === 1) {
        offset = Math.max(lineValue - start, end - lineValue);
      } else if (index2 === 0) {
        offset = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
      }
      lineValue += validIndex2 < index2 ? offset : -offset;
      if (lineValue < start - epsilon || lineValue > end + epsilon) {
        return;
      }
    }
    return lineValue;
  }
  function garbageCollect(caches, length) {
    each(caches, (cache) => {
      const gc = cache.gc;
      const gcLen = gc.length / 2;
      let i;
      if (gcLen > length) {
        for (i = 0; i < gcLen; ++i) {
          delete cache.data[gc[i]];
        }
        gc.splice(0, gcLen);
      }
    });
  }
  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickLength : 0;
  }
  function getTitleHeight(options, fallback) {
    if (!options.display) {
      return 0;
    }
    const font = toFont(options.font, fallback);
    const padding = toPadding(options.padding);
    const lines = isArray(options.text) ? options.text.length : 1;
    return lines * font.lineHeight + padding.height;
  }
  function createScaleContext(parent, scale) {
    return createContext(parent, {
      scale,
      type: "scale"
    });
  }
  function createTickContext(parent, index2, tick) {
    return createContext(parent, {
      tick,
      index: index2,
      type: "tick"
    });
  }
  function titleAlign(align, position, reverse) {
    let ret = _toLeftRightCenter(align);
    if (reverse && position !== "right" || !reverse && position === "right") {
      ret = reverseAlign(ret);
    }
    return ret;
  }
  function titleArgs(scale, offset, position, align) {
    const { top: top2, left, bottom: bottom2, right, chart } = scale;
    const { chartArea, scales: scales2 } = chart;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    const height = bottom2 - top2;
    const width = right - left;
    if (scale.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
      } else if (position === "center") {
        titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
      } else {
        titleY = offsetFromEdge(scale, position, offset);
      }
      maxWidth = right - left;
    } else {
      if (isObject2(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
      } else if (position === "center") {
        titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
      } else {
        titleX = offsetFromEdge(scale, position, offset);
      }
      titleY = _alignStartEnd(align, bottom2, top2);
      rotation = position === "left" ? -HALF_PI : HALF_PI;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  var Scale = class extends Element {
    constructor(cfg) {
      super();
      this.id = cfg.id;
      this.type = cfg.type;
      this.options = void 0;
      this.ctx = cfg.ctx;
      this.chart = cfg.chart;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this._margins = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      this.maxWidth = void 0;
      this.maxHeight = void 0;
      this.paddingTop = void 0;
      this.paddingBottom = void 0;
      this.paddingLeft = void 0;
      this.paddingRight = void 0;
      this.axis = void 0;
      this.labelRotation = void 0;
      this.min = void 0;
      this.max = void 0;
      this._range = void 0;
      this.ticks = [];
      this._gridLineItems = null;
      this._labelItems = null;
      this._labelSizes = null;
      this._length = 0;
      this._maxLength = 0;
      this._longestTextCache = {};
      this._startPixel = void 0;
      this._endPixel = void 0;
      this._reversePixels = false;
      this._userMax = void 0;
      this._userMin = void 0;
      this._suggestedMax = void 0;
      this._suggestedMin = void 0;
      this._ticksLength = 0;
      this._borderValue = 0;
      this._cache = {};
      this._dataLimitsCached = false;
      this.$context = void 0;
    }
    init(options) {
      this.options = options.setContext(this.getContext());
      this.axis = options.axis;
      this._userMin = this.parse(options.min);
      this._userMax = this.parse(options.max);
      this._suggestedMin = this.parse(options.suggestedMin);
      this._suggestedMax = this.parse(options.suggestedMax);
    }
    parse(raw, index2) {
      return raw;
    }
    getUserBounds() {
      let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
      _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
      _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
      _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
      _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
      return {
        min: finiteOrDefault(_userMin, _suggestedMin),
        max: finiteOrDefault(_userMax, _suggestedMax),
        minDefined: isNumberFinite(_userMin),
        maxDefined: isNumberFinite(_userMax)
      };
    }
    getMinMax(canStack) {
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      let range2;
      if (minDefined && maxDefined) {
        return {
          min,
          max
        };
      }
      const metas = this.getMatchingVisibleMetas();
      for (let i = 0, ilen = metas.length; i < ilen; ++i) {
        range2 = metas[i].controller.getMinMax(this, canStack);
        if (!minDefined) {
          min = Math.min(min, range2.min);
        }
        if (!maxDefined) {
          max = Math.max(max, range2.max);
        }
      }
      min = maxDefined && min > max ? max : min;
      max = minDefined && min > max ? min : max;
      return {
        min: finiteOrDefault(min, finiteOrDefault(max, min)),
        max: finiteOrDefault(max, finiteOrDefault(min, max))
      };
    }
    getPadding() {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      };
    }
    getTicks() {
      return this.ticks;
    }
    getLabels() {
      const data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    }
    getLabelItems(chartArea = this.chart.chartArea) {
      const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
      return items;
    }
    beforeLayout() {
      this._cache = {};
      this._dataLimitsCached = false;
    }
    beforeUpdate() {
      callback(this.options.beforeUpdate, [
        this
      ]);
    }
    update(maxWidth, maxHeight, margins) {
      const { beginAtZero, grace, ticks: tickOpts } = this.options;
      const sampleSize = tickOpts.sampleSize;
      this.beforeUpdate();
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins = Object.assign({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      this.ticks = null;
      this._labelSizes = null;
      this._gridLineItems = null;
      this._labelItems = null;
      this.beforeSetDimensions();
      this.setDimensions();
      this.afterSetDimensions();
      this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
      if (!this._dataLimitsCached) {
        this.beforeDataLimits();
        this.determineDataLimits();
        this.afterDataLimits();
        this._range = _addGrace(this, grace, beginAtZero);
        this._dataLimitsCached = true;
      }
      this.beforeBuildTicks();
      this.ticks = this.buildTicks() || [];
      this.afterBuildTicks();
      const samplingEnabled = sampleSize < this.ticks.length;
      this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
      this.configure();
      this.beforeCalculateLabelRotation();
      this.calculateLabelRotation();
      this.afterCalculateLabelRotation();
      if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
        this.ticks = autoSkip(this, this.ticks);
        this._labelSizes = null;
        this.afterAutoSkip();
      }
      if (samplingEnabled) {
        this._convertTicksToLabels(this.ticks);
      }
      this.beforeFit();
      this.fit();
      this.afterFit();
      this.afterUpdate();
    }
    configure() {
      let reversePixels = this.options.reverse;
      let startPixel, endPixel;
      if (this.isHorizontal()) {
        startPixel = this.left;
        endPixel = this.right;
      } else {
        startPixel = this.top;
        endPixel = this.bottom;
        reversePixels = !reversePixels;
      }
      this._startPixel = startPixel;
      this._endPixel = endPixel;
      this._reversePixels = reversePixels;
      this._length = endPixel - startPixel;
      this._alignToPixels = this.options.alignToPixels;
    }
    afterUpdate() {
      callback(this.options.afterUpdate, [
        this
      ]);
    }
    beforeSetDimensions() {
      callback(this.options.beforeSetDimensions, [
        this
      ]);
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = 0;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = 0;
        this.bottom = this.height;
      }
      this.paddingLeft = 0;
      this.paddingTop = 0;
      this.paddingRight = 0;
      this.paddingBottom = 0;
    }
    afterSetDimensions() {
      callback(this.options.afterSetDimensions, [
        this
      ]);
    }
    _callHooks(name) {
      this.chart.notifyPlugins(name, this.getContext());
      callback(this.options[name], [
        this
      ]);
    }
    beforeDataLimits() {
      this._callHooks("beforeDataLimits");
    }
    determineDataLimits() {
    }
    afterDataLimits() {
      this._callHooks("afterDataLimits");
    }
    beforeBuildTicks() {
      this._callHooks("beforeBuildTicks");
    }
    buildTicks() {
      return [];
    }
    afterBuildTicks() {
      this._callHooks("afterBuildTicks");
    }
    beforeTickToLabelConversion() {
      callback(this.options.beforeTickToLabelConversion, [
        this
      ]);
    }
    generateTickLabels(ticks) {
      const tickOpts = this.options.ticks;
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        tick = ticks[i];
        tick.label = callback(tickOpts.callback, [
          tick.value,
          i,
          ticks
        ], this);
      }
    }
    afterTickToLabelConversion() {
      callback(this.options.afterTickToLabelConversion, [
        this
      ]);
    }
    beforeCalculateLabelRotation() {
      callback(this.options.beforeCalculateLabelRotation, [
        this
      ]);
    }
    calculateLabelRotation() {
      const options = this.options;
      const tickOpts = options.ticks;
      const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
      const minRotation = tickOpts.minRotation || 0;
      const maxRotation = tickOpts.maxRotation;
      let labelRotation = minRotation;
      let tickWidth, maxHeight, maxLabelDiagonal;
      if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
        this.labelRotation = minRotation;
        return;
      }
      const labelSizes = this._getLabelSizes();
      const maxLabelWidth = labelSizes.widest.width;
      const maxLabelHeight = labelSizes.highest.height;
      const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
      tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }
      this.labelRotation = labelRotation;
    }
    afterCalculateLabelRotation() {
      callback(this.options.afterCalculateLabelRotation, [
        this
      ]);
    }
    afterAutoSkip() {
    }
    beforeFit() {
      callback(this.options.beforeFit, [
        this
      ]);
    }
    fit() {
      const minSize = {
        width: 0,
        height: 0
      };
      const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
      const display = this._isVisible();
      const isHorizontal = this.isHorizontal();
      if (display) {
        const titleHeight = getTitleHeight(titleOpts, chart.options.font);
        if (isHorizontal) {
          minSize.width = this.maxWidth;
          minSize.height = getTickMarkLength(gridOpts) + titleHeight;
        } else {
          minSize.height = this.maxHeight;
          minSize.width = getTickMarkLength(gridOpts) + titleHeight;
        }
        if (tickOpts.display && this.ticks.length) {
          const { first, last, widest, highest } = this._getLabelSizes();
          const tickPadding = tickOpts.padding * 2;
          const angleRadians = toRadians(this.labelRotation);
          const cos = Math.cos(angleRadians);
          const sin = Math.sin(angleRadians);
          if (isHorizontal) {
            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
          } else {
            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
          }
          this._calculatePadding(first, last, sin, cos);
        }
      }
      this._handleMargins();
      if (isHorizontal) {
        this.width = this._length = chart.width - this._margins.left - this._margins.right;
        this.height = minSize.height;
      } else {
        this.width = minSize.width;
        this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
      }
    }
    _calculatePadding(first, last, sin, cos) {
      const { ticks: { align, padding }, position } = this.options;
      const isRotated = this.labelRotation !== 0;
      const labelsBelowTicks = position !== "top" && this.axis === "x";
      if (this.isHorizontal()) {
        const offsetLeft = this.getPixelForTick(0) - this.left;
        const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
        let paddingLeft = 0;
        let paddingRight = 0;
        if (isRotated) {
          if (labelsBelowTicks) {
            paddingLeft = cos * first.width;
            paddingRight = sin * last.height;
          } else {
            paddingLeft = sin * first.height;
            paddingRight = cos * last.width;
          }
        } else if (align === "start") {
          paddingRight = last.width;
        } else if (align === "end") {
          paddingLeft = first.width;
        } else if (align !== "inner") {
          paddingLeft = first.width / 2;
          paddingRight = last.width / 2;
        }
        this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
        this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
      } else {
        let paddingTop = last.height / 2;
        let paddingBottom = first.height / 2;
        if (align === "start") {
          paddingTop = 0;
          paddingBottom = first.height;
        } else if (align === "end") {
          paddingTop = last.height;
          paddingBottom = 0;
        }
        this.paddingTop = paddingTop + padding;
        this.paddingBottom = paddingBottom + padding;
      }
    }
    _handleMargins() {
      if (this._margins) {
        this._margins.left = Math.max(this.paddingLeft, this._margins.left);
        this._margins.top = Math.max(this.paddingTop, this._margins.top);
        this._margins.right = Math.max(this.paddingRight, this._margins.right);
        this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
      }
    }
    afterFit() {
      callback(this.options.afterFit, [
        this
      ]);
    }
    isHorizontal() {
      const { axis, position } = this.options;
      return position === "top" || position === "bottom" || axis === "x";
    }
    isFullSize() {
      return this.options.fullSize;
    }
    _convertTicksToLabels(ticks) {
      this.beforeTickToLabelConversion();
      this.generateTickLabels(ticks);
      let i, ilen;
      for (i = 0, ilen = ticks.length; i < ilen; i++) {
        if (isNullOrUndef(ticks[i].label)) {
          ticks.splice(i, 1);
          ilen--;
          i--;
        }
      }
      this.afterTickToLabelConversion();
    }
    _getLabelSizes() {
      let labelSizes = this._labelSizes;
      if (!labelSizes) {
        const sampleSize = this.options.ticks.sampleSize;
        let ticks = this.ticks;
        if (sampleSize < ticks.length) {
          ticks = sample(ticks, sampleSize);
        }
        this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
      }
      return labelSizes;
    }
    _computeLabelSizes(ticks, length, maxTicksLimit) {
      const { ctx, _longestTextCache: caches } = this;
      const widths = [];
      const heights = [];
      const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
      let widestLabelSize = 0;
      let highestLabelSize = 0;
      let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
      for (i = 0; i < length; i += increment) {
        label = ticks[i].label;
        tickFont = this._resolveTickFontOptions(i);
        ctx.font = fontString = tickFont.string;
        cache = caches[fontString] = caches[fontString] || {
          data: {},
          gc: []
        };
        lineHeight = tickFont.lineHeight;
        width = height = 0;
        if (!isNullOrUndef(label) && !isArray(label)) {
          width = _measureText(ctx, cache.data, cache.gc, width, label);
          height = lineHeight;
        } else if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            nestedLabel = label[j];
            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
              width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
              height += lineHeight;
            }
          }
        }
        widths.push(width);
        heights.push(height);
        widestLabelSize = Math.max(width, widestLabelSize);
        highestLabelSize = Math.max(height, highestLabelSize);
      }
      garbageCollect(caches, length);
      const widest = widths.indexOf(widestLabelSize);
      const highest = heights.indexOf(highestLabelSize);
      const valueAt = (idx) => ({
        width: widths[idx] || 0,
        height: heights[idx] || 0
      });
      return {
        first: valueAt(0),
        last: valueAt(length - 1),
        widest: valueAt(widest),
        highest: valueAt(highest),
        widths,
        heights
      };
    }
    getLabelForValue(value) {
      return value;
    }
    getPixelForValue(value, index2) {
      return NaN;
    }
    getValueForPixel(pixel) {
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getPixelForDecimal(decimal) {
      if (this._reversePixels) {
        decimal = 1 - decimal;
      }
      const pixel = this._startPixel + decimal * this._length;
      return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
    }
    getDecimalForPixel(pixel) {
      const decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    }
    getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    }
    getBaseValue() {
      const { min, max } = this;
      return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    }
    getContext(index2) {
      const ticks = this.ticks || [];
      if (index2 >= 0 && index2 < ticks.length) {
        const tick = ticks[index2];
        return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
      }
      return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
    }
    _tickSize() {
      const optionTicks = this.options.ticks;
      const rot = toRadians(this.labelRotation);
      const cos = Math.abs(Math.cos(rot));
      const sin = Math.abs(Math.sin(rot));
      const labelSizes = this._getLabelSizes();
      const padding = optionTicks.autoSkipPadding || 0;
      const w = labelSizes ? labelSizes.widest.width + padding : 0;
      const h = labelSizes ? labelSizes.highest.height + padding : 0;
      return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    }
    _isVisible() {
      const display = this.options.display;
      if (display !== "auto") {
        return !!display;
      }
      return this.getMatchingVisibleMetas().length > 0;
    }
    _computeGridLineItems(chartArea) {
      const axis = this.axis;
      const chart = this.chart;
      const options = this.options;
      const { grid, position, border } = options;
      const offset = grid.offset;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const ticksLength = ticks.length + (offset ? 1 : 0);
      const tl = getTickMarkLength(grid);
      const items = [];
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = borderOpts.display ? borderOpts.width : 0;
      const axisHalfWidth = axisWidth / 2;
      const alignBorderValue = function(pixel) {
        return _alignPixel(chart, pixel, axisWidth);
      };
      let borderValue, i, lineValue, alignedLineValue;
      let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
      if (position === "top") {
        borderValue = alignBorderValue(this.bottom);
        ty1 = this.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position === "bottom") {
        borderValue = alignBorderValue(this.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = this.top + tl;
      } else if (position === "left") {
        borderValue = alignBorderValue(this.right);
        tx1 = this.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else if (position === "right") {
        borderValue = alignBorderValue(this.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = this.left + tl;
      } else if (axis === "x") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        y1 = chartArea.top;
        y2 = chartArea.bottom;
        ty1 = borderValue + axisHalfWidth;
        ty2 = ty1 + tl;
      } else if (axis === "y") {
        if (position === "center") {
          borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
        }
        tx1 = borderValue - axisHalfWidth;
        tx2 = tx1 - tl;
        x1 = chartArea.left;
        x2 = chartArea.right;
      }
      const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
      const step = Math.max(1, Math.ceil(ticksLength / limit));
      for (i = 0; i < ticksLength; i += step) {
        const context = this.getContext(i);
        const optsAtIndex = grid.setContext(context);
        const optsAtIndexBorder = border.setContext(context);
        const lineWidth = optsAtIndex.lineWidth;
        const lineColor = optsAtIndex.color;
        const borderDash = optsAtIndexBorder.dash || [];
        const borderDashOffset = optsAtIndexBorder.dashOffset;
        const tickWidth = optsAtIndex.tickWidth;
        const tickColor = optsAtIndex.tickColor;
        const tickBorderDash = optsAtIndex.tickBorderDash || [];
        const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
        lineValue = getPixelForGridLine(this, i, offset);
        if (lineValue === void 0) {
          continue;
        }
        alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }
        items.push({
          tx1,
          ty1,
          tx2,
          ty2,
          x1,
          y1,
          x2,
          y2,
          width: lineWidth,
          color: lineColor,
          borderDash,
          borderDashOffset,
          tickWidth,
          tickColor,
          tickBorderDash,
          tickBorderDashOffset
        });
      }
      this._ticksLength = ticksLength;
      this._borderValue = borderValue;
      return items;
    }
    _computeLabelItems(chartArea) {
      const axis = this.axis;
      const options = this.options;
      const { position, ticks: optionTicks } = options;
      const isHorizontal = this.isHorizontal();
      const ticks = this.ticks;
      const { align, crossAlign, padding, mirror } = optionTicks;
      const tl = getTickMarkLength(options.grid);
      const tickAndPadding = tl + padding;
      const hTickAndPadding = mirror ? -padding : tickAndPadding;
      const rotation = -toRadians(this.labelRotation);
      const items = [];
      let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
      let textBaseline = "middle";
      if (position === "top") {
        y = this.bottom - hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "bottom") {
        y = this.top + hTickAndPadding;
        textAlign = this._getXAxisLabelAlignment();
      } else if (position === "left") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (position === "right") {
        const ret = this._getYAxisLabelAlignment(tl);
        textAlign = ret.textAlign;
        x = ret.x;
      } else if (axis === "x") {
        if (position === "center") {
          y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
        }
        textAlign = this._getXAxisLabelAlignment();
      } else if (axis === "y") {
        if (position === "center") {
          x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
        } else if (isObject2(position)) {
          const positionAxisID = Object.keys(position)[0];
          const value = position[positionAxisID];
          x = this.chart.scales[positionAxisID].getPixelForValue(value);
        }
        textAlign = this._getYAxisLabelAlignment(tl).textAlign;
      }
      if (axis === "y") {
        if (align === "start") {
          textBaseline = "top";
        } else if (align === "end") {
          textBaseline = "bottom";
        }
      }
      const labelSizes = this._getLabelSizes();
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        label = tick.label;
        const optsAtIndex = optionTicks.setContext(this.getContext(i));
        pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
        font = this._resolveTickFontOptions(i);
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;
        const halfCount = lineCount / 2;
        const color2 = optsAtIndex.color;
        const strokeColor = optsAtIndex.textStrokeColor;
        const strokeWidth = optsAtIndex.textStrokeWidth;
        let tickTextAlign = textAlign;
        if (isHorizontal) {
          x = pixel;
          if (textAlign === "inner") {
            if (i === ilen - 1) {
              tickTextAlign = !this.options.reverse ? "right" : "left";
            } else if (i === 0) {
              tickTextAlign = !this.options.reverse ? "left" : "right";
            } else {
              tickTextAlign = "center";
            }
          }
          if (position === "top") {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = -lineCount * lineHeight + lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
            } else {
              textOffset = -labelSizes.highest.height + lineHeight / 2;
            }
          } else {
            if (crossAlign === "near" || rotation !== 0) {
              textOffset = lineHeight / 2;
            } else if (crossAlign === "center") {
              textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
            } else {
              textOffset = labelSizes.highest.height - lineCount * lineHeight;
            }
          }
          if (mirror) {
            textOffset *= -1;
          }
          if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
            x += lineHeight / 2 * Math.sin(rotation);
          }
        } else {
          y = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }
        let backdrop;
        if (optsAtIndex.showLabelBackdrop) {
          const labelPadding = toPadding(optsAtIndex.backdropPadding);
          const height = labelSizes.heights[i];
          const width = labelSizes.widths[i];
          let top2 = textOffset - labelPadding.top;
          let left = 0 - labelPadding.left;
          switch (textBaseline) {
            case "middle":
              top2 -= height / 2;
              break;
            case "bottom":
              top2 -= height;
              break;
          }
          switch (textAlign) {
            case "center":
              left -= width / 2;
              break;
            case "right":
              left -= width;
              break;
            case "inner":
              if (i === ilen - 1) {
                left -= width;
              } else if (i > 0) {
                left -= width / 2;
              }
              break;
          }
          backdrop = {
            left,
            top: top2,
            width: width + labelPadding.width,
            height: height + labelPadding.height,
            color: optsAtIndex.backdropColor
          };
        }
        items.push({
          label,
          font,
          textOffset,
          options: {
            rotation,
            color: color2,
            strokeColor,
            strokeWidth,
            textAlign: tickTextAlign,
            textBaseline,
            translation: [
              x,
              y
            ],
            backdrop
          }
        });
      }
      return items;
    }
    _getXAxisLabelAlignment() {
      const { position, ticks } = this.options;
      const rotation = -toRadians(this.labelRotation);
      if (rotation) {
        return position === "top" ? "left" : "right";
      }
      let align = "center";
      if (ticks.align === "start") {
        align = "left";
      } else if (ticks.align === "end") {
        align = "right";
      } else if (ticks.align === "inner") {
        align = "inner";
      }
      return align;
    }
    _getYAxisLabelAlignment(tl) {
      const { position, ticks: { crossAlign, mirror, padding } } = this.options;
      const labelSizes = this._getLabelSizes();
      const tickAndPadding = tl + padding;
      const widest = labelSizes.widest.width;
      let textAlign;
      let x;
      if (position === "left") {
        if (mirror) {
          x = this.right + padding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x += widest;
          }
        } else {
          x = this.right - tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x = this.left;
          }
        }
      } else if (position === "right") {
        if (mirror) {
          x = this.left + padding;
          if (crossAlign === "near") {
            textAlign = "right";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x -= widest / 2;
          } else {
            textAlign = "left";
            x -= widest;
          }
        } else {
          x = this.left + tickAndPadding;
          if (crossAlign === "near") {
            textAlign = "left";
          } else if (crossAlign === "center") {
            textAlign = "center";
            x += widest / 2;
          } else {
            textAlign = "right";
            x = this.right;
          }
        }
      } else {
        textAlign = "right";
      }
      return {
        textAlign,
        x
      };
    }
    _computeLabelArea() {
      if (this.options.ticks.mirror) {
        return;
      }
      const chart = this.chart;
      const position = this.options.position;
      if (position === "left" || position === "right") {
        return {
          top: 0,
          left: this.left,
          bottom: chart.height,
          right: this.right
        };
      }
      if (position === "top" || position === "bottom") {
        return {
          top: this.top,
          left: 0,
          bottom: this.bottom,
          right: chart.width
        };
      }
    }
    drawBackground() {
      const { ctx, options: { backgroundColor }, left, top: top2, width, height } = this;
      if (backgroundColor) {
        ctx.save();
        ctx.fillStyle = backgroundColor;
        ctx.fillRect(left, top2, width, height);
        ctx.restore();
      }
    }
    getLineWidthForValue(value) {
      const grid = this.options.grid;
      if (!this._isVisible() || !grid.display) {
        return 0;
      }
      const ticks = this.ticks;
      const index2 = ticks.findIndex((t) => t.value === value);
      if (index2 >= 0) {
        const opts = grid.setContext(this.getContext(index2));
        return opts.lineWidth;
      }
      return 0;
    }
    drawGrid(chartArea) {
      const grid = this.options.grid;
      const ctx = this.ctx;
      const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
      let i, ilen;
      const drawLine = (p1, p2, style) => {
        if (!style.width || !style.color) {
          return;
        }
        ctx.save();
        ctx.lineWidth = style.width;
        ctx.strokeStyle = style.color;
        ctx.setLineDash(style.borderDash || []);
        ctx.lineDashOffset = style.borderDashOffset;
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        ctx.restore();
      };
      if (grid.display) {
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          const item = items[i];
          if (grid.drawOnChartArea) {
            drawLine({
              x: item.x1,
              y: item.y1
            }, {
              x: item.x2,
              y: item.y2
            }, item);
          }
          if (grid.drawTicks) {
            drawLine({
              x: item.tx1,
              y: item.ty1
            }, {
              x: item.tx2,
              y: item.ty2
            }, {
              color: item.tickColor,
              width: item.tickWidth,
              borderDash: item.tickBorderDash,
              borderDashOffset: item.tickBorderDashOffset
            });
          }
        }
      }
    }
    drawBorder() {
      const { chart, ctx, options: { border, grid } } = this;
      const borderOpts = border.setContext(this.getContext());
      const axisWidth = border.display ? borderOpts.width : 0;
      if (!axisWidth) {
        return;
      }
      const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
      const borderValue = this._borderValue;
      let x1, x2, y1, y2;
      if (this.isHorizontal()) {
        x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
        x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
        y1 = y2 = borderValue;
      } else {
        y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
        y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
        x1 = x2 = borderValue;
      }
      ctx.save();
      ctx.lineWidth = borderOpts.width;
      ctx.strokeStyle = borderOpts.color;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      ctx.restore();
    }
    drawLabels(chartArea) {
      const optionTicks = this.options.ticks;
      if (!optionTicks.display) {
        return;
      }
      const ctx = this.ctx;
      const area = this._computeLabelArea();
      if (area) {
        clipArea(ctx, area);
      }
      const items = this.getLabelItems(chartArea);
      for (const item of items) {
        const renderTextOptions = item.options;
        const tickFont = item.font;
        const label = item.label;
        const y = item.textOffset;
        renderText(ctx, label, 0, y, tickFont, renderTextOptions);
      }
      if (area) {
        unclipArea(ctx);
      }
    }
    drawTitle() {
      const { ctx, options: { position, title, reverse } } = this;
      if (!title.display) {
        return;
      }
      const font = toFont(title.font);
      const padding = toPadding(title.padding);
      const align = title.align;
      let offset = font.lineHeight / 2;
      if (position === "bottom" || position === "center" || isObject2(position)) {
        offset += padding.bottom;
        if (isArray(title.text)) {
          offset += font.lineHeight * (title.text.length - 1);
        }
      } else {
        offset += padding.top;
      }
      const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
      renderText(ctx, title.text, 0, 0, font, {
        color: title.color,
        maxWidth,
        rotation,
        textAlign: titleAlign(align, position, reverse),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
    draw(chartArea) {
      if (!this._isVisible()) {
        return;
      }
      this.drawBackground();
      this.drawGrid(chartArea);
      this.drawBorder();
      this.drawTitle();
      this.drawLabels(chartArea);
    }
    _layers() {
      const opts = this.options;
      const tz = opts.ticks && opts.ticks.z || 0;
      const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
      const bz = valueOrDefault(opts.border && opts.border.z, 0);
      if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
        return [
          {
            z: tz,
            draw: (chartArea) => {
              this.draw(chartArea);
            }
          }
        ];
      }
      return [
        {
          z: gz,
          draw: (chartArea) => {
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawTitle();
          }
        },
        {
          z: bz,
          draw: () => {
            this.drawBorder();
          }
        },
        {
          z: tz,
          draw: (chartArea) => {
            this.drawLabels(chartArea);
          }
        }
      ];
    }
    getMatchingVisibleMetas(type) {
      const metas = this.chart.getSortedVisibleDatasetMetas();
      const axisID = this.axis + "AxisID";
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        const meta = metas[i];
        if (meta[axisID] === this.id && (!type || meta.type === type)) {
          result.push(meta);
        }
      }
      return result;
    }
    _resolveTickFontOptions(index2) {
      const opts = this.options.ticks.setContext(this.getContext(index2));
      return toFont(opts.font);
    }
    _maxDigits() {
      const fontSize = this._resolveTickFontOptions(0).lineHeight;
      return (this.isHorizontal() ? this.width : this.height) / fontSize;
    }
  };
  var TypedRegistry = class {
    constructor(type, scope, override) {
      this.type = type;
      this.scope = scope;
      this.override = override;
      this.items = /* @__PURE__ */ Object.create(null);
    }
    isForType(type) {
      return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
    }
    register(item) {
      const proto = Object.getPrototypeOf(item);
      let parentScope;
      if (isIChartComponent(proto)) {
        parentScope = this.register(proto);
      }
      const items = this.items;
      const id = item.id;
      const scope = this.scope + "." + id;
      if (!id) {
        throw new Error("class does not have id: " + item);
      }
      if (id in items) {
        return scope;
      }
      items[id] = item;
      registerDefaults(item, scope, parentScope);
      if (this.override) {
        defaults.override(item.id, item.overrides);
      }
      return scope;
    }
    get(id) {
      return this.items[id];
    }
    unregister(item) {
      const items = this.items;
      const id = item.id;
      const scope = this.scope;
      if (id in items) {
        delete items[id];
      }
      if (scope && id in defaults[scope]) {
        delete defaults[scope][id];
        if (this.override) {
          delete overrides[id];
        }
      }
    }
  };
  function registerDefaults(item, scope, parentScope) {
    const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
      parentScope ? defaults.get(parentScope) : {},
      defaults.get(scope),
      item.defaults
    ]);
    defaults.set(scope, itemDefaults);
    if (item.defaultRoutes) {
      routeDefaults(scope, item.defaultRoutes);
    }
    if (item.descriptors) {
      defaults.describe(scope, item.descriptors);
    }
  }
  function routeDefaults(scope, routes) {
    Object.keys(routes).forEach((property) => {
      const propertyParts = property.split(".");
      const sourceName = propertyParts.pop();
      const sourceScope = [
        scope
      ].concat(propertyParts).join(".");
      const parts = routes[property].split(".");
      const targetName = parts.pop();
      const targetScope = parts.join(".");
      defaults.route(sourceScope, sourceName, targetScope, targetName);
    });
  }
  function isIChartComponent(proto) {
    return "id" in proto && "defaults" in proto;
  }
  var Registry = class {
    constructor() {
      this.controllers = new TypedRegistry(DatasetController, "datasets", true);
      this.elements = new TypedRegistry(Element, "elements");
      this.plugins = new TypedRegistry(Object, "plugins");
      this.scales = new TypedRegistry(Scale, "scales");
      this._typedRegistries = [
        this.controllers,
        this.scales,
        this.elements
      ];
    }
    add(...args) {
      this._each("register", args);
    }
    remove(...args) {
      this._each("unregister", args);
    }
    addControllers(...args) {
      this._each("register", args, this.controllers);
    }
    addElements(...args) {
      this._each("register", args, this.elements);
    }
    addPlugins(...args) {
      this._each("register", args, this.plugins);
    }
    addScales(...args) {
      this._each("register", args, this.scales);
    }
    getController(id) {
      return this._get(id, this.controllers, "controller");
    }
    getElement(id) {
      return this._get(id, this.elements, "element");
    }
    getPlugin(id) {
      return this._get(id, this.plugins, "plugin");
    }
    getScale(id) {
      return this._get(id, this.scales, "scale");
    }
    removeControllers(...args) {
      this._each("unregister", args, this.controllers);
    }
    removeElements(...args) {
      this._each("unregister", args, this.elements);
    }
    removePlugins(...args) {
      this._each("unregister", args, this.plugins);
    }
    removeScales(...args) {
      this._each("unregister", args, this.scales);
    }
    _each(method, args, typedRegistry) {
      [
        ...args
      ].forEach((arg) => {
        const reg = typedRegistry || this._getRegistryForType(arg);
        if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
          this._exec(method, reg, arg);
        } else {
          each(arg, (item) => {
            const itemReg = typedRegistry || this._getRegistryForType(item);
            this._exec(method, itemReg, item);
          });
        }
      });
    }
    _exec(method, registry2, component) {
      const camelMethod = _capitalize(method);
      callback(component["before" + camelMethod], [], component);
      registry2[method](component);
      callback(component["after" + camelMethod], [], component);
    }
    _getRegistryForType(type) {
      for (let i = 0; i < this._typedRegistries.length; i++) {
        const reg = this._typedRegistries[i];
        if (reg.isForType(type)) {
          return reg;
        }
      }
      return this.plugins;
    }
    _get(id, typedRegistry, type) {
      const item = typedRegistry.get(id);
      if (item === void 0) {
        throw new Error('"' + id + '" is not a registered ' + type + ".");
      }
      return item;
    }
  };
  var registry = /* @__PURE__ */ new Registry();
  var PluginService = class {
    constructor() {
      this._init = [];
    }
    notify(chart, hook, args, filter) {
      if (hook === "beforeInit") {
        this._init = this._createDescriptors(chart, true);
        this._notify(this._init, chart, "install");
      }
      const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
      const result = this._notify(descriptors2, chart, hook, args);
      if (hook === "afterDestroy") {
        this._notify(descriptors2, chart, "stop");
        this._notify(this._init, chart, "uninstall");
      }
      return result;
    }
    _notify(descriptors2, chart, hook, args) {
      args = args || {};
      for (const descriptor of descriptors2) {
        const plugin = descriptor.plugin;
        const method = plugin[hook];
        const params = [
          chart,
          args,
          descriptor.options
        ];
        if (callback(method, params, plugin) === false && args.cancelable) {
          return false;
        }
      }
      return true;
    }
    invalidate() {
      if (!isNullOrUndef(this._cache)) {
        this._oldCache = this._cache;
        this._cache = void 0;
      }
    }
    _descriptors(chart) {
      if (this._cache) {
        return this._cache;
      }
      const descriptors2 = this._cache = this._createDescriptors(chart);
      this._notifyStateChanges(chart);
      return descriptors2;
    }
    _createDescriptors(chart, all) {
      const config = chart && chart.config;
      const options = valueOrDefault(config.options && config.options.plugins, {});
      const plugins2 = allPlugins(config);
      return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);
    }
    _notifyStateChanges(chart) {
      const previousDescriptors = this._oldCache || [];
      const descriptors2 = this._cache;
      const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
      this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
      this._notify(diff(descriptors2, previousDescriptors), chart, "start");
    }
  };
  function allPlugins(config) {
    const localIds = {};
    const plugins2 = [];
    const keys = Object.keys(registry.plugins.items);
    for (let i = 0; i < keys.length; i++) {
      plugins2.push(registry.getPlugin(keys[i]));
    }
    const local = config.plugins || [];
    for (let i = 0; i < local.length; i++) {
      const plugin = local[i];
      if (plugins2.indexOf(plugin) === -1) {
        plugins2.push(plugin);
        localIds[plugin.id] = true;
      }
    }
    return {
      plugins: plugins2,
      localIds
    };
  }
  function getOpts(options, all) {
    if (!all && options === false) {
      return null;
    }
    if (options === true) {
      return {};
    }
    return options;
  }
  function createDescriptors(chart, { plugins: plugins2, localIds }, options, all) {
    const result = [];
    const context = chart.getContext();
    for (const plugin of plugins2) {
      const id = plugin.id;
      const opts = getOpts(options[id], all);
      if (opts === null) {
        continue;
      }
      result.push({
        plugin,
        options: pluginOpts(chart.config, {
          plugin,
          local: localIds[id]
        }, opts, context)
      });
    }
    return result;
  }
  function pluginOpts(config, { plugin, local }, opts, context) {
    const keys = config.pluginScopeKeys(plugin);
    const scopes = config.getOptionScopes(opts, keys);
    if (local && plugin.defaults) {
      scopes.push(plugin.defaults);
    }
    return config.createResolver(scopes, context, [
      ""
    ], {
      scriptable: false,
      indexable: false,
      allKeys: true
    });
  }
  function getIndexAxis(type, options) {
    const datasetDefaults = defaults.datasets[type] || {};
    const datasetOptions = (options.datasets || {})[type] || {};
    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
  }
  function getAxisFromDefaultScaleID(id, indexAxis) {
    let axis = id;
    if (id === "_index_") {
      axis = indexAxis;
    } else if (id === "_value_") {
      axis = indexAxis === "x" ? "y" : "x";
    }
    return axis;
  }
  function getDefaultScaleIDFromAxis(axis, indexAxis) {
    return axis === indexAxis ? "_index_" : "_value_";
  }
  function idMatchesAxis(id) {
    if (id === "x" || id === "y" || id === "r") {
      return id;
    }
  }
  function axisFromPosition(position) {
    if (position === "top" || position === "bottom") {
      return "x";
    }
    if (position === "left" || position === "right") {
      return "y";
    }
  }
  function determineAxis(id, ...scaleOptions) {
    if (idMatchesAxis(id)) {
      return id;
    }
    for (const opts of scaleOptions) {
      const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
      if (axis) {
        return axis;
      }
    }
    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
  }
  function getAxisFromDataset(id, axis, dataset) {
    if (dataset[axis + "AxisID"] === id) {
      return {
        axis
      };
    }
  }
  function retrieveAxisFromDatasets(id, config) {
    if (config.data && config.data.datasets) {
      const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
      if (boundDs.length) {
        return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
      }
    }
    return {};
  }
  function mergeScaleConfig(config, options) {
    const chartDefaults = overrides[config.type] || {
      scales: {}
    };
    const configScales = options.scales || {};
    const chartIndexAxis = getIndexAxis(config.type, options);
    const scales2 = /* @__PURE__ */ Object.create(null);
    Object.keys(configScales).forEach((id) => {
      const scaleConf = configScales[id];
      if (!isObject2(scaleConf)) {
        return console.error(`Invalid scale configuration for scale: ${id}`);
      }
      if (scaleConf._proxy) {
        return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
      }
      const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
      const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
      const defaultScaleOptions = chartDefaults.scales || {};
      scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
        {
          axis
        },
        scaleConf,
        defaultScaleOptions[axis],
        defaultScaleOptions[defaultId]
      ]);
    });
    config.data.datasets.forEach((dataset) => {
      const type = dataset.type || config.type;
      const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
      const datasetDefaults = overrides[type] || {};
      const defaultScaleOptions = datasetDefaults.scales || {};
      Object.keys(defaultScaleOptions).forEach((defaultID) => {
        const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
        const id = dataset[axis + "AxisID"] || axis;
        scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
        mergeIf(scales2[id], [
          {
            axis
          },
          configScales[id],
          defaultScaleOptions[defaultID]
        ]);
      });
    });
    Object.keys(scales2).forEach((key) => {
      const scale = scales2[key];
      mergeIf(scale, [
        defaults.scales[scale.type],
        defaults.scale
      ]);
    });
    return scales2;
  }
  function initOptions(config) {
    const options = config.options || (config.options = {});
    options.plugins = valueOrDefault(options.plugins, {});
    options.scales = mergeScaleConfig(config, options);
  }
  function initData(data) {
    data = data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    return data;
  }
  function initConfig(config) {
    config = config || {};
    config.data = initData(config.data);
    initOptions(config);
    return config;
  }
  var keyCache = /* @__PURE__ */ new Map();
  var keysCached = /* @__PURE__ */ new Set();
  function cachedKeys(cacheKey, generate) {
    let keys = keyCache.get(cacheKey);
    if (!keys) {
      keys = generate();
      keyCache.set(cacheKey, keys);
      keysCached.add(keys);
    }
    return keys;
  }
  var addIfFound = (set2, obj, key) => {
    const opts = resolveObjectKey(obj, key);
    if (opts !== void 0) {
      set2.add(opts);
    }
  };
  var Config = class {
    constructor(config) {
      this._config = initConfig(config);
      this._scopeCache = /* @__PURE__ */ new Map();
      this._resolverCache = /* @__PURE__ */ new Map();
    }
    get platform() {
      return this._config.platform;
    }
    get type() {
      return this._config.type;
    }
    set type(type) {
      this._config.type = type;
    }
    get data() {
      return this._config.data;
    }
    set data(data) {
      this._config.data = initData(data);
    }
    get options() {
      return this._config.options;
    }
    set options(options) {
      this._config.options = options;
    }
    get plugins() {
      return this._config.plugins;
    }
    update() {
      const config = this._config;
      this.clearCache();
      initOptions(config);
    }
    clearCache() {
      this._scopeCache.clear();
      this._resolverCache.clear();
    }
    datasetScopeKeys(datasetType) {
      return cachedKeys(datasetType, () => [
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetAnimationScopeKeys(datasetType, transition) {
      return cachedKeys(`${datasetType}.transition.${transition}`, () => [
        [
          `datasets.${datasetType}.transitions.${transition}`,
          `transitions.${transition}`
        ],
        [
          `datasets.${datasetType}`,
          ""
        ]
      ]);
    }
    datasetElementScopeKeys(datasetType, elementType) {
      return cachedKeys(`${datasetType}-${elementType}`, () => [
        [
          `datasets.${datasetType}.elements.${elementType}`,
          `datasets.${datasetType}`,
          `elements.${elementType}`,
          ""
        ]
      ]);
    }
    pluginScopeKeys(plugin) {
      const id = plugin.id;
      const type = this.type;
      return cachedKeys(`${type}-plugin-${id}`, () => [
        [
          `plugins.${id}`,
          ...plugin.additionalOptionScopes || []
        ]
      ]);
    }
    _cachedScopes(mainScope, resetCache) {
      const _scopeCache = this._scopeCache;
      let cache = _scopeCache.get(mainScope);
      if (!cache || resetCache) {
        cache = /* @__PURE__ */ new Map();
        _scopeCache.set(mainScope, cache);
      }
      return cache;
    }
    getOptionScopes(mainScope, keyLists, resetCache) {
      const { options, type } = this;
      const cache = this._cachedScopes(mainScope, resetCache);
      const cached = cache.get(keyLists);
      if (cached) {
        return cached;
      }
      const scopes = /* @__PURE__ */ new Set();
      keyLists.forEach((keys) => {
        if (mainScope) {
          scopes.add(mainScope);
          keys.forEach((key) => addIfFound(scopes, mainScope, key));
        }
        keys.forEach((key) => addIfFound(scopes, options, key));
        keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
        keys.forEach((key) => addIfFound(scopes, defaults, key));
        keys.forEach((key) => addIfFound(scopes, descriptors, key));
      });
      const array = Array.from(scopes);
      if (array.length === 0) {
        array.push(/* @__PURE__ */ Object.create(null));
      }
      if (keysCached.has(keyLists)) {
        cache.set(keyLists, array);
      }
      return array;
    }
    chartOptionScopes() {
      const { options, type } = this;
      return [
        options,
        overrides[type] || {},
        defaults.datasets[type] || {},
        {
          type
        },
        defaults,
        descriptors
      ];
    }
    resolveNamedOptions(scopes, names2, context, prefixes = [
      ""
    ]) {
      const result = {
        $shared: true
      };
      const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
      let options = resolver;
      if (needContext(resolver, names2)) {
        result.$shared = false;
        context = isFunction(context) ? context() : context;
        const subResolver = this.createResolver(scopes, context, subPrefixes);
        options = _attachContext(resolver, context, subResolver);
      }
      for (const prop of names2) {
        result[prop] = options[prop];
      }
      return result;
    }
    createResolver(scopes, context, prefixes = [
      ""
    ], descriptorDefaults) {
      const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
      return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
    }
  };
  function getResolver(resolverCache, scopes, prefixes) {
    let cache = resolverCache.get(scopes);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      resolverCache.set(scopes, cache);
    }
    const cacheKey = prefixes.join();
    let cached = cache.get(cacheKey);
    if (!cached) {
      const resolver = _createResolver(scopes, prefixes);
      cached = {
        resolver,
        subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
      };
      cache.set(cacheKey, cached);
    }
    return cached;
  }
  var hasFunction = (value) => isObject2(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
  function needContext(proxy, names2) {
    const { isScriptable, isIndexable } = _descriptors(proxy);
    for (const prop of names2) {
      const scriptable = isScriptable(prop);
      const indexable = isIndexable(prop);
      const value = (indexable || scriptable) && proxy[prop];
      if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
        return true;
      }
    }
    return false;
  }
  var version = "4.4.8";
  var KNOWN_POSITIONS = [
    "top",
    "bottom",
    "left",
    "right",
    "chartArea"
  ];
  function positionIsHorizontal(position, axis) {
    return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
  }
  function compare2Level(l1, l2) {
    return function(a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }
  function onAnimationsComplete(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    chart.notifyPlugins("afterRender");
    callback(animationOptions && animationOptions.onComplete, [
      context
    ], chart);
  }
  function onAnimationProgress(context) {
    const chart = context.chart;
    const animationOptions = chart.options.animation;
    callback(animationOptions && animationOptions.onProgress, [
      context
    ], chart);
  }
  function getCanvas(item) {
    if (_isDomSupported() && typeof item === "string") {
      item = document.getElementById(item);
    } else if (item && item.length) {
      item = item[0];
    }
    if (item && item.canvas) {
      item = item.canvas;
    }
    return item;
  }
  var instances = {};
  var getChart = (key) => {
    const canvas = getCanvas(key);
    return Object.values(instances).filter((c) => c.canvas === canvas).pop();
  };
  function moveNumericKeys(obj, start, move) {
    const keys = Object.keys(obj);
    for (const key of keys) {
      const intKey = +key;
      if (intKey >= start) {
        const value = obj[key];
        delete obj[key];
        if (move > 0 || intKey > start) {
          obj[intKey + move] = value;
        }
      }
    }
  }
  function determineLastEvent(e, lastEvent, inChartArea, isClick) {
    if (!inChartArea || e.type === "mouseout") {
      return null;
    }
    if (isClick) {
      return lastEvent;
    }
    return e;
  }
  function getSizeForArea(scale, chartArea, field) {
    return scale.options.clip ? scale[field] : chartArea[field];
  }
  function getDatasetArea(meta, chartArea) {
    const { xScale, yScale } = meta;
    if (xScale && yScale) {
      return {
        left: getSizeForArea(xScale, chartArea, "left"),
        right: getSizeForArea(xScale, chartArea, "right"),
        top: getSizeForArea(yScale, chartArea, "top"),
        bottom: getSizeForArea(yScale, chartArea, "bottom")
      };
    }
    return chartArea;
  }
  var Chart = class {
    static register(...items) {
      registry.add(...items);
      invalidatePlugins();
    }
    static unregister(...items) {
      registry.remove(...items);
      invalidatePlugins();
    }
    constructor(item, userConfig) {
      const config = this.config = new Config(userConfig);
      const initialCanvas = getCanvas(item);
      const existingChart = getChart(initialCanvas);
      if (existingChart) {
        throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
      }
      const options = config.createResolver(config.chartOptionScopes(), this.getContext());
      this.platform = new (config.platform || _detectPlatform(initialCanvas))();
      this.platform.updateConfig(config);
      const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
      const canvas = context && context.canvas;
      const height = canvas && canvas.height;
      const width = canvas && canvas.width;
      this.id = uid();
      this.ctx = context;
      this.canvas = canvas;
      this.width = width;
      this.height = height;
      this._options = options;
      this._aspectRatio = this.aspectRatio;
      this._layers = [];
      this._metasets = [];
      this._stacks = void 0;
      this.boxes = [];
      this.currentDevicePixelRatio = void 0;
      this.chartArea = void 0;
      this._active = [];
      this._lastEvent = void 0;
      this._listeners = {};
      this._responsiveListeners = void 0;
      this._sortedMetasets = [];
      this.scales = {};
      this._plugins = new PluginService();
      this.$proxies = {};
      this._hiddenIndices = {};
      this.attached = false;
      this._animationsDisabled = void 0;
      this.$context = void 0;
      this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);
      this._dataChanges = [];
      instances[this.id] = this;
      if (!context || !canvas) {
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }
      animator.listen(this, "complete", onAnimationsComplete);
      animator.listen(this, "progress", onAnimationProgress);
      this._initialize();
      if (this.attached) {
        this.update();
      }
    }
    get aspectRatio() {
      const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
      if (!isNullOrUndef(aspectRatio)) {
        return aspectRatio;
      }
      if (maintainAspectRatio && _aspectRatio) {
        return _aspectRatio;
      }
      return height ? width / height : null;
    }
    get data() {
      return this.config.data;
    }
    set data(data) {
      this.config.data = data;
    }
    get options() {
      return this._options;
    }
    set options(options) {
      this.config.options = options;
    }
    get registry() {
      return registry;
    }
    _initialize() {
      this.notifyPlugins("beforeInit");
      if (this.options.responsive) {
        this.resize();
      } else {
        retinaScale(this, this.options.devicePixelRatio);
      }
      this.bindEvents();
      this.notifyPlugins("afterInit");
      return this;
    }
    clear() {
      clearCanvas(this.canvas, this.ctx);
      return this;
    }
    stop() {
      animator.stop(this);
      return this;
    }
    resize(width, height) {
      if (!animator.running(this)) {
        this._resize(width, height);
      } else {
        this._resizeBeforeDraw = {
          width,
          height
        };
      }
    }
    _resize(width, height) {
      const options = this.options;
      const canvas = this.canvas;
      const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
      const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
      const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
      const mode = this.width ? "resize" : "attach";
      this.width = newSize.width;
      this.height = newSize.height;
      this._aspectRatio = this.aspectRatio;
      if (!retinaScale(this, newRatio, true)) {
        return;
      }
      this.notifyPlugins("resize", {
        size: newSize
      });
      callback(options.onResize, [
        this,
        newSize
      ], this);
      if (this.attached) {
        if (this._doResize(mode)) {
          this.render();
        }
      }
    }
    ensureScalesHaveIDs() {
      const options = this.options;
      const scalesOptions = options.scales || {};
      each(scalesOptions, (axisOptions, axisID) => {
        axisOptions.id = axisID;
      });
    }
    buildOrUpdateScales() {
      const options = this.options;
      const scaleOpts = options.scales;
      const scales2 = this.scales;
      const updated = Object.keys(scales2).reduce((obj, id) => {
        obj[id] = false;
        return obj;
      }, {});
      let items = [];
      if (scaleOpts) {
        items = items.concat(Object.keys(scaleOpts).map((id) => {
          const scaleOptions = scaleOpts[id];
          const axis = determineAxis(id, scaleOptions);
          const isRadial = axis === "r";
          const isHorizontal = axis === "x";
          return {
            options: scaleOptions,
            dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
            dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
          };
        }));
      }
      each(items, (item) => {
        const scaleOptions = item.options;
        const id = scaleOptions.id;
        const axis = determineAxis(id, scaleOptions);
        const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
        if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }
        updated[id] = true;
        let scale = null;
        if (id in scales2 && scales2[id].type === scaleType) {
          scale = scales2[id];
        } else {
          const scaleClass = registry.getScale(scaleType);
          scale = new scaleClass({
            id,
            type: scaleType,
            ctx: this.ctx,
            chart: this
          });
          scales2[scale.id] = scale;
        }
        scale.init(scaleOptions, options);
      });
      each(updated, (hasUpdated, id) => {
        if (!hasUpdated) {
          delete scales2[id];
        }
      });
      each(scales2, (scale) => {
        layouts.configure(this, scale, scale.options);
        layouts.addBox(this, scale);
      });
    }
    _updateMetasets() {
      const metasets = this._metasets;
      const numData = this.data.datasets.length;
      const numMeta = metasets.length;
      metasets.sort((a, b) => a.index - b.index);
      if (numMeta > numData) {
        for (let i = numData; i < numMeta; ++i) {
          this._destroyDatasetMeta(i);
        }
        metasets.splice(numData, numMeta - numData);
      }
      this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
    }
    _removeUnreferencedMetasets() {
      const { _metasets: metasets, data: { datasets } } = this;
      if (metasets.length > datasets.length) {
        delete this._stacks;
      }
      metasets.forEach((meta, index2) => {
        if (datasets.filter((x) => x === meta._dataset).length === 0) {
          this._destroyDatasetMeta(index2);
        }
      });
    }
    buildOrUpdateControllers() {
      const newControllers = [];
      const datasets = this.data.datasets;
      let i, ilen;
      this._removeUnreferencedMetasets();
      for (i = 0, ilen = datasets.length; i < ilen; i++) {
        const dataset = datasets[i];
        let meta = this.getDatasetMeta(i);
        const type = dataset.type || this.config.type;
        if (meta.type && meta.type !== type) {
          this._destroyDatasetMeta(i);
          meta = this.getDatasetMeta(i);
        }
        meta.type = type;
        meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
        meta.order = dataset.order || 0;
        meta.index = i;
        meta.label = "" + dataset.label;
        meta.visible = this.isDatasetVisible(i);
        if (meta.controller) {
          meta.controller.updateIndex(i);
          meta.controller.linkScales();
        } else {
          const ControllerClass = registry.getController(type);
          const { datasetElementType, dataElementType } = defaults.datasets[type];
          Object.assign(ControllerClass, {
            dataElementType: registry.getElement(dataElementType),
            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
          });
          meta.controller = new ControllerClass(this, i);
          newControllers.push(meta.controller);
        }
      }
      this._updateMetasets();
      return newControllers;
    }
    _resetElements() {
      each(this.data.datasets, (dataset, datasetIndex) => {
        this.getDatasetMeta(datasetIndex).controller.reset();
      }, this);
    }
    reset() {
      this._resetElements();
      this.notifyPlugins("reset");
    }
    update(mode) {
      const config = this.config;
      config.update();
      const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
      const animsDisabled = this._animationsDisabled = !options.animation;
      this._updateScales();
      this._checkEventBindings();
      this._updateHiddenIndices();
      this._plugins.invalidate();
      if (this.notifyPlugins("beforeUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      const newControllers = this.buildOrUpdateControllers();
      this.notifyPlugins("beforeElementsUpdate");
      let minPadding = 0;
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
        const { controller } = this.getDatasetMeta(i);
        const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
        controller.buildOrUpdateElements(reset);
        minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
      }
      minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
      this._updateLayout(minPadding);
      if (!animsDisabled) {
        each(newControllers, (controller) => {
          controller.reset();
        });
      }
      this._updateDatasets(mode);
      this.notifyPlugins("afterUpdate", {
        mode
      });
      this._layers.sort(compare2Level("z", "_idx"));
      const { _active, _lastEvent } = this;
      if (_lastEvent) {
        this._eventHandler(_lastEvent, true);
      } else if (_active.length) {
        this._updateHoverStyles(_active, _active, true);
      }
      this.render();
    }
    _updateScales() {
      each(this.scales, (scale) => {
        layouts.removeBox(this, scale);
      });
      this.ensureScalesHaveIDs();
      this.buildOrUpdateScales();
    }
    _checkEventBindings() {
      const options = this.options;
      const existingEvents = new Set(Object.keys(this._listeners));
      const newEvents = new Set(options.events);
      if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
        this.unbindEvents();
        this.bindEvents();
      }
    }
    _updateHiddenIndices() {
      const { _hiddenIndices } = this;
      const changes = this._getUniformDataChanges() || [];
      for (const { method, start, count } of changes) {
        const move = method === "_removeElements" ? -count : count;
        moveNumericKeys(_hiddenIndices, start, move);
      }
    }
    _getUniformDataChanges() {
      const _dataChanges = this._dataChanges;
      if (!_dataChanges || !_dataChanges.length) {
        return;
      }
      this._dataChanges = [];
      const datasetCount = this.data.datasets.length;
      const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
      const changeSet = makeSet(0);
      for (let i = 1; i < datasetCount; i++) {
        if (!setsEqual(changeSet, makeSet(i))) {
          return;
        }
      }
      return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
        method: a[1],
        start: +a[2],
        count: +a[3]
      }));
    }
    _updateLayout(minPadding) {
      if (this.notifyPlugins("beforeLayout", {
        cancelable: true
      }) === false) {
        return;
      }
      layouts.update(this, this.width, this.height, minPadding);
      const area = this.chartArea;
      const noArea = area.width <= 0 || area.height <= 0;
      this._layers = [];
      each(this.boxes, (box) => {
        if (noArea && box.position === "chartArea") {
          return;
        }
        if (box.configure) {
          box.configure();
        }
        this._layers.push(...box._layers());
      }, this);
      this._layers.forEach((item, index2) => {
        item._idx = index2;
      });
      this.notifyPlugins("afterLayout");
    }
    _updateDatasets(mode) {
      if (this.notifyPlugins("beforeDatasetsUpdate", {
        mode,
        cancelable: true
      }) === false) {
        return;
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this.getDatasetMeta(i).controller.configure();
      }
      for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._updateDataset(i, isFunction(mode) ? mode({
          datasetIndex: i
        }) : mode);
      }
      this.notifyPlugins("afterDatasetsUpdate", {
        mode
      });
    }
    _updateDataset(index2, mode) {
      const meta = this.getDatasetMeta(index2);
      const args = {
        meta,
        index: index2,
        mode,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
        return;
      }
      meta.controller._update(mode);
      args.cancelable = false;
      this.notifyPlugins("afterDatasetUpdate", args);
    }
    render() {
      if (this.notifyPlugins("beforeRender", {
        cancelable: true
      }) === false) {
        return;
      }
      if (animator.has(this)) {
        if (this.attached && !animator.running(this)) {
          animator.start(this);
        }
      } else {
        this.draw();
        onAnimationsComplete({
          chart: this
        });
      }
    }
    draw() {
      let i;
      if (this._resizeBeforeDraw) {
        const { width, height } = this._resizeBeforeDraw;
        this._resizeBeforeDraw = null;
        this._resize(width, height);
      }
      this.clear();
      if (this.width <= 0 || this.height <= 0) {
        return;
      }
      if (this.notifyPlugins("beforeDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const layers = this._layers;
      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
        layers[i].draw(this.chartArea);
      }
      this._drawDatasets();
      for (; i < layers.length; ++i) {
        layers[i].draw(this.chartArea);
      }
      this.notifyPlugins("afterDraw");
    }
    _getSortedDatasetMetas(filterVisible) {
      const metasets = this._sortedMetasets;
      const result = [];
      let i, ilen;
      for (i = 0, ilen = metasets.length; i < ilen; ++i) {
        const meta = metasets[i];
        if (!filterVisible || meta.visible) {
          result.push(meta);
        }
      }
      return result;
    }
    getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    }
    _drawDatasets() {
      if (this.notifyPlugins("beforeDatasetsDraw", {
        cancelable: true
      }) === false) {
        return;
      }
      const metasets = this.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        this._drawDataset(metasets[i]);
      }
      this.notifyPlugins("afterDatasetsDraw");
    }
    _drawDataset(meta) {
      const ctx = this.ctx;
      const clip = meta._clip;
      const useClip = !clip.disabled;
      const area = getDatasetArea(meta, this.chartArea);
      const args = {
        meta,
        index: meta.index,
        cancelable: true
      };
      if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
        return;
      }
      if (useClip) {
        clipArea(ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? this.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
        });
      }
      meta.controller.draw();
      if (useClip) {
        unclipArea(ctx);
      }
      args.cancelable = false;
      this.notifyPlugins("afterDatasetDraw", args);
    }
    isPointInArea(point) {
      return _isPointInArea(point, this.chartArea, this._minPadding);
    }
    getElementsAtEventForMode(e, mode, options, useFinalPosition) {
      const method = Interaction.modes[mode];
      if (typeof method === "function") {
        return method(this, e, options, useFinalPosition);
      }
      return [];
    }
    getDatasetMeta(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      const metasets = this._metasets;
      let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
      if (!meta) {
        meta = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          xAxisID: null,
          yAxisID: null,
          order: dataset && dataset.order || 0,
          index: datasetIndex,
          _dataset: dataset,
          _parsed: [],
          _sorted: false
        };
        metasets.push(meta);
      }
      return meta;
    }
    getContext() {
      return this.$context || (this.$context = createContext(null, {
        chart: this,
        type: "chart"
      }));
    }
    getVisibleDatasetCount() {
      return this.getSortedVisibleDatasetMetas().length;
    }
    isDatasetVisible(datasetIndex) {
      const dataset = this.data.datasets[datasetIndex];
      if (!dataset) {
        return false;
      }
      const meta = this.getDatasetMeta(datasetIndex);
      return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
    }
    setDatasetVisibility(datasetIndex, visible) {
      const meta = this.getDatasetMeta(datasetIndex);
      meta.hidden = !visible;
    }
    toggleDataVisibility(index2) {
      this._hiddenIndices[index2] = !this._hiddenIndices[index2];
    }
    getDataVisibility(index2) {
      return !this._hiddenIndices[index2];
    }
    _updateVisibility(datasetIndex, dataIndex, visible) {
      const mode = visible ? "show" : "hide";
      const meta = this.getDatasetMeta(datasetIndex);
      const anims = meta.controller._resolveAnimations(void 0, mode);
      if (defined(dataIndex)) {
        meta.data[dataIndex].hidden = !visible;
        this.update();
      } else {
        this.setDatasetVisibility(datasetIndex, visible);
        anims.update(meta, {
          visible
        });
        this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
      }
    }
    hide(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, false);
    }
    show(datasetIndex, dataIndex) {
      this._updateVisibility(datasetIndex, dataIndex, true);
    }
    _destroyDatasetMeta(datasetIndex) {
      const meta = this._metasets[datasetIndex];
      if (meta && meta.controller) {
        meta.controller._destroy();
      }
      delete this._metasets[datasetIndex];
    }
    _stop() {
      let i, ilen;
      this.stop();
      animator.remove(this);
      for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        this._destroyDatasetMeta(i);
      }
    }
    destroy() {
      this.notifyPlugins("beforeDestroy");
      const { canvas, ctx } = this;
      this._stop();
      this.config.clearCache();
      if (canvas) {
        this.unbindEvents();
        clearCanvas(canvas, ctx);
        this.platform.releaseContext(ctx);
        this.canvas = null;
        this.ctx = null;
      }
      delete instances[this.id];
      this.notifyPlugins("afterDestroy");
    }
    toBase64Image(...args) {
      return this.canvas.toDataURL(...args);
    }
    bindEvents() {
      this.bindUserEvents();
      if (this.options.responsive) {
        this.bindResponsiveEvents();
      } else {
        this.attached = true;
      }
    }
    bindUserEvents() {
      const listeners = this._listeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const listener = (e, x, y) => {
        e.offsetX = x;
        e.offsetY = y;
        this._eventHandler(e);
      };
      each(this.options.events, (type) => _add(type, listener));
    }
    bindResponsiveEvents() {
      if (!this._responsiveListeners) {
        this._responsiveListeners = {};
      }
      const listeners = this._responsiveListeners;
      const platform = this.platform;
      const _add = (type, listener2) => {
        platform.addEventListener(this, type, listener2);
        listeners[type] = listener2;
      };
      const _remove = (type, listener2) => {
        if (listeners[type]) {
          platform.removeEventListener(this, type, listener2);
          delete listeners[type];
        }
      };
      const listener = (width, height) => {
        if (this.canvas) {
          this.resize(width, height);
        }
      };
      let detached;
      const attached = () => {
        _remove("attach", attached);
        this.attached = true;
        this.resize();
        _add("resize", listener);
        _add("detach", detached);
      };
      detached = () => {
        this.attached = false;
        _remove("resize", listener);
        this._stop();
        this._resize(0, 0);
        _add("attach", attached);
      };
      if (platform.isAttached(this.canvas)) {
        attached();
      } else {
        detached();
      }
    }
    unbindEvents() {
      each(this._listeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._listeners = {};
      each(this._responsiveListeners, (listener, type) => {
        this.platform.removeEventListener(this, type, listener);
      });
      this._responsiveListeners = void 0;
    }
    updateHoverStyle(items, mode, enabled) {
      const prefix = enabled ? "set" : "remove";
      let meta, item, i, ilen;
      if (mode === "dataset") {
        meta = this.getDatasetMeta(items[0].datasetIndex);
        meta.controller["_" + prefix + "DatasetHoverStyle"]();
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
        if (controller) {
          controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
        }
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements) {
      const lastActive = this._active || [];
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("No dataset found at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(active, lastActive);
      if (changed) {
        this._active = active;
        this._lastEvent = null;
        this._updateHoverStyles(active, lastActive);
      }
    }
    notifyPlugins(hook, args, filter) {
      return this._plugins.notify(this, hook, args, filter);
    }
    isPluginEnabled(pluginId) {
      return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
    }
    _updateHoverStyles(active, lastActive, replay) {
      const hoverOptions = this.options.hover;
      const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
      const deactivated = diff(lastActive, active);
      const activated = replay ? active : diff(active, lastActive);
      if (deactivated.length) {
        this.updateHoverStyle(deactivated, hoverOptions.mode, false);
      }
      if (activated.length && hoverOptions.mode) {
        this.updateHoverStyle(activated, hoverOptions.mode, true);
      }
    }
    _eventHandler(e, replay) {
      const args = {
        event: e,
        replay,
        cancelable: true,
        inChartArea: this.isPointInArea(e)
      };
      const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
      if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
        return;
      }
      const changed = this._handleEvent(e, replay, args.inChartArea);
      args.cancelable = false;
      this.notifyPlugins("afterEvent", args, eventFilter);
      if (changed || args.changed) {
        this.render();
      }
      return this;
    }
    _handleEvent(e, replay, inChartArea) {
      const { _active: lastActive = [], options } = this;
      const useFinalPosition = replay;
      const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
      const isClick = _isClickEvent(e);
      const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
      if (inChartArea) {
        this._lastEvent = null;
        callback(options.onHover, [
          e,
          active,
          this
        ], this);
        if (isClick) {
          callback(options.onClick, [
            e,
            active,
            this
          ], this);
        }
      }
      const changed = !_elementsEqual(active, lastActive);
      if (changed || replay) {
        this._active = active;
        this._updateHoverStyles(active, lastActive, replay);
      }
      this._lastEvent = lastEvent;
      return changed;
    }
    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive;
      }
      const hoverOptions = this.options.hover;
      return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
    }
  };
  __publicField(Chart, "defaults", defaults);
  __publicField(Chart, "instances", instances);
  __publicField(Chart, "overrides", overrides);
  __publicField(Chart, "registry", registry);
  __publicField(Chart, "version", version);
  __publicField(Chart, "getChart", getChart);
  function invalidatePlugins() {
    return each(Chart.instances, (chart) => chart._plugins.invalidate());
  }
  function clipArc(ctx, element, endAngle) {
    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
    let angleMargin = pixelMargin / outerRadius;
    ctx.beginPath();
    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
    if (innerRadius > pixelMargin) {
      angleMargin = pixelMargin / innerRadius;
      ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
    }
    ctx.closePath();
    ctx.clip();
  }
  function toRadiusCorners(value) {
    return _readValueToProps(value, [
      "outerStart",
      "outerEnd",
      "innerStart",
      "innerEnd"
    ]);
  }
  function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
    const o = toRadiusCorners(arc.options.borderRadius);
    const halfThickness = (outerRadius - innerRadius) / 2;
    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
    const computeOuterLimit = (val) => {
      const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
      return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
    };
    return {
      outerStart: computeOuterLimit(o.outerStart),
      outerEnd: computeOuterLimit(o.outerEnd),
      innerStart: _limitValue(o.innerStart, 0, innerLimit),
      innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
    };
  }
  function rThetaToXY(r, theta, x, y) {
    return {
      x: x + r * Math.cos(theta),
      y: y + r * Math.sin(theta)
    };
  }
  function pathArc(ctx, element, offset, spacing, end, circular) {
    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
    let spacingOffset = 0;
    const alpha2 = end - start;
    if (spacing) {
      const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
      const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
      const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
      const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
      spacingOffset = (alpha2 - adjustedAngle) / 2;
    }
    const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
    const angleOffset = (alpha2 - beta) / 2;
    const startAngle = start + angleOffset + spacingOffset;
    const endAngle = end - angleOffset - spacingOffset;
    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
    const outerStartAdjustedRadius = outerRadius - outerStart;
    const outerEndAdjustedRadius = outerRadius - outerEnd;
    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
    const innerStartAdjustedRadius = innerRadius + innerStart;
    const innerEndAdjustedRadius = innerRadius + innerEnd;
    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
    ctx.beginPath();
    if (circular) {
      const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
      ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
      ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
      if (outerEnd > 0) {
        const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
      }
      const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
      ctx.lineTo(p4.x, p4.y);
      if (innerEnd > 0) {
        const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
      }
      const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
      ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
      ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
      if (innerStart > 0) {
        const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
      }
      const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
      ctx.lineTo(p8.x, p8.y);
      if (outerStart > 0) {
        const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
        ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
      }
    } else {
      ctx.moveTo(x, y);
      const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
      const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerStartX, outerStartY);
      const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
      const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
      ctx.lineTo(outerEndX, outerEndY);
    }
    ctx.closePath();
  }
  function drawArc(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference } = element;
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.fill();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.fill();
    return endAngle;
  }
  function drawBorder(ctx, element, offset, spacing, circular) {
    const { fullCircles, startAngle, circumference, options } = element;
    const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } = options;
    const inner = options.borderAlign === "inner";
    if (!borderWidth) {
      return;
    }
    ctx.setLineDash(borderDash || []);
    ctx.lineDashOffset = borderDashOffset;
    if (inner) {
      ctx.lineWidth = borderWidth * 2;
      ctx.lineJoin = borderJoinStyle || "round";
    } else {
      ctx.lineWidth = borderWidth;
      ctx.lineJoin = borderJoinStyle || "bevel";
    }
    let endAngle = element.endAngle;
    if (fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      for (let i = 0; i < fullCircles; ++i) {
        ctx.stroke();
      }
      if (!isNaN(circumference)) {
        endAngle = startAngle + (circumference % TAU || TAU);
      }
    }
    if (inner) {
      clipArc(ctx, element, endAngle);
    }
    if (!fullCircles) {
      pathArc(ctx, element, offset, spacing, endAngle, circular);
      ctx.stroke();
    }
  }
  var ArcElement = class extends Element {
    constructor(cfg) {
      super();
      __publicField(this, "circumference");
      __publicField(this, "endAngle");
      __publicField(this, "fullCircles");
      __publicField(this, "innerRadius");
      __publicField(this, "outerRadius");
      __publicField(this, "pixelMargin");
      __publicField(this, "startAngle");
      this.options = void 0;
      this.circumference = void 0;
      this.startAngle = void 0;
      this.endAngle = void 0;
      this.innerRadius = void 0;
      this.outerRadius = void 0;
      this.pixelMargin = 0;
      this.fullCircles = 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(chartX, chartY, useFinalPosition) {
      const point = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      const { angle, distance } = getAngleFromPoint(point, {
        x: chartX,
        y: chartY
      });
      const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "circumference"
      ], useFinalPosition);
      const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
      const _circumference = valueOrDefault(circumference, endAngle - startAngle);
      const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
      const betweenAngles = _circumference >= TAU || nonZeroBetween;
      const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
      return betweenAngles && withinRadius;
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ], useFinalPosition);
      const { offset, spacing } = this.options;
      const halfAngle = (startAngle + endAngle) / 2;
      const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
      return {
        x: x + Math.cos(halfAngle) * halfRadius,
        y: y + Math.sin(halfAngle) * halfRadius
      };
    }
    tooltipPosition(useFinalPosition) {
      return this.getCenterPoint(useFinalPosition);
    }
    draw(ctx) {
      const { options, circumference } = this;
      const offset = (options.offset || 0) / 4;
      const spacing = (options.spacing || 0) / 2;
      const circular = options.circular;
      this.pixelMargin = options.borderAlign === "inner" ? 0.33 : 0;
      this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
      if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
        return;
      }
      ctx.save();
      const halfAngle = (this.startAngle + this.endAngle) / 2;
      ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
      const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
      const radiusOffset = offset * fix;
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      drawArc(ctx, this, radiusOffset, spacing, circular);
      drawBorder(ctx, this, radiusOffset, spacing, circular);
      ctx.restore();
    }
  };
  __publicField(ArcElement, "id", "arc");
  __publicField(ArcElement, "defaults", {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: true
  });
  __publicField(ArcElement, "defaultRoutes", {
    backgroundColor: "backgroundColor"
  });
  __publicField(ArcElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash"
  });
  function setStyle(ctx, options, style = options) {
    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
  }
  function lineTo(ctx, previous, target) {
    ctx.lineTo(target.x, target.y);
  }
  function getLineMethod(options) {
    if (options.stepped) {
      return _steppedLineTo;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierCurveTo;
    }
    return lineTo;
  }
  function pathVars(points, segment, params = {}) {
    const count = points.length;
    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
    const { start: segmentStart, end: segmentEnd } = segment;
    const start = Math.max(paramsStart, segmentStart);
    const end = Math.min(paramsEnd, segmentEnd);
    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
    return {
      count,
      start,
      loop: segment.loop,
      ilen: end < start && !outside ? count + end - start : end - start
    };
  }
  function pathSegment(ctx, line, segment, params) {
    const { points, options } = line;
    const { count, start, loop, ilen } = pathVars(points, segment, params);
    const lineMethod = getLineMethod(options);
    let { move = true, reverse } = params || {};
    let i, point, prev;
    for (i = 0; i <= ilen; ++i) {
      point = points[(start + (reverse ? ilen - i : i)) % count];
      if (point.skip) {
        continue;
      } else if (move) {
        ctx.moveTo(point.x, point.y);
        move = false;
      } else {
        lineMethod(ctx, prev, point, reverse, options.stepped);
      }
      prev = point;
    }
    if (loop) {
      point = points[(start + (reverse ? ilen : 0)) % count];
      lineMethod(ctx, prev, point, reverse, options.stepped);
    }
    return !!loop;
  }
  function fastPathSegment(ctx, line, segment, params) {
    const points = line.points;
    const { count, start, ilen } = pathVars(points, segment, params);
    const { move = true, reverse } = params || {};
    let avgX = 0;
    let countX = 0;
    let i, point, prevX, minY, maxY, lastY;
    const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
    const drawX = () => {
      if (minY !== maxY) {
        ctx.lineTo(avgX, maxY);
        ctx.lineTo(avgX, minY);
        ctx.lineTo(avgX, lastY);
      }
    };
    if (move) {
      point = points[pointIndex(0)];
      ctx.moveTo(point.x, point.y);
    }
    for (i = 0; i <= ilen; ++i) {
      point = points[pointIndex(i)];
      if (point.skip) {
        continue;
      }
      const x = point.x;
      const y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
        } else if (y > maxY) {
          maxY = y;
        }
        avgX = (countX * avgX + x) / ++countX;
      } else {
        drawX();
        ctx.lineTo(x, y);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
      }
      lastY = y;
    }
    drawX();
  }
  function _getSegmentMethod(line) {
    const opts = line.options;
    const borderDash = opts.borderDash && opts.borderDash.length;
    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
    return useFastPath ? fastPathSegment : pathSegment;
  }
  function _getInterpolationMethod(options) {
    if (options.stepped) {
      return _steppedInterpolation;
    }
    if (options.tension || options.cubicInterpolationMode === "monotone") {
      return _bezierInterpolation;
    }
    return _pointInLine;
  }
  function strokePathWithCache(ctx, line, start, count) {
    let path = line._path;
    if (!path) {
      path = line._path = new Path2D();
      if (line.path(path, start, count)) {
        path.closePath();
      }
    }
    setStyle(ctx, line.options);
    ctx.stroke(path);
  }
  function strokePathDirect(ctx, line, start, count) {
    const { segments, options } = line;
    const segmentMethod = _getSegmentMethod(line);
    for (const segment of segments) {
      setStyle(ctx, options, segment.style);
      ctx.beginPath();
      if (segmentMethod(ctx, line, segment, {
        start,
        end: start + count - 1
      })) {
        ctx.closePath();
      }
      ctx.stroke();
    }
  }
  var usePath2D = typeof Path2D === "function";
  function draw(ctx, line, start, count) {
    if (usePath2D && !line.options.segment) {
      strokePathWithCache(ctx, line, start, count);
    } else {
      strokePathDirect(ctx, line, start, count);
    }
  }
  var LineElement = class extends Element {
    constructor(cfg) {
      super();
      this.animated = true;
      this.options = void 0;
      this._chart = void 0;
      this._loop = void 0;
      this._fullLoop = void 0;
      this._path = void 0;
      this._points = void 0;
      this._segments = void 0;
      this._decimated = false;
      this._pointsUpdated = false;
      this._datasetIndex = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    updateControlPoints(chartArea, indexAxis) {
      const options = this.options;
      if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
        const loop = options.spanGaps ? this._loop : this._fullLoop;
        _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
        this._pointsUpdated = true;
      }
    }
    set points(points) {
      this._points = points;
      delete this._segments;
      delete this._path;
      this._pointsUpdated = false;
    }
    get points() {
      return this._points;
    }
    get segments() {
      return this._segments || (this._segments = _computeSegments(this, this.options.segment));
    }
    first() {
      const segments = this.segments;
      const points = this.points;
      return segments.length && points[segments[0].start];
    }
    last() {
      const segments = this.segments;
      const points = this.points;
      const count = segments.length;
      return count && points[segments[count - 1].end];
    }
    interpolate(point, property) {
      const options = this.options;
      const value = point[property];
      const points = this.points;
      const segments = _boundSegments(this, {
        property,
        start: value,
        end: value
      });
      if (!segments.length) {
        return;
      }
      const result = [];
      const _interpolate = _getInterpolationMethod(options);
      let i, ilen;
      for (i = 0, ilen = segments.length; i < ilen; ++i) {
        const { start, end } = segments[i];
        const p1 = points[start];
        const p2 = points[end];
        if (p1 === p2) {
          result.push(p1);
          continue;
        }
        const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
        const interpolated = _interpolate(p1, p2, t, options.stepped);
        interpolated[property] = point[property];
        result.push(interpolated);
      }
      return result.length === 1 ? result[0] : result;
    }
    pathSegment(ctx, segment, params) {
      const segmentMethod = _getSegmentMethod(this);
      return segmentMethod(ctx, this, segment, params);
    }
    path(ctx, start, count) {
      const segments = this.segments;
      const segmentMethod = _getSegmentMethod(this);
      let loop = this._loop;
      start = start || 0;
      count = count || this.points.length - start;
      for (const segment of segments) {
        loop &= segmentMethod(ctx, this, segment, {
          start,
          end: start + count - 1
        });
      }
      return !!loop;
    }
    draw(ctx, chartArea, start, count) {
      const options = this.options || {};
      const points = this.points || [];
      if (points.length && options.borderWidth) {
        ctx.save();
        draw(ctx, this, start, count);
        ctx.restore();
      }
      if (this.animated) {
        this._pointsUpdated = false;
        this._path = void 0;
      }
    }
  };
  __publicField(LineElement, "id", "line");
  __publicField(LineElement, "defaults", {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: true,
    cubicInterpolationMode: "default",
    fill: false,
    spanGaps: false,
    stepped: false,
    tension: 0
  });
  __publicField(LineElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  __publicField(LineElement, "descriptors", {
    _scriptable: true,
    _indexable: (name) => name !== "borderDash" && name !== "fill"
  });
  function inRange$1(el, pos, axis, useFinalPosition) {
    const options = el.options;
    const { [axis]: value } = el.getProps([
      axis
    ], useFinalPosition);
    return Math.abs(pos - value) < options.radius + options.hitRadius;
  }
  var PointElement = class extends Element {
    constructor(cfg) {
      super();
      __publicField(this, "parsed");
      __publicField(this, "skip");
      __publicField(this, "stop");
      this.options = void 0;
      this.parsed = void 0;
      this.skip = void 0;
      this.stop = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      const options = this.options;
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange$1(this, mouseX, "x", useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange$1(this, mouseY, "y", useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y } = this.getProps([
        "x",
        "y"
      ], useFinalPosition);
      return {
        x,
        y
      };
    }
    size(options) {
      options = options || this.options || {};
      let radius = options.radius || 0;
      radius = Math.max(radius, radius && options.hoverRadius || 0);
      const borderWidth = radius && options.borderWidth || 0;
      return (radius + borderWidth) * 2;
    }
    draw(ctx, area) {
      const options = this.options;
      if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {
        return;
      }
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.fillStyle = options.backgroundColor;
      drawPoint(ctx, options, this.x, this.y);
    }
    getRange() {
      const options = this.options || {};
      return options.radius + options.hitRadius;
    }
  };
  __publicField(PointElement, "id", "point");
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaults", {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  });
  /**
  * @type {any}
  */
  __publicField(PointElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  function getBarBounds(bar, useFinalPosition) {
    const { x, y, base, width, height } = bar.getProps([
      "x",
      "y",
      "base",
      "width",
      "height"
    ], useFinalPosition);
    let left, right, top2, bottom2, half;
    if (bar.horizontal) {
      half = height / 2;
      left = Math.min(x, base);
      right = Math.max(x, base);
      top2 = y - half;
      bottom2 = y + half;
    } else {
      half = width / 2;
      left = x - half;
      right = x + half;
      top2 = Math.min(y, base);
      bottom2 = Math.max(y, base);
    }
    return {
      left,
      top: top2,
      right,
      bottom: bottom2
    };
  }
  function skipOrLimit(skip2, value, min, max) {
    return skip2 ? 0 : _limitValue(value, min, max);
  }
  function parseBorderWidth(bar, maxW, maxH) {
    const value = bar.options.borderWidth;
    const skip2 = bar.borderSkipped;
    const o = toTRBL(value);
    return {
      t: skipOrLimit(skip2.top, o.top, 0, maxH),
      r: skipOrLimit(skip2.right, o.right, 0, maxW),
      b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
      l: skipOrLimit(skip2.left, o.left, 0, maxW)
    };
  }
  function parseBorderRadius(bar, maxW, maxH) {
    const { enableBorderRadius } = bar.getProps([
      "enableBorderRadius"
    ]);
    const value = bar.options.borderRadius;
    const o = toTRBLCorners(value);
    const maxR = Math.min(maxW, maxH);
    const skip2 = bar.borderSkipped;
    const enableBorder = enableBorderRadius || isObject2(value);
    return {
      topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
      topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
      bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
      bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
    };
  }
  function boundingRects(bar) {
    const bounds = getBarBounds(bar);
    const width = bounds.right - bounds.left;
    const height = bounds.bottom - bounds.top;
    const border = parseBorderWidth(bar, width / 2, height / 2);
    const radius = parseBorderRadius(bar, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height,
        radius
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b,
        radius: {
          topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
          topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
          bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
          bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
        }
      }
    };
  }
  function inRange(bar, x, y, useFinalPosition) {
    const skipX = x === null;
    const skipY = y === null;
    const skipBoth = skipX && skipY;
    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
  }
  function hasRadius(radius) {
    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
  }
  function addNormalRectPath(ctx, rect) {
    ctx.rect(rect.x, rect.y, rect.w, rect.h);
  }
  function inflateRect(rect, amount, refRect = {}) {
    const x = rect.x !== refRect.x ? -amount : 0;
    const y = rect.y !== refRect.y ? -amount : 0;
    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
    return {
      x: rect.x + x,
      y: rect.y + y,
      w: rect.w + w,
      h: rect.h + h,
      radius: rect.radius
    };
  }
  var BarElement = class extends Element {
    constructor(cfg) {
      super();
      this.options = void 0;
      this.horizontal = void 0;
      this.base = void 0;
      this.width = void 0;
      this.height = void 0;
      this.inflateAmount = void 0;
      if (cfg) {
        Object.assign(this, cfg);
      }
    }
    draw(ctx) {
      const { inflateAmount, options: { borderColor, backgroundColor } } = this;
      const { inner, outer } = boundingRects(this);
      const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
      ctx.save();
      if (outer.w !== inner.w || outer.h !== inner.h) {
        ctx.beginPath();
        addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
        ctx.clip();
        addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
        ctx.fillStyle = borderColor;
        ctx.fill("evenodd");
      }
      ctx.beginPath();
      addRectPath(ctx, inflateRect(inner, inflateAmount));
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
    inRange(mouseX, mouseY, useFinalPosition) {
      return inRange(this, mouseX, mouseY, useFinalPosition);
    }
    inXRange(mouseX, useFinalPosition) {
      return inRange(this, mouseX, null, useFinalPosition);
    }
    inYRange(mouseY, useFinalPosition) {
      return inRange(this, null, mouseY, useFinalPosition);
    }
    getCenterPoint(useFinalPosition) {
      const { x, y, base, horizontal } = this.getProps([
        "x",
        "y",
        "base",
        "horizontal"
      ], useFinalPosition);
      return {
        x: horizontal ? (x + base) / 2 : x,
        y: horizontal ? y : (y + base) / 2
      };
    }
    getRange(axis) {
      return axis === "x" ? this.width / 2 : this.height / 2;
    }
  };
  __publicField(BarElement, "id", "bar");
  __publicField(BarElement, "defaults", {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  });
  __publicField(BarElement, "defaultRoutes", {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  });
  var elements = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcElement,
    BarElement,
    LineElement,
    PointElement
  });
  var BORDER_COLORS = [
    "rgb(54, 162, 235)",
    "rgb(255, 99, 132)",
    "rgb(255, 159, 64)",
    "rgb(255, 205, 86)",
    "rgb(75, 192, 192)",
    "rgb(153, 102, 255)",
    "rgb(201, 203, 207)"
    // grey
  ];
  var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
  function getBorderColor(i) {
    return BORDER_COLORS[i % BORDER_COLORS.length];
  }
  function getBackgroundColor(i) {
    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
  }
  function colorizeDefaultDataset(dataset, i) {
    dataset.borderColor = getBorderColor(i);
    dataset.backgroundColor = getBackgroundColor(i);
    return ++i;
  }
  function colorizeDoughnutDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
    return i;
  }
  function colorizePolarAreaDataset(dataset, i) {
    dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
    return i;
  }
  function getColorizer(chart) {
    let i = 0;
    return (dataset, datasetIndex) => {
      const controller = chart.getDatasetMeta(datasetIndex).controller;
      if (controller instanceof DoughnutController) {
        i = colorizeDoughnutDataset(dataset, i);
      } else if (controller instanceof PolarAreaController) {
        i = colorizePolarAreaDataset(dataset, i);
      } else if (controller) {
        i = colorizeDefaultDataset(dataset, i);
      }
    };
  }
  function containsColorsDefinitions(descriptors2) {
    let k;
    for (k in descriptors2) {
      if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
        return true;
      }
    }
    return false;
  }
  function containsColorsDefinition(descriptor) {
    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
  }
  function containsDefaultColorsDefenitions() {
    return defaults.borderColor !== "rgba(0,0,0,0.1)" || defaults.backgroundColor !== "rgba(0,0,0,0.1)";
  }
  var plugin_colors = {
    id: "colors",
    defaults: {
      enabled: true,
      forceOverride: false
    },
    beforeLayout(chart, _args, options) {
      if (!options.enabled) {
        return;
      }
      const { data: { datasets }, options: chartOptions } = chart.config;
      const { elements: elements2 } = chartOptions;
      const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2) || containsDefaultColorsDefenitions();
      if (!options.forceOverride && containsColorDefenition) {
        return;
      }
      const colorizer = getColorizer(chart);
      datasets.forEach(colorizer);
    }
  };
  function lttbDecimation(data, start, count, availableWidth, options) {
    const samples = options.samples || availableWidth;
    if (samples >= count) {
      return data.slice(start, start + count);
    }
    const decimated = [];
    const bucketWidth = (count - 2) / (samples - 2);
    let sampledIndex = 0;
    const endIndex = start + count - 1;
    let a = start;
    let i, maxAreaPoint, maxArea, area, nextA;
    decimated[sampledIndex++] = data[a];
    for (i = 0; i < samples - 2; i++) {
      let avgX = 0;
      let avgY = 0;
      let j;
      const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
      const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
      const avgRangeLength = avgRangeEnd - avgRangeStart;
      for (j = avgRangeStart; j < avgRangeEnd; j++) {
        avgX += data[j].x;
        avgY += data[j].y;
      }
      avgX /= avgRangeLength;
      avgY /= avgRangeLength;
      const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
      const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
      const { x: pointAx, y: pointAy } = data[a];
      maxArea = area = -1;
      for (j = rangeOffs; j < rangeTo; j++) {
        area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
        if (area > maxArea) {
          maxArea = area;
          maxAreaPoint = data[j];
          nextA = j;
        }
      }
      decimated[sampledIndex++] = maxAreaPoint;
      a = nextA;
    }
    decimated[sampledIndex++] = data[endIndex];
    return decimated;
  }
  function minMaxDecimation(data, start, count, availableWidth) {
    let avgX = 0;
    let countX = 0;
    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
    const decimated = [];
    const endIndex = start + count - 1;
    const xMin = data[start].x;
    const xMax = data[endIndex].x;
    const dx = xMax - xMin;
    for (i = start; i < start + count; ++i) {
      point = data[i];
      x = (point.x - xMin) / dx * availableWidth;
      y = point.y;
      const truncX = x | 0;
      if (truncX === prevX) {
        if (y < minY) {
          minY = y;
          minIndex = i;
        } else if (y > maxY) {
          maxY = y;
          maxIndex = i;
        }
        avgX = (countX * avgX + point.x) / ++countX;
      } else {
        const lastIndex = i - 1;
        if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
          const intermediateIndex1 = Math.min(minIndex, maxIndex);
          const intermediateIndex2 = Math.max(minIndex, maxIndex);
          if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {
              x: avgX
            }));
          }
          if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
            decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {
              x: avgX
            }));
          }
        }
        if (i > 0 && lastIndex !== startIndex) {
          decimated.push(data[lastIndex]);
        }
        decimated.push(point);
        prevX = truncX;
        countX = 0;
        minY = maxY = y;
        minIndex = maxIndex = startIndex = i;
      }
    }
    return decimated;
  }
  function cleanDecimatedDataset(dataset) {
    if (dataset._decimated) {
      const data = dataset._data;
      delete dataset._decimated;
      delete dataset._data;
      Object.defineProperty(dataset, "data", {
        configurable: true,
        enumerable: true,
        writable: true,
        value: data
      });
    }
  }
  function cleanDecimatedData(chart) {
    chart.data.datasets.forEach((dataset) => {
      cleanDecimatedDataset(dataset);
    });
  }
  function getStartAndCountOfVisiblePointsSimplified(meta, points) {
    const pointCount = points.length;
    let start = 0;
    let count;
    const { iScale } = meta;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
    }
    if (maxDefined) {
      count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
    return {
      start,
      count
    };
  }
  var plugin_decimation = {
    id: "decimation",
    defaults: {
      algorithm: "min-max",
      enabled: false
    },
    beforeElementsUpdate: (chart, args, options) => {
      if (!options.enabled) {
        cleanDecimatedData(chart);
        return;
      }
      const availableWidth = chart.width;
      chart.data.datasets.forEach((dataset, datasetIndex) => {
        const { _data, indexAxis } = dataset;
        const meta = chart.getDatasetMeta(datasetIndex);
        const data = _data || dataset.data;
        if (resolve([
          indexAxis,
          chart.options.indexAxis
        ]) === "y") {
          return;
        }
        if (!meta.controller.supportsDecimation) {
          return;
        }
        const xAxis = chart.scales[meta.xAxisID];
        if (xAxis.type !== "linear" && xAxis.type !== "time") {
          return;
        }
        if (chart.options.parsing) {
          return;
        }
        let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
        const threshold = options.threshold || 4 * availableWidth;
        if (count <= threshold) {
          cleanDecimatedDataset(dataset);
          return;
        }
        if (isNullOrUndef(_data)) {
          dataset._data = data;
          delete dataset.data;
          Object.defineProperty(dataset, "data", {
            configurable: true,
            enumerable: true,
            get: function() {
              return this._decimated;
            },
            set: function(d) {
              this._data = d;
            }
          });
        }
        let decimated;
        switch (options.algorithm) {
          case "lttb":
            decimated = lttbDecimation(data, start, count, availableWidth, options);
            break;
          case "min-max":
            decimated = minMaxDecimation(data, start, count, availableWidth);
            break;
          default:
            throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
        }
        dataset._decimated = decimated;
      });
    },
    destroy(chart) {
      cleanDecimatedData(chart);
    }
  };
  function _segments(line, target, property) {
    const segments = line.segments;
    const points = line.points;
    const tpoints = target.points;
    const parts = [];
    for (const segment of segments) {
      let { start, end } = segment;
      end = _findSegmentEnd(start, end, points);
      const bounds = _getBounds(property, points[start], points[end], segment.loop);
      if (!target.segments) {
        parts.push({
          source: segment,
          target: bounds,
          start: points[start],
          end: points[end]
        });
        continue;
      }
      const targetSegments = _boundSegments(target, bounds);
      for (const tgt of targetSegments) {
        const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
        const fillSources = _boundSegment(segment, points, subBounds);
        for (const fillSource of fillSources) {
          parts.push({
            source: fillSource,
            target: tgt,
            start: {
              [property]: _getEdge(bounds, subBounds, "start", Math.max)
            },
            end: {
              [property]: _getEdge(bounds, subBounds, "end", Math.min)
            }
          });
        }
      }
    }
    return parts;
  }
  function _getBounds(property, first, last, loop) {
    if (loop) {
      return;
    }
    let start = first[property];
    let end = last[property];
    if (property === "angle") {
      start = _normalizeAngle(start);
      end = _normalizeAngle(end);
    }
    return {
      property,
      start,
      end
    };
  }
  function _pointsFromSegments(boundary, line) {
    const { x = null, y = null } = boundary || {};
    const linePoints = line.points;
    const points = [];
    line.segments.forEach(({ start, end }) => {
      end = _findSegmentEnd(start, end, linePoints);
      const first = linePoints[start];
      const last = linePoints[end];
      if (y !== null) {
        points.push({
          x: first.x,
          y
        });
        points.push({
          x: last.x,
          y
        });
      } else if (x !== null) {
        points.push({
          x,
          y: first.y
        });
        points.push({
          x,
          y: last.y
        });
      }
    });
    return points;
  }
  function _findSegmentEnd(start, end, points) {
    for (; end > start; end--) {
      const point = points[end];
      if (!isNaN(point.x) && !isNaN(point.y)) {
        break;
      }
    }
    return end;
  }
  function _getEdge(a, b, prop, fn) {
    if (a && b) {
      return fn(a[prop], b[prop]);
    }
    return a ? a[prop] : b ? b[prop] : 0;
  }
  function _createBoundaryLine(boundary, line) {
    let points = [];
    let _loop = false;
    if (isArray(boundary)) {
      _loop = true;
      points = boundary;
    } else {
      points = _pointsFromSegments(boundary, line);
    }
    return points.length ? new LineElement({
      points,
      options: {
        tension: 0
      },
      _loop,
      _fullLoop: _loop
    }) : null;
  }
  function _shouldApplyFill(source) {
    return source && source.fill !== false;
  }
  function _resolveTarget(sources, index2, propagate) {
    const source = sources[index2];
    let fill2 = source.fill;
    const visited = [
      index2
    ];
    let target;
    if (!propagate) {
      return fill2;
    }
    while (fill2 !== false && visited.indexOf(fill2) === -1) {
      if (!isNumberFinite(fill2)) {
        return fill2;
      }
      target = sources[fill2];
      if (!target) {
        return false;
      }
      if (target.visible) {
        return fill2;
      }
      visited.push(fill2);
      fill2 = target.fill;
    }
    return false;
  }
  function _decodeFill(line, index2, count) {
    const fill2 = parseFillOption(line);
    if (isObject2(fill2)) {
      return isNaN(fill2.value) ? false : fill2;
    }
    let target = parseFloat(fill2);
    if (isNumberFinite(target) && Math.floor(target) === target) {
      return decodeTargetIndex(fill2[0], index2, target, count);
    }
    return [
      "origin",
      "start",
      "end",
      "stack",
      "shape"
    ].indexOf(fill2) >= 0 && fill2;
  }
  function decodeTargetIndex(firstCh, index2, target, count) {
    if (firstCh === "-" || firstCh === "+") {
      target = index2 + target;
    }
    if (target === index2 || target < 0 || target >= count) {
      return false;
    }
    return target;
  }
  function _getTargetPixel(fill2, scale) {
    let pixel = null;
    if (fill2 === "start") {
      pixel = scale.bottom;
    } else if (fill2 === "end") {
      pixel = scale.top;
    } else if (isObject2(fill2)) {
      pixel = scale.getPixelForValue(fill2.value);
    } else if (scale.getBasePixel) {
      pixel = scale.getBasePixel();
    }
    return pixel;
  }
  function _getTargetValue(fill2, scale, startValue) {
    let value;
    if (fill2 === "start") {
      value = startValue;
    } else if (fill2 === "end") {
      value = scale.options.reverse ? scale.min : scale.max;
    } else if (isObject2(fill2)) {
      value = fill2.value;
    } else {
      value = scale.getBaseValue();
    }
    return value;
  }
  function parseFillOption(line) {
    const options = line.options;
    const fillOption = options.fill;
    let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
    if (fill2 === void 0) {
      fill2 = !!options.backgroundColor;
    }
    if (fill2 === false || fill2 === null) {
      return false;
    }
    if (fill2 === true) {
      return "origin";
    }
    return fill2;
  }
  function _buildStackLine(source) {
    const { scale, index: index2, line } = source;
    const points = [];
    const segments = line.segments;
    const sourcePoints = line.points;
    const linesBelow = getLinesBelow(scale, index2);
    linesBelow.push(_createBoundaryLine({
      x: null,
      y: scale.bottom
    }, line));
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      for (let j = segment.start; j <= segment.end; j++) {
        addPointsBelow(points, sourcePoints[j], linesBelow);
      }
    }
    return new LineElement({
      points,
      options: {}
    });
  }
  function getLinesBelow(scale, index2) {
    const below = [];
    const metas = scale.getMatchingVisibleMetas("line");
    for (let i = 0; i < metas.length; i++) {
      const meta = metas[i];
      if (meta.index === index2) {
        break;
      }
      if (!meta.hidden) {
        below.unshift(meta.dataset);
      }
    }
    return below;
  }
  function addPointsBelow(points, sourcePoint, linesBelow) {
    const postponed = [];
    for (let j = 0; j < linesBelow.length; j++) {
      const line = linesBelow[j];
      const { first, last, point } = findPoint(line, sourcePoint, "x");
      if (!point || first && last) {
        continue;
      }
      if (first) {
        postponed.unshift(point);
      } else {
        points.push(point);
        if (!last) {
          break;
        }
      }
    }
    points.push(...postponed);
  }
  function findPoint(line, sourcePoint, property) {
    const point = line.interpolate(sourcePoint, property);
    if (!point) {
      return {};
    }
    const pointValue = point[property];
    const segments = line.segments;
    const linePoints = line.points;
    let first = false;
    let last = false;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      const firstValue = linePoints[segment.start][property];
      const lastValue = linePoints[segment.end][property];
      if (_isBetween(pointValue, firstValue, lastValue)) {
        first = pointValue === firstValue;
        last = pointValue === lastValue;
        break;
      }
    }
    return {
      first,
      last,
      point
    };
  }
  var simpleArc = class {
    constructor(opts) {
      this.x = opts.x;
      this.y = opts.y;
      this.radius = opts.radius;
    }
    pathSegment(ctx, bounds, opts) {
      const { x, y, radius } = this;
      bounds = bounds || {
        start: 0,
        end: TAU
      };
      ctx.arc(x, y, radius, bounds.end, bounds.start, true);
      return !opts.bounds;
    }
    interpolate(point) {
      const { x, y, radius } = this;
      const angle = point.angle;
      return {
        x: x + Math.cos(angle) * radius,
        y: y + Math.sin(angle) * radius,
        angle
      };
    }
  };
  function _getTarget(source) {
    const { chart, fill: fill2, line } = source;
    if (isNumberFinite(fill2)) {
      return getLineByIndex(chart, fill2);
    }
    if (fill2 === "stack") {
      return _buildStackLine(source);
    }
    if (fill2 === "shape") {
      return true;
    }
    const boundary = computeBoundary(source);
    if (boundary instanceof simpleArc) {
      return boundary;
    }
    return _createBoundaryLine(boundary, line);
  }
  function getLineByIndex(chart, index2) {
    const meta = chart.getDatasetMeta(index2);
    const visible = meta && chart.isDatasetVisible(index2);
    return visible ? meta.dataset : null;
  }
  function computeBoundary(source) {
    const scale = source.scale || {};
    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }
    return computeLinearBoundary(source);
  }
  function computeLinearBoundary(source) {
    const { scale = {}, fill: fill2 } = source;
    const pixel = _getTargetPixel(fill2, scale);
    if (isNumberFinite(pixel)) {
      const horizontal = scale.isHorizontal();
      return {
        x: horizontal ? pixel : null,
        y: horizontal ? null : pixel
      };
    }
    return null;
  }
  function computeCircularBoundary(source) {
    const { scale, fill: fill2 } = source;
    const options = scale.options;
    const length = scale.getLabels().length;
    const start = options.reverse ? scale.max : scale.min;
    const value = _getTargetValue(fill2, scale, start);
    const target = [];
    if (options.grid.circular) {
      const center = scale.getPointPositionForValue(0, start);
      return new simpleArc({
        x: center.x,
        y: center.y,
        radius: scale.getDistanceFromCenterForValue(value)
      });
    }
    for (let i = 0; i < length; ++i) {
      target.push(scale.getPointPositionForValue(i, value));
    }
    return target;
  }
  function _drawfill(ctx, source, area) {
    const target = _getTarget(source);
    const { line, scale, axis } = source;
    const lineOpts = line.options;
    const fillOption = lineOpts.fill;
    const color2 = lineOpts.backgroundColor;
    const { above = color2, below = color2 } = fillOption || {};
    if (target && line.points.length) {
      clipArea(ctx, area);
      doFill(ctx, {
        line,
        target,
        above,
        below,
        area,
        scale,
        axis
      });
      unclipArea(ctx);
    }
  }
  function doFill(ctx, cfg) {
    const { line, target, above, below, area, scale } = cfg;
    const property = line._loop ? "angle" : cfg.axis;
    ctx.save();
    if (property === "x" && below !== above) {
      clipVertical(ctx, target, area.top);
      fill(ctx, {
        line,
        target,
        color: above,
        scale,
        property
      });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    }
    fill(ctx, {
      line,
      target,
      color: below,
      scale,
      property
    });
    ctx.restore();
  }
  function clipVertical(ctx, target, clipY) {
    const { segments, points } = target;
    let first = true;
    let lineLoop = false;
    ctx.beginPath();
    for (const segment of segments) {
      const { start, end } = segment;
      const firstPoint = points[start];
      const lastPoint = points[_findSegmentEnd(start, end, points)];
      if (first) {
        ctx.moveTo(firstPoint.x, firstPoint.y);
        first = false;
      } else {
        ctx.lineTo(firstPoint.x, clipY);
        ctx.lineTo(firstPoint.x, firstPoint.y);
      }
      lineLoop = !!target.pathSegment(ctx, segment, {
        move: lineLoop
      });
      if (lineLoop) {
        ctx.closePath();
      } else {
        ctx.lineTo(lastPoint.x, clipY);
      }
    }
    ctx.lineTo(target.first().x, clipY);
    ctx.closePath();
    ctx.clip();
  }
  function fill(ctx, cfg) {
    const { line, target, property, color: color2, scale } = cfg;
    const segments = _segments(line, target, property);
    for (const { source: src, target: tgt, start, end } of segments) {
      const { style: { backgroundColor = color2 } = {} } = src;
      const notShape = target !== true;
      ctx.save();
      ctx.fillStyle = backgroundColor;
      clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
      ctx.beginPath();
      const lineLoop = !!line.pathSegment(ctx, src);
      let loop;
      if (notShape) {
        if (lineLoop) {
          ctx.closePath();
        } else {
          interpolatedLineTo(ctx, target, end, property);
        }
        const targetLoop = !!target.pathSegment(ctx, tgt, {
          move: lineLoop,
          reverse: true
        });
        loop = lineLoop && targetLoop;
        if (!loop) {
          interpolatedLineTo(ctx, target, start, property);
        }
      }
      ctx.closePath();
      ctx.fill(loop ? "evenodd" : "nonzero");
      ctx.restore();
    }
  }
  function clipBounds(ctx, scale, bounds) {
    const { top: top2, bottom: bottom2 } = scale.chart.chartArea;
    const { property, start, end } = bounds || {};
    if (property === "x") {
      ctx.beginPath();
      ctx.rect(start, top2, end - start, bottom2 - top2);
      ctx.clip();
    }
  }
  function interpolatedLineTo(ctx, target, point, property) {
    const interpolatedPoint = target.interpolate(point, property);
    if (interpolatedPoint) {
      ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
    }
  }
  var index = {
    id: "filler",
    afterDatasetsUpdate(chart, _args, options) {
      const count = (chart.data.datasets || []).length;
      const sources = [];
      let meta, i, line, source;
      for (i = 0; i < count; ++i) {
        meta = chart.getDatasetMeta(i);
        line = meta.dataset;
        source = null;
        if (line && line.options && line instanceof LineElement) {
          source = {
            visible: chart.isDatasetVisible(i),
            index: i,
            fill: _decodeFill(line, i, count),
            chart,
            axis: meta.controller.options.indexAxis,
            scale: meta.vScale,
            line
          };
        }
        meta.$filler = source;
        sources.push(source);
      }
      for (i = 0; i < count; ++i) {
        source = sources[i];
        if (!source || source.fill === false) {
          continue;
        }
        source.fill = _resolveTarget(sources, i, options.propagate);
      }
    },
    beforeDraw(chart, _args, options) {
      const draw2 = options.drawTime === "beforeDraw";
      const metasets = chart.getSortedVisibleDatasetMetas();
      const area = chart.chartArea;
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source = metasets[i].$filler;
        if (!source) {
          continue;
        }
        source.line.updateControlPoints(area, source.axis);
        if (draw2 && source.fill) {
          _drawfill(chart.ctx, source, area);
        }
      }
    },
    beforeDatasetsDraw(chart, _args, options) {
      if (options.drawTime !== "beforeDatasetsDraw") {
        return;
      }
      const metasets = chart.getSortedVisibleDatasetMetas();
      for (let i = metasets.length - 1; i >= 0; --i) {
        const source = metasets[i].$filler;
        if (_shouldApplyFill(source)) {
          _drawfill(chart.ctx, source, chart.chartArea);
        }
      }
    },
    beforeDatasetDraw(chart, args, options) {
      const source = args.meta.$filler;
      if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") {
        return;
      }
      _drawfill(chart.ctx, source, chart.chartArea);
    },
    defaults: {
      propagate: true,
      drawTime: "beforeDatasetDraw"
    }
  };
  var getBoxSize = (labelOpts, fontSize) => {
    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
    if (labelOpts.usePointStyle) {
      boxHeight = Math.min(boxHeight, fontSize);
      boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
    }
    return {
      boxWidth,
      boxHeight,
      itemHeight: Math.max(fontSize, boxHeight)
    };
  };
  var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
  var Legend = class extends Element {
    constructor(config) {
      super();
      this._added = false;
      this.legendHitBoxes = [];
      this._hoveredItem = null;
      this.doughnutMode = false;
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this.legendItems = void 0;
      this.columnSizes = void 0;
      this.lineWidths = void 0;
      this.maxHeight = void 0;
      this.maxWidth = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.height = void 0;
      this.width = void 0;
      this._margins = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight, margins) {
      this.maxWidth = maxWidth;
      this.maxHeight = maxHeight;
      this._margins = margins;
      this.setDimensions();
      this.buildLabels();
      this.fit();
    }
    setDimensions() {
      if (this.isHorizontal()) {
        this.width = this.maxWidth;
        this.left = this._margins.left;
        this.right = this.width;
      } else {
        this.height = this.maxHeight;
        this.top = this._margins.top;
        this.bottom = this.height;
      }
    }
    buildLabels() {
      const labelOpts = this.options.labels || {};
      let legendItems = callback(labelOpts.generateLabels, [
        this.chart
      ], this) || [];
      if (labelOpts.filter) {
        legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
      }
      if (labelOpts.sort) {
        legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
      }
      if (this.options.reverse) {
        legendItems.reverse();
      }
      this.legendItems = legendItems;
    }
    fit() {
      const { options, ctx } = this;
      if (!options.display) {
        this.width = this.height = 0;
        return;
      }
      const labelOpts = options.labels;
      const labelFont = toFont(labelOpts.font);
      const fontSize = labelFont.size;
      const titleHeight = this._computeTitleHeight();
      const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
      let width, height;
      ctx.font = labelFont.string;
      if (this.isHorizontal()) {
        width = this.maxWidth;
        height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
      } else {
        height = this.maxHeight;
        width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
      }
      this.width = Math.min(width, options.maxWidth || this.maxWidth);
      this.height = Math.min(height, options.maxHeight || this.maxHeight);
    }
    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
      const { ctx, maxWidth, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const lineWidths = this.lineWidths = [
        0
      ];
      const lineHeight = itemHeight + padding;
      let totalHeight = titleHeight;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      let row = -1;
      let top2 = -lineHeight;
      this.legendItems.forEach((legendItem, i) => {
        const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
        if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
          totalHeight += lineHeight;
          lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
          top2 += lineHeight;
          row++;
        }
        hitboxes[i] = {
          left: 0,
          top: top2,
          row,
          width: itemWidth,
          height: itemHeight
        };
        lineWidths[lineWidths.length - 1] += itemWidth + padding;
      });
      return totalHeight;
    }
    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
      const { ctx, maxHeight, options: { labels: { padding } } } = this;
      const hitboxes = this.legendHitBoxes = [];
      const columnSizes = this.columnSizes = [];
      const heightLimit = maxHeight - titleHeight;
      let totalWidth = padding;
      let currentColWidth = 0;
      let currentColHeight = 0;
      let left = 0;
      let col = 0;
      this.legendItems.forEach((legendItem, i) => {
        const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
        if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
          totalWidth += currentColWidth + padding;
          columnSizes.push({
            width: currentColWidth,
            height: currentColHeight
          });
          left += currentColWidth + padding;
          col++;
          currentColWidth = currentColHeight = 0;
        }
        hitboxes[i] = {
          left,
          top: currentColHeight,
          col,
          width: itemWidth,
          height: itemHeight
        };
        currentColWidth = Math.max(currentColWidth, itemWidth);
        currentColHeight += itemHeight + padding;
      });
      totalWidth += currentColWidth;
      columnSizes.push({
        width: currentColWidth,
        height: currentColHeight
      });
      return totalWidth;
    }
    adjustHitBoxes() {
      if (!this.options.display) {
        return;
      }
      const titleHeight = this._computeTitleHeight();
      const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
      const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
      if (this.isHorizontal()) {
        let row = 0;
        let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        for (const hitbox of hitboxes) {
          if (row !== hitbox.row) {
            row = hitbox.row;
            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
          }
          hitbox.top += this.top + titleHeight + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
          left += hitbox.width + padding;
        }
      } else {
        let col = 0;
        let top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        for (const hitbox of hitboxes) {
          if (hitbox.col !== col) {
            col = hitbox.col;
            top2 = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
          }
          hitbox.top = top2;
          hitbox.left += this.left + padding;
          hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
          top2 += hitbox.height + padding;
        }
      }
    }
    isHorizontal() {
      return this.options.position === "top" || this.options.position === "bottom";
    }
    draw() {
      if (this.options.display) {
        const ctx = this.ctx;
        clipArea(ctx, this);
        this._draw();
        unclipArea(ctx);
      }
    }
    _draw() {
      const { options: opts, columnSizes, lineWidths, ctx } = this;
      const { align, labels: labelOpts } = opts;
      const defaultColor = defaults.color;
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const labelFont = toFont(labelOpts.font);
      const { padding } = labelOpts;
      const fontSize = labelFont.size;
      const halfFontSize = fontSize / 2;
      let cursor;
      this.drawTitle();
      ctx.textAlign = rtlHelper.textAlign("left");
      ctx.textBaseline = "middle";
      ctx.lineWidth = 0.5;
      ctx.font = labelFont.string;
      const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
      const drawLegendBox = function(x, y, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
          return;
        }
        ctx.save();
        const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
        ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
        ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
        ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
        ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
        if (labelOpts.usePointStyle) {
          const drawOptions = {
            radius: boxHeight * Math.SQRT2 / 2,
            pointStyle: legendItem.pointStyle,
            rotation: legendItem.rotation,
            borderWidth: lineWidth
          };
          const centerX = rtlHelper.xPlus(x, boxWidth / 2);
          const centerY = y + halfFontSize;
          drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
        } else {
          const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
          const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
          const borderRadius = toTRBLCorners(legendItem.borderRadius);
          ctx.beginPath();
          if (Object.values(borderRadius).some((v) => v !== 0)) {
            addRoundedRectPath(ctx, {
              x: xBoxLeft,
              y: yBoxTop,
              w: boxWidth,
              h: boxHeight,
              radius: borderRadius
            });
          } else {
            ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
          }
          ctx.fill();
          if (lineWidth !== 0) {
            ctx.stroke();
          }
        }
        ctx.restore();
      };
      const fillText = function(x, y, legendItem) {
        renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
          strikethrough: legendItem.hidden,
          textAlign: rtlHelper.textAlign(legendItem.textAlign)
        });
      };
      const isHorizontal = this.isHorizontal();
      const titleHeight = this._computeTitleHeight();
      if (isHorizontal) {
        cursor = {
          x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
          y: this.top + padding + titleHeight,
          line: 0
        };
      } else {
        cursor = {
          x: this.left + padding,
          y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
          line: 0
        };
      }
      overrideTextDirection(this.ctx, opts.textDirection);
      const lineHeight = itemHeight + padding;
      this.legendItems.forEach((legendItem, i) => {
        ctx.strokeStyle = legendItem.fontColor;
        ctx.fillStyle = legendItem.fontColor;
        const textWidth = ctx.measureText(legendItem.text).width;
        const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
        const width = boxWidth + halfFontSize + textWidth;
        let x = cursor.x;
        let y = cursor.y;
        rtlHelper.setWidth(this.width);
        if (isHorizontal) {
          if (i > 0 && x + width + padding > this.right) {
            y = cursor.y += lineHeight;
            cursor.line++;
            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
          }
        } else if (i > 0 && y + lineHeight > this.bottom) {
          x = cursor.x = x + columnSizes[cursor.line].width + padding;
          cursor.line++;
          y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
        }
        const realX = rtlHelper.x(x);
        drawLegendBox(realX, y, legendItem);
        x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
        fillText(rtlHelper.x(x), y, legendItem);
        if (isHorizontal) {
          cursor.x += width + padding;
        } else if (typeof legendItem.text !== "string") {
          const fontLineHeight = labelFont.lineHeight;
          cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
        } else {
          cursor.y += lineHeight;
        }
      });
      restoreTextDirection(this.ctx, opts.textDirection);
    }
    drawTitle() {
      const opts = this.options;
      const titleOpts = opts.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      if (!titleOpts.display) {
        return;
      }
      const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
      const ctx = this.ctx;
      const position = titleOpts.position;
      const halfFontSize = titleFont.size / 2;
      const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
      let y;
      let left = this.left;
      let maxWidth = this.width;
      if (this.isHorizontal()) {
        maxWidth = Math.max(...this.lineWidths);
        y = this.top + topPaddingPlusHalfFontSize;
        left = _alignStartEnd(opts.align, left, this.right - maxWidth);
      } else {
        const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
        y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
      }
      const x = _alignStartEnd(position, left, left + maxWidth);
      ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
      ctx.textBaseline = "middle";
      ctx.strokeStyle = titleOpts.color;
      ctx.fillStyle = titleOpts.color;
      ctx.font = titleFont.string;
      renderText(ctx, titleOpts.text, x, y, titleFont);
    }
    _computeTitleHeight() {
      const titleOpts = this.options.title;
      const titleFont = toFont(titleOpts.font);
      const titlePadding = toPadding(titleOpts.padding);
      return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
    }
    _getLegendItemAt(x, y) {
      let i, hitBox, lh;
      if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
        lh = this.legendHitBoxes;
        for (i = 0; i < lh.length; ++i) {
          hitBox = lh[i];
          if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
            return this.legendItems[i];
          }
        }
      }
      return null;
    }
    handleEvent(e) {
      const opts = this.options;
      if (!isListened(e.type, opts)) {
        return;
      }
      const hoveredItem = this._getLegendItemAt(e.x, e.y);
      if (e.type === "mousemove" || e.type === "mouseout") {
        const previous = this._hoveredItem;
        const sameItem = itemsEqual(previous, hoveredItem);
        if (previous && !sameItem) {
          callback(opts.onLeave, [
            e,
            previous,
            this
          ], this);
        }
        this._hoveredItem = hoveredItem;
        if (hoveredItem && !sameItem) {
          callback(opts.onHover, [
            e,
            hoveredItem,
            this
          ], this);
        }
      } else if (hoveredItem) {
        callback(opts.onClick, [
          e,
          hoveredItem,
          this
        ], this);
      }
    }
  };
  function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
    return {
      itemWidth,
      itemHeight
    };
  }
  function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
    let legendItemText = legendItem.text;
    if (legendItemText && typeof legendItemText !== "string") {
      legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
    }
    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
  }
  function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
    let itemHeight = _itemHeight;
    if (typeof legendItem.text !== "string") {
      itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
    }
    return itemHeight;
  }
  function calculateLegendItemHeight(legendItem, fontLineHeight) {
    const labelHeight = legendItem.text ? legendItem.text.length : 0;
    return fontLineHeight * labelHeight;
  }
  function isListened(type, opts) {
    if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
      return true;
    }
    if (opts.onClick && (type === "click" || type === "mouseup")) {
      return true;
    }
    return false;
  }
  var plugin_legend = {
    id: "legend",
    _element: Legend,
    start(chart, _args, options) {
      const legend = chart.legend = new Legend({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, legend, options);
      layouts.addBox(chart, legend);
    },
    stop(chart) {
      layouts.removeBox(chart, chart.legend);
      delete chart.legend;
    },
    beforeUpdate(chart, _args, options) {
      const legend = chart.legend;
      layouts.configure(chart, legend, options);
      legend.options = options;
    },
    afterUpdate(chart) {
      const legend = chart.legend;
      legend.buildLabels();
      legend.adjustHitBoxes();
    },
    afterEvent(chart, args) {
      if (!args.replay) {
        chart.legend.handleEvent(args.event);
      }
    },
    defaults: {
      display: true,
      position: "top",
      align: "center",
      fullSize: true,
      reverse: false,
      weight: 1e3,
      onClick(e, legendItem, legend) {
        const index2 = legendItem.datasetIndex;
        const ci = legend.chart;
        if (ci.isDatasetVisible(index2)) {
          ci.hide(index2);
          legendItem.hidden = true;
        } else {
          ci.show(index2);
          legendItem.hidden = false;
        }
      },
      onHover: null,
      onLeave: null,
      labels: {
        color: (ctx) => ctx.chart.options.color,
        boxWidth: 40,
        padding: 10,
        generateLabels(chart) {
          const datasets = chart.data.datasets;
          const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
          return chart._getSortedDatasetMetas().map((meta) => {
            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
            const borderWidth = toPadding(style.borderWidth);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              fontColor: color2,
              hidden: !meta.visible,
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: (borderWidth.width + borderWidth.height) / 4,
              strokeStyle: style.borderColor,
              pointStyle: pointStyle || style.pointStyle,
              rotation: style.rotation,
              textAlign: textAlign || style.textAlign,
              borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
              datasetIndex: meta.index
            };
          }, this);
        }
      },
      title: {
        color: (ctx) => ctx.chart.options.color,
        display: false,
        position: "center",
        text: ""
      }
    },
    descriptors: {
      _scriptable: (name) => !name.startsWith("on"),
      labels: {
        _scriptable: (name) => ![
          "generateLabels",
          "filter",
          "sort"
        ].includes(name)
      }
    }
  };
  var Title = class extends Element {
    constructor(config) {
      super();
      this.chart = config.chart;
      this.options = config.options;
      this.ctx = config.ctx;
      this._padding = void 0;
      this.top = void 0;
      this.bottom = void 0;
      this.left = void 0;
      this.right = void 0;
      this.width = void 0;
      this.height = void 0;
      this.position = void 0;
      this.weight = void 0;
      this.fullSize = void 0;
    }
    update(maxWidth, maxHeight) {
      const opts = this.options;
      this.left = 0;
      this.top = 0;
      if (!opts.display) {
        this.width = this.height = this.right = this.bottom = 0;
        return;
      }
      this.width = this.right = maxWidth;
      this.height = this.bottom = maxHeight;
      const lineCount = isArray(opts.text) ? opts.text.length : 1;
      this._padding = toPadding(opts.padding);
      const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
      if (this.isHorizontal()) {
        this.height = textSize;
      } else {
        this.width = textSize;
      }
    }
    isHorizontal() {
      const pos = this.options.position;
      return pos === "top" || pos === "bottom";
    }
    _drawArgs(offset) {
      const { top: top2, left, bottom: bottom2, right, options } = this;
      const align = options.align;
      let rotation = 0;
      let maxWidth, titleX, titleY;
      if (this.isHorizontal()) {
        titleX = _alignStartEnd(align, left, right);
        titleY = top2 + offset;
        maxWidth = right - left;
      } else {
        if (options.position === "left") {
          titleX = left + offset;
          titleY = _alignStartEnd(align, bottom2, top2);
          rotation = PI * -0.5;
        } else {
          titleX = right - offset;
          titleY = _alignStartEnd(align, top2, bottom2);
          rotation = PI * 0.5;
        }
        maxWidth = bottom2 - top2;
      }
      return {
        titleX,
        titleY,
        maxWidth,
        rotation
      };
    }
    draw() {
      const ctx = this.ctx;
      const opts = this.options;
      if (!opts.display) {
        return;
      }
      const fontOpts = toFont(opts.font);
      const lineHeight = fontOpts.lineHeight;
      const offset = lineHeight / 2 + this._padding.top;
      const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
      renderText(ctx, opts.text, 0, 0, fontOpts, {
        color: opts.color,
        maxWidth,
        rotation,
        textAlign: _toLeftRightCenter(opts.align),
        textBaseline: "middle",
        translation: [
          titleX,
          titleY
        ]
      });
    }
  };
  function createTitle(chart, titleOpts) {
    const title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart
    });
    layouts.configure(chart, title, titleOpts);
    layouts.addBox(chart, title);
    chart.titleBlock = title;
  }
  var plugin_title = {
    id: "title",
    _element: Title,
    start(chart, _args, options) {
      createTitle(chart, options);
    },
    stop(chart) {
      const titleBlock = chart.titleBlock;
      layouts.removeBox(chart, titleBlock);
      delete chart.titleBlock;
    },
    beforeUpdate(chart, _args, options) {
      const title = chart.titleBlock;
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "bold"
      },
      fullSize: true,
      padding: 10,
      position: "top",
      text: "",
      weight: 2e3
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var map2 = /* @__PURE__ */ new WeakMap();
  var plugin_subtitle = {
    id: "subtitle",
    start(chart, _args, options) {
      const title = new Title({
        ctx: chart.ctx,
        options,
        chart
      });
      layouts.configure(chart, title, options);
      layouts.addBox(chart, title);
      map2.set(chart, title);
    },
    stop(chart) {
      layouts.removeBox(chart, map2.get(chart));
      map2.delete(chart);
    },
    beforeUpdate(chart, _args, options) {
      const title = map2.get(chart);
      layouts.configure(chart, title, options);
      title.options = options;
    },
    defaults: {
      align: "center",
      display: false,
      font: {
        weight: "normal"
      },
      fullSize: true,
      padding: 0,
      position: "top",
      text: "",
      weight: 1500
    },
    defaultRoutes: {
      color: "color"
    },
    descriptors: {
      _scriptable: true,
      _indexable: false
    }
  };
  var positioners = {
    average(items) {
      if (!items.length) {
        return false;
      }
      let i, len;
      let xSet = /* @__PURE__ */ new Set();
      let y = 0;
      let count = 0;
      for (i = 0, len = items.length; i < len; ++i) {
        const el = items[i].element;
        if (el && el.hasValue()) {
          const pos = el.tooltipPosition();
          xSet.add(pos.x);
          y += pos.y;
          ++count;
        }
      }
      if (count === 0 || xSet.size === 0) {
        return false;
      }
      const xAverage = [
        ...xSet
      ].reduce((a, b) => a + b) / xSet.size;
      return {
        x: xAverage,
        y: y / count
      };
    },
    nearest(items, eventPosition) {
      if (!items.length) {
        return false;
      }
      let x = eventPosition.x;
      let y = eventPosition.y;
      let minDistance = Number.POSITIVE_INFINITY;
      let i, len, nearestElement;
      for (i = 0, len = items.length; i < len; ++i) {
        const el = items[i].element;
        if (el && el.hasValue()) {
          const center = el.getCenterPoint();
          const d = distanceBetweenPoints(eventPosition, center);
          if (d < minDistance) {
            minDistance = d;
            nearestElement = el;
          }
        }
      }
      if (nearestElement) {
        const tp = nearestElement.tooltipPosition();
        x = tp.x;
        y = tp.y;
      }
      return {
        x,
        y
      };
    }
  };
  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (isArray(toPush)) {
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }
    return base;
  }
  function splitNewlines(str) {
    if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
      return str.split("\n");
    }
    return str;
  }
  function createTooltipItem(chart, item) {
    const { element, datasetIndex, index: index2 } = item;
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    const { label, value } = controller.getLabelAndValue(index2);
    return {
      chart,
      label,
      parsed: controller.getParsed(index2),
      raw: chart.data.datasets[datasetIndex].data[index2],
      formattedValue: value,
      dataset: controller.getDataset(),
      dataIndex: index2,
      datasetIndex,
      element
    };
  }
  function getTooltipSize(tooltip, options) {
    const ctx = tooltip.chart.ctx;
    const { body, footer, title } = tooltip;
    const { boxWidth, boxHeight } = options;
    const bodyFont = toFont(options.bodyFont);
    const titleFont = toFont(options.titleFont);
    const footerFont = toFont(options.footerFont);
    const titleLineCount = title.length;
    const footerLineCount = footer.length;
    const bodyLineItemCount = body.length;
    const padding = toPadding(options.padding);
    let height = padding.height;
    let width = 0;
    let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
    if (titleLineCount) {
      height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
    }
    if (combinedBodyLength) {
      const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
      height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
    }
    if (footerLineCount) {
      height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
    }
    let widthPadding = 0;
    const maxLineWidth = function(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };
    ctx.save();
    ctx.font = titleFont.string;
    each(tooltip.title, maxLineWidth);
    ctx.font = bodyFont.string;
    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
    each(body, (bodyItem) => {
      each(bodyItem.before, maxLineWidth);
      each(bodyItem.lines, maxLineWidth);
      each(bodyItem.after, maxLineWidth);
    });
    widthPadding = 0;
    ctx.font = footerFont.string;
    each(tooltip.footer, maxLineWidth);
    ctx.restore();
    width += padding.width;
    return {
      width,
      height
    };
  }
  function determineYAlign(chart, size) {
    const { y, height } = size;
    if (y < height / 2) {
      return "top";
    } else if (y > chart.height - height / 2) {
      return "bottom";
    }
    return "center";
  }
  function doesNotFitWithAlign(xAlign, chart, options, size) {
    const { x, width } = size;
    const caret = options.caretSize + options.caretPadding;
    if (xAlign === "left" && x + width + caret > chart.width) {
      return true;
    }
    if (xAlign === "right" && x - width - caret < 0) {
      return true;
    }
  }
  function determineXAlign(chart, options, size, yAlign) {
    const { x, width } = size;
    const { width: chartWidth, chartArea: { left, right } } = chart;
    let xAlign = "center";
    if (yAlign === "center") {
      xAlign = x <= (left + right) / 2 ? "left" : "right";
    } else if (x <= width / 2) {
      xAlign = "left";
    } else if (x >= chartWidth - width / 2) {
      xAlign = "right";
    }
    if (doesNotFitWithAlign(xAlign, chart, options, size)) {
      xAlign = "center";
    }
    return xAlign;
  }
  function determineAlignment(chart, options, size) {
    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
    return {
      xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
      yAlign
    };
  }
  function alignX(size, xAlign) {
    let { x, width } = size;
    if (xAlign === "right") {
      x -= width;
    } else if (xAlign === "center") {
      x -= width / 2;
    }
    return x;
  }
  function alignY(size, yAlign, paddingAndSize) {
    let { y, height } = size;
    if (yAlign === "top") {
      y += paddingAndSize;
    } else if (yAlign === "bottom") {
      y -= height + paddingAndSize;
    } else {
      y -= height / 2;
    }
    return y;
  }
  function getBackgroundPoint(options, size, alignment, chart) {
    const { caretSize, caretPadding, cornerRadius } = options;
    const { xAlign, yAlign } = alignment;
    const paddingAndSize = caretSize + caretPadding;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    let x = alignX(size, xAlign);
    const y = alignY(size, yAlign, paddingAndSize);
    if (yAlign === "center") {
      if (xAlign === "left") {
        x += paddingAndSize;
      } else if (xAlign === "right") {
        x -= paddingAndSize;
      }
    } else if (xAlign === "left") {
      x -= Math.max(topLeft, bottomLeft) + caretSize;
    } else if (xAlign === "right") {
      x += Math.max(topRight, bottomRight) + caretSize;
    }
    return {
      x: _limitValue(x, 0, chart.width - size.width),
      y: _limitValue(y, 0, chart.height - size.height)
    };
  }
  function getAlignedX(tooltip, align, options) {
    const padding = toPadding(options.padding);
    return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
  }
  function getBeforeAfterBodyLines(callback2) {
    return pushOrConcat([], splitNewlines(callback2));
  }
  function createTooltipContext(parent, tooltip, tooltipItems) {
    return createContext(parent, {
      tooltip,
      tooltipItems,
      type: "tooltip"
    });
  }
  function overrideCallbacks(callbacks, context) {
    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
    return override ? callbacks.override(override) : callbacks;
  }
  var defaultCallbacks = {
    beforeTitle: noop2,
    title(tooltipItems) {
      if (tooltipItems.length > 0) {
        const item = tooltipItems[0];
        const labels = item.chart.data.labels;
        const labelCount = labels ? labels.length : 0;
        if (this && this.options && this.options.mode === "dataset") {
          return item.dataset.label || "";
        } else if (item.label) {
          return item.label;
        } else if (labelCount > 0 && item.dataIndex < labelCount) {
          return labels[item.dataIndex];
        }
      }
      return "";
    },
    afterTitle: noop2,
    beforeBody: noop2,
    beforeLabel: noop2,
    label(tooltipItem) {
      if (this && this.options && this.options.mode === "dataset") {
        return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
      }
      let label = tooltipItem.dataset.label || "";
      if (label) {
        label += ": ";
      }
      const value = tooltipItem.formattedValue;
      if (!isNullOrUndef(value)) {
        label += value;
      }
      return label;
    },
    labelColor(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        borderColor: options.borderColor,
        backgroundColor: options.backgroundColor,
        borderWidth: options.borderWidth,
        borderDash: options.borderDash,
        borderDashOffset: options.borderDashOffset,
        borderRadius: 0
      };
    },
    labelTextColor() {
      return this.options.bodyColor;
    },
    labelPointStyle(tooltipItem) {
      const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
      const options = meta.controller.getStyle(tooltipItem.dataIndex);
      return {
        pointStyle: options.pointStyle,
        rotation: options.rotation
      };
    },
    afterLabel: noop2,
    afterBody: noop2,
    beforeFooter: noop2,
    footer: noop2,
    afterFooter: noop2
  };
  function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
    const result = callbacks[name].call(ctx, arg);
    if (typeof result === "undefined") {
      return defaultCallbacks[name].call(ctx, arg);
    }
    return result;
  }
  var Tooltip = class extends Element {
    constructor(config) {
      super();
      this.opacity = 0;
      this._active = [];
      this._eventPosition = void 0;
      this._size = void 0;
      this._cachedAnimations = void 0;
      this._tooltipItems = [];
      this.$animations = void 0;
      this.$context = void 0;
      this.chart = config.chart;
      this.options = config.options;
      this.dataPoints = void 0;
      this.title = void 0;
      this.beforeBody = void 0;
      this.body = void 0;
      this.afterBody = void 0;
      this.footer = void 0;
      this.xAlign = void 0;
      this.yAlign = void 0;
      this.x = void 0;
      this.y = void 0;
      this.height = void 0;
      this.width = void 0;
      this.caretX = void 0;
      this.caretY = void 0;
      this.labelColors = void 0;
      this.labelPointStyles = void 0;
      this.labelTextColors = void 0;
    }
    initialize(options) {
      this.options = options;
      this._cachedAnimations = void 0;
      this.$context = void 0;
    }
    _resolveAnimations() {
      const cached = this._cachedAnimations;
      if (cached) {
        return cached;
      }
      const chart = this.chart;
      const options = this.options.setContext(this.getContext());
      const opts = options.enabled && chart.options.animation && options.animations;
      const animations = new Animations(this.chart, opts);
      if (opts._cacheable) {
        this._cachedAnimations = Object.freeze(animations);
      }
      return animations;
    }
    getContext() {
      return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
    }
    getTitle(context, options) {
      const { callbacks } = options;
      const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
      const title = invokeCallbackWithFallback(callbacks, "title", this, context);
      const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    }
    getBeforeBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
    }
    getBody(tooltipItems, options) {
      const { callbacks } = options;
      const bodyItems = [];
      each(tooltipItems, (context) => {
        const bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        const scoped = overrideCallbacks(callbacks, context);
        pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
        pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
        pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    }
    getAfterBody(tooltipItems, options) {
      return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
    }
    getFooter(tooltipItems, options) {
      const { callbacks } = options;
      const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
      const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
      const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
      let lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    }
    _createItems(options) {
      const active = this._active;
      const data = this.chart.data;
      const labelColors = [];
      const labelPointStyles = [];
      const labelTextColors = [];
      let tooltipItems = [];
      let i, len;
      for (i = 0, len = active.length; i < len; ++i) {
        tooltipItems.push(createTooltipItem(this.chart, active[i]));
      }
      if (options.filter) {
        tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));
      }
      if (options.itemSort) {
        tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));
      }
      each(tooltipItems, (context) => {
        const scoped = overrideCallbacks(options.callbacks, context);
        labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
        labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
        labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
      });
      this.labelColors = labelColors;
      this.labelPointStyles = labelPointStyles;
      this.labelTextColors = labelTextColors;
      this.dataPoints = tooltipItems;
      return tooltipItems;
    }
    update(changed, replay) {
      const options = this.options.setContext(this.getContext());
      const active = this._active;
      let properties;
      let tooltipItems = [];
      if (!active.length) {
        if (this.opacity !== 0) {
          properties = {
            opacity: 0
          };
        }
      } else {
        const position = positioners[options.position].call(this, active, this._eventPosition);
        tooltipItems = this._createItems(options);
        this.title = this.getTitle(tooltipItems, options);
        this.beforeBody = this.getBeforeBody(tooltipItems, options);
        this.body = this.getBody(tooltipItems, options);
        this.afterBody = this.getAfterBody(tooltipItems, options);
        this.footer = this.getFooter(tooltipItems, options);
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, size);
        const alignment = determineAlignment(this.chart, options, positionAndSize);
        const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        properties = {
          opacity: 1,
          x: backgroundPoint.x,
          y: backgroundPoint.y,
          width: size.width,
          height: size.height,
          caretX: position.x,
          caretY: position.y
        };
      }
      this._tooltipItems = tooltipItems;
      this.$context = void 0;
      if (properties) {
        this._resolveAnimations().update(this, properties);
      }
      if (changed && options.external) {
        options.external.call(this, {
          chart: this.chart,
          tooltip: this,
          replay
        });
      }
    }
    drawCaret(tooltipPoint, ctx, size, options) {
      const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    }
    getCaretPosition(tooltipPoint, size, options) {
      const { xAlign, yAlign } = this;
      const { caretSize, cornerRadius } = options;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
      const { x: ptX, y: ptY } = tooltipPoint;
      const { width, height } = size;
      let x1, x2, x3, y1, y2, y3;
      if (yAlign === "center") {
        y2 = ptY + height / 2;
        if (xAlign === "left") {
          x1 = ptX;
          x2 = x1 - caretSize;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
        x3 = x1;
      } else {
        if (xAlign === "left") {
          x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
        } else if (xAlign === "right") {
          x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
        } else {
          x2 = this.caretX;
        }
        if (yAlign === "top") {
          y1 = ptY;
          y2 = y1 - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          x1 = x2 + caretSize;
          x3 = x2 - caretSize;
        }
        y3 = y1;
      }
      return {
        x1,
        x2,
        x3,
        y1,
        y2,
        y3
      };
    }
    drawTitle(pt, ctx, options) {
      const title = this.title;
      const length = title.length;
      let titleFont, titleSpacing, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.titleAlign, options);
        ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
        ctx.textBaseline = "middle";
        titleFont = toFont(options.titleFont);
        titleSpacing = options.titleSpacing;
        ctx.fillStyle = options.titleColor;
        ctx.font = titleFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
          pt.y += titleFont.lineHeight + titleSpacing;
          if (i + 1 === length) {
            pt.y += options.titleMarginBottom - titleSpacing;
          }
        }
      }
    }
    _drawColorBox(ctx, pt, i, rtlHelper, options) {
      const labelColor = this.labelColors[i];
      const labelPointStyle = this.labelPointStyles[i];
      const { boxHeight, boxWidth } = options;
      const bodyFont = toFont(options.bodyFont);
      const colorX = getAlignedX(this, "left", options);
      const rtlColorX = rtlHelper.x(colorX);
      const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
      const colorY = pt.y + yOffSet;
      if (options.usePointStyle) {
        const drawOptions = {
          radius: Math.min(boxWidth, boxHeight) / 2,
          pointStyle: labelPointStyle.pointStyle,
          rotation: labelPointStyle.rotation,
          borderWidth: 1
        };
        const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
        const centerY = colorY + boxHeight / 2;
        ctx.strokeStyle = options.multiKeyBackground;
        ctx.fillStyle = options.multiKeyBackground;
        drawPoint(ctx, drawOptions, centerX, centerY);
        ctx.strokeStyle = labelColor.borderColor;
        ctx.fillStyle = labelColor.backgroundColor;
        drawPoint(ctx, drawOptions, centerX, centerY);
      } else {
        ctx.lineWidth = isObject2(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
        ctx.strokeStyle = labelColor.borderColor;
        ctx.setLineDash(labelColor.borderDash || []);
        ctx.lineDashOffset = labelColor.borderDashOffset || 0;
        const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
        const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
        const borderRadius = toTRBLCorners(labelColor.borderRadius);
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          ctx.beginPath();
          ctx.fillStyle = options.multiKeyBackground;
          addRoundedRectPath(ctx, {
            x: outerX,
            y: colorY,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.beginPath();
          addRoundedRectPath(ctx, {
            x: innerX,
            y: colorY + 1,
            w: boxWidth - 2,
            h: boxHeight - 2,
            radius: borderRadius
          });
          ctx.fill();
        } else {
          ctx.fillStyle = options.multiKeyBackground;
          ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
          ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
          ctx.fillStyle = labelColor.backgroundColor;
          ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
        }
      }
      ctx.fillStyle = this.labelTextColors[i];
    }
    drawBody(pt, ctx, options) {
      const { body } = this;
      const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;
      const bodyFont = toFont(options.bodyFont);
      let bodyLineHeight = bodyFont.lineHeight;
      let xLinePadding = 0;
      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
      const fillLineOfText = function(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
        pt.y += bodyLineHeight + bodySpacing;
      };
      const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      let bodyItem, textColor, lines, i, j, ilen, jlen;
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = "middle";
      ctx.font = bodyFont.string;
      pt.x = getAlignedX(this, bodyAlignForCalculation, options);
      ctx.fillStyle = options.bodyColor;
      each(this.beforeBody, fillLineOfText);
      xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
      for (i = 0, ilen = body.length; i < ilen; ++i) {
        bodyItem = body[i];
        textColor = this.labelTextColors[i];
        ctx.fillStyle = textColor;
        each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;
        if (displayColors && lines.length) {
          this._drawColorBox(ctx, pt, i, rtlHelper, options);
          bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
        }
        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          fillLineOfText(lines[j]);
          bodyLineHeight = bodyFont.lineHeight;
        }
        each(bodyItem.after, fillLineOfText);
      }
      xLinePadding = 0;
      bodyLineHeight = bodyFont.lineHeight;
      each(this.afterBody, fillLineOfText);
      pt.y -= bodySpacing;
    }
    drawFooter(pt, ctx, options) {
      const footer = this.footer;
      const length = footer.length;
      let footerFont, i;
      if (length) {
        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
        pt.x = getAlignedX(this, options.footerAlign, options);
        pt.y += options.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
        ctx.textBaseline = "middle";
        footerFont = toFont(options.footerFont);
        ctx.fillStyle = options.footerColor;
        ctx.font = footerFont.string;
        for (i = 0; i < length; ++i) {
          ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
          pt.y += footerFont.lineHeight + options.footerSpacing;
        }
      }
    }
    drawBackground(pt, ctx, tooltipSize, options) {
      const { xAlign, yAlign } = this;
      const { x, y } = pt;
      const { width, height } = tooltipSize;
      const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options.cornerRadius);
      ctx.fillStyle = options.backgroundColor;
      ctx.strokeStyle = options.borderColor;
      ctx.lineWidth = options.borderWidth;
      ctx.beginPath();
      ctx.moveTo(x + topLeft, y);
      if (yAlign === "top") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width - topRight, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
      if (yAlign === "center" && xAlign === "right") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + width, y + height - bottomRight);
      ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
      if (yAlign === "bottom") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x + bottomLeft, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
      if (yAlign === "center" && xAlign === "left") {
        this.drawCaret(pt, ctx, tooltipSize, options);
      }
      ctx.lineTo(x, y + topLeft);
      ctx.quadraticCurveTo(x, y, x + topLeft, y);
      ctx.closePath();
      ctx.fill();
      if (options.borderWidth > 0) {
        ctx.stroke();
      }
    }
    _updateAnimationTarget(options) {
      const chart = this.chart;
      const anims = this.$animations;
      const animX = anims && anims.x;
      const animY = anims && anims.y;
      if (animX || animY) {
        const position = positioners[options.position].call(this, this._active, this._eventPosition);
        if (!position) {
          return;
        }
        const size = this._size = getTooltipSize(this, options);
        const positionAndSize = Object.assign({}, position, this._size);
        const alignment = determineAlignment(chart, options, positionAndSize);
        const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
        if (animX._to !== point.x || animY._to !== point.y) {
          this.xAlign = alignment.xAlign;
          this.yAlign = alignment.yAlign;
          this.width = size.width;
          this.height = size.height;
          this.caretX = position.x;
          this.caretY = position.y;
          this._resolveAnimations().update(this, point);
        }
      }
    }
    _willRender() {
      return !!this.opacity;
    }
    draw(ctx) {
      const options = this.options.setContext(this.getContext());
      let opacity = this.opacity;
      if (!opacity) {
        return;
      }
      this._updateAnimationTarget(options);
      const tooltipSize = {
        width: this.width,
        height: this.height
      };
      const pt = {
        x: this.x,
        y: this.y
      };
      opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
      const padding = toPadding(options.padding);
      const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
      if (options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity;
        this.drawBackground(pt, ctx, tooltipSize, options);
        overrideTextDirection(ctx, options.textDirection);
        pt.y += padding.top;
        this.drawTitle(pt, ctx, options);
        this.drawBody(pt, ctx, options);
        this.drawFooter(pt, ctx, options);
        restoreTextDirection(ctx, options.textDirection);
        ctx.restore();
      }
    }
    getActiveElements() {
      return this._active || [];
    }
    setActiveElements(activeElements, eventPosition) {
      const lastActive = this._active;
      const active = activeElements.map(({ datasetIndex, index: index2 }) => {
        const meta = this.chart.getDatasetMeta(datasetIndex);
        if (!meta) {
          throw new Error("Cannot find a dataset at index " + datasetIndex);
        }
        return {
          datasetIndex,
          element: meta.data[index2],
          index: index2
        };
      });
      const changed = !_elementsEqual(lastActive, active);
      const positionChanged = this._positionChanged(active, eventPosition);
      if (changed || positionChanged) {
        this._active = active;
        this._eventPosition = eventPosition;
        this._ignoreReplayEvents = true;
        this.update(true);
      }
    }
    handleEvent(e, replay, inChartArea = true) {
      if (replay && this._ignoreReplayEvents) {
        return false;
      }
      this._ignoreReplayEvents = false;
      const options = this.options;
      const lastActive = this._active || [];
      const active = this._getActiveElements(e, lastActive, replay, inChartArea);
      const positionChanged = this._positionChanged(active, e);
      const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
      if (changed) {
        this._active = active;
        if (options.enabled || options.external) {
          this._eventPosition = {
            x: e.x,
            y: e.y
          };
          this.update(true, replay);
        }
      }
      return changed;
    }
    _getActiveElements(e, lastActive, replay, inChartArea) {
      const options = this.options;
      if (e.type === "mouseout") {
        return [];
      }
      if (!inChartArea) {
        return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
      }
      const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
      if (options.reverse) {
        active.reverse();
      }
      return active;
    }
    _positionChanged(active, e) {
      const { caretX, caretY, options } = this;
      const position = positioners[options.position].call(this, active, e);
      return position !== false && (caretX !== position.x || caretY !== position.y);
    }
  };
  __publicField(Tooltip, "positioners", positioners);
  var plugin_tooltip = {
    id: "tooltip",
    _element: Tooltip,
    positioners,
    afterInit(chart, _args, options) {
      if (options) {
        chart.tooltip = new Tooltip({
          chart,
          options
        });
      }
    },
    beforeUpdate(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    reset(chart, _args, options) {
      if (chart.tooltip) {
        chart.tooltip.initialize(options);
      }
    },
    afterDraw(chart) {
      const tooltip = chart.tooltip;
      if (tooltip && tooltip._willRender()) {
        const args = {
          tooltip
        };
        if (chart.notifyPlugins("beforeTooltipDraw", __spreadProps(__spreadValues({}, args), {
          cancelable: true
        })) === false) {
          return;
        }
        tooltip.draw(chart.ctx);
        chart.notifyPlugins("afterTooltipDraw", args);
      }
    },
    afterEvent(chart, args) {
      if (chart.tooltip) {
        const useFinalPosition = args.replay;
        if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
          args.changed = true;
        }
      }
    },
    defaults: {
      enabled: true,
      external: null,
      position: "average",
      backgroundColor: "rgba(0,0,0,0.8)",
      titleColor: "#fff",
      titleFont: {
        weight: "bold"
      },
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleAlign: "left",
      bodyColor: "#fff",
      bodySpacing: 2,
      bodyFont: {},
      bodyAlign: "left",
      footerColor: "#fff",
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFont: {
        weight: "bold"
      },
      footerAlign: "left",
      padding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      boxHeight: (ctx, opts) => opts.bodyFont.size,
      boxWidth: (ctx, opts) => opts.bodyFont.size,
      multiKeyBackground: "#fff",
      displayColors: true,
      boxPadding: 0,
      borderColor: "rgba(0,0,0,0)",
      borderWidth: 0,
      animation: {
        duration: 400,
        easing: "easeOutQuart"
      },
      animations: {
        numbers: {
          type: "number",
          properties: [
            "x",
            "y",
            "width",
            "height",
            "caretX",
            "caretY"
          ]
        },
        opacity: {
          easing: "linear",
          duration: 200
        }
      },
      callbacks: defaultCallbacks
    },
    defaultRoutes: {
      bodyFont: "font",
      footerFont: "font",
      titleFont: "font"
    },
    descriptors: {
      _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
      _indexable: false,
      callbacks: {
        _scriptable: false,
        _indexable: false
      },
      animation: {
        _fallback: false
      },
      animations: {
        _fallback: "animation"
      }
    },
    additionalOptionScopes: [
      "interaction"
    ]
  };
  var plugins = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    Colors: plugin_colors,
    Decimation: plugin_decimation,
    Filler: index,
    Legend: plugin_legend,
    SubTitle: plugin_subtitle,
    Title: plugin_title,
    Tooltip: plugin_tooltip
  });
  var addIfString = (labels, raw, index2, addedLabels) => {
    if (typeof raw === "string") {
      index2 = labels.push(raw) - 1;
      addedLabels.unshift({
        index: index2,
        label: raw
      });
    } else if (isNaN(raw)) {
      index2 = null;
    }
    return index2;
  };
  function findOrAddLabel(labels, raw, index2, addedLabels) {
    const first = labels.indexOf(raw);
    if (first === -1) {
      return addIfString(labels, raw, index2, addedLabels);
    }
    const last = labels.lastIndexOf(raw);
    return first !== last ? index2 : first;
  }
  var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
  function _getLabelForValue(value) {
    const labels = this.getLabels();
    if (value >= 0 && value < labels.length) {
      return labels[value];
    }
    return value;
  }
  var CategoryScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this._startValue = void 0;
      this._valueRange = 0;
      this._addedLabels = [];
    }
    init(scaleOptions) {
      const added = this._addedLabels;
      if (added.length) {
        const labels = this.getLabels();
        for (const { index: index2, label } of added) {
          if (labels[index2] === label) {
            labels.splice(index2, 1);
          }
        }
        this._addedLabels = [];
      }
      super.init(scaleOptions);
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      const labels = this.getLabels();
      index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
      return validIndex(index2, labels.length - 1);
    }
    determineDataLimits() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this.getMinMax(true);
      if (this.options.bounds === "ticks") {
        if (!minDefined) {
          min = 0;
        }
        if (!maxDefined) {
          max = this.getLabels().length - 1;
        }
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const min = this.min;
      const max = this.max;
      const offset = this.options.offset;
      const ticks = [];
      let labels = this.getLabels();
      labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
      this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
      this._startValue = this.min - (offset ? 0.5 : 0);
      for (let value = min; value <= max; value++) {
        ticks.push({
          value
        });
      }
      return ticks;
    }
    getLabelForValue(value) {
      return _getLabelForValue.call(this, value);
    }
    configure() {
      super.configure();
      if (!this.isHorizontal()) {
        this._reversePixels = !this._reversePixels;
      }
    }
    getPixelForValue(value) {
      if (typeof value !== "number") {
        value = this.parse(value);
      }
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getPixelForTick(index2) {
      const ticks = this.ticks;
      if (index2 < 0 || index2 > ticks.length - 1) {
        return null;
      }
      return this.getPixelForValue(ticks[index2].value);
    }
    getValueForPixel(pixel) {
      return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
    }
    getBasePixel() {
      return this.bottom;
    }
  };
  __publicField(CategoryScale, "id", "category");
  __publicField(CategoryScale, "defaults", {
    ticks: {
      callback: _getLabelForValue
    }
  });
  function generateTicks$1(generationOptions, dataRange) {
    const ticks = [];
    const MIN_SPACING = 1e-14;
    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
    const unit = step || 1;
    const maxSpaces = maxTicks - 1;
    const { min: rmin, max: rmax } = dataRange;
    const minDefined = !isNullOrUndef(min);
    const maxDefined = !isNullOrUndef(max);
    const countDefined = !isNullOrUndef(count);
    const minSpacing = (rmax - rmin) / (maxDigits + 1);
    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
    let factor, niceMin, niceMax, numSpaces;
    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
      return [
        {
          value: rmin
        },
        {
          value: rmax
        }
      ];
    }
    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
    if (numSpaces > maxSpaces) {
      spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
    }
    if (!isNullOrUndef(precision)) {
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }
    if (bounds === "ticks") {
      niceMin = Math.floor(rmin / spacing) * spacing;
      niceMax = Math.ceil(rmax / spacing) * spacing;
    } else {
      niceMin = rmin;
      niceMax = rmax;
    }
    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
      numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
      spacing = (max - min) / numSpaces;
      niceMin = min;
      niceMax = max;
    } else if (countDefined) {
      niceMin = minDefined ? min : niceMin;
      niceMax = maxDefined ? max : niceMax;
      numSpaces = count - 1;
      spacing = (niceMax - niceMin) / numSpaces;
    } else {
      numSpaces = (niceMax - niceMin) / spacing;
      if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
        numSpaces = Math.round(numSpaces);
      } else {
        numSpaces = Math.ceil(numSpaces);
      }
    }
    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    let j = 0;
    if (minDefined) {
      if (includeBounds && niceMin !== min) {
        ticks.push({
          value: min
        });
        if (niceMin < min) {
          j++;
        }
        if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
          j++;
        }
      } else if (niceMin < min) {
        j++;
      }
    }
    for (; j < numSpaces; ++j) {
      const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
      if (maxDefined && tickValue > max) {
        break;
      }
      ticks.push({
        value: tickValue
      });
    }
    if (maxDefined && includeBounds && niceMax !== max) {
      if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
        ticks[ticks.length - 1].value = max;
      } else {
        ticks.push({
          value: max
        });
      }
    } else if (!maxDefined || niceMax === max) {
      ticks.push({
        value: niceMax
      });
    }
    return ticks;
  }
  function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
    const rad = toRadians(minRotation);
    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
    const length = 0.75 * minSpacing * ("" + value).length;
    return Math.min(minSpacing / ratio, length);
  }
  var LinearScaleBase = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._endValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      if (isNullOrUndef(raw)) {
        return null;
      }
      if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
        return null;
      }
      return +raw;
    }
    handleTickRangeOptions() {
      const { beginAtZero } = this.options;
      const { minDefined, maxDefined } = this.getUserBounds();
      let { min, max } = this;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (beginAtZero) {
        const minSign = sign(min);
        const maxSign = sign(max);
        if (minSign < 0 && maxSign < 0) {
          setMax(0);
        } else if (minSign > 0 && maxSign > 0) {
          setMin(0);
        }
      }
      if (min === max) {
        let offset = max === 0 ? 1 : Math.abs(max * 0.05);
        setMax(max + offset);
        if (!beginAtZero) {
          setMin(min - offset);
        }
      }
      this.min = min;
      this.max = max;
    }
    getTickLimit() {
      const tickOpts = this.options.ticks;
      let { maxTicksLimit, stepSize } = tickOpts;
      let maxTicks;
      if (stepSize) {
        maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
        if (maxTicks > 1e3) {
          console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
          maxTicks = 1e3;
        }
      } else {
        maxTicks = this.computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }
      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }
      return maxTicks;
    }
    computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    }
    buildTicks() {
      const opts = this.options;
      const tickOpts = opts.ticks;
      let maxTicks = this.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      const numericGeneratorOptions = {
        maxTicks,
        bounds: opts.bounds,
        min: opts.min,
        max: opts.max,
        precision: tickOpts.precision,
        step: tickOpts.stepSize,
        count: tickOpts.count,
        maxDigits: this._maxDigits(),
        horizontal: this.isHorizontal(),
        minRotation: tickOpts.minRotation || 0,
        includeBounds: tickOpts.includeBounds !== false
      };
      const dataRange = this._range || this;
      const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    configure() {
      const ticks = this.ticks;
      let start = this.min;
      let end = this.max;
      super.configure();
      if (this.options.offset && ticks.length) {
        const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
        start -= offset;
        end += offset;
      }
      this._startValue = start;
      this._endValue = end;
      this._valueRange = end - start;
    }
    getLabelForValue(value) {
      return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
  };
  var LinearScale = class extends LinearScaleBase {
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? min : 0;
      this.max = isNumberFinite(max) ? max : 1;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      const horizontal = this.isHorizontal();
      const length = horizontal ? this.width : this.height;
      const minRotation = toRadians(this.options.ticks.minRotation);
      const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
      const tickFont = this._resolveTickFontOptions(0);
      return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
    }
    getPixelForValue(value) {
      return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    }
  };
  __publicField(LinearScale, "id", "linear");
  __publicField(LinearScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.numeric
    }
  });
  var log10Floor = (v) => Math.floor(log10(v));
  var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
  function isMajor(tickVal) {
    const remain = tickVal / Math.pow(10, log10Floor(tickVal));
    return remain === 1;
  }
  function steps(min, max, rangeExp) {
    const rangeStep = Math.pow(10, rangeExp);
    const start = Math.floor(min / rangeStep);
    const end = Math.ceil(max / rangeStep);
    return end - start;
  }
  function startExp(min, max) {
    const range2 = max - min;
    let rangeExp = log10Floor(range2);
    while (steps(min, max, rangeExp) > 10) {
      rangeExp++;
    }
    while (steps(min, max, rangeExp) < 10) {
      rangeExp--;
    }
    return Math.min(rangeExp, log10Floor(min));
  }
  function generateTicks(generationOptions, { min, max }) {
    min = finiteOrDefault(generationOptions.min, min);
    const ticks = [];
    const minExp = log10Floor(min);
    let exp = startExp(min, max);
    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
    const stepSize = Math.pow(10, exp);
    const base = minExp > exp ? Math.pow(10, minExp) : 0;
    const start = Math.round((min - base) * precision) / precision;
    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
    let significand = Math.floor((start - offset) / Math.pow(10, exp));
    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
    while (value < max) {
      ticks.push({
        value,
        major: isMajor(value),
        significand
      });
      if (significand >= 10) {
        significand = significand < 15 ? 15 : 20;
      } else {
        significand++;
      }
      if (significand >= 20) {
        exp++;
        significand = 2;
        precision = exp >= 0 ? 1 : precision;
      }
      value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
    }
    const lastTick = finiteOrDefault(generationOptions.max, value);
    ticks.push({
      value: lastTick,
      major: isMajor(lastTick),
      significand
    });
    return ticks;
  }
  var LogarithmicScale = class extends Scale {
    constructor(cfg) {
      super(cfg);
      this.start = void 0;
      this.end = void 0;
      this._startValue = void 0;
      this._valueRange = 0;
    }
    parse(raw, index2) {
      const value = LinearScaleBase.prototype.parse.apply(this, [
        raw,
        index2
      ]);
      if (value === 0) {
        this._zero = true;
        return void 0;
      }
      return isNumberFinite(value) && value > 0 ? value : null;
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(true);
      this.min = isNumberFinite(min) ? Math.max(0, min) : null;
      this.max = isNumberFinite(max) ? Math.max(0, max) : null;
      if (this.options.beginAtZero) {
        this._zero = true;
      }
      if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
        this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
      }
      this.handleTickRangeOptions();
    }
    handleTickRangeOptions() {
      const { minDefined, maxDefined } = this.getUserBounds();
      let min = this.min;
      let max = this.max;
      const setMin = (v) => min = minDefined ? min : v;
      const setMax = (v) => max = maxDefined ? max : v;
      if (min === max) {
        if (min <= 0) {
          setMin(1);
          setMax(10);
        } else {
          setMin(changeExponent(min, -1));
          setMax(changeExponent(max, 1));
        }
      }
      if (min <= 0) {
        setMin(changeExponent(max, -1));
      }
      if (max <= 0) {
        setMax(changeExponent(min, 1));
      }
      this.min = min;
      this.max = max;
    }
    buildTicks() {
      const opts = this.options;
      const generationOptions = {
        min: this._userMin,
        max: this._userMax
      };
      const ticks = generateTicks(generationOptions, this);
      if (opts.bounds === "ticks") {
        _setMinAndMaxByKey(ticks, this, "value");
      }
      if (opts.reverse) {
        ticks.reverse();
        this.start = this.max;
        this.end = this.min;
      } else {
        this.start = this.min;
        this.end = this.max;
      }
      return ticks;
    }
    getLabelForValue(value) {
      return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
    }
    configure() {
      const start = this.min;
      super.configure();
      this._startValue = log10(start);
      this._valueRange = log10(this.max) - log10(start);
    }
    getPixelForValue(value) {
      if (value === void 0 || value === 0) {
        value = this.min;
      }
      if (value === null || isNaN(value)) {
        return NaN;
      }
      return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
    }
    getValueForPixel(pixel) {
      const decimal = this.getDecimalForPixel(pixel);
      return Math.pow(10, this._startValue + decimal * this._valueRange);
    }
  };
  __publicField(LogarithmicScale, "id", "logarithmic");
  __publicField(LogarithmicScale, "defaults", {
    ticks: {
      callback: Ticks.formatters.logarithmic,
      major: {
        enabled: true
      }
    }
  });
  function getTickBackdropHeight(opts) {
    const tickOpts = opts.ticks;
    if (tickOpts.display && opts.display) {
      const padding = toPadding(tickOpts.backdropPadding);
      return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
    }
    return 0;
  }
  function measureLabelSize(ctx, font, label) {
    label = isArray(label) ? label : [
      label
    ];
    return {
      w: _longestText(ctx, font.string, label),
      h: label.length * font.lineHeight
    };
  }
  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size,
        end: pos
      };
    }
    return {
      start: pos,
      end: pos + size
    };
  }
  function fitWithPointLabels(scale) {
    const orig = {
      l: scale.left + scale._padding.left,
      r: scale.right - scale._padding.right,
      t: scale.top + scale._padding.top,
      b: scale.bottom - scale._padding.bottom
    };
    const limits = Object.assign({}, orig);
    const labelSizes = [];
    const padding = [];
    const valueCount = scale._pointLabels.length;
    const pointLabelOpts = scale.options.pointLabels;
    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
    for (let i = 0; i < valueCount; i++) {
      const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
      padding[i] = opts.padding;
      const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
      const plFont = toFont(opts.font);
      const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
      labelSizes[i] = textSize;
      const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
      const angle = Math.round(toDegrees(angleRadians));
      const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
      updateLimits(limits, orig, angleRadians, hLimits, vLimits);
    }
    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
  }
  function updateLimits(limits, orig, angle, hLimits, vLimits) {
    const sin = Math.abs(Math.sin(angle));
    const cos = Math.abs(Math.cos(angle));
    let x = 0;
    let y = 0;
    if (hLimits.start < orig.l) {
      x = (orig.l - hLimits.start) / sin;
      limits.l = Math.min(limits.l, orig.l - x);
    } else if (hLimits.end > orig.r) {
      x = (hLimits.end - orig.r) / sin;
      limits.r = Math.max(limits.r, orig.r + x);
    }
    if (vLimits.start < orig.t) {
      y = (orig.t - vLimits.start) / cos;
      limits.t = Math.min(limits.t, orig.t - y);
    } else if (vLimits.end > orig.b) {
      y = (vLimits.end - orig.b) / cos;
      limits.b = Math.max(limits.b, orig.b + y);
    }
  }
  function createPointLabelItem(scale, index2, itemOpts) {
    const outerDistance = scale.drawingArea;
    const { extra, additionalAngle, padding, size } = itemOpts;
    const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
    const y = yForAngle(pointLabelPosition.y, size.h, angle);
    const textAlign = getTextAlignForAngle(angle);
    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
    return {
      visible: true,
      x: pointLabelPosition.x,
      y,
      textAlign,
      left,
      top: y,
      right: left + size.w,
      bottom: y + size.h
    };
  }
  function isNotOverlapped(item, area) {
    if (!area) {
      return true;
    }
    const { left, top: top2, right, bottom: bottom2 } = item;
    const apexesInArea = _isPointInArea({
      x: left,
      y: top2
    }, area) || _isPointInArea({
      x: left,
      y: bottom2
    }, area) || _isPointInArea({
      x: right,
      y: top2
    }, area) || _isPointInArea({
      x: right,
      y: bottom2
    }, area);
    return !apexesInArea;
  }
  function buildPointLabelItems(scale, labelSizes, padding) {
    const items = [];
    const valueCount = scale._pointLabels.length;
    const opts = scale.options;
    const { centerPointLabels, display } = opts.pointLabels;
    const itemOpts = {
      extra: getTickBackdropHeight(opts) / 2,
      additionalAngle: centerPointLabels ? PI / valueCount : 0
    };
    let area;
    for (let i = 0; i < valueCount; i++) {
      itemOpts.padding = padding[i];
      itemOpts.size = labelSizes[i];
      const item = createPointLabelItem(scale, i, itemOpts);
      items.push(item);
      if (display === "auto") {
        item.visible = isNotOverlapped(item, area);
        if (item.visible) {
          area = item;
        }
      }
    }
    return items;
  }
  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return "center";
    } else if (angle < 180) {
      return "left";
    }
    return "right";
  }
  function leftForTextAlign(x, w, align) {
    if (align === "right") {
      x -= w;
    } else if (align === "center") {
      x -= w / 2;
    }
    return x;
  }
  function yForAngle(y, h, angle) {
    if (angle === 90 || angle === 270) {
      y -= h / 2;
    } else if (angle > 270 || angle < 90) {
      y -= h;
    }
    return y;
  }
  function drawPointLabelBox(ctx, opts, item) {
    const { left, top: top2, right, bottom: bottom2 } = item;
    const { backdropColor } = opts;
    if (!isNullOrUndef(backdropColor)) {
      const borderRadius = toTRBLCorners(opts.borderRadius);
      const padding = toPadding(opts.backdropPadding);
      ctx.fillStyle = backdropColor;
      const backdropLeft = left - padding.left;
      const backdropTop = top2 - padding.top;
      const backdropWidth = right - left + padding.width;
      const backdropHeight = bottom2 - top2 + padding.height;
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: backdropLeft,
          y: backdropTop,
          w: backdropWidth,
          h: backdropHeight,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
      }
    }
  }
  function drawPointLabels(scale, labelCount) {
    const { ctx, options: { pointLabels } } = scale;
    for (let i = labelCount - 1; i >= 0; i--) {
      const item = scale._pointLabelItems[i];
      if (!item.visible) {
        continue;
      }
      const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
      drawPointLabelBox(ctx, optsAtIndex, item);
      const plFont = toFont(optsAtIndex.font);
      const { x, y, textAlign } = item;
      renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
        color: optsAtIndex.color,
        textAlign,
        textBaseline: "middle"
      });
    }
  }
  function pathRadiusLine(scale, radius, circular, labelCount) {
    const { ctx } = scale;
    if (circular) {
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
    } else {
      let pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);
      for (let i = 1; i < labelCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }
  }
  function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
    const ctx = scale.ctx;
    const circular = gridLineOpts.circular;
    const { color: color2, lineWidth } = gridLineOpts;
    if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
      return;
    }
    ctx.save();
    ctx.strokeStyle = color2;
    ctx.lineWidth = lineWidth;
    ctx.setLineDash(borderOpts.dash || []);
    ctx.lineDashOffset = borderOpts.dashOffset;
    ctx.beginPath();
    pathRadiusLine(scale, radius, circular, labelCount);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  function createPointLabelContext(parent, index2, label) {
    return createContext(parent, {
      label,
      index: index2,
      type: "pointLabel"
    });
  }
  var RadialLinearScale = class extends LinearScaleBase {
    constructor(cfg) {
      super(cfg);
      this.xCenter = void 0;
      this.yCenter = void 0;
      this.drawingArea = void 0;
      this._pointLabels = [];
      this._pointLabelItems = [];
    }
    setDimensions() {
      const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
      const w = this.width = this.maxWidth - padding.width;
      const h = this.height = this.maxHeight - padding.height;
      this.xCenter = Math.floor(this.left + w / 2 + padding.left);
      this.yCenter = Math.floor(this.top + h / 2 + padding.top);
      this.drawingArea = Math.floor(Math.min(w, h) / 2);
    }
    determineDataLimits() {
      const { min, max } = this.getMinMax(false);
      this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
      this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
      this.handleTickRangeOptions();
    }
    computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    }
    generateTickLabels(ticks) {
      LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
      this._pointLabels = this.getLabels().map((value, index2) => {
        const label = callback(this.options.pointLabels.callback, [
          value,
          index2
        ], this);
        return label || label === 0 ? label : "";
      }).filter((v, i) => this.chart.getDataVisibility(i));
    }
    fit() {
      const opts = this.options;
      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(this);
      } else {
        this.setCenterPoint(0, 0, 0, 0);
      }
    }
    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
      this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
      this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
    }
    getIndexAngle(index2) {
      const angleMultiplier = TAU / (this._pointLabels.length || 1);
      const startAngle = this.options.startAngle || 0;
      return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
    }
    getDistanceFromCenterForValue(value) {
      if (isNullOrUndef(value)) {
        return NaN;
      }
      const scalingFactor = this.drawingArea / (this.max - this.min);
      if (this.options.reverse) {
        return (this.max - value) * scalingFactor;
      }
      return (value - this.min) * scalingFactor;
    }
    getValueForDistanceFromCenter(distance) {
      if (isNullOrUndef(distance)) {
        return NaN;
      }
      const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
      return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
    }
    getPointLabelContext(index2) {
      const pointLabels = this._pointLabels || [];
      if (index2 >= 0 && index2 < pointLabels.length) {
        const pointLabel = pointLabels[index2];
        return createPointLabelContext(this.getContext(), index2, pointLabel);
      }
    }
    getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
      const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
      return {
        x: Math.cos(angle) * distanceFromCenter + this.xCenter,
        y: Math.sin(angle) * distanceFromCenter + this.yCenter,
        angle
      };
    }
    getPointPositionForValue(index2, value) {
      return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
    }
    getBasePosition(index2) {
      return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
    }
    getPointLabelPosition(index2) {
      const { left, top: top2, right, bottom: bottom2 } = this._pointLabelItems[index2];
      return {
        left,
        top: top2,
        right,
        bottom: bottom2
      };
    }
    drawBackground() {
      const { backgroundColor, grid: { circular } } = this.options;
      if (backgroundColor) {
        const ctx = this.ctx;
        ctx.save();
        ctx.beginPath();
        pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
        ctx.closePath();
        ctx.fillStyle = backgroundColor;
        ctx.fill();
        ctx.restore();
      }
    }
    drawGrid() {
      const ctx = this.ctx;
      const opts = this.options;
      const { angleLines, grid, border } = opts;
      const labelCount = this._pointLabels.length;
      let i, offset, position;
      if (opts.pointLabels.display) {
        drawPointLabels(this, labelCount);
      }
      if (grid.display) {
        this.ticks.forEach((tick, index2) => {
          if (index2 !== 0 || index2 === 0 && this.min < 0) {
            offset = this.getDistanceFromCenterForValue(tick.value);
            const context = this.getContext(index2);
            const optsAtIndex = grid.setContext(context);
            const optsAtIndexBorder = border.setContext(context);
            drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
          }
        });
      }
      if (angleLines.display) {
        ctx.save();
        for (i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
          const { color: color2, lineWidth } = optsAtIndex;
          if (!lineWidth || !color2) {
            continue;
          }
          ctx.lineWidth = lineWidth;
          ctx.strokeStyle = color2;
          ctx.setLineDash(optsAtIndex.borderDash);
          ctx.lineDashOffset = optsAtIndex.borderDashOffset;
          offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
          position = this.getPointPosition(i, offset);
          ctx.beginPath();
          ctx.moveTo(this.xCenter, this.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }
        ctx.restore();
      }
    }
    drawBorder() {
    }
    drawLabels() {
      const ctx = this.ctx;
      const opts = this.options;
      const tickOpts = opts.ticks;
      if (!tickOpts.display) {
        return;
      }
      const startAngle = this.getIndexAngle(0);
      let offset, width;
      ctx.save();
      ctx.translate(this.xCenter, this.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      this.ticks.forEach((tick, index2) => {
        if (index2 === 0 && this.min >= 0 && !opts.reverse) {
          return;
        }
        const optsAtIndex = tickOpts.setContext(this.getContext(index2));
        const tickFont = toFont(optsAtIndex.font);
        offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
        if (optsAtIndex.showLabelBackdrop) {
          ctx.font = tickFont.string;
          width = ctx.measureText(tick.label).width;
          ctx.fillStyle = optsAtIndex.backdropColor;
          const padding = toPadding(optsAtIndex.backdropPadding);
          ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
        }
        renderText(ctx, tick.label, 0, -offset, tickFont, {
          color: optsAtIndex.color,
          strokeColor: optsAtIndex.textStrokeColor,
          strokeWidth: optsAtIndex.textStrokeWidth
        });
      });
      ctx.restore();
    }
    drawTitle() {
    }
  };
  __publicField(RadialLinearScale, "id", "radialLinear");
  __publicField(RadialLinearScale, "defaults", {
    display: true,
    animate: true,
    position: "chartArea",
    angleLines: {
      display: true,
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    grid: {
      circular: false
    },
    startAngle: 0,
    ticks: {
      showLabelBackdrop: true,
      callback: Ticks.formatters.numeric
    },
    pointLabels: {
      backdropColor: void 0,
      backdropPadding: 2,
      display: true,
      font: {
        size: 10
      },
      callback(label) {
        return label;
      },
      padding: 5,
      centerPointLabels: false
    }
  });
  __publicField(RadialLinearScale, "defaultRoutes", {
    "angleLines.color": "borderColor",
    "pointLabels.color": "color",
    "ticks.color": "color"
  });
  __publicField(RadialLinearScale, "descriptors", {
    angleLines: {
      _fallback: "grid"
    }
  });
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1e3
    },
    second: {
      common: true,
      size: 1e3,
      steps: 60
    },
    minute: {
      common: true,
      size: 6e4,
      steps: 60
    },
    hour: {
      common: true,
      size: 36e5,
      steps: 24
    },
    day: {
      common: true,
      size: 864e5,
      steps: 30
    },
    week: {
      common: false,
      size: 6048e5,
      steps: 4
    },
    month: {
      common: true,
      size: 2628e6,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7884e6,
      steps: 4
    },
    year: {
      common: true,
      size: 3154e7
    }
  };
  var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
  function sorter(a, b) {
    return a - b;
  }
  function parse(scale, input) {
    if (isNullOrUndef(input)) {
      return null;
    }
    const adapter = scale._adapter;
    const { parser, round: round2, isoWeekday } = scale._parseOpts;
    let value = input;
    if (typeof parser === "function") {
      value = parser(value);
    }
    if (!isNumberFinite(value)) {
      value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
    }
    if (value === null) {
      return null;
    }
    if (round2) {
      value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
    }
    return +value;
  }
  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    const ilen = UNITS.length;
    for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
      const interval = INTERVALS[UNITS[i]];
      const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i];
      }
    }
    return UNITS[ilen - 1];
  }
  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
      const unit = UNITS[i];
      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
        return unit;
      }
    }
    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }
  function determineMajorUnit(unit) {
    for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
      if (INTERVALS[UNITS[i]].common) {
        return UNITS[i];
      }
    }
  }
  function addTick(ticks, time, timestamps) {
    if (!timestamps) {
      ticks[time] = true;
    } else if (timestamps.length) {
      const { lo, hi } = _lookup(timestamps, time);
      const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
      ticks[timestamp] = true;
    }
  }
  function setMajorTicks(scale, ticks, map3, majorUnit) {
    const adapter = scale._adapter;
    const first = +adapter.startOf(ticks[0].value, majorUnit);
    const last = ticks[ticks.length - 1].value;
    let major, index2;
    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index2 = map3[major];
      if (index2 >= 0) {
        ticks[index2].major = true;
      }
    }
    return ticks;
  }
  function ticksFromTimestamps(scale, values, majorUnit) {
    const ticks = [];
    const map3 = {};
    const ilen = values.length;
    let i, value;
    for (i = 0; i < ilen; ++i) {
      value = values[i];
      map3[value] = i;
      ticks.push({
        value,
        major: false
      });
    }
    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
  }
  var TimeScale = class extends Scale {
    constructor(props) {
      super(props);
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
      this._unit = "day";
      this._majorUnit = void 0;
      this._offsets = {};
      this._normalized = false;
      this._parseOpts = void 0;
    }
    init(scaleOpts, opts = {}) {
      const time = scaleOpts.time || (scaleOpts.time = {});
      const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
      adapter.init(opts);
      mergeIf(time.displayFormats, adapter.formats());
      this._parseOpts = {
        parser: time.parser,
        round: time.round,
        isoWeekday: time.isoWeekday
      };
      super.init(scaleOpts);
      this._normalized = opts.normalized;
    }
    parse(raw, index2) {
      if (raw === void 0) {
        return null;
      }
      return parse(this, raw);
    }
    beforeLayout() {
      super.beforeLayout();
      this._cache = {
        data: [],
        labels: [],
        all: []
      };
    }
    determineDataLimits() {
      const options = this.options;
      const adapter = this._adapter;
      const unit = options.time.unit || "day";
      let { min, max, minDefined, maxDefined } = this.getUserBounds();
      function _applyBounds(bounds) {
        if (!minDefined && !isNaN(bounds.min)) {
          min = Math.min(min, bounds.min);
        }
        if (!maxDefined && !isNaN(bounds.max)) {
          max = Math.max(max, bounds.max);
        }
      }
      if (!minDefined || !maxDefined) {
        _applyBounds(this._getLabelBounds());
        if (options.bounds !== "ticks" || options.ticks.source !== "labels") {
          _applyBounds(this.getMinMax(false));
        }
      }
      min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
      max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
      this.min = Math.min(min, max - 1);
      this.max = Math.max(min + 1, max);
    }
    _getLabelBounds() {
      const arr = this.getLabelTimestamps();
      let min = Number.POSITIVE_INFINITY;
      let max = Number.NEGATIVE_INFINITY;
      if (arr.length) {
        min = arr[0];
        max = arr[arr.length - 1];
      }
      return {
        min,
        max
      };
    }
    buildTicks() {
      const options = this.options;
      const timeOpts = options.time;
      const tickOpts = options.ticks;
      const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
      if (options.bounds === "ticks" && timestamps.length) {
        this.min = this._userMin || timestamps[0];
        this.max = this._userMax || timestamps[timestamps.length - 1];
      }
      const min = this.min;
      const max = this.max;
      const ticks = _filterBetween(timestamps, min, max);
      this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
      this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
      this.initOffsets(timestamps);
      if (options.reverse) {
        ticks.reverse();
      }
      return ticksFromTimestamps(this, ticks, this._majorUnit);
    }
    afterAutoSkip() {
      if (this.options.offsetAfterAutoskip) {
        this.initOffsets(this.ticks.map((tick) => +tick.value));
      }
    }
    initOffsets(timestamps = []) {
      let start = 0;
      let end = 0;
      let first, last;
      if (this.options.offset && timestamps.length) {
        first = this.getDecimalForValue(timestamps[0]);
        if (timestamps.length === 1) {
          start = 1 - first;
        } else {
          start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
        }
        last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
        if (timestamps.length === 1) {
          end = last;
        } else {
          end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
        }
      }
      const limit = timestamps.length < 3 ? 0.5 : 0.25;
      start = _limitValue(start, 0, limit);
      end = _limitValue(end, 0, limit);
      this._offsets = {
        start,
        end,
        factor: 1 / (start + 1 + end)
      };
    }
    _generate() {
      const adapter = this._adapter;
      const min = this.min;
      const max = this.max;
      const options = this.options;
      const timeOpts = options.time;
      const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
      const stepSize = valueOrDefault(options.ticks.stepSize, 1);
      const weekday = minor === "week" ? timeOpts.isoWeekday : false;
      const hasWeekday = isNumber(weekday) || weekday === true;
      const ticks = {};
      let first = min;
      let time, count;
      if (hasWeekday) {
        first = +adapter.startOf(first, "isoWeek", weekday);
      }
      first = +adapter.startOf(first, hasWeekday ? "day" : minor);
      if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
        throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
      }
      const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
      for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
        addTick(ticks, time, timestamps);
      }
      if (time === max || options.bounds === "ticks" || count === 1) {
        addTick(ticks, time, timestamps);
      }
      return Object.keys(ticks).sort(sorter).map((x) => +x);
    }
    getLabelForValue(value) {
      const adapter = this._adapter;
      const timeOpts = this.options.time;
      if (timeOpts.tooltipFormat) {
        return adapter.format(value, timeOpts.tooltipFormat);
      }
      return adapter.format(value, timeOpts.displayFormats.datetime);
    }
    format(value, format) {
      const options = this.options;
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const fmt = format || formats[unit];
      return this._adapter.format(value, fmt);
    }
    _tickFormatFunction(time, index2, ticks, format) {
      const options = this.options;
      const formatter = options.ticks.callback;
      if (formatter) {
        return callback(formatter, [
          time,
          index2,
          ticks
        ], this);
      }
      const formats = options.time.displayFormats;
      const unit = this._unit;
      const majorUnit = this._majorUnit;
      const minorFormat = unit && formats[unit];
      const majorFormat = majorUnit && formats[majorUnit];
      const tick = ticks[index2];
      const major = majorUnit && majorFormat && tick && tick.major;
      return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
    }
    generateTickLabels(ticks) {
      let i, ilen, tick;
      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        tick.label = this._tickFormatFunction(tick.value, i, ticks);
      }
    }
    getDecimalForValue(value) {
      return value === null ? NaN : (value - this.min) / (this.max - this.min);
    }
    getPixelForValue(value) {
      const offsets = this._offsets;
      const pos = this.getDecimalForValue(value);
      return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return this.min + pos * (this.max - this.min);
    }
    _getLabelSize(label) {
      const ticksOpts = this.options.ticks;
      const tickLabelWidth = this.ctx.measureText(label).width;
      const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      const cosRotation = Math.cos(angle);
      const sinRotation = Math.sin(angle);
      const tickFontSize = this._resolveTickFontOptions(0).size;
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    }
    _getLabelCapacity(exampleTime) {
      const timeOpts = this.options.time;
      const displayFormats = timeOpts.displayFormats;
      const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
        exampleTime
      ], this._majorUnit), format);
      const size = this._getLabelSize(exampleLabel);
      const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
      return capacity > 0 ? capacity : 1;
    }
    getDataTimestamps() {
      let timestamps = this._cache.data || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const metas = this.getMatchingVisibleMetas();
      if (this._normalized && metas.length) {
        return this._cache.data = metas[0].controller.getAllParsedValues(this);
      }
      for (i = 0, ilen = metas.length; i < ilen; ++i) {
        timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
      }
      return this._cache.data = this.normalize(timestamps);
    }
    getLabelTimestamps() {
      const timestamps = this._cache.labels || [];
      let i, ilen;
      if (timestamps.length) {
        return timestamps;
      }
      const labels = this.getLabels();
      for (i = 0, ilen = labels.length; i < ilen; ++i) {
        timestamps.push(parse(this, labels[i]));
      }
      return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
    }
    normalize(values) {
      return _arrayUnique(values.sort(sorter));
    }
  };
  __publicField(TimeScale, "id", "time");
  __publicField(TimeScale, "defaults", {
    bounds: "data",
    adapters: {},
    time: {
      parser: false,
      unit: false,
      round: false,
      isoWeekday: false,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: false,
      major: {
        enabled: false
      }
    }
  });
  function interpolate2(table, val, reverse) {
    let lo = 0;
    let hi = table.length - 1;
    let prevSource, nextSource, prevTarget, nextTarget;
    if (reverse) {
      if (val >= table[lo].pos && val <= table[hi].pos) {
        ({ lo, hi } = _lookupByKey(table, "pos", val));
      }
      ({ pos: prevSource, time: prevTarget } = table[lo]);
      ({ pos: nextSource, time: nextTarget } = table[hi]);
    } else {
      if (val >= table[lo].time && val <= table[hi].time) {
        ({ lo, hi } = _lookupByKey(table, "time", val));
      }
      ({ time: prevSource, pos: prevTarget } = table[lo]);
      ({ time: nextSource, pos: nextTarget } = table[hi]);
    }
    const span = nextSource - prevSource;
    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
  }
  var TimeSeriesScale = class extends TimeScale {
    constructor(props) {
      super(props);
      this._table = [];
      this._minPos = void 0;
      this._tableRange = void 0;
    }
    initOffsets() {
      const timestamps = this._getTimestampsForTable();
      const table = this._table = this.buildLookupTable(timestamps);
      this._minPos = interpolate2(table, this.min);
      this._tableRange = interpolate2(table, this.max) - this._minPos;
      super.initOffsets(timestamps);
    }
    buildLookupTable(timestamps) {
      const { min, max } = this;
      const items = [];
      const table = [];
      let i, ilen, prev, curr, next;
      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        curr = timestamps[i];
        if (curr >= min && curr <= max) {
          items.push(curr);
        }
      }
      if (items.length < 2) {
        return [
          {
            time: min,
            pos: 0
          },
          {
            time: max,
            pos: 1
          }
        ];
      }
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        next = items[i + 1];
        prev = items[i - 1];
        curr = items[i];
        if (Math.round((next + prev) / 2) !== curr) {
          table.push({
            time: curr,
            pos: i / (ilen - 1)
          });
        }
      }
      return table;
    }
    _generate() {
      const min = this.min;
      const max = this.max;
      let timestamps = super.getDataTimestamps();
      if (!timestamps.includes(min) || !timestamps.length) {
        timestamps.splice(0, 0, min);
      }
      if (!timestamps.includes(max) || timestamps.length === 1) {
        timestamps.push(max);
      }
      return timestamps.sort((a, b) => a - b);
    }
    _getTimestampsForTable() {
      let timestamps = this._cache.all || [];
      if (timestamps.length) {
        return timestamps;
      }
      const data = this.getDataTimestamps();
      const label = this.getLabelTimestamps();
      if (data.length && label.length) {
        timestamps = this.normalize(data.concat(label));
      } else {
        timestamps = data.length ? data : label;
      }
      timestamps = this._cache.all = timestamps;
      return timestamps;
    }
    getDecimalForValue(value) {
      return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
    }
    getValueForPixel(pixel) {
      const offsets = this._offsets;
      const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
    }
  };
  __publicField(TimeSeriesScale, "id", "timeseries");
  __publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
  var scales = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    CategoryScale,
    LinearScale,
    LogarithmicScale,
    RadialLinearScale,
    TimeScale,
    TimeSeriesScale
  });
  var registerables = [
    controllers,
    elements,
    plugins,
    scales
  ];

  // node_modules/chart.js/auto/auto.js
  Chart.register(...registerables);
  var auto_default = Chart;

  // js/app.js
  var csrfToken = document.querySelector("meta[name='csrf-token']").getAttribute("content");
  var Hooks2 = {};
  Hooks2.LocationMap = {
    mounted() {
      const lat = document.getElementById("product-order-latitude").innerText;
      const lng = document.getElementById("product-order-longitude").innerText;
      function initMap() {
        const map3 = new google.maps.Map(
          document.getElementById("product-order-map"),
          {
            center: {
              lat: parseFloat(lat),
              lng: parseFloat(lng)
            },
            zoom: 8
          }
        );
        new google.maps.Marker({
          position: {
            lat: parseFloat(lat),
            lng: parseFloat(lng)
          },
          map: map3,
          title: "Hello World!"
        });
      }
      initMap();
    },
    updated() {
      const lat = document.getElementById("product-order-latitude").innerText;
      const lng = document.getElementById("product-order-longitude").innerText;
      function initMap() {
        const map3 = new google.maps.Map(
          document.getElementById("product-order-map"),
          {
            center: {
              lat: parseFloat(lat),
              lng: parseFloat(lng)
            },
            zoom: 8
          }
        );
        new google.maps.Marker({
          position: {
            lat: parseFloat(lat),
            lng: parseFloat(lng)
          },
          map: map3,
          title: "Hello World!"
        });
      }
      initMap();
    }
  };
  Hooks2.ProductLocation = {
    mounted() {
      const input = document.getElementById("product_order_location");
      const delivery_latitude_product_order = document.getElementById(
        "delivery_latitude_product_order"
      );
      const delivery_longitude_product_order = document.getElementById(
        "delivery_longitude_product_order"
      );
      const options = {
        fields: ["address_components", "geometry", "icon", "name"],
        componentRestrictions: { country: "ke" }
      };
      const autocomplete1 = new google.maps.places.Autocomplete(input, options);
      autocomplete1.addListener("place_changed", () => {
        const place1 = autocomplete1.getPlace();
        delivery_latitude_product_order.value = place1.geometry.location.lat();
        delivery_longitude_product_order.value = place1.geometry.location.lng();
      });
    },
    updated() {
      const input = document.getElementById("product_order_location");
      const delivery_latitude_product_order = document.getElementById(
        "delivery_latitude_product_order"
      );
      const delivery_longitude_product_order = document.getElementById(
        "delivery_longitude_product_order"
      );
      const options = {
        fields: ["address_components", "geometry", "icon", "name"],
        componentRestrictions: { country: "ke" }
      };
      const autocomplete1 = new google.maps.places.Autocomplete(input, options);
      autocomplete1.addListener("place_changed", () => {
        const place1 = autocomplete1.getPlace();
        delivery_latitude_product_order.value = place1.geometry.location.lat();
        delivery_longitude_product_order.value = place1.geometry.location.lng();
      });
    }
  };
  document.addEventListener("DOMContentLoaded", () => {
    updateCartValue();
  });
  var updateCartValue = () => {
    order_items = sessionStorage.getItem("order_items");
    if (order_items) {
      document.getElementById("cart-navbar-value").innerHTML = JSON.parse(order_items).length;
    } else {
      document.getElementById("cart-navbar-value").innerHTML = 0;
    }
  };
  Hooks2.RestoreCart = {
    mounted() {
      order_items = sessionStorage.getItem("order_items");
      this.pushEvent("RestoreCart", { order_items });
      updateCartValue();
    }
  };
  Hooks2.UpdateCart = {
    mounted() {
      this.handleEvent("UpdateCart", ({ order_items: order_items2 }) => {
        sessionStorage.setItem("order_items", order_items2);
        updateCartValue();
      });
    }
  };
  Hooks2.deleteCartItem = {
    mounted() {
      this.handleEvent("deleteCartItem", ({ order_items: order_items2 }) => {
        sessionStorage.setItem("order_items", order_items2);
        window.location.reload();
        updateCartValue();
      });
    }
  };
  Hooks2.clearCart = {
    mounted() {
      this.handleEvent("clearCart", () => {
        sessionStorage.removeItem("order_items");
      });
    }
  };
  Hooks2.SwiperHook = {
    mounted() {
      this.swiper = new Swiper(this.el, {
        // Enable horizontal direction (more common for image sliders)
        direction: "horizontal",
        // Enable loop
        loop: true,
        // Enable auto play
        autoplay: {
          delay: 3e3,
          // 3 seconds between slides
          disableOnInteraction: false
          // Continue autoplay after user interaction
        },
        // Add pagination
        pagination: {
          el: ".swiper-pagination",
          clickable: true
        },
        // Add effects
        effect: "slide",
        // You can try 'fade', 'cube', 'coverflow', etc.
        // Optional: add responsive breakpoints
        breakpoints: {
          640: {
            slidesPerView: 1
          },
          768: {
            slidesPerView: 1
          },
          1024: {
            slidesPerView: 1
          }
        }
      });
    },
    updated() {
      if (this.swiper) {
        this.swiper.destroy();
      }
      setTimeout(() => {
        this.swiper = new Swiper(this.el, {
          direction: "horizontal",
          loop: true,
          autoplay: {
            delay: 3e3,
            disableOnInteraction: false
          },
          pagination: {
            el: ".swiper-pagination",
            clickable: true
          },
          effect: "slide"
        });
      }, 100);
    },
    destroyed() {
      if (this.swiper) {
        this.swiper.destroy();
        this.swiper = null;
      }
    },
    beforeDestroy() {
      if (this.swiper) {
        this.swiper.destroy();
        this.swiper = null;
      }
    }
  };
  Hooks2.EachProductSwiperHook = {
    mounted() {
      this.swiper = new Swiper(this.el, {
        // Enable horizontal direction (more common for image sliders)
        direction: "horizontal",
        // Enable loop
        loop: true,
        // Enable auto play
        autoplay: {
          delay: 3e3,
          // 3 seconds between slides
          disableOnInteraction: false
          // Continue autoplay after user interaction
        },
        // Add pagination
        pagination: {
          el: ".swiper-pagination",
          clickable: true
        },
        // Add navigation buttons
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev"
        },
        // Add effects
        effect: "slide",
        // You can try 'fade', 'cube', 'coverflow', etc.
        // Optional: add responsive breakpoints
        breakpoints: {
          640: {
            slidesPerView: 1
          },
          768: {
            slidesPerView: 1
          },
          1024: {
            slidesPerView: 1
          }
        }
      });
    },
    updated() {
      if (this.swiper) {
        this.swiper.destroy();
      }
      setTimeout(() => {
        this.swiper = new Swiper(this.el, {
          direction: "horizontal",
          loop: true,
          autoplay: {
            delay: 3e3,
            disableOnInteraction: false
          },
          pagination: {
            el: ".swiper-pagination",
            clickable: true
          },
          effect: "slide"
        });
      }, 100);
    },
    destroyed() {
      if (this.swiper) {
        this.swiper.destroy();
        this.swiper = null;
      }
    },
    beforeDestroy() {
      if (this.swiper) {
        this.swiper.destroy();
        this.swiper = null;
      }
    }
  };
  var liveSocket = new LiveSocket("/live", Socket, {
    longPollFallbackMs: 2500,
    params: { _csrf_token: csrfToken },
    hooks: Hooks2
  });
  import_topbar.default.config({ barColors: { 0: "#29d" }, shadowColor: "rgba(0, 0, 0, .3)" });
  window.addEventListener("phx:page-loading-start", (_info) => import_topbar.default.show(300));
  window.addEventListener("phx:page-loading-stop", (_info) => import_topbar.default.hide());
  liveSocket.connect();
  window.liveSocket = liveSocket;
  document.addEventListener("DOMContentLoaded", function() {
    const toggleButton = document.getElementById("toggle-reviews");
    const reviewSection = document.getElementById("reviews-section");
    const dropdownIcon = document.getElementById("dropdown-icon");
    const toggleAction = document.getElementById("toggle-review-form");
    const reviewForm = document.getElementById("form-review");
    toggleButton.addEventListener("click", function() {
      reviewSection.classList.toggle("hidden");
      dropdownIcon.style.transform = reviewSection.classList.contains("hidden") ? "rotate(0deg)" : "rotate(180deg)";
    });
    toggleAction.addEventListener("click", function() {
      reviewForm.classList.toggle("hidden");
    });
  });
  Hooks2.OrderSummaryChart = {
    mounted() {
      console.log("OrderSummaryChart mounted");
      this.renderChart();
    },
    updated() {
      console.log("OrderSummaryChart updated");
      this.renderChart();
    },
    renderChart() {
      console.log("renderChart called");
      if (this.chart) {
        this.chart.destroy();
      }
      const ctx = this.el.getContext("2d");
      const chartData = JSON.parse(this.el.dataset.chartData);
      const chartLabels = JSON.parse(this.el.dataset.chartLabels);
      console.log("Chart Data:", chartData);
      console.log("Chart Labels:", chartLabels);
      this.chart = new auto_default(ctx, {
        type: "line",
        data: {
          labels: chartLabels,
          datasets: [{
            label: "Orders",
            backgroundColor: "rgba(119, 51, 255, 0.2)",
            borderColor: "rgba(119, 51, 255, 1)",
            fill: true,
            data: chartData,
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: { enabled: true }
          },
          scales: {
            x: {
              title: { display: true, text: this.el.dataset.xAxisTitle },
              grid: { color: "#374151", lineWidth: 0.1 }
            },
            y: {
              title: { display: true, text: "Number of Orders" },
              beginAtZero: true,
              grid: { color: "#374151", lineWidth: 0.1 }
            }
          }
        }
      });
    }
  };
  Hooks2.RevenueChart = {
    mounted() {
      const ctx = this.el.getContext("2d");
      const averageSales = parseFloat(this.el.dataset.averageSales);
      const averageRevenue = parseFloat(this.el.dataset.averageRevenue);
      const days = JSON.parse(this.el.dataset.days);
      const sales = JSON.parse(this.el.dataset.sales);
      const revenue = JSON.parse(this.el.dataset.revenue);
      new auto_default(ctx, {
        type: "bar",
        data: {
          labels: days,
          // Use the day numbers here
          datasets: [
            {
              label: "Daily Sales",
              data: sales,
              backgroundColor: "rgba(0, 0, 0, 0.07)",
              barThickness: 8,
              borderRadius: 4
            },
            {
              label: "Daily Revenue",
              data: revenue,
              backgroundColor: "rgba(118, 238, 14, 0.3)",
              barThickness: 8,
              borderRadius: 4
            }
          ]
        },
        options: {
          scales: {
            y: {
              beginAtZero: true,
              display: false,
              title: {
                display: false,
                text: "Amount"
              },
              grid: {
                display: false
              }
            },
            x: {
              title: {
                display: false,
                text: "Day"
              },
              grid: {
                display: false
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.dataset.label || "";
                  if (label) {
                    label += ": ";
                  }
                  if (context.parsed.y !== null) {
                    label += new Intl.NumberFormat("en-US", { style: "currency", currency: "KES" }).format(context.parsed.y);
                  }
                  return label;
                }
              }
            }
          }
        }
      });
    }
  };
})();
/**
 * @license MIT
 * topbar 2.0.0, 2023-02-04
 * https://buunguyen.github.io/topbar
 * Copyright (c) 2021 Buu Nguyen
 */
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.js:
  (*!
   * Chart.js v4.4.8
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.4.8
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vYXNzZXRzL3ZlbmRvci90b3BiYXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2h0bWwvcHJpdi9zdGF0aWMvcGhvZW5peF9odG1sLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC91dGlscy5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9wdXNoLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC90aW1lci5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvY2hhbm5lbC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvYWpheC5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXgvYXNzZXRzL2pzL3Bob2VuaXgvbG9uZ3BvbGwuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4L2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zZXJpYWxpemVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peC9hc3NldHMvanMvcGhvZW5peC9zb2NrZXQuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvY29uc3RhbnRzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2VudHJ5X3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3V0aWxzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2Jyb3dzZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3VwbG9hZF9lbnRyeS5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy9saXZlX3VwbG9hZGVyLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2FyaWEuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvaG9va3MuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZWxlbWVudF9yZWYuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3Bvc3RfbW9ycGhfcmVzdG9yZXIuanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9ub2RlX21vZHVsZXMvbW9ycGhkb20vZGlzdC9tb3JwaGRvbS1lc20uanMiLCAiLi4vLi4vLi4vZGVwcy9waG9lbml4X2xpdmVfdmlldy9hc3NldHMvanMvcGhvZW5peF9saXZlX3ZpZXcvZG9tX3BhdGNoLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3JlbmRlcmVkLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2pzLmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L3ZpZXdfaG9vay5qcyIsICIuLi8uLi8uLi9kZXBzL3Bob2VuaXhfbGl2ZV92aWV3L2Fzc2V0cy9qcy9waG9lbml4X2xpdmVfdmlldy92aWV3LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2xpdmVfc29ja2V0LmpzIiwgIi4uLy4uLy4uL2RlcHMvcGhvZW5peF9saXZlX3ZpZXcvYXNzZXRzL2pzL3Bob2VuaXhfbGl2ZV92aWV3L2luZGV4LmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9qcy9hcHAuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9Aa3Vya2xlL2NvbG9yL2Rpc3QvY29sb3IuZXNtLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb3JlLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5tYXRoLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5leHRyYXMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmVhc2luZy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29sb3IudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGwudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnRpY2tzLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5kZWZhdWx0cy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuZGVmYXVsdHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNhbnZhcy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29uZmlnLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jdXJ2ZS50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZG9tLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5pbnRlcnBvbGF0aW9uLnRzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5ydGwudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdG9yLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb24uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmFuaW1hdGlvbnMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYmFyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYnViYmxlLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuZG91Z2hudXQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5saW5lLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucG9sYXJBcmVhLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucGllLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucmFkYXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5zY2F0dGVyLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hZGFwdGVycy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vcGxhdGZvcm0uYmFzZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNpYy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5kb20uanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGxhdGZvcm0vaW5kZXguanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmVsZW1lbnQudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnNjYWxlLmF1dG9za2lwLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudHlwZWRSZWdpc3RyeS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUucmVnaXN0cnkuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLnBsdWdpbnMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbmZpZy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuY29udHJvbGxlci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmFyYy50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5wb2ludC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmJhci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5jb2xvcnMudHMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZGVjaW1hdGlvbi5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnNlZ21lbnQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5oZWxwZXIuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5vcHRpb25zLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIudGFyZ2V0LnN0YWNrLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9zaW1wbGVBcmMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci50YXJnZXQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5kcmF3aW5nLmpzIiwgIi4uLy4uLy4uL2Fzc2V0cy9ub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9pbmRleC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5sZWdlbmQuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udGl0bGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uc3VidGl0bGUuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4udG9vbHRpcC5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUuY2F0ZWdvcnkuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhcmJhc2UuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubG9nYXJpdGhtaWMuanMiLCAiLi4vLi4vLi4vYXNzZXRzL25vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnJhZGlhbExpbmVhci5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUudGltZS5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUudGltZXNlcmllcy5qcyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9pbmRleC50cyIsICIuLi8uLi8uLi9hc3NldHMvbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2F1dG8vYXV0by5qcyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG4gKiBAbGljZW5zZSBNSVRcbiAqIHRvcGJhciAyLjAuMCwgMjAyMy0wMi0wNFxuICogaHR0cHM6Ly9idXVuZ3V5ZW4uZ2l0aHViLmlvL3RvcGJhclxuICogQ29weXJpZ2h0IChjKSAyMDIxIEJ1dSBOZ3V5ZW5cbiAqL1xuKGZ1bmN0aW9uICh3aW5kb3csIGRvY3VtZW50KSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxhc3RUaW1lID0gMDtcbiAgICB2YXIgdmVuZG9ycyA9IFtcIm1zXCIsIFwibW96XCIsIFwid2Via2l0XCIsIFwib1wiXTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3gpIHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPVxuICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArIFwiUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID1cbiAgICAgICAgd2luZG93W3ZlbmRvcnNbeF0gKyBcIkNhbmNlbEFuaW1hdGlvbkZyYW1lXCJdIHx8XG4gICAgICAgIHdpbmRvd1t2ZW5kb3JzW3hdICsgXCJDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIl07XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSlcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHZhciB0aW1lVG9DYWxsID0gTWF0aC5tYXgoMCwgMTYgLSAoY3VyclRpbWUgLSBsYXN0VGltZSkpO1xuICAgICAgICB2YXIgaWQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTtcbiAgICAgICAgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9O1xuICAgIGlmICghd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKVxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICB9O1xuICB9KSgpO1xuXG4gIHZhciBjYW52YXMsXG4gICAgY3VycmVudFByb2dyZXNzLFxuICAgIHNob3dpbmcsXG4gICAgcHJvZ3Jlc3NUaW1lcklkID0gbnVsbCxcbiAgICBmYWRlVGltZXJJZCA9IG51bGwsXG4gICAgZGVsYXlUaW1lcklkID0gbnVsbCxcbiAgICBhZGRFdmVudCA9IGZ1bmN0aW9uIChlbGVtLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyKSBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgZWxzZSBpZiAoZWxlbS5hdHRhY2hFdmVudCkgZWxlbS5hdHRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBoYW5kbGVyKTtcbiAgICAgIGVsc2UgZWxlbVtcIm9uXCIgKyB0eXBlXSA9IGhhbmRsZXI7XG4gICAgfSxcbiAgICBvcHRpb25zID0ge1xuICAgICAgYXV0b1J1bjogdHJ1ZSxcbiAgICAgIGJhclRoaWNrbmVzczogMyxcbiAgICAgIGJhckNvbG9yczoge1xuICAgICAgICAwOiBcInJnYmEoMjYsICAxODgsIDE1NiwgLjkpXCIsXG4gICAgICAgIFwiLjI1XCI6IFwicmdiYSg1MiwgIDE1MiwgMjE5LCAuOSlcIixcbiAgICAgICAgXCIuNTBcIjogXCJyZ2JhKDI0MSwgMTk2LCAxNSwgIC45KVwiLFxuICAgICAgICBcIi43NVwiOiBcInJnYmEoMjMwLCAxMjYsIDM0LCAgLjkpXCIsXG4gICAgICAgIFwiMS4wXCI6IFwicmdiYSgyMTEsIDg0LCAgMCwgICAuOSlcIixcbiAgICAgIH0sXG4gICAgICBzaGFkb3dCbHVyOiAxMCxcbiAgICAgIHNoYWRvd0NvbG9yOiBcInJnYmEoMCwgICAwLCAgIDAsICAgLjYpXCIsXG4gICAgICBjbGFzc05hbWU6IG51bGwsXG4gICAgfSxcbiAgICByZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5iYXJUaGlja25lc3MgKiA1OyAvLyBuZWVkIHNwYWNlIGZvciBzaGFkb3dcblxuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguc2hhZG93Qmx1ciA9IG9wdGlvbnMuc2hhZG93Qmx1cjtcbiAgICAgIGN0eC5zaGFkb3dDb2xvciA9IG9wdGlvbnMuc2hhZG93Q29sb3I7XG5cbiAgICAgIHZhciBsaW5lR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgY2FudmFzLndpZHRoLCAwKTtcbiAgICAgIGZvciAodmFyIHN0b3AgaW4gb3B0aW9ucy5iYXJDb2xvcnMpXG4gICAgICAgIGxpbmVHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgb3B0aW9ucy5iYXJDb2xvcnNbc3RvcF0pO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbygwLCBvcHRpb25zLmJhclRoaWNrbmVzcyAvIDIpO1xuICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgTWF0aC5jZWlsKGN1cnJlbnRQcm9ncmVzcyAqIGNhbnZhcy53aWR0aCksXG4gICAgICAgIG9wdGlvbnMuYmFyVGhpY2tuZXNzIC8gMixcbiAgICAgICk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsaW5lR3JhZGllbnQ7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBjcmVhdGVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdmFyIHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gc3R5bGUucmlnaHQgPSBzdHlsZS5tYXJnaW4gPSBzdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IDEwMDAwMTtcbiAgICAgIHN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgIGlmIChvcHRpb25zLmNsYXNzTmFtZSkgY2FudmFzLmNsYXNzTGlzdC5hZGQob3B0aW9ucy5jbGFzc05hbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgYWRkRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCByZXBhaW50KTtcbiAgICB9LFxuICAgIHRvcGJhciA9IHtcbiAgICAgIGNvbmZpZzogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkgb3B0aW9uc1trZXldID0gb3B0c1trZXldO1xuICAgICAgfSxcbiAgICAgIHNob3c6IGZ1bmN0aW9uIChkZWxheSkge1xuICAgICAgICBpZiAoc2hvd2luZykgcmV0dXJuO1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICBpZiAoZGVsYXlUaW1lcklkKSByZXR1cm47XG4gICAgICAgICAgZGVsYXlUaW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB0b3BiYXIuc2hvdygpLCBkZWxheSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvd2luZyA9IHRydWU7XG4gICAgICAgICAgaWYgKGZhZGVUaW1lcklkICE9PSBudWxsKSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoZmFkZVRpbWVySWQpO1xuICAgICAgICAgIGlmICghY2FudmFzKSBjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgdG9wYmFyLnByb2dyZXNzKDApO1xuICAgICAgICAgIGlmIChvcHRpb25zLmF1dG9SdW4pIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiBsb29wKCkge1xuICAgICAgICAgICAgICBwcm9ncmVzc1RpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICAgICAgICB0b3BiYXIucHJvZ3Jlc3MoXG4gICAgICAgICAgICAgICAgXCIrXCIgKyAwLjA1ICogTWF0aC5wb3coMSAtIE1hdGguc3FydChjdXJyZW50UHJvZ3Jlc3MpLCAyKSxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uICh0bykge1xuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gY3VycmVudFByb2dyZXNzO1xuICAgICAgICBpZiAodHlwZW9mIHRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdG8gPVxuICAgICAgICAgICAgKHRvLmluZGV4T2YoXCIrXCIpID49IDAgfHwgdG8uaW5kZXhPZihcIi1cIikgPj0gMFxuICAgICAgICAgICAgICA/IGN1cnJlbnRQcm9ncmVzc1xuICAgICAgICAgICAgICA6IDApICsgcGFyc2VGbG9hdCh0byk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFByb2dyZXNzID0gdG8gPiAxID8gMSA6IHRvO1xuICAgICAgICByZXBhaW50KCk7XG4gICAgICAgIHJldHVybiBjdXJyZW50UHJvZ3Jlc3M7XG4gICAgICB9LFxuICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZGVsYXlUaW1lcklkKTtcbiAgICAgICAgZGVsYXlUaW1lcklkID0gbnVsbDtcbiAgICAgICAgaWYgKCFzaG93aW5nKSByZXR1cm47XG4gICAgICAgIHNob3dpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb2dyZXNzVGltZXJJZCAhPSBudWxsKSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHByb2dyZXNzVGltZXJJZCk7XG4gICAgICAgICAgcHJvZ3Jlc3NUaW1lcklkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAoZnVuY3Rpb24gbG9vcCgpIHtcbiAgICAgICAgICBpZiAodG9wYmFyLnByb2dyZXNzKFwiKy4xXCIpID49IDEpIHtcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5vcGFjaXR5IC09IDAuMDU7XG4gICAgICAgICAgICBpZiAoY2FudmFzLnN0eWxlLm9wYWNpdHkgPD0gMC4wNSkge1xuICAgICAgICAgICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICBmYWRlVGltZXJJZCA9IG51bGw7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZmFkZVRpbWVySWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgICAgICB9KSgpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gdG9wYmFyO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0b3BiYXI7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b3BiYXIgPSB0b3BiYXI7XG4gIH1cbn0pLmNhbGwodGhpcywgd2luZG93LCBkb2N1bWVudCk7XG4iLCAiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIFBvbHlmaWxsRXZlbnQgPSBldmVudENvbnN0cnVjdG9yKCk7XG5cbiAgZnVuY3Rpb24gZXZlbnRDb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gd2luZG93LkN1c3RvbUV2ZW50O1xuICAgIC8vIElFPD05IFN1cHBvcnRcbiAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge2J1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWR9O1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgIHJldHVybiBldnQ7XG4gICAgfVxuICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgcmV0dXJuIEN1c3RvbUV2ZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRIaWRkZW5JbnB1dChuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJoaWRkZW5cIjtcbiAgICBpbnB1dC5uYW1lID0gbmFtZTtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGVsZW1lbnQsIHRhcmdldE1vZGlmaWVyS2V5KSB7XG4gICAgdmFyIHRvID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvXCIpLFxuICAgICAgICBtZXRob2QgPSBidWlsZEhpZGRlbklucHV0KFwiX21ldGhvZFwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtbWV0aG9kXCIpKSxcbiAgICAgICAgY3NyZiA9IGJ1aWxkSGlkZGVuSW5wdXQoXCJfY3NyZl90b2tlblwiLCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY3NyZlwiKSksXG4gICAgICAgIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgICAgc3VibWl0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICB0YXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGZvcm0ubWV0aG9kID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1tZXRob2RcIikgPT09IFwiZ2V0XCIpID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICAgIGZvcm0uYWN0aW9uID0gdG87XG4gICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICBpZiAodGFyZ2V0KSBmb3JtLnRhcmdldCA9IHRhcmdldDtcbiAgICBlbHNlIGlmICh0YXJnZXRNb2RpZmllcktleSkgZm9ybS50YXJnZXQgPSBcIl9ibGFua1wiO1xuXG4gICAgZm9ybS5hcHBlbmRDaGlsZChjc3JmKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKG1ldGhvZCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIC8vIEluc2VydCBhIGJ1dHRvbiBhbmQgY2xpY2sgaXQgaW5zdGVhZCBvZiB1c2luZyBgZm9ybS5zdWJtaXRgXG4gICAgLy8gYmVjYXVzZSB0aGUgYHN1Ym1pdGAgZnVuY3Rpb24gZG9lcyBub3QgZW1pdCBhIGBzdWJtaXRgIGV2ZW50LlxuICAgIHN1Ym1pdC50eXBlID0gXCJzdWJtaXRcIjtcbiAgICBmb3JtLmFwcGVuZENoaWxkKHN1Ym1pdCk7XG4gICAgc3VibWl0LmNsaWNrKCk7XG4gIH1cblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGUudGFyZ2V0O1xuICAgIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGhvZW5peExpbmtFdmVudCA9IG5ldyBQb2x5ZmlsbEV2ZW50KCdwaG9lbml4LmxpbmsuY2xpY2snLCB7XG4gICAgICAgIFwiYnViYmxlc1wiOiB0cnVlLCBcImNhbmNlbGFibGVcIjogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZWxlbWVudC5kaXNwYXRjaEV2ZW50KHBob2VuaXhMaW5rRXZlbnQpKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdG9cIikpIHtcbiAgICAgICAgaGFuZGxlQ2xpY2soZWxlbWVudCwgZS5tZXRhS2V5IHx8IGUuc2hpZnRLZXkpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9LCBmYWxzZSk7XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Bob2VuaXgubGluay5jbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbmZpcm1cIik7XG4gICAgaWYobWVzc2FnZSAmJiAhd2luZG93LmNvbmZpcm0obWVzc2FnZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbn0pKCk7XG4iLCAiLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWx1ZSkgPT4ge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIil7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgbGV0IGNsb3N1cmUgPSBmdW5jdGlvbiAoKXsgcmV0dXJuIHZhbHVlIH1cbiAgICByZXR1cm4gY2xvc3VyZVxuICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IGdsb2JhbFNlbGYgPSB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiBudWxsXG5leHBvcnQgY29uc3QgcGh4V2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IG51bGxcbmV4cG9ydCBjb25zdCBnbG9iYWwgPSBnbG9iYWxTZWxmIHx8IHBoeFdpbmRvdyB8fCBnbG9iYWxcbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZTTiA9IFwiMi4wLjBcIlxuZXhwb3J0IGNvbnN0IFNPQ0tFVF9TVEFURVMgPSB7Y29ubmVjdGluZzogMCwgb3BlbjogMSwgY2xvc2luZzogMiwgY2xvc2VkOiAzfVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDEwMDAwXG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMFxuZXhwb3J0IGNvbnN0IENIQU5ORUxfU1RBVEVTID0ge1xuICBjbG9zZWQ6IFwiY2xvc2VkXCIsXG4gIGVycm9yZWQ6IFwiZXJyb3JlZFwiLFxuICBqb2luZWQ6IFwiam9pbmVkXCIsXG4gIGpvaW5pbmc6IFwiam9pbmluZ1wiLFxuICBsZWF2aW5nOiBcImxlYXZpbmdcIixcbn1cbmV4cG9ydCBjb25zdCBDSEFOTkVMX0VWRU5UUyA9IHtcbiAgY2xvc2U6IFwicGh4X2Nsb3NlXCIsXG4gIGVycm9yOiBcInBoeF9lcnJvclwiLFxuICBqb2luOiBcInBoeF9qb2luXCIsXG4gIHJlcGx5OiBcInBoeF9yZXBseVwiLFxuICBsZWF2ZTogXCJwaHhfbGVhdmVcIlxufVxuXG5leHBvcnQgY29uc3QgVFJBTlNQT1JUUyA9IHtcbiAgbG9uZ3BvbGw6IFwibG9uZ3BvbGxcIixcbiAgd2Vic29ja2V0OiBcIndlYnNvY2tldFwiXG59XG5leHBvcnQgY29uc3QgWEhSX1NUQVRFUyA9IHtcbiAgY29tcGxldGU6IDRcbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWwgLSBUaGUgQ2hhbm5lbFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50LCBmb3IgZXhhbXBsZSBgXCJwaHhfam9pblwiYFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgLSBUaGUgcGF5bG9hZCwgZm9yIGV4YW1wbGUgYHt1c2VyX2lkOiAxMjN9YFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoIHtcbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQpe1xuICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWxcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnRcbiAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkIHx8IGZ1bmN0aW9uICgpeyByZXR1cm4ge30gfVxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnJlY0hvb2tzID0gW11cbiAgICB0aGlzLnNlbnQgPSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gICAqL1xuICByZXNlbmQodGltZW91dCl7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dFxuICAgIHRoaXMucmVzZXQoKVxuICAgIHRoaXMuc2VuZCgpXG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIHNlbmQoKXtcbiAgICBpZih0aGlzLmhhc1JlY2VpdmVkKFwidGltZW91dFwiKSl7IHJldHVybiB9XG4gICAgdGhpcy5zdGFydFRpbWVvdXQoKVxuICAgIHRoaXMuc2VudCA9IHRydWVcbiAgICB0aGlzLmNoYW5uZWwuc29ja2V0LnB1c2goe1xuICAgICAgdG9waWM6IHRoaXMuY2hhbm5lbC50b3BpYyxcbiAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgcGF5bG9hZDogdGhpcy5wYXlsb2FkKCksXG4gICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5qb2luUmVmKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gc3RhdHVzXG4gICAqIEBwYXJhbSB7Kn0gY2FsbGJhY2tcbiAgICovXG4gIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5oYXNSZWNlaXZlZChzdGF0dXMpKXtcbiAgICAgIGNhbGxiYWNrKHRoaXMucmVjZWl2ZWRSZXNwLnJlc3BvbnNlKVxuICAgIH1cblxuICAgIHRoaXMucmVjSG9va3MucHVzaCh7c3RhdHVzLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcmVzZXQoKXtcbiAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICB0aGlzLnJlZiA9IG51bGxcbiAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbFxuICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbFxuICAgIHRoaXMuc2VudCA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG1hdGNoUmVjZWl2ZSh7c3RhdHVzLCByZXNwb25zZSwgX3JlZn0pe1xuICAgIHRoaXMucmVjSG9va3MuZmlsdGVyKGggPT4gaC5zdGF0dXMgPT09IHN0YXR1cylcbiAgICAgIC5mb3JFYWNoKGggPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbmNlbFJlZkV2ZW50KCl7XG4gICAgaWYoIXRoaXMucmVmRXZlbnQpeyByZXR1cm4gfVxuICAgIHRoaXMuY2hhbm5lbC5vZmYodGhpcy5yZWZFdmVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2FuY2VsVGltZW91dCgpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRUaW1lcilcbiAgICB0aGlzLnRpbWVvdXRUaW1lciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRUaW1lb3V0KCl7XG4gICAgaWYodGhpcy50aW1lb3V0VGltZXIpeyB0aGlzLmNhbmNlbFRpbWVvdXQoKSB9XG4gICAgdGhpcy5yZWYgPSB0aGlzLmNoYW5uZWwuc29ja2V0Lm1ha2VSZWYoKVxuICAgIHRoaXMucmVmRXZlbnQgPSB0aGlzLmNoYW5uZWwucmVwbHlFdmVudE5hbWUodGhpcy5yZWYpXG5cbiAgICB0aGlzLmNoYW5uZWwub24odGhpcy5yZWZFdmVudCwgcGF5bG9hZCA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFJlZkV2ZW50KClcbiAgICAgIHRoaXMuY2FuY2VsVGltZW91dCgpXG4gICAgICB0aGlzLnJlY2VpdmVkUmVzcCA9IHBheWxvYWRcbiAgICAgIHRoaXMubWF0Y2hSZWNlaXZlKHBheWxvYWQpXG4gICAgfSlcblxuICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRyaWdnZXIoXCJ0aW1lb3V0XCIsIHt9KVxuICAgIH0sIHRoaXMudGltZW91dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFzUmVjZWl2ZWQoc3RhdHVzKXtcbiAgICByZXR1cm4gdGhpcy5yZWNlaXZlZFJlc3AgJiYgdGhpcy5yZWNlaXZlZFJlc3Auc3RhdHVzID09PSBzdGF0dXNcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlcihzdGF0dXMsIHJlc3BvbnNlKXtcbiAgICB0aGlzLmNoYW5uZWwudHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7c3RhdHVzLCByZXNwb25zZX0pXG4gIH1cbn1cbiIsICIvKipcbiAqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybVxuICogY2FsY3VsYXRlZCB0aW1lb3V0IHJldHJpZXMsIHN1Y2ggYXMgZXhwb25lbnRpYWwgYmFja29mZi5cbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHRoaXMuY29ubmVjdCgpLCBmdW5jdGlvbih0cmllcyl7XG4gKiAgIHJldHVybiBbMTAwMCwgNTAwMCwgMTAwMDBdW3RyaWVzIC0gMV0gfHwgMTAwMDBcbiAqIH0pXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciA1MDAwXG4gKiByZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gKiByZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSAvLyBmaXJlcyBhZnRlciAxMDAwXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRpbWVyQ2FsY1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaW1lciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpe1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMudGltZXJDYWxjID0gdGltZXJDYWxjXG4gICAgdGhpcy50aW1lciA9IG51bGxcbiAgICB0aGlzLnRyaWVzID0gMFxuICB9XG5cbiAgcmVzZXQoKXtcbiAgICB0aGlzLnRyaWVzID0gMFxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IHByZXZpb3VzIHNjaGVkdWxlVGltZW91dCBhbmQgc2NoZWR1bGVzIGNhbGxiYWNrXG4gICAqL1xuICBzY2hlZHVsZVRpbWVvdXQoKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcilcblxuICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJpZXMgPSB0aGlzLnRyaWVzICsgMVxuICAgICAgdGhpcy5jYWxsYmFjaygpXG4gICAgfSwgdGhpcy50aW1lckNhbGModGhpcy50cmllcyArIDEpKVxuICB9XG59XG4iLCAiaW1wb3J0IHtjbG9zdXJlfSBmcm9tIFwiLi91dGlsc1wiXG5pbXBvcnQge1xuICBDSEFOTkVMX0VWRU5UUyxcbiAgQ0hBTk5FTF9TVEFURVMsXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBQdXNoIGZyb20gXCIuL3B1c2hcIlxuaW1wb3J0IFRpbWVyIGZyb20gXCIuL3RpbWVyXCJcblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBwYXJhbXNcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yKHRvcGljLCBwYXJhbXMsIHNvY2tldCl7XG4gICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZFxuICAgIHRoaXMudG9waWMgPSB0b3BpY1xuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShwYXJhbXMgfHwge30pXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLmJpbmRpbmdzID0gW11cbiAgICB0aGlzLmJpbmRpbmdSZWYgPSAwXG4gICAgdGhpcy50aW1lb3V0ID0gdGhpcy5zb2NrZXQudGltZW91dFxuICAgIHRoaXMuam9pbmVkT25jZSA9IGZhbHNlXG4gICAgdGhpcy5qb2luUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmpvaW4sIHRoaXMucGFyYW1zLCB0aGlzLnRpbWVvdXQpXG4gICAgdGhpcy5wdXNoQnVmZmVyID0gW11cbiAgICB0aGlzLnN0YXRlQ2hhbmdlUmVmcyA9IFtdXG5cbiAgICB0aGlzLnJlam9pblRpbWVyID0gbmV3IFRpbWVyKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pbigpIH1cbiAgICB9LCB0aGlzLnNvY2tldC5yZWpvaW5BZnRlck1zKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25FcnJvcigoKSA9PiB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCkpKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VSZWZzLnB1c2godGhpcy5zb2NrZXQub25PcGVuKCgpID0+IHtcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgaWYodGhpcy5pc0Vycm9yZWQoKSl7IHRoaXMucmVqb2luKCkgfVxuICAgIH0pXG4gICAgKVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5qb2luZWRcbiAgICAgIHRoaXMucmVqb2luVGltZXIucmVzZXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2gocHVzaEV2ZW50ID0+IHB1c2hFdmVudC5zZW5kKCkpXG4gICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXVxuICAgIH0pXG4gICAgdGhpcy5qb2luUHVzaC5yZWNlaXZlKFwiZXJyb3JcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMub25DbG9zZSgoKSA9PiB7XG4gICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KClcbiAgICAgIGlmKHRoaXMuc29ja2V0Lmhhc0xvZ2dlcigpKSB0aGlzLnNvY2tldC5sb2coXCJjaGFubmVsXCIsIGBjbG9zZSAke3RoaXMudG9waWN9ICR7dGhpcy5qb2luUmVmKCl9YClcbiAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5jbG9zZWRcbiAgICAgIHRoaXMuc29ja2V0LnJlbW92ZSh0aGlzKVxuICAgIH0pXG4gICAgdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbilcbiAgICAgIGlmKHRoaXMuaXNKb2luaW5nKCkpeyB0aGlzLmpvaW5QdXNoLnJlc2V0KCkgfVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIGlmKHRoaXMuc29ja2V0LmlzQ29ubmVjdGVkKCkpeyB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpIH1cbiAgICB9KVxuICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4ge1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgYHRpbWVvdXQgJHt0aGlzLnRvcGljfSAoJHt0aGlzLmpvaW5SZWYoKX0pYCwgdGhpcy5qb2luUHVzaC50aW1lb3V0KVxuICAgICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGhpcy50aW1lb3V0KVxuICAgICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWRcbiAgICAgIHRoaXMuam9pblB1c2gucmVzZXQoKVxuICAgICAgaWYodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSl7IHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCkgfVxuICAgIH0pXG4gICAgdGhpcy5vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwgKHBheWxvYWQsIHJlZikgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyKHRoaXMucmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEpvaW4gdGhlIGNoYW5uZWxcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBpZih0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gam9pbiBtdWx0aXBsZSB0aW1lcy4gJ2pvaW4nIGNhbiBvbmx5IGJlIGNhbGxlZCBhIHNpbmdsZSB0aW1lIHBlciBjaGFubmVsIGluc3RhbmNlXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXRcbiAgICAgIHRoaXMuam9pbmVkT25jZSA9IHRydWVcbiAgICAgIHRoaXMucmVqb2luKClcbiAgICAgIHJldHVybiB0aGlzLmpvaW5QdXNoXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhvb2sgaW50byBjaGFubmVsIGNsb3NlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbkNsb3NlKGNhbGxiYWNrKXtcbiAgICB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmNsb3NlLCBjYWxsYmFjaylcbiAgfVxuXG4gIC8qKlxuICAgKiBIb29rIGludG8gY2hhbm5lbCBlcnJvcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uRXJyb3IoY2FsbGJhY2spe1xuICAgIHJldHVybiB0aGlzLm9uKENIQU5ORUxfRVZFTlRTLmVycm9yLCByZWFzb24gPT4gY2FsbGJhY2socmVhc29uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIG9uIGNoYW5uZWwgZXZlbnRzXG4gICAqXG4gICAqIFN1YnNjcmlwdGlvbiByZXR1cm5zIGEgcmVmIGNvdW50ZXIsIHdoaWNoIGNhbiBiZSB1c2VkIGxhdGVyIHRvXG4gICAqIHVuc3Vic2NyaWJlIHRoZSBleGFjdCBldmVudCBsaXN0ZW5lclxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjb25zdCByZWYyID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX290aGVyX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqIC8vIFNpbmNlIHVuc3Vic2NyaXB0aW9uLCBkb19zdHVmZiB3b24ndCBmaXJlLFxuICAgKiAvLyB3aGlsZSBkb19vdGhlcl9zdHVmZiB3aWxsIGtlZXAgZmlyaW5nIG9uIHRoZSBcImV2ZW50XCJcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfSByZWZcbiAgICovXG4gIG9uKGV2ZW50LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMuYmluZGluZ1JlZisrXG4gICAgdGhpcy5iaW5kaW5ncy5wdXNoKHtldmVudCwgcmVmLCBjYWxsYmFja30pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlcyBvZmYgb2YgY2hhbm5lbCBldmVudHNcbiAgICpcbiAgICogVXNlIHRoZSByZWYgcmV0dXJuZWQgZnJvbSBhIGNoYW5uZWwub24oKSB0byB1bnN1YnNjcmliZSBvbmVcbiAgICogaGFuZGxlciwgb3IgcGFzcyBub3RoaW5nIGZvciB0aGUgcmVmIHRvIHVuc3Vic2NyaWJlIGFsbFxuICAgKiBoYW5kbGVycyBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBVbnN1YnNjcmliZSB0aGUgZG9fc3R1ZmYgaGFuZGxlclxuICAgKiBjb25zdCByZWYxID0gY2hhbm5lbC5vbihcImV2ZW50XCIsIGRvX3N0dWZmKVxuICAgKiBjaGFubmVsLm9mZihcImV2ZW50XCIsIHJlZjEpXG4gICAqXG4gICAqIC8vIFVuc3Vic2NyaWJlIGFsbCBoYW5kbGVycyBmcm9tIGV2ZW50XG4gICAqIGNoYW5uZWwub2ZmKFwiZXZlbnRcIilcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7aW50ZWdlcn0gcmVmXG4gICAqL1xuICBvZmYoZXZlbnQsIHJlZil7XG4gICAgdGhpcy5iaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICByZXR1cm4gIShiaW5kLmV2ZW50ID09PSBldmVudCAmJiAodHlwZW9mIHJlZiA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZWYgPT09IGJpbmQucmVmKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYW5QdXNoKCl7IHJldHVybiB0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuaXNKb2luZWQoKSB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSBgZXZlbnRgIHRvIHBob2VuaXggd2l0aCB0aGUgcGF5bG9hZCBgcGF5bG9hZGAuXG4gICAqIFBob2VuaXggcmVjZWl2ZXMgdGhpcyBpbiB0aGUgYGhhbmRsZV9pbihldmVudCwgcGF5bG9hZCwgc29ja2V0KWBcbiAgICogZnVuY3Rpb24uIGlmIHBob2VuaXggcmVwbGllcyBvciBpdCB0aW1lcyBvdXQgKGRlZmF1bHQgMTAwMDBtcyksXG4gICAqIHRoZW4gb3B0aW9uYWxseSB0aGUgcmVwbHkgY2FuIGJlIHJlY2VpdmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjaGFubmVsLnB1c2goXCJldmVudFwiKVxuICAgKiAgIC5yZWNlaXZlKFwib2tcIiwgcGF5bG9hZCA9PiBjb25zb2xlLmxvZyhcInBob2VuaXggcmVwbGllZDpcIiwgcGF5bG9hZCkpXG4gICAqICAgLnJlY2VpdmUoXCJlcnJvclwiLCBlcnIgPT4gY29uc29sZS5sb2coXCJwaG9lbml4IGVycm9yZWRcIiwgZXJyKSlcbiAgICogICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gY29uc29sZS5sb2coXCJ0aW1lZCBvdXQgcHVzaGluZ1wiKSlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dF1cbiAgICogQHJldHVybnMge1B1c2h9XG4gICAqL1xuICBwdXNoKGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0KXtcbiAgICBwYXlsb2FkID0gcGF5bG9hZCB8fCB7fVxuICAgIGlmKCF0aGlzLmpvaW5lZE9uY2Upe1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5qb2luKCkgYmVmb3JlIHB1c2hpbmcgZXZlbnRzYClcbiAgICB9XG4gICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBmdW5jdGlvbiAoKXsgcmV0dXJuIHBheWxvYWQgfSwgdGltZW91dClcbiAgICBpZih0aGlzLmNhblB1c2goKSl7XG4gICAgICBwdXNoRXZlbnQuc2VuZCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hFdmVudC5zdGFydFRpbWVvdXQoKVxuICAgICAgdGhpcy5wdXNoQnVmZmVyLnB1c2gocHVzaEV2ZW50KVxuICAgIH1cblxuICAgIHJldHVybiBwdXNoRXZlbnRcbiAgfVxuXG4gIC8qKiBMZWF2ZXMgdGhlIGNoYW5uZWxcbiAgICpcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kXG4gICAqIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXJcbiAgICpcbiAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzXG4gICAqXG4gICAqIFRvIHJlY2VpdmUgbGVhdmUgYWNrbm93bGVkZ2VtZW50cywgdXNlIHRoZSBgcmVjZWl2ZWBcbiAgICogaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY2hhbm5lbC5sZWF2ZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICpcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSB0aW1lb3V0XG4gICAqIEByZXR1cm5zIHtQdXNofVxuICAgKi9cbiAgbGVhdmUodGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpXG4gICAgdGhpcy5qb2luUHVzaC5jYW5jZWxUaW1lb3V0KClcblxuICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nXG4gICAgbGV0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZih0aGlzLnNvY2tldC5oYXNMb2dnZXIoKSkgdGhpcy5zb2NrZXQubG9nKFwiY2hhbm5lbFwiLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApXG4gICAgICB0aGlzLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIFwibGVhdmVcIilcbiAgICB9XG4gICAgbGV0IGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCBjbG9zdXJlKHt9KSwgdGltZW91dClcbiAgICBsZWF2ZVB1c2gucmVjZWl2ZShcIm9rXCIsICgpID0+IG9uQ2xvc2UoKSlcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCAoKSA9PiBvbkNsb3NlKCkpXG4gICAgbGVhdmVQdXNoLnNlbmQoKVxuICAgIGlmKCF0aGlzLmNhblB1c2goKSl7IGxlYXZlUHVzaC50cmlnZ2VyKFwib2tcIiwge30pIH1cblxuICAgIHJldHVybiBsZWF2ZVB1c2hcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICpcbiAgICogUmVjZWl2ZXMgYWxsIGV2ZW50cyBmb3Igc3BlY2lhbGl6ZWQgbWVzc2FnZSBoYW5kbGluZ1xuICAgKiBiZWZvcmUgZGlzcGF0Y2hpbmcgdG8gdGhlIGNoYW5uZWwgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAgICogQHBhcmFtIHtpbnRlZ2VyfSByZWZcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIG9uTWVzc2FnZShfZXZlbnQsIHBheWxvYWQsIF9yZWYpeyByZXR1cm4gcGF5bG9hZCB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWYpe1xuICAgIGlmKHRoaXMudG9waWMgIT09IHRvcGljKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmKGpvaW5SZWYgJiYgam9pblJlZiAhPT0gdGhpcy5qb2luUmVmKCkpe1xuICAgICAgaWYodGhpcy5zb2NrZXQuaGFzTG9nZ2VyKCkpIHRoaXMuc29ja2V0LmxvZyhcImNoYW5uZWxcIiwgXCJkcm9wcGluZyBvdXRkYXRlZCBtZXNzYWdlXCIsIHt0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5SZWZ9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBqb2luUmVmKCl7IHJldHVybiB0aGlzLmpvaW5QdXNoLnJlZiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWpvaW4odGltZW91dCA9IHRoaXMudGltZW91dCl7XG4gICAgaWYodGhpcy5pc0xlYXZpbmcoKSl7IHJldHVybiB9XG4gICAgdGhpcy5zb2NrZXQubGVhdmVPcGVuVG9waWModGhpcy50b3BpYylcbiAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmluZ1xuICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRyaWdnZXIoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZil7XG4gICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5vbk1lc3NhZ2UoZXZlbnQsIHBheWxvYWQsIHJlZiwgam9pblJlZilcbiAgICBpZihwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCl7IHRocm93IG5ldyBFcnJvcihcImNoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZFwiKSB9XG5cbiAgICBsZXQgZXZlbnRCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MuZmlsdGVyKGJpbmQgPT4gYmluZC5ldmVudCA9PT0gZXZlbnQpXG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZXZlbnRCaW5kaW5ncy5sZW5ndGg7IGkrKyl7XG4gICAgICBsZXQgYmluZCA9IGV2ZW50QmluZGluZ3NbaV1cbiAgICAgIGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZiwgam9pblJlZiB8fCB0aGlzLmpvaW5SZWYoKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlcGx5RXZlbnROYW1lKHJlZil7IHJldHVybiBgY2hhbl9yZXBseV8ke3JlZn1gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzQ2xvc2VkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNFcnJvcmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSm9pbmVkKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNKb2luaW5nKCl7IHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzTGVhdmluZygpeyByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMubGVhdmluZyB9XG59XG4iLCAiaW1wb3J0IHtcbiAgZ2xvYmFsLFxuICBYSFJfU1RBVEVTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFqYXgge1xuXG4gIHN0YXRpYyByZXF1ZXN0KG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgaWYoZ2xvYmFsLlhEb21haW5SZXF1ZXN0KXtcbiAgICAgIGxldCByZXEgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCkgLy8gSUU4LCBJRTlcbiAgICAgIHJldHVybiB0aGlzLnhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlcSA9IG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKSAvLyBJRTcrLCBGaXJlZm94LCBDaHJvbWUsIE9wZXJhLCBTYWZhcmlcbiAgICAgIHJldHVybiB0aGlzLnhoclJlcXVlc3QocmVxLCBtZXRob2QsIGVuZFBvaW50LCBhY2NlcHQsIGJvZHksIHRpbWVvdXQsIG9udGltZW91dCwgY2FsbGJhY2spXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHhkb21haW5SZXF1ZXN0KHJlcSwgbWV0aG9kLCBlbmRQb2ludCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLnRpbWVvdXQgPSB0aW1lb3V0XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludClcbiAgICByZXEub25sb2FkID0gKCkgPT4ge1xuICAgICAgbGV0IHJlc3BvbnNlID0gdGhpcy5wYXJzZUpTT04ocmVxLnJlc3BvbnNlVGV4dClcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgIH1cbiAgICBpZihvbnRpbWVvdXQpeyByZXEub250aW1lb3V0ID0gb250aW1lb3V0IH1cblxuICAgIC8vIFdvcmsgYXJvdW5kIGJ1ZyBpbiBJRTkgdGhhdCByZXF1aXJlcyBhbiBhdHRhY2hlZCBvbnByb2dyZXNzIGhhbmRsZXJcbiAgICByZXEub25wcm9ncmVzcyA9ICgpID0+IHsgfVxuXG4gICAgcmVxLnNlbmQoYm9keSlcbiAgICByZXR1cm4gcmVxXG4gIH1cblxuICBzdGF0aWMgeGhyUmVxdWVzdChyZXEsIG1ldGhvZCwgZW5kUG9pbnQsIGFjY2VwdCwgYm9keSwgdGltZW91dCwgb250aW1lb3V0LCBjYWxsYmFjayl7XG4gICAgcmVxLm9wZW4obWV0aG9kLCBlbmRQb2ludCwgdHJ1ZSlcbiAgICByZXEudGltZW91dCA9IHRpbWVvdXRcbiAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBhY2NlcHQpXG4gICAgcmVxLm9uZXJyb3IgPSAoKSA9PiBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsKVxuICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZihyZXEucmVhZHlTdGF0ZSA9PT0gWEhSX1NUQVRFUy5jb21wbGV0ZSAmJiBjYWxsYmFjayl7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHRoaXMucGFyc2VKU09OKHJlcS5yZXNwb25zZVRleHQpXG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihvbnRpbWVvdXQpeyByZXEub250aW1lb3V0ID0gb250aW1lb3V0IH1cblxuICAgIHJlcS5zZW5kKGJvZHkpXG4gICAgcmV0dXJuIHJlcVxuICB9XG5cbiAgc3RhdGljIHBhcnNlSlNPTihyZXNwKXtcbiAgICBpZighcmVzcCB8fCByZXNwID09PSBcIlwiKXsgcmV0dXJuIG51bGwgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJlc3ApXG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwiZmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcIiwgcmVzcClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHNlcmlhbGl6ZShvYmosIHBhcmVudEtleSl7XG4gICAgbGV0IHF1ZXJ5U3RyID0gW11cbiAgICBmb3IodmFyIGtleSBpbiBvYmope1xuICAgICAgaWYoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpeyBjb250aW51ZSB9XG4gICAgICBsZXQgcGFyYW1LZXkgPSBwYXJlbnRLZXkgPyBgJHtwYXJlbnRLZXl9WyR7a2V5fV1gIDoga2V5XG4gICAgICBsZXQgcGFyYW1WYWwgPSBvYmpba2V5XVxuICAgICAgaWYodHlwZW9mIHBhcmFtVmFsID09PSBcIm9iamVjdFwiKXtcbiAgICAgICAgcXVlcnlTdHIucHVzaCh0aGlzLnNlcmlhbGl6ZShwYXJhbVZhbCwgcGFyYW1LZXkpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnlTdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocGFyYW1LZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1WYWwpKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXVlcnlTdHIuam9pbihcIiZcIilcbiAgfVxuXG4gIHN0YXRpYyBhcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpe1xuICAgIGlmKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKXsgcmV0dXJuIHVybCB9XG5cbiAgICBsZXQgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/IFwiJlwiIDogXCI/XCJcbiAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7dGhpcy5zZXJpYWxpemUocGFyYW1zKX1gXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBTT0NLRVRfU1RBVEVTLFxuICBUUkFOU1BPUlRTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBBamF4IGZyb20gXCIuL2FqYXhcIlxuXG5sZXQgYXJyYXlCdWZmZXJUb0Jhc2U2NCA9IChidWZmZXIpID0+IHtcbiAgbGV0IGJpbmFyeSA9IFwiXCJcbiAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICBsZXQgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aFxuICBmb3IobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspeyBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkgfVxuICByZXR1cm4gYnRvYShiaW5hcnkpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExvbmdQb2xsIHtcblxuICBjb25zdHJ1Y3RvcihlbmRQb2ludCl7XG4gICAgdGhpcy5lbmRQb2ludCA9IG51bGxcbiAgICB0aGlzLnRva2VuID0gbnVsbFxuICAgIHRoaXMuc2tpcEhlYXJ0YmVhdCA9IHRydWVcbiAgICB0aGlzLnJlcXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLmF3YWl0aW5nQmF0Y2hBY2sgPSBmYWxzZVxuICAgIHRoaXMuY3VycmVudEJhdGNoID0gbnVsbFxuICAgIHRoaXMuY3VycmVudEJhdGNoVGltZXIgPSBudWxsXG4gICAgdGhpcy5iYXRjaEJ1ZmZlciA9IFtdXG4gICAgdGhpcy5vbm9wZW4gPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgdGhpcy5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgIHRoaXMub25jbG9zZSA9IGZ1bmN0aW9uICgpeyB9IC8vIG5vb3BcbiAgICB0aGlzLnBvbGxFbmRwb2ludCA9IHRoaXMubm9ybWFsaXplRW5kcG9pbnQoZW5kUG9pbnQpXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gICAgLy8gd2UgbXVzdCB3YWl0IGZvciB0aGUgY2FsbGVyIHRvIGZpbmlzaCBzZXR0aW5nIHVwIG91ciBjYWxsYmFja3MgYW5kIHRpbWVvdXQgcHJvcGVydGllc1xuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wb2xsKCksIDApXG4gIH1cblxuICBub3JtYWxpemVFbmRwb2ludChlbmRQb2ludCl7XG4gICAgcmV0dXJuIChlbmRQb2ludFxuICAgICAgLnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIilcbiAgICAgIC5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIilcbiAgICAgIC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoLiopXFwvXCIgKyBUUkFOU1BPUlRTLndlYnNvY2tldCksIFwiJDEvXCIgKyBUUkFOU1BPUlRTLmxvbmdwb2xsKSlcbiAgfVxuXG4gIGVuZHBvaW50VVJMKCl7XG4gICAgcmV0dXJuIEFqYXguYXBwZW5kUGFyYW1zKHRoaXMucG9sbEVuZHBvaW50LCB7dG9rZW46IHRoaXMudG9rZW59KVxuICB9XG5cbiAgY2xvc2VBbmRSZXRyeShjb2RlLCByZWFzb24sIHdhc0NsZWFuKXtcbiAgICB0aGlzLmNsb3NlKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5jb25uZWN0aW5nXG4gIH1cblxuICBvbnRpbWVvdXQoKXtcbiAgICB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpXG4gICAgdGhpcy5jbG9zZUFuZFJldHJ5KDEwMDUsIFwidGltZW91dFwiLCBmYWxzZSlcbiAgfVxuXG4gIGlzQWN0aXZlKCl7IHJldHVybiB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMub3BlbiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZyB9XG5cbiAgcG9sbCgpe1xuICAgIHRoaXMuYWpheChcIkdFVFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIiwgbnVsbCwgKCkgPT4gdGhpcy5vbnRpbWVvdXQoKSwgcmVzcCA9PiB7XG4gICAgICBpZihyZXNwKXtcbiAgICAgICAgdmFyIHtzdGF0dXMsIHRva2VuLCBtZXNzYWdlc30gPSByZXNwXG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzID0gMFxuICAgICAgfVxuXG4gICAgICBzd2l0Y2goc3RhdHVzKXtcbiAgICAgICAgY2FzZSAyMDA6XG4gICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgLy8gVGFza3MgYXJlIHdoYXQgdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIHNldFRpbWVvdXQgY2FsbGJhY2tzLFxuICAgICAgICAgICAgLy8gcHJvbWlzZSByZXNvbHZlcyBhbmQgbW9yZSBhcmUgcnVuIHdpdGhpbi5cbiAgICAgICAgICAgIC8vIEluIG1vZGVybiBicm93c2VycywgdGhlcmUgYXJlIHR3byBkaWZmZXJlbnQga2luZHMgb2YgdGFza3MsXG4gICAgICAgICAgICAvLyBtaWNyb3Rhc2tzIGFuZCBtYWNyb3Rhc2tzLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhcmUgbWFpbmx5IHVzZWQgZm9yIFByb21pc2VzLCB3aGlsZSBtYWNyb3Rhc2tzIGFyZVxuICAgICAgICAgICAgLy8gdXNlZCBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICAgICAgLy8gTWljcm90YXNrcyBhbHdheXMgaGF2ZSBwcmlvcml0eSBvdmVyIG1hY3JvdGFza3MuIElmIHRoZSBKUyBlbmdpbmVcbiAgICAgICAgICAgIC8vIGlzIGxvb2tpbmcgZm9yIGEgdGFzayB0byBydW4sIGl0IHdpbGwgYWx3YXlzIHRyeSB0byBlbXB0eSB0aGVcbiAgICAgICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBydW4gYW55dGhpbmcgZnJvbSB0aGVcbiAgICAgICAgICAgIC8vIG1hY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgdGhlIFdlYlNvY2tldCB0cmFuc3BvcnQsIG1lc3NhZ2VzIGFsd2F5cyBhcnJpdmUgaW4gdGhlaXIgb3duXG4gICAgICAgICAgICAvLyBldmVudC4gVGhpcyBtZWFucyB0aGF0IGlmIGFueSBwcm9taXNlcyBhcmUgcmVzb2x2ZWQgZnJvbSB3aXRoaW4sXG4gICAgICAgICAgICAvLyB0aGVpciBjYWxsYmFja3Mgd2lsbCBhbHdheXMgZmluaXNoIGV4ZWN1dGlvbiBieSB0aGUgdGltZSB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgbWVzc2FnZSBldmVudCBoYW5kbGVyIGlzIHJ1bi5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBlbXVsYXRlIHRoaXMgYmVoYXZpb3VyLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSBlYWNoXG4gICAgICAgICAgICAvLyBvbm1lc3NhZ2UgaGFuZGxlciBpcyBydW4gd2l0aGluIGl0cyBvd24gbWFjcm90YXNrLlxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLm9ubWVzc2FnZSh7ZGF0YTogbXNnfSksIDApXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLnBvbGwoKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgIHRoaXMucG9sbCgpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0MTA6XG4gICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gU09DS0VUX1NUQVRFUy5vcGVuXG4gICAgICAgICAgdGhpcy5vbm9wZW4oe30pXG4gICAgICAgICAgdGhpcy5wb2xsKClcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNDAzKVxuICAgICAgICAgIHRoaXMuY2xvc2UoMTAwOCwgXCJmb3JiaWRkZW5cIiwgZmFsc2UpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICB0aGlzLm9uZXJyb3IoNTAwKVxuICAgICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCA1MDApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGB1bmhhbmRsZWQgcG9sbCBzdGF0dXMgJHtzdGF0dXN9YClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gd2UgY29sbGVjdCBhbGwgcHVzaGVzIHdpdGhpbiB0aGUgY3VycmVudCBldmVudCBsb29wIGJ5XG4gIC8vIHNldFRpbWVvdXQgMCwgd2hpY2ggb3B0aW1pemVzIGJhY2stdG8tYmFjayBwcm9jZWR1cmFsXG4gIC8vIHB1c2hlcyBhZ2FpbnN0IGFuIGVtcHR5IGJ1ZmZlclxuXG4gIHNlbmQoYm9keSl7XG4gICAgaWYodHlwZW9mKGJvZHkpICE9PSBcInN0cmluZ1wiKXsgYm9keSA9IGFycmF5QnVmZmVyVG9CYXNlNjQoYm9keSkgfVxuICAgIGlmKHRoaXMuY3VycmVudEJhdGNoKXtcbiAgICAgIHRoaXMuY3VycmVudEJhdGNoLnB1c2goYm9keSlcbiAgICB9IGVsc2UgaWYodGhpcy5hd2FpdGluZ0JhdGNoQWNrKXtcbiAgICAgIHRoaXMuYmF0Y2hCdWZmZXIucHVzaChib2R5KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN1cnJlbnRCYXRjaCA9IFtib2R5XVxuICAgICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmJhdGNoU2VuZCh0aGlzLmN1cnJlbnRCYXRjaClcbiAgICAgICAgdGhpcy5jdXJyZW50QmF0Y2ggPSBudWxsXG4gICAgICB9LCAwKVxuICAgIH1cbiAgfVxuXG4gIGJhdGNoU2VuZChtZXNzYWdlcyl7XG4gICAgdGhpcy5hd2FpdGluZ0JhdGNoQWNrID0gdHJ1ZVxuICAgIHRoaXMuYWpheChcIlBPU1RcIiwgXCJhcHBsaWNhdGlvbi94LW5kanNvblwiLCBtZXNzYWdlcy5qb2luKFwiXFxuXCIpLCAoKSA9PiB0aGlzLm9uZXJyb3IoXCJ0aW1lb3V0XCIpLCByZXNwID0+IHtcbiAgICAgIHRoaXMuYXdhaXRpbmdCYXRjaEFjayA9IGZhbHNlXG4gICAgICBpZighcmVzcCB8fCByZXNwLnN0YXR1cyAhPT0gMjAwKXtcbiAgICAgICAgdGhpcy5vbmVycm9yKHJlc3AgJiYgcmVzcC5zdGF0dXMpXG4gICAgICAgIHRoaXMuY2xvc2VBbmRSZXRyeSgxMDExLCBcImludGVybmFsIHNlcnZlciBlcnJvclwiLCBmYWxzZSlcbiAgICAgIH0gZWxzZSBpZih0aGlzLmJhdGNoQnVmZmVyLmxlbmd0aCA+IDApe1xuICAgICAgICB0aGlzLmJhdGNoU2VuZCh0aGlzLmJhdGNoQnVmZmVyKVxuICAgICAgICB0aGlzLmJhdGNoQnVmZmVyID0gW11cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgY2xvc2UoY29kZSwgcmVhc29uLCB3YXNDbGVhbil7XG4gICAgZm9yKGxldCByZXEgb2YgdGhpcy5yZXFzKXsgcmVxLmFib3J0KCkgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNPQ0tFVF9TVEFURVMuY2xvc2VkXG4gICAgbGV0IG9wdHMgPSBPYmplY3QuYXNzaWduKHtjb2RlOiAxMDAwLCByZWFzb246IHVuZGVmaW5lZCwgd2FzQ2xlYW46IHRydWV9LCB7Y29kZSwgcmVhc29uLCB3YXNDbGVhbn0pXG4gICAgdGhpcy5iYXRjaEJ1ZmZlciA9IFtdXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudEJhdGNoVGltZXIpXG4gICAgdGhpcy5jdXJyZW50QmF0Y2hUaW1lciA9IG51bGxcbiAgICBpZih0eXBlb2YoQ2xvc2VFdmVudCkgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgdGhpcy5vbmNsb3NlKG5ldyBDbG9zZUV2ZW50KFwiY2xvc2VcIiwgb3B0cykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25jbG9zZShvcHRzKVxuICAgIH1cbiAgfVxuXG4gIGFqYXgobWV0aG9kLCBjb250ZW50VHlwZSwgYm9keSwgb25DYWxsZXJUaW1lb3V0LCBjYWxsYmFjayl7XG4gICAgbGV0IHJlcVxuICAgIGxldCBvbnRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlcXMuZGVsZXRlKHJlcSlcbiAgICAgIG9uQ2FsbGVyVGltZW91dCgpXG4gICAgfVxuICAgIHJlcSA9IEFqYXgucmVxdWVzdChtZXRob2QsIHRoaXMuZW5kcG9pbnRVUkwoKSwgY29udGVudFR5cGUsIGJvZHksIHRoaXMudGltZW91dCwgb250aW1lb3V0LCByZXNwID0+IHtcbiAgICAgIHRoaXMucmVxcy5kZWxldGUocmVxKVxuICAgICAgaWYodGhpcy5pc0FjdGl2ZSgpKXsgY2FsbGJhY2socmVzcCkgfVxuICAgIH0pXG4gICAgdGhpcy5yZXFzLmFkZChyZXEpXG4gIH1cbn1cbiIsICIvKipcbiAqIEluaXRpYWxpemVzIHRoZSBQcmVzZW5jZVxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsIC0gVGhlIENoYW5uZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIG9wdGlvbnMsXG4gKiAgICAgICAgZm9yIGV4YW1wbGUgYHtldmVudHM6IHtzdGF0ZTogXCJzdGF0ZVwiLCBkaWZmOiBcImRpZmZcIn19YFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVzZW5jZSB7XG5cbiAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0cyA9IHt9KXtcbiAgICBsZXQgZXZlbnRzID0gb3B0cy5ldmVudHMgfHwge3N0YXRlOiBcInByZXNlbmNlX3N0YXRlXCIsIGRpZmY6IFwicHJlc2VuY2VfZGlmZlwifVxuICAgIHRoaXMuc3RhdGUgPSB7fVxuICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsXG4gICAgdGhpcy5qb2luUmVmID0gbnVsbFxuICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgb25Kb2luOiBmdW5jdGlvbiAoKXsgfSxcbiAgICAgIG9uTGVhdmU6IGZ1bmN0aW9uICgpeyB9LFxuICAgICAgb25TeW5jOiBmdW5jdGlvbiAoKXsgfVxuICAgIH1cblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuc3RhdGUsIG5ld1N0YXRlID0+IHtcbiAgICAgIGxldCB7b25Kb2luLCBvbkxlYXZlLCBvblN5bmN9ID0gdGhpcy5jYWxsZXJcblxuICAgICAgdGhpcy5qb2luUmVmID0gdGhpcy5jaGFubmVsLmpvaW5SZWYoKVxuICAgICAgdGhpcy5zdGF0ZSA9IFByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKVxuXG4gICAgICB0aGlzLnBlbmRpbmdEaWZmcy5mb3JFYWNoKGRpZmYgPT4ge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0RpZmZzID0gW11cbiAgICAgIG9uU3luYygpXG4gICAgfSlcblxuICAgIHRoaXMuY2hhbm5lbC5vbihldmVudHMuZGlmZiwgZGlmZiA9PiB7XG4gICAgICBsZXQge29uSm9pbiwgb25MZWF2ZSwgb25TeW5jfSA9IHRoaXMuY2FsbGVyXG5cbiAgICAgIGlmKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpe1xuICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXRlID0gUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKVxuICAgICAgICBvblN5bmMoKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW4oY2FsbGJhY2speyB0aGlzLmNhbGxlci5vbkpvaW4gPSBjYWxsYmFjayB9XG5cbiAgb25MZWF2ZShjYWxsYmFjayl7IHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjayB9XG5cbiAgb25TeW5jKGNhbGxiYWNrKXsgdGhpcy5jYWxsZXIub25TeW5jID0gY2FsbGJhY2sgfVxuXG4gIGxpc3QoYnkpeyByZXR1cm4gUHJlc2VuY2UubGlzdCh0aGlzLnN0YXRlLCBieSkgfVxuXG4gIGluUGVuZGluZ1N5bmNTdGF0ZSgpe1xuICAgIHJldHVybiAhdGhpcy5qb2luUmVmIHx8ICh0aGlzLmpvaW5SZWYgIT09IHRoaXMuY2hhbm5lbC5qb2luUmVmKCkpXG4gIH1cblxuICAvLyBsb3dlci1sZXZlbCBwdWJsaWMgc3RhdGljIEFQSVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHN5bmMgdGhlIGxpc3Qgb2YgcHJlc2VuY2VzIG9uIHRoZSBzZXJ2ZXJcbiAgICogd2l0aCB0aGUgY2xpZW50J3Mgc3RhdGUuIEFuIG9wdGlvbmFsIGBvbkpvaW5gIGFuZCBgb25MZWF2ZWAgY2FsbGJhY2sgY2FuXG4gICAqIGJlIHByb3ZpZGVkIHRvIHJlYWN0IHRvIGNoYW5nZXMgaW4gdGhlIGNsaWVudCdzIGxvY2FsIHByZXNlbmNlcyBhY3Jvc3NcbiAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY1N0YXRlKGN1cnJlbnRTdGF0ZSwgbmV3U3RhdGUsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5jbG9uZShjdXJyZW50U3RhdGUpXG4gICAgbGV0IGpvaW5zID0ge31cbiAgICBsZXQgbGVhdmVzID0ge31cblxuICAgIHRoaXMubWFwKHN0YXRlLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgaWYoIW5ld1N0YXRlW2tleV0pe1xuICAgICAgICBsZWF2ZXNba2V5XSA9IHByZXNlbmNlXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLm1hcChuZXdTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2UpID0+IHtcbiAgICAgIGxldCBjdXJyZW50UHJlc2VuY2UgPSBzdGF0ZVtrZXldXG4gICAgICBpZihjdXJyZW50UHJlc2VuY2Upe1xuICAgICAgICBsZXQgbmV3UmVmcyA9IG5ld1ByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1clJlZnMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMubWFwKG0gPT4gbS5waHhfcmVmKVxuICAgICAgICBsZXQgam9pbmVkTWV0YXMgPSBuZXdQcmVzZW5jZS5tZXRhcy5maWx0ZXIobSA9PiBjdXJSZWZzLmluZGV4T2YobS5waHhfcmVmKSA8IDApXG4gICAgICAgIGxldCBsZWZ0TWV0YXMgPSBjdXJyZW50UHJlc2VuY2UubWV0YXMuZmlsdGVyKG0gPT4gbmV3UmVmcy5pbmRleE9mKG0ucGh4X3JlZikgPCAwKVxuICAgICAgICBpZihqb2luZWRNZXRhcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgICAgICBqb2luc1trZXldLm1ldGFzID0gam9pbmVkTWV0YXNcbiAgICAgICAgfVxuICAgICAgICBpZihsZWZ0TWV0YXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgbGVhdmVzW2tleV0gPSB0aGlzLmNsb25lKGN1cnJlbnRQcmVzZW5jZSlcbiAgICAgICAgICBsZWF2ZXNba2V5XS5tZXRhcyA9IGxlZnRNZXRhc1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBqb2luc1trZXldID0gbmV3UHJlc2VuY2VcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7am9pbnM6IGpvaW5zLCBsZWF2ZXM6IGxlYXZlc30sIG9uSm9pbiwgb25MZWF2ZSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBVc2VkIHRvIHN5bmMgYSBkaWZmIG9mIHByZXNlbmNlIGpvaW4gYW5kIGxlYXZlXG4gICAqIGV2ZW50cyBmcm9tIHRoZSBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLiBMaWtlIGBzeW5jU3RhdGVgLCBgc3luY0RpZmZgXG4gICAqIGFjY2VwdHMgb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyXG4gICAqIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGEgZGV2aWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJlc2VuY2V9XG4gICAqL1xuICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSl7XG4gICAgbGV0IHtqb2lucywgbGVhdmVzfSA9IHRoaXMuY2xvbmUoZGlmZilcbiAgICBpZighb25Kb2luKXsgb25Kb2luID0gZnVuY3Rpb24gKCl7IH0gfVxuICAgIGlmKCFvbkxlYXZlKXsgb25MZWF2ZSA9IGZ1bmN0aW9uICgpeyB9IH1cblxuICAgIHRoaXMubWFwKGpvaW5zLCAoa2V5LCBuZXdQcmVzZW5jZSkgPT4ge1xuICAgICAgbGV0IGN1cnJlbnRQcmVzZW5jZSA9IHN0YXRlW2tleV1cbiAgICAgIHN0YXRlW2tleV0gPSB0aGlzLmNsb25lKG5ld1ByZXNlbmNlKVxuICAgICAgaWYoY3VycmVudFByZXNlbmNlKXtcbiAgICAgICAgbGV0IGpvaW5lZFJlZnMgPSBzdGF0ZVtrZXldLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgICAgbGV0IGN1ck1ldGFzID0gY3VycmVudFByZXNlbmNlLm1ldGFzLmZpbHRlcihtID0+IGpvaW5lZFJlZnMuaW5kZXhPZihtLnBoeF9yZWYpIDwgMClcbiAgICAgICAgc3RhdGVba2V5XS5tZXRhcy51bnNoaWZ0KC4uLmN1ck1ldGFzKVxuICAgICAgfVxuICAgICAgb25Kb2luKGtleSwgY3VycmVudFByZXNlbmNlLCBuZXdQcmVzZW5jZSlcbiAgICB9KVxuICAgIHRoaXMubWFwKGxlYXZlcywgKGtleSwgbGVmdFByZXNlbmNlKSA9PiB7XG4gICAgICBsZXQgY3VycmVudFByZXNlbmNlID0gc3RhdGVba2V5XVxuICAgICAgaWYoIWN1cnJlbnRQcmVzZW5jZSl7IHJldHVybiB9XG4gICAgICBsZXQgcmVmc1RvUmVtb3ZlID0gbGVmdFByZXNlbmNlLm1ldGFzLm1hcChtID0+IG0ucGh4X3JlZilcbiAgICAgIGN1cnJlbnRQcmVzZW5jZS5tZXRhcyA9IGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5maWx0ZXIocCA9PiB7XG4gICAgICAgIHJldHVybiByZWZzVG9SZW1vdmUuaW5kZXhPZihwLnBoeF9yZWYpIDwgMFxuICAgICAgfSlcbiAgICAgIG9uTGVhdmUoa2V5LCBjdXJyZW50UHJlc2VuY2UsIGxlZnRQcmVzZW5jZSlcbiAgICAgIGlmKGN1cnJlbnRQcmVzZW5jZS5tZXRhcy5sZW5ndGggPT09IDApe1xuICAgICAgICBkZWxldGUgc3RhdGVba2V5XVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJlc2VuY2VzLCB3aXRoIHNlbGVjdGVkIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJlc2VuY2VzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNob29zZXJcbiAgICpcbiAgICogQHJldHVybnMge1ByZXNlbmNlfVxuICAgKi9cbiAgc3RhdGljIGxpc3QocHJlc2VuY2VzLCBjaG9vc2VyKXtcbiAgICBpZighY2hvb3Nlcil7IGNob29zZXIgPSBmdW5jdGlvbiAoa2V5LCBwcmVzKXsgcmV0dXJuIHByZXMgfSB9XG5cbiAgICByZXR1cm4gdGhpcy5tYXAocHJlc2VuY2VzLCAoa2V5LCBwcmVzZW5jZSkgPT4ge1xuICAgICAgcmV0dXJuIGNob29zZXIoa2V5LCBwcmVzZW5jZSlcbiAgICB9KVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIHN0YXRpYyBtYXAob2JqLCBmdW5jKXtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoa2V5ID0+IGZ1bmMoa2V5LCBvYmpba2V5XSkpXG4gIH1cblxuICBzdGF0aWMgY2xvbmUob2JqKXsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxufVxuIiwgIi8qIFRoZSBkZWZhdWx0IHNlcmlhbGl6ZXIgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBtZXNzYWdlcyAqL1xuaW1wb3J0IHtcbiAgQ0hBTk5FTF9FVkVOVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuZXhwb3J0IGRlZmF1bHQge1xuICBIRUFERVJfTEVOR1RIOiAxLFxuICBNRVRBX0xFTkdUSDogNCxcbiAgS0lORFM6IHtwdXNoOiAwLCByZXBseTogMSwgYnJvYWRjYXN0OiAyfSxcblxuICBlbmNvZGUobXNnLCBjYWxsYmFjayl7XG4gICAgaWYobXNnLnBheWxvYWQuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKXtcbiAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLmJpbmFyeUVuY29kZShtc2cpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGF5bG9hZCA9IFttc2cuam9pbl9yZWYsIG1zZy5yZWYsIG1zZy50b3BpYywgbXNnLmV2ZW50LCBtc2cucGF5bG9hZF1cbiAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICB9XG4gIH0sXG5cbiAgZGVjb2RlKHJhd1BheWxvYWQsIGNhbGxiYWNrKXtcbiAgICBpZihyYXdQYXlsb2FkLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcil7XG4gICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IEpTT04ucGFyc2UocmF3UGF5bG9hZClcbiAgICAgIHJldHVybiBjYWxsYmFjayh7am9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkfSlcbiAgICB9XG4gIH0sXG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGJpbmFyeUVuY29kZShtZXNzYWdlKXtcbiAgICBsZXQge2pvaW5fcmVmLCByZWYsIGV2ZW50LCB0b3BpYywgcGF5bG9hZH0gPSBtZXNzYWdlXG4gICAgbGV0IG1ldGFMZW5ndGggPSB0aGlzLk1FVEFfTEVOR1RIICsgam9pbl9yZWYubGVuZ3RoICsgcmVmLmxlbmd0aCArIHRvcGljLmxlbmd0aCArIGV2ZW50Lmxlbmd0aFxuICAgIGxldCBoZWFkZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5IRUFERVJfTEVOR1RIICsgbWV0YUxlbmd0aClcbiAgICBsZXQgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIpXG4gICAgbGV0IG9mZnNldCA9IDBcblxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMucHVzaCkgLy8ga2luZFxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5fcmVmLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCByZWYubGVuZ3RoKVxuICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRvcGljLmxlbmd0aClcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBldmVudC5sZW5ndGgpXG4gICAgQXJyYXkuZnJvbShqb2luX3JlZiwgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20ocmVmLCBjaGFyID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpXG4gICAgQXJyYXkuZnJvbSh0b3BpYywgY2hhciA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKVxuICAgIEFycmF5LmZyb20oZXZlbnQsIGNoYXIgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSlcblxuICAgIHZhciBjb21iaW5lZCA9IG5ldyBVaW50OEFycmF5KGhlYWRlci5ieXRlTGVuZ3RoICsgcGF5bG9hZC5ieXRlTGVuZ3RoKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShoZWFkZXIpLCAwKVxuICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShwYXlsb2FkKSwgaGVhZGVyLmJ5dGVMZW5ndGgpXG5cbiAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyXG4gIH0sXG5cbiAgYmluYXJ5RGVjb2RlKGJ1ZmZlcil7XG4gICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKVxuICAgIGxldCBraW5kID0gdmlldy5nZXRVaW50OCgwKVxuICAgIGxldCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbiAgICBzd2l0Y2goa2luZCl7XG4gICAgICBjYXNlIHRoaXMuS0lORFMucHVzaDogcmV0dXJuIHRoaXMuZGVjb2RlUHVzaChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgICBjYXNlIHRoaXMuS0lORFMucmVwbHk6IHJldHVybiB0aGlzLmRlY29kZVJlcGx5KGJ1ZmZlciwgdmlldywgZGVjb2RlcilcbiAgICAgIGNhc2UgdGhpcy5LSU5EUy5icm9hZGNhc3Q6IHJldHVybiB0aGlzLmRlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpXG4gICAgfVxuICB9LFxuXG4gIGRlY29kZVB1c2goYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMilcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgzKVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIIC0gMSAvLyBwdXNoZXMgaGF2ZSBubyByZWZcbiAgICBsZXQgam9pblJlZiA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGpvaW5SZWZTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBqb2luUmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH0sXG5cbiAgZGVjb2RlUmVwbHkoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgam9pblJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDEpXG4gICAgbGV0IHJlZlNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IHRvcGljU2l6ZSA9IHZpZXcuZ2V0VWludDgoMylcbiAgICBsZXQgZXZlbnRTaXplID0gdmlldy5nZXRVaW50OCg0KVxuICAgIGxldCBvZmZzZXQgPSB0aGlzLkhFQURFUl9MRU5HVEggKyB0aGlzLk1FVEFfTEVOR1RIXG4gICAgbGV0IGpvaW5SZWYgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBqb2luUmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgam9pblJlZlNpemVcbiAgICBsZXQgcmVmID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgcmVmU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgcmVmU2l6ZVxuICAgIGxldCB0b3BpYyA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIHRvcGljU2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplXG4gICAgbGV0IGV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZXZlbnRTaXplKSlcbiAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemVcbiAgICBsZXQgZGF0YSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKVxuICAgIGxldCBwYXlsb2FkID0ge3N0YXR1czogZXZlbnQsIHJlc3BvbnNlOiBkYXRhfVxuICAgIHJldHVybiB7am9pbl9yZWY6IGpvaW5SZWYsIHJlZjogcmVmLCB0b3BpYzogdG9waWMsIGV2ZW50OiBDSEFOTkVMX0VWRU5UUy5yZXBseSwgcGF5bG9hZDogcGF5bG9hZH1cbiAgfSxcblxuICBkZWNvZGVCcm9hZGNhc3QoYnVmZmVyLCB2aWV3LCBkZWNvZGVyKXtcbiAgICBsZXQgdG9waWNTaXplID0gdmlldy5nZXRVaW50OCgxKVxuICAgIGxldCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpXG4gICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDJcbiAgICBsZXQgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKVxuICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZVxuICAgIGxldCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ICsgZXZlbnRTaXplXG4gICAgbGV0IGRhdGEgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aClcblxuICAgIHJldHVybiB7am9pbl9yZWY6IG51bGwsIHJlZjogbnVsbCwgdG9waWM6IHRvcGljLCBldmVudDogZXZlbnQsIHBheWxvYWQ6IGRhdGF9XG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBnbG9iYWwsXG4gIHBoeFdpbmRvdyxcbiAgQ0hBTk5FTF9FVkVOVFMsXG4gIERFRkFVTFRfVElNRU9VVCxcbiAgREVGQVVMVF9WU04sXG4gIFNPQ0tFVF9TVEFURVMsXG4gIFRSQU5TUE9SVFMsXG4gIFdTX0NMT1NFX05PUk1BTFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBjbG9zdXJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IEFqYXggZnJvbSBcIi4vYWpheFwiXG5pbXBvcnQgQ2hhbm5lbCBmcm9tIFwiLi9jaGFubmVsXCJcbmltcG9ydCBMb25nUG9sbCBmcm9tIFwiLi9sb25ncG9sbFwiXG5pbXBvcnQgU2VyaWFsaXplciBmcm9tIFwiLi9zZXJpYWxpemVyXCJcbmltcG9ydCBUaW1lciBmcm9tIFwiLi90aW1lclwiXG5cbi8qKiBJbml0aWFsaXplcyB0aGUgU29ja2V0ICpcbiAqXG4gKiBGb3IgSUU4IHN1cHBvcnQgdXNlIGFuIEVTNS1zaGltIChodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9zb2NrZXRcImAgKGluaGVyaXRlZCBob3N0ICYgcHJvdG9jb2wpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMudHJhbnNwb3J0XSAtIFRoZSBXZWJzb2NrZXQgVHJhbnNwb3J0LCBmb3IgZXhhbXBsZSBXZWJTb2NrZXQgb3IgUGhvZW5peC5Mb25nUG9sbC5cbiAqXG4gKiBEZWZhdWx0cyB0byBXZWJTb2NrZXQgd2l0aCBhdXRvbWF0aWMgTG9uZ1BvbGwgZmFsbGJhY2sgaWYgV2ViU29ja2V0IGlzIG5vdCBkZWZpbmVkLlxuICogVG8gZmFsbGJhY2sgdG8gTG9uZ1BvbGwgd2hlbiBXZWJTb2NrZXQgYXR0ZW1wdHMgZmFpbCwgdXNlIGBsb25nUG9sbEZhbGxiYWNrTXM6IDI1MDBgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmxvbmdQb2xsRmFsbGJhY2tNc10gLSBUaGUgbWlsbGlzZWNvbmQgdGltZSB0byBhdHRlbXB0IHRoZSBwcmltYXJ5IHRyYW5zcG9ydFxuICogYmVmb3JlIGZhbGxpbmcgYmFjayB0byB0aGUgTG9uZ1BvbGwgdHJhbnNwb3J0LiBEaXNhYmxlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmRlYnVnXSAtIFdoZW4gdHJ1ZSwgZW5hYmxlcyBkZWJ1ZyBsb2dnaW5nLiBEZWZhdWx0IGZhbHNlLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLmVuY29kZV0gLSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLlxuICpcbiAqIERlZmF1bHRzIHRvIEpTT04gZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5kZWNvZGVdIC0gVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBKU09OOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIChwYXlsb2FkLCBjYWxsYmFjaykgPT4gY2FsbGJhY2soSlNPTi5wYXJzZShwYXlsb2FkKSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0XSAtIFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAqXG4gKiBEZWZhdWx0cyBgREVGQVVMVF9USU1FT1VUYFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlYXJ0YmVhdEludGVydmFsTXNdIC0gVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnJlY29ubmVjdEFmdGVyTXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbGlzZWNcbiAqIHNvY2tldCByZWNvbm5lY3QgaW50ZXJ2YWwuXG4gKlxuICogRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMCwgNTAsIDEwMCwgMTUwLCAyMDAsIDI1MCwgNTAwLCAxMDAwLCAyMDAwXVt0cmllcyAtIDFdIHx8IDUwMDBcbiAqIH1cbiAqIGBgYGBcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMucmVqb2luQWZ0ZXJNc10gLSBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsaXNlY1xuICogcmVqb2luIGludGVydmFsIGZvciBpbmRpdmlkdWFsIGNoYW5uZWxzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgcmV0dXJuIFsxMDAwLCAyMDAwLCA1MDAwXVt0cmllcyAtIDFdIHx8IDEwMDAwXG4gKiB9XG4gKiBgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMubG9nZ2VyXSAtIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogZnVuY3Rpb24oa2luZCwgbXNnLCBkYXRhKSB7XG4gKiAgIGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKVxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmxvbmdwb2xsZXJUaW1lb3V0XSAtIFRoZSBtYXhpbXVtIHRpbWVvdXQgb2YgYSBsb25nIHBvbGwgQUpBWCByZXF1ZXN0LlxuICpcbiAqIERlZmF1bHRzIHRvIDIwcyAoZG91YmxlIHRoZSBzZXJ2ZXIgbG9uZyBwb2xsIHRpbWVyKS5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3R8ZnVuY3Rpb24pfSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmJpbmFyeVR5cGVdIC0gVGhlIGJpbmFyeSB0eXBlIHRvIHVzZSBmb3IgYmluYXJ5IFdlYlNvY2tldCBmcmFtZXMuXG4gKlxuICogRGVmYXVsdHMgdG8gXCJhcnJheWJ1ZmZlclwiXG4gKlxuICogQHBhcmFtIHt2c259IFtvcHRzLnZzbl0gLSBUaGUgc2VyaWFsaXplcidzIHByb3RvY29sIHZlcnNpb24gdG8gc2VuZCBvbiBjb25uZWN0LlxuICpcbiAqIERlZmF1bHRzIHRvIERFRkFVTFRfVlNOLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5zZXNzaW9uU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBQaG9lbml4IHVzZXMgc2Vzc2lvblN0b3JhZ2UgZm9yIGxvbmdwb2xsIGZhbGxiYWNrIGhpc3RvcnkuIE92ZXJyaWRpbmcgdGhlIHN0b3JlIGlzXG4gKiB1c2VmdWwgd2hlbiBQaG9lbml4IHdvbid0IGhhdmUgYWNjZXNzIHRvIGBzZXNzaW9uU3RvcmFnZWAuIEZvciBleGFtcGxlLCBUaGlzIGNvdWxkXG4gKiBoYXBwZW4gaWYgYSBzaXRlIGxvYWRzIGEgY3Jvc3MtZG9tYWluIGNoYW5uZWwgaW4gYW4gaWZyYW1lLiBFeGFtcGxlIHVzYWdlOlxuICpcbiAqICAgICBjbGFzcyBJbk1lbW9yeVN0b3JhZ2Uge1xuICogICAgICAgY29uc3RydWN0b3IoKSB7IHRoaXMuc3RvcmFnZSA9IHt9IH1cbiAqICAgICAgIGdldEl0ZW0oa2V5TmFtZSkgeyByZXR1cm4gdGhpcy5zdG9yYWdlW2tleU5hbWVdIHx8IG51bGwgfVxuICogICAgICAgcmVtb3ZlSXRlbShrZXlOYW1lKSB7IGRlbGV0ZSB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gfVxuICogICAgICAgc2V0SXRlbShrZXlOYW1lLCBrZXlWYWx1ZSkgeyB0aGlzLnN0b3JhZ2Vba2V5TmFtZV0gPSBrZXlWYWx1ZSB9XG4gKiAgICAgfVxuICpcbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2NrZXQge1xuICBjb25zdHJ1Y3RvcihlbmRQb2ludCwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0ge29wZW46IFtdLCBjbG9zZTogW10sIGVycm9yOiBbXSwgbWVzc2FnZTogW119XG4gICAgdGhpcy5jaGFubmVscyA9IFtdXG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgREVGQVVMVF9USU1FT1VUXG4gICAgdGhpcy50cmFuc3BvcnQgPSBvcHRzLnRyYW5zcG9ydCB8fCBnbG9iYWwuV2ViU29ja2V0IHx8IExvbmdQb2xsXG4gICAgdGhpcy5wcmltYXJ5UGFzc2VkSGVhbHRoQ2hlY2sgPSBmYWxzZVxuICAgIHRoaXMubG9uZ1BvbGxGYWxsYmFja01zID0gb3B0cy5sb25nUG9sbEZhbGxiYWNrTXNcbiAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBudWxsXG4gICAgdGhpcy5zZXNzaW9uU3RvcmUgPSBvcHRzLnNlc3Npb25TdG9yYWdlIHx8IChnbG9iYWwgJiYgZ2xvYmFsLnNlc3Npb25TdG9yYWdlKVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucyA9IDBcbiAgICB0aGlzLmRlZmF1bHRFbmNvZGVyID0gU2VyaWFsaXplci5lbmNvZGUuYmluZChTZXJpYWxpemVyKVxuICAgIHRoaXMuZGVmYXVsdERlY29kZXIgPSBTZXJpYWxpemVyLmRlY29kZS5iaW5kKFNlcmlhbGl6ZXIpXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICB0aGlzLmJpbmFyeVR5cGUgPSBvcHRzLmJpbmFyeVR5cGUgfHwgXCJhcnJheWJ1ZmZlclwiXG4gICAgdGhpcy5jb25uZWN0Q2xvY2sgPSAxXG4gICAgaWYodGhpcy50cmFuc3BvcnQgIT09IExvbmdQb2xsKXtcbiAgICAgIHRoaXMuZW5jb2RlID0gb3B0cy5lbmNvZGUgfHwgdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSBvcHRzLmRlY29kZSB8fCB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW5jb2RlID0gdGhpcy5kZWZhdWx0RW5jb2RlclxuICAgICAgdGhpcy5kZWNvZGUgPSB0aGlzLmRlZmF1bHREZWNvZGVyXG4gICAgfVxuICAgIGxldCBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgIGlmKHBoeFdpbmRvdyAmJiBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcil7XG4gICAgICBwaHhXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9lID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgICAgICAgIGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPSB0aGlzLmNvbm5lY3RDbG9ja1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgcGh4V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlc2hvd1wiLCBfZSA9PiB7XG4gICAgICAgIGlmKGF3YWl0aW5nQ29ubmVjdGlvbk9uUGFnZVNob3cgPT09IHRoaXMuY29ubmVjdENsb2NrKXtcbiAgICAgICAgICBhd2FpdGluZ0Nvbm5lY3Rpb25PblBhZ2VTaG93ID0gbnVsbFxuICAgICAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyA9IG9wdHMuaGVhcnRiZWF0SW50ZXJ2YWxNcyB8fCAzMDAwMFxuICAgIHRoaXMucmVqb2luQWZ0ZXJNcyA9ICh0cmllcykgPT4ge1xuICAgICAgaWYob3B0cy5yZWpvaW5BZnRlck1zKXtcbiAgICAgICAgcmV0dXJuIG9wdHMucmVqb2luQWZ0ZXJNcyh0cmllcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTAwMCwgMjAwMCwgNTAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlY29ubmVjdEFmdGVyTXMgPSAodHJpZXMpID0+IHtcbiAgICAgIGlmKG9wdHMucmVjb25uZWN0QWZ0ZXJNcyl7XG4gICAgICAgIHJldHVybiBvcHRzLnJlY29ubmVjdEFmdGVyTXModHJpZXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEwLCA1MCwgMTAwLCAxNTAsIDIwMCwgMjUwLCA1MDAsIDEwMDAsIDIwMDBdW3RyaWVzIC0gMV0gfHwgNTAwMFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxvZ2dlciA9IG9wdHMubG9nZ2VyIHx8IG51bGxcbiAgICBpZighdGhpcy5sb2dnZXIgJiYgb3B0cy5kZWJ1Zyl7XG4gICAgICB0aGlzLmxvZ2dlciA9IChraW5kLCBtc2csIGRhdGEpID0+IHsgY29uc29sZS5sb2coYCR7a2luZH06ICR7bXNnfWAsIGRhdGEpIH1cbiAgICB9XG4gICAgdGhpcy5sb25ncG9sbGVyVGltZW91dCA9IG9wdHMubG9uZ3BvbGxlclRpbWVvdXQgfHwgMjAwMDBcbiAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUob3B0cy5wYXJhbXMgfHwge30pXG4gICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWBcbiAgICB0aGlzLnZzbiA9IG9wdHMudnNuIHx8IERFRkFVTFRfVlNOXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lb3V0VGltZXIgPSBudWxsXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcigoKSA9PiB7XG4gICAgICB0aGlzLnRlYXJkb3duKCgpID0+IHRoaXMuY29ubmVjdCgpKVxuICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb25nUG9sbCB0cmFuc3BvcnQgcmVmZXJlbmNlXG4gICAqL1xuICBnZXRMb25nUG9sbFRyYW5zcG9ydCgpeyByZXR1cm4gTG9uZ1BvbGwgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBhbmQgcmVwbGFjZXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3VHJhbnNwb3J0IC0gVGhlIG5ldyB0cmFuc3BvcnQgY2xhc3MgdG8gaW5zdGFudGlhdGVcbiAgICpcbiAgICovXG4gIHJlcGxhY2VUcmFuc3BvcnQobmV3VHJhbnNwb3J0KXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgaWYodGhpcy5jb25uKXtcbiAgICAgIHRoaXMuY29ubi5jbG9zZSgpXG4gICAgICB0aGlzLmNvbm4gPSBudWxsXG4gICAgfVxuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc29ja2V0IHByb3RvY29sXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBwcm90b2NvbCgpeyByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wubWF0Y2goL15odHRwcy8pID8gXCJ3c3NcIiA6IFwid3NcIiB9XG5cbiAgLyoqXG4gICAqIFRoZSBmdWxseSBxdWFsaWZpZWQgc29ja2V0IHVybFxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5kUG9pbnRVUkwoKXtcbiAgICBsZXQgdXJpID0gQWpheC5hcHBlbmRQYXJhbXMoXG4gICAgICBBamF4LmFwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCB0aGlzLnBhcmFtcygpKSwge3ZzbjogdGhpcy52c259KVxuICAgIGlmKHVyaS5jaGFyQXQoMCkgIT09IFwiL1wiKXsgcmV0dXJuIHVyaSB9XG4gICAgaWYodXJpLmNoYXJBdCgxKSA9PT0gXCIvXCIpeyByZXR1cm4gYCR7dGhpcy5wcm90b2NvbCgpfToke3VyaX1gIH1cblxuICAgIHJldHVybiBgJHt0aGlzLnByb3RvY29sKCl9Oi8vJHtsb2NhdGlvbi5ob3N0fSR7dXJpfWBcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0XG4gICAqXG4gICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXMgZm9yIHZhbGlkIHN0YXR1cyBjb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgc29ja2V0IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBjb2RlIC0gQSBzdGF0dXMgY29kZSBmb3IgZGlzY29ubmVjdGlvbiAoT3B0aW9uYWwpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gQSB0ZXh0dWFsIGRlc2NyaXB0aW9uIG9mIHRoZSByZWFzb24gdG8gZGlzY29ubmVjdC4gKE9wdGlvbmFsKVxuICAgKi9cbiAgZGlzY29ubmVjdChjYWxsYmFjaywgY29kZSwgcmVhc29uKXtcbiAgICB0aGlzLmNvbm5lY3RDbG9jaysrXG4gICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgdGhpcy5yZWNvbm5lY3RUaW1lci5yZXNldCgpXG4gICAgdGhpcy50ZWFyZG93bihjYWxsYmFjaywgY29kZSwgcmVhc29uKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1zIHRvIHNlbmQgd2hlbiBjb25uZWN0aW5nLCBmb3IgZXhhbXBsZSBge3VzZXJfaWQ6IHVzZXJUb2tlbn1gXG4gICAqXG4gICAqIFBhc3NpbmcgcGFyYW1zIHRvIGNvbm5lY3QgaXMgZGVwcmVjYXRlZDsgcGFzcyB0aGVtIGluIHRoZSBTb2NrZXQgY29uc3RydWN0b3IgaW5zdGVhZDpcbiAgICogYG5ldyBTb2NrZXQoXCIvc29ja2V0XCIsIHtwYXJhbXM6IHt1c2VyX2lkOiB1c2VyVG9rZW59fSlgLlxuICAgKi9cbiAgY29ubmVjdChwYXJhbXMpe1xuICAgIGlmKHBhcmFtcyl7XG4gICAgICBjb25zb2xlICYmIGNvbnNvbGUubG9nKFwicGFzc2luZyBwYXJhbXMgdG8gY29ubmVjdCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHBhc3MgOnBhcmFtcyB0byB0aGUgU29ja2V0IGNvbnN0cnVjdG9yXCIpXG4gICAgICB0aGlzLnBhcmFtcyA9IGNsb3N1cmUocGFyYW1zKVxuICAgIH1cbiAgICBpZih0aGlzLmNvbm4peyByZXR1cm4gfVxuICAgIGlmKHRoaXMubG9uZ1BvbGxGYWxsYmFja01zICYmIHRoaXMudHJhbnNwb3J0ICE9PSBMb25nUG9sbCl7XG4gICAgICB0aGlzLmNvbm5lY3RXaXRoRmFsbGJhY2soTG9uZ1BvbGwsIHRoaXMubG9uZ1BvbGxGYWxsYmFja01zKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydENvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIHRoZSBtZXNzYWdlLiBPdmVycmlkZSBgdGhpcy5sb2dnZXJgIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLiBub29wcyBieSBkZWZhdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICovXG4gIGxvZyhraW5kLCBtc2csIGRhdGEpeyB0aGlzLmxvZ2dlciAmJiB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgbG9nZ2VyIGhhcyBiZWVuIHNldCBvbiB0aGlzIHNvY2tldC5cbiAgICovXG4gIGhhc0xvZ2dlcigpeyByZXR1cm4gdGhpcy5sb2dnZXIgIT09IG51bGwgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgY2FsbGJhY2tzIGZvciBjb25uZWN0aW9uIG9wZW4gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbk9wZW4oZnVuY3Rpb24oKXsgY29uc29sZS5pbmZvKFwidGhlIHNvY2tldCB3YXMgb3BlbmVkXCIpIH0pXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBvbk9wZW4oY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBjbG9zZSBldmVudHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIG9uQ2xvc2UoY2FsbGJhY2spe1xuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBjYWxsYmFja3MgZm9yIGNvbm5lY3Rpb24gZXJyb3IgZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlIHNvY2tldC5vbkVycm9yKGZ1bmN0aW9uKGVycm9yKXsgYWxlcnQoXCJBbiBlcnJvciBvY2N1cnJlZFwiKSB9KVxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25FcnJvcihjYWxsYmFjayl7XG4gICAgbGV0IHJlZiA9IHRoaXMubWFrZVJlZigpXG4gICAgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5lcnJvci5wdXNoKFtyZWYsIGNhbGxiYWNrXSlcbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBmb3IgY29ubmVjdGlvbiBtZXNzYWdlIGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25NZXNzYWdlKGNhbGxiYWNrKXtcbiAgICBsZXQgcmVmID0gdGhpcy5tYWtlUmVmKClcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLm1lc3NhZ2UucHVzaChbcmVmLCBjYWxsYmFja10pXG4gICAgcmV0dXJuIHJlZlxuICB9XG5cbiAgLyoqXG4gICAqIFBpbmdzIHRoZSBzZXJ2ZXIgYW5kIGludm9rZXMgdGhlIGNhbGxiYWNrIHdpdGggdGhlIFJUVCBpbiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICpcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwaW5nIHdhcyBwdXNoZWQgb3IgZmFsc2UgaWYgdW5hYmxlIHRvIGJlIHB1c2hlZC5cbiAgICovXG4gIHBpbmcoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gZmFsc2UgfVxuICAgIGxldCByZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIGxldCBzdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgdGhpcy5wdXNoKHt0b3BpYzogXCJwaG9lbml4XCIsIGV2ZW50OiBcImhlYXJ0YmVhdFwiLCBwYXlsb2FkOiB7fSwgcmVmOiByZWZ9KVxuICAgIGxldCBvbk1zZ1JlZiA9IHRoaXMub25NZXNzYWdlKG1zZyA9PiB7XG4gICAgICBpZihtc2cucmVmID09PSByZWYpe1xuICAgICAgICB0aGlzLm9mZihbb25Nc2dSZWZdKVxuICAgICAgICBjYWxsYmFjayhEYXRlLm5vdygpIC0gc3RhcnRUaW1lKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0cmFuc3BvcnRDb25uZWN0KCl7XG4gICAgdGhpcy5jb25uZWN0Q2xvY2srK1xuICAgIHRoaXMuY2xvc2VXYXNDbGVhbiA9IGZhbHNlXG4gICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kUG9pbnRVUkwoKSlcbiAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZVxuICAgIHRoaXMuY29ubi50aW1lb3V0ID0gdGhpcy5sb25ncG9sbGVyVGltZW91dFxuICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLm9uQ29ubk9wZW4oKVxuICAgIHRoaXMuY29ubi5vbmVycm9yID0gZXJyb3IgPT4gdGhpcy5vbkNvbm5FcnJvcihlcnJvcilcbiAgICB0aGlzLmNvbm4ub25tZXNzYWdlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5NZXNzYWdlKGV2ZW50KVxuICAgIHRoaXMuY29ubi5vbmNsb3NlID0gZXZlbnQgPT4gdGhpcy5vbkNvbm5DbG9zZShldmVudClcbiAgfVxuXG4gIGdldFNlc3Npb24oa2V5KXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JlICYmIHRoaXMuc2Vzc2lvblN0b3JlLmdldEl0ZW0oa2V5KSB9XG5cbiAgc3RvcmVTZXNzaW9uKGtleSwgdmFsKXsgdGhpcy5zZXNzaW9uU3RvcmUgJiYgdGhpcy5zZXNzaW9uU3RvcmUuc2V0SXRlbShrZXksIHZhbCkgfVxuXG4gIGNvbm5lY3RXaXRoRmFsbGJhY2soZmFsbGJhY2tUcmFuc3BvcnQsIGZhbGxiYWNrVGhyZXNob2xkID0gMjUwMCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICBsZXQgZXN0YWJsaXNoZWQgPSBmYWxzZVxuICAgIGxldCBwcmltYXJ5VHJhbnNwb3J0ID0gdHJ1ZVxuICAgIGxldCBvcGVuUmVmLCBlcnJvclJlZlxuICAgIGxldCBmYWxsYmFjayA9IChyZWFzb24pID0+IHtcbiAgICAgIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBmYWxsaW5nIGJhY2sgdG8gJHtmYWxsYmFja1RyYW5zcG9ydC5uYW1lfS4uLmAsIHJlYXNvbilcbiAgICAgIHRoaXMub2ZmKFtvcGVuUmVmLCBlcnJvclJlZl0pXG4gICAgICBwcmltYXJ5VHJhbnNwb3J0ID0gZmFsc2VcbiAgICAgIHRoaXMucmVwbGFjZVRyYW5zcG9ydChmYWxsYmFja1RyYW5zcG9ydClcbiAgICAgIHRoaXMudHJhbnNwb3J0Q29ubmVjdCgpXG4gICAgfVxuICAgIGlmKHRoaXMuZ2V0U2Vzc2lvbihgcGh4OmZhbGxiYWNrOiR7ZmFsbGJhY2tUcmFuc3BvcnQubmFtZX1gKSl7IHJldHVybiBmYWxsYmFjayhcIm1lbW9yaXplZFwiKSB9XG5cbiAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZhbGxiYWNrLCBmYWxsYmFja1RocmVzaG9sZClcblxuICAgIGVycm9yUmVmID0gdGhpcy5vbkVycm9yKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImVycm9yXCIsIHJlYXNvbilcbiAgICAgIGlmKHByaW1hcnlUcmFuc3BvcnQgJiYgIWVzdGFibGlzaGVkKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZmFsbGJhY2tUaW1lcilcbiAgICAgICAgZmFsbGJhY2socmVhc29uKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgZXN0YWJsaXNoZWQgPSB0cnVlXG4gICAgICBpZighcHJpbWFyeVRyYW5zcG9ydCl7XG4gICAgICAgIC8vIG9ubHkgbWVtb3JpemUgTFAgaWYgd2UgbmV2ZXIgY29ubmVjdGVkIHRvIHByaW1hcnlcbiAgICAgICAgaWYoIXRoaXMucHJpbWFyeVBhc3NlZEhlYWx0aENoZWNrKXsgdGhpcy5zdG9yZVNlc3Npb24oYHBoeDpmYWxsYmFjazoke2ZhbGxiYWNrVHJhbnNwb3J0Lm5hbWV9YCwgXCJ0cnVlXCIpIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKFwidHJhbnNwb3J0XCIsIGBlc3RhYmxpc2hlZCAke2ZhbGxiYWNrVHJhbnNwb3J0Lm5hbWV9IGZhbGxiYWNrYClcbiAgICAgIH1cbiAgICAgIC8vIGlmIHdlJ3ZlIGVzdGFibGlzaGVkIHByaW1hcnksIGdpdmUgdGhlIGZhbGxiYWNrIGEgbmV3IHBlcmlvZCB0byBhdHRlbXB0IHBpbmdcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgICB0aGlzLmZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KGZhbGxiYWNrLCBmYWxsYmFja1RocmVzaG9sZClcbiAgICAgIHRoaXMucGluZyhydHQgPT4ge1xuICAgICAgICB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBcImNvbm5lY3RlZCB0byBwcmltYXJ5IGFmdGVyXCIsIHJ0dClcbiAgICAgICAgdGhpcy5wcmltYXJ5UGFzc2VkSGVhbHRoQ2hlY2sgPSB0cnVlXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmZhbGxiYWNrVGltZXIpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy50cmFuc3BvcnRDb25uZWN0KClcbiAgfVxuXG4gIGNsZWFySGVhcnRiZWF0cygpe1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVyKVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lcilcbiAgfVxuXG4gIG9uQ29ubk9wZW4oKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgJHt0aGlzLnRyYW5zcG9ydC5uYW1lfSBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZFBvaW50VVJMKCl9YClcbiAgICB0aGlzLmNsb3NlV2FzQ2xlYW4gPSBmYWxzZVxuICAgIHRoaXMuZXN0YWJsaXNoZWRDb25uZWN0aW9ucysrXG4gICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKVxuICAgIHRoaXMucmVjb25uZWN0VGltZXIucmVzZXQoKVxuICAgIHRoaXMucmVzZXRIZWFydGJlYXQoKVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Mub3Blbi5mb3JFYWNoKChbLCBjYWxsYmFja10pID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgaGVhcnRiZWF0VGltZW91dCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZil7XG4gICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXsgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJoZWFydGJlYXQgdGltZW91dC4gQXR0ZW1wdGluZyB0byByZS1lc3RhYmxpc2ggY29ubmVjdGlvblwiKSB9XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgICAgdGhpcy5jbG9zZVdhc0NsZWFuID0gZmFsc2VcbiAgICAgIHRoaXMudGVhcmRvd24oKCkgPT4gdGhpcy5yZWNvbm5lY3RUaW1lci5zY2hlZHVsZVRpbWVvdXQoKSwgV1NfQ0xPU0VfTk9STUFMLCBcImhlYXJ0YmVhdCB0aW1lb3V0XCIpXG4gICAgfVxuICB9XG5cbiAgcmVzZXRIZWFydGJlYXQoKXtcbiAgICBpZih0aGlzLmNvbm4gJiYgdGhpcy5jb25uLnNraXBIZWFydGJlYXQpeyByZXR1cm4gfVxuICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGxcbiAgICB0aGlzLmNsZWFySGVhcnRiZWF0cygpXG4gICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIHRlYXJkb3duKGNhbGxiYWNrLCBjb2RlLCByZWFzb24pe1xuICAgIGlmKCF0aGlzLmNvbm4pe1xuICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9XG5cbiAgICB0aGlzLndhaXRGb3JCdWZmZXJEb25lKCgpID0+IHtcbiAgICAgIGlmKHRoaXMuY29ubil7XG4gICAgICAgIGlmKGNvZGUpeyB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uIHx8IFwiXCIpIH0gZWxzZSB7IHRoaXMuY29ubi5jbG9zZSgpIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy53YWl0Rm9yU29ja2V0Q2xvc2VkKCgpID0+IHtcbiAgICAgICAgaWYodGhpcy5jb25uKXtcbiAgICAgICAgICB0aGlzLmNvbm4ub25vcGVuID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gZnVuY3Rpb24gKCl7IH0gLy8gbm9vcFxuICAgICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uLm9uY2xvc2UgPSBmdW5jdGlvbiAoKXsgfSAvLyBub29wXG4gICAgICAgICAgdGhpcy5jb25uID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgd2FpdEZvckJ1ZmZlckRvbmUoY2FsbGJhY2ssIHRyaWVzID0gMSl7XG4gICAgaWYodHJpZXMgPT09IDUgfHwgIXRoaXMuY29ubiB8fCAhdGhpcy5jb25uLmJ1ZmZlcmVkQW1vdW50KXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy53YWl0Rm9yQnVmZmVyRG9uZShjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgd2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgPSAxKXtcbiAgICBpZih0cmllcyA9PT0gNSB8fCAhdGhpcy5jb25uIHx8IHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNsb3NlZCl7XG4gICAgICBjYWxsYmFjaygpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMud2FpdEZvclNvY2tldENsb3NlZChjYWxsYmFjaywgdHJpZXMgKyAxKVxuICAgIH0sIDE1MCAqIHRyaWVzKVxuICB9XG5cbiAgb25Db25uQ2xvc2UoZXZlbnQpe1xuICAgIGxldCBjbG9zZUNvZGUgPSBldmVudCAmJiBldmVudC5jb2RlXG4gICAgaWYodGhpcy5oYXNMb2dnZXIoKSkgdGhpcy5sb2coXCJ0cmFuc3BvcnRcIiwgXCJjbG9zZVwiLCBldmVudClcbiAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIHRoaXMuY2xlYXJIZWFydGJlYXRzKClcbiAgICBpZighdGhpcy5jbG9zZVdhc0NsZWFuICYmIGNsb3NlQ29kZSAhPT0gMTAwMCl7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpXG4gICAgfVxuICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MuY2xvc2UuZm9yRWFjaCgoWywgY2FsbGJhY2tdKSA9PiBjYWxsYmFjayhldmVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG9uQ29ubkVycm9yKGVycm9yKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBlcnJvcilcbiAgICBsZXQgdHJhbnNwb3J0QmVmb3JlID0gdGhpcy50cmFuc3BvcnRcbiAgICBsZXQgZXN0YWJsaXNoZWRCZWZvcmUgPSB0aGlzLmVzdGFibGlzaGVkQ29ubmVjdGlvbnNcbiAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmVycm9yLmZvckVhY2goKFssIGNhbGxiYWNrXSkgPT4ge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIHRyYW5zcG9ydEJlZm9yZSwgZXN0YWJsaXNoZWRCZWZvcmUpXG4gICAgfSlcbiAgICBpZih0cmFuc3BvcnRCZWZvcmUgPT09IHRoaXMudHJhbnNwb3J0IHx8IGVzdGFibGlzaGVkQmVmb3JlID4gMCl7XG4gICAgICB0aGlzLnRyaWdnZXJDaGFuRXJyb3IoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdHJpZ2dlckNoYW5FcnJvcigpe1xuICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgIGlmKCEoY2hhbm5lbC5pc0Vycm9yZWQoKSB8fCBjaGFubmVsLmlzTGVhdmluZygpIHx8IGNoYW5uZWwuaXNDbG9zZWQoKSkpe1xuICAgICAgICBjaGFubmVsLnRyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgY29ubmVjdGlvblN0YXRlKCl7XG4gICAgc3dpdGNoKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSl7XG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzogcmV0dXJuIFwiY29ubmVjdGluZ1wiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMub3BlbjogcmV0dXJuIFwib3BlblwiXG4gICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzogcmV0dXJuIFwiY2xvc2luZ1wiXG4gICAgICBkZWZhdWx0OiByZXR1cm4gXCJjbG9zZWRcIlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29ubmVjdGVkKCl7IHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdGF0ZSgpID09PSBcIm9wZW5cIiB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q2hhbm5lbH1cbiAgICovXG4gIHJlbW92ZShjaGFubmVsKXtcbiAgICB0aGlzLm9mZihjaGFubmVsLnN0YXRlQ2hhbmdlUmVmcylcbiAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoYyA9PiBjICE9PSBjaGFubmVsKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYG9uT3BlbmAsIGBvbkNsb3NlYCwgYG9uRXJyb3IsYCBhbmQgYG9uTWVzc2FnZWAgcmVnaXN0cmF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtyZWZzfSAtIGxpc3Qgb2YgcmVmcyByZXR1cm5lZCBieSBjYWxscyB0b1xuICAgKiAgICAgICAgICAgICAgICAgYG9uT3BlbmAsIGBvbkNsb3NlYCwgYG9uRXJyb3IsYCBhbmQgYG9uTWVzc2FnZWBcbiAgICovXG4gIG9mZihyZWZzKXtcbiAgICBmb3IobGV0IGtleSBpbiB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzKXtcbiAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3Nba2V5XS5maWx0ZXIoKFtyZWZdKSA9PiB7XG4gICAgICAgIHJldHVybiByZWZzLmluZGV4T2YocmVmKSA9PT0gLTFcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIG5ldyBjaGFubmVsIGZvciB0aGUgZ2l2ZW4gdG9waWNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcGljXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFuUGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIGNoYW5uZWxcbiAgICogQHJldHVybnMge0NoYW5uZWx9XG4gICAqL1xuICBjaGFubmVsKHRvcGljLCBjaGFuUGFyYW1zID0ge30pe1xuICAgIGxldCBjaGFuID0gbmV3IENoYW5uZWwodG9waWMsIGNoYW5QYXJhbXMsIHRoaXMpXG4gICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pXG4gICAgcmV0dXJuIGNoYW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cbiAgcHVzaChkYXRhKXtcbiAgICBpZih0aGlzLmhhc0xvZ2dlcigpKXtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IGRhdGFcbiAgICAgIHRoaXMubG9nKFwicHVzaFwiLCBgJHt0b3BpY30gJHtldmVudH0gKCR7am9pbl9yZWZ9LCAke3JlZn0pYCwgcGF5bG9hZClcbiAgICB9XG5cbiAgICBpZih0aGlzLmlzQ29ubmVjdGVkKCkpe1xuICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgcmVzdWx0ID0+IHRoaXMuY29ubi5zZW5kKHJlc3VsdCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKCgpID0+IHRoaXMuZW5jb2RlKGRhdGEsIHJlc3VsdCA9PiB0aGlzLmNvbm4uc2VuZChyZXN1bHQpKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIG1ha2VSZWYoKXtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxXG4gICAgaWYobmV3UmVmID09PSB0aGlzLnJlZil7IHRoaXMucmVmID0gMCB9IGVsc2UgeyB0aGlzLnJlZiA9IG5ld1JlZiB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWYudG9TdHJpbmcoKVxuICB9XG5cbiAgc2VuZEhlYXJ0YmVhdCgpe1xuICAgIGlmKHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiAmJiAhdGhpcy5pc0Nvbm5lY3RlZCgpKXsgcmV0dXJuIH1cbiAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLm1ha2VSZWYoKVxuICAgIHRoaXMucHVzaCh7dG9waWM6IFwicGhvZW5peFwiLCBldmVudDogXCJoZWFydGJlYXRcIiwgcGF5bG9hZDoge30sIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmfSlcbiAgICB0aGlzLmhlYXJ0YmVhdFRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oZWFydGJlYXRUaW1lb3V0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcylcbiAgfVxuXG4gIGZsdXNoU2VuZEJ1ZmZlcigpe1xuICAgIGlmKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCl7XG4gICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKVxuICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW11cbiAgICB9XG4gIH1cblxuICBvbkNvbm5NZXNzYWdlKHJhd01lc3NhZ2Upe1xuICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgbXNnID0+IHtcbiAgICAgIGxldCB7dG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmfSA9IG1zZ1xuICAgICAgaWYocmVmICYmIHJlZiA9PT0gdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKXtcbiAgICAgICAgdGhpcy5jbGVhckhlYXJ0YmVhdHMoKVxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsXG4gICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VuZEhlYXJ0YmVhdCgpLCB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMpXG4gICAgICB9XG5cbiAgICAgIGlmKHRoaXMuaGFzTG9nZ2VyKCkpIHRoaXMubG9nKFwicmVjZWl2ZVwiLCBgJHtwYXlsb2FkLnN0YXR1cyB8fCBcIlwifSAke3RvcGljfSAke2V2ZW50fSAke3JlZiAmJiBcIihcIiArIHJlZiArIFwiKVwiIHx8IFwiXCJ9YCwgcGF5bG9hZClcblxuICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBjaGFubmVsID0gdGhpcy5jaGFubmVsc1tpXVxuICAgICAgICBpZighY2hhbm5lbC5pc01lbWJlcih0b3BpYywgZXZlbnQsIHBheWxvYWQsIGpvaW5fcmVmKSl7IGNvbnRpbnVlIH1cbiAgICAgICAgY2hhbm5lbC50cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYsIGpvaW5fcmVmKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZUNoYW5nZUNhbGxiYWNrcy5tZXNzYWdlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbGV0IFssIGNhbGxiYWNrXSA9IHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MubWVzc2FnZVtpXVxuICAgICAgICBjYWxsYmFjayhtc2cpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGxlYXZlT3BlblRvcGljKHRvcGljKXtcbiAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZChjID0+IGMudG9waWMgPT09IHRvcGljICYmIChjLmlzSm9pbmVkKCkgfHwgYy5pc0pvaW5pbmcoKSkpXG4gICAgaWYoZHVwQ2hhbm5lbCl7XG4gICAgICBpZih0aGlzLmhhc0xvZ2dlcigpKSB0aGlzLmxvZyhcInRyYW5zcG9ydFwiLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYClcbiAgICAgIGR1cENoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgfVxufVxuIiwgImV4cG9ydCBjb25zdCBDT05TRUNVVElWRV9SRUxPQURTID0gXCJjb25zZWN1dGl2ZS1yZWxvYWRzXCJcbmV4cG9ydCBjb25zdCBNQVhfUkVMT0FEUyA9IDEwXG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NSU4gPSA1MDAwXG5leHBvcnQgY29uc3QgUkVMT0FEX0pJVFRFUl9NQVggPSAxMDAwMFxuZXhwb3J0IGNvbnN0IEZBSUxTQUZFX0pJVFRFUiA9IDMwMDAwXG5leHBvcnQgY29uc3QgUEhYX0VWRU5UX0NMQVNTRVMgPSBbXG4gIFwicGh4LWNsaWNrLWxvYWRpbmdcIiwgXCJwaHgtY2hhbmdlLWxvYWRpbmdcIiwgXCJwaHgtc3VibWl0LWxvYWRpbmdcIixcbiAgXCJwaHgta2V5ZG93bi1sb2FkaW5nXCIsIFwicGh4LWtleXVwLWxvYWRpbmdcIiwgXCJwaHgtYmx1ci1sb2FkaW5nXCIsIFwicGh4LWZvY3VzLWxvYWRpbmdcIixcbiAgXCJwaHgtaG9vay1sb2FkaW5nXCJcbl1cbmV4cG9ydCBjb25zdCBQSFhfQ09NUE9ORU5UID0gXCJkYXRhLXBoeC1jb21wb25lbnRcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0xJTksgPSBcImRhdGEtcGh4LWxpbmtcIlxuZXhwb3J0IGNvbnN0IFBIWF9UUkFDS19TVEFUSUMgPSBcInRyYWNrLXN0YXRpY1wiXG5leHBvcnQgY29uc3QgUEhYX0xJTktfU1RBVEUgPSBcImRhdGEtcGh4LWxpbmstc3RhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUZfTE9BRElORyA9IFwiZGF0YS1waHgtcmVmLWxvYWRpbmdcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUZfU1JDID0gXCJkYXRhLXBoeC1yZWYtc3JjXCJcbmV4cG9ydCBjb25zdCBQSFhfUkVGX0xPQ0sgPSBcImRhdGEtcGh4LXJlZi1sb2NrXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJBQ0tfVVBMT0FEUyA9IFwidHJhY2stdXBsb2Fkc1wiXG5leHBvcnQgY29uc3QgUEhYX1VQTE9BRF9SRUYgPSBcImRhdGEtcGh4LXVwbG9hZC1yZWZcIlxuZXhwb3J0IGNvbnN0IFBIWF9QUkVGTElHSFRFRF9SRUZTID0gXCJkYXRhLXBoeC1wcmVmbGlnaHRlZC1yZWZzXCJcbmV4cG9ydCBjb25zdCBQSFhfRE9ORV9SRUZTID0gXCJkYXRhLXBoeC1kb25lLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9EUk9QX1RBUkdFVCA9IFwiZHJvcC10YXJnZXRcIlxuZXhwb3J0IGNvbnN0IFBIWF9BQ1RJVkVfRU5UUllfUkVGUyA9IFwiZGF0YS1waHgtYWN0aXZlLXJlZnNcIlxuZXhwb3J0IGNvbnN0IFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCA9IFwicGh4OmxpdmUtZmlsZTp1cGRhdGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0tJUCA9IFwiZGF0YS1waHgtc2tpcFwiXG5leHBvcnQgY29uc3QgUEhYX01BR0lDX0lEID0gXCJkYXRhLXBoeC1pZFwiXG5leHBvcnQgY29uc3QgUEhYX1BSVU5FID0gXCJkYXRhLXBoeC1wcnVuZVwiXG5leHBvcnQgY29uc3QgUEhYX0NPTk5FQ1RFRF9DTEFTUyA9IFwicGh4LWNvbm5lY3RlZFwiXG5leHBvcnQgY29uc3QgUEhYX0xPQURJTkdfQ0xBU1MgPSBcInBoeC1sb2FkaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfRVJST1JfQ0xBU1MgPSBcInBoeC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX0NMSUVOVF9FUlJPUl9DTEFTUyA9IFwicGh4LWNsaWVudC1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1NFUlZFUl9FUlJPUl9DTEFTUyA9IFwicGh4LXNlcnZlci1lcnJvclwiXG5leHBvcnQgY29uc3QgUEhYX1BBUkVOVF9JRCA9IFwiZGF0YS1waHgtcGFyZW50LWlkXCJcbmV4cG9ydCBjb25zdCBQSFhfTUFJTiA9IFwiZGF0YS1waHgtbWFpblwiXG5leHBvcnQgY29uc3QgUEhYX1JPT1RfSUQgPSBcImRhdGEtcGh4LXJvb3QtaWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9WSUVXUE9SVF9UT1AgPSBcInZpZXdwb3J0LXRvcFwiXG5leHBvcnQgY29uc3QgUEhYX1ZJRVdQT1JUX0JPVFRPTSA9IFwidmlld3BvcnQtYm90dG9tXCJcbmV4cG9ydCBjb25zdCBQSFhfVFJJR0dFUl9BQ1RJT04gPSBcInRyaWdnZXItYWN0aW9uXCJcbmV4cG9ydCBjb25zdCBQSFhfSEFTX0ZPQ1VTRUQgPSBcInBoeC1oYXMtZm9jdXNlZFwiXG5leHBvcnQgY29uc3QgRk9DVVNBQkxFX0lOUFVUUyA9IFtcInRleHRcIiwgXCJ0ZXh0YXJlYVwiLCBcIm51bWJlclwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIiwgXCJzZWFyY2hcIiwgXCJ0ZWxcIiwgXCJ1cmxcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwiY29sb3JcIiwgXCJyYW5nZVwiXVxuZXhwb3J0IGNvbnN0IENIRUNLQUJMRV9JTlBVVFMgPSBbXCJjaGVja2JveFwiLCBcInJhZGlvXCJdXG5leHBvcnQgY29uc3QgUEhYX0hBU19TVUJNSVRURUQgPSBcInBoeC1oYXMtc3VibWl0dGVkXCJcbmV4cG9ydCBjb25zdCBQSFhfU0VTU0lPTiA9IFwiZGF0YS1waHgtc2Vzc2lvblwiXG5leHBvcnQgY29uc3QgUEhYX1ZJRVdfU0VMRUNUT1IgPSBgWyR7UEhYX1NFU1NJT059XWBcbmV4cG9ydCBjb25zdCBQSFhfU1RJQ0tZID0gXCJkYXRhLXBoeC1zdGlja3lcIlxuZXhwb3J0IGNvbnN0IFBIWF9TVEFUSUMgPSBcImRhdGEtcGh4LXN0YXRpY1wiXG5leHBvcnQgY29uc3QgUEhYX1JFQURPTkxZID0gXCJkYXRhLXBoeC1yZWFkb25seVwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVEID0gXCJkYXRhLXBoeC1kaXNhYmxlZFwiXG5leHBvcnQgY29uc3QgUEhYX0RJU0FCTEVfV0lUSCA9IFwiZGlzYWJsZS13aXRoXCJcbmV4cG9ydCBjb25zdCBQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUgPSBcImRhdGEtcGh4LWRpc2FibGUtd2l0aC1yZXN0b3JlXCJcbmV4cG9ydCBjb25zdCBQSFhfSE9PSyA9IFwiaG9va1wiXG5leHBvcnQgY29uc3QgUEhYX0RFQk9VTkNFID0gXCJkZWJvdW5jZVwiXG5leHBvcnQgY29uc3QgUEhYX1RIUk9UVExFID0gXCJ0aHJvdHRsZVwiXG5leHBvcnQgY29uc3QgUEhYX1VQREFURSA9IFwidXBkYXRlXCJcbmV4cG9ydCBjb25zdCBQSFhfU1RSRUFNID0gXCJzdHJlYW1cIlxuZXhwb3J0IGNvbnN0IFBIWF9TVFJFQU1fUkVGID0gXCJkYXRhLXBoeC1zdHJlYW1cIlxuZXhwb3J0IGNvbnN0IFBIWF9LRVkgPSBcImtleVwiXG5leHBvcnQgY29uc3QgUEhYX1BSSVZBVEUgPSBcInBoeFByaXZhdGVcIlxuZXhwb3J0IGNvbnN0IFBIWF9BVVRPX1JFQ09WRVIgPSBcImF1dG8tcmVjb3ZlclwiXG5leHBvcnQgY29uc3QgUEhYX0xWX0RFQlVHID0gXCJwaHg6bGl2ZS1zb2NrZXQ6ZGVidWdcIlxuZXhwb3J0IGNvbnN0IFBIWF9MVl9QUk9GSUxFID0gXCJwaHg6bGl2ZS1zb2NrZXQ6cHJvZmlsaW5nXCJcbmV4cG9ydCBjb25zdCBQSFhfTFZfTEFURU5DWV9TSU0gPSBcInBoeDpsaXZlLXNvY2tldDpsYXRlbmN5LXNpbVwiXG5leHBvcnQgY29uc3QgUEhYX0xWX0hJU1RPUllfUE9TSVRJT04gPSBcInBoeDpuYXYtaGlzdG9yeS1wb3NpdGlvblwiXG5leHBvcnQgY29uc3QgUEhYX1BST0dSRVNTID0gXCJwcm9ncmVzc1wiXG5leHBvcnQgY29uc3QgUEhYX01PVU5URUQgPSBcIm1vdW50ZWRcIlxuZXhwb3J0IGNvbnN0IFBIWF9SRUxPQURfU1RBVFVTID0gXCJfX3Bob2VuaXhfcmVsb2FkX3N0YXR1c19fXCJcbmV4cG9ydCBjb25zdCBMT0FERVJfVElNRU9VVCA9IDFcbmV4cG9ydCBjb25zdCBNQVhfQ0hJTERfSk9JTl9BVFRFTVBUUyA9IDNcbmV4cG9ydCBjb25zdCBCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUID0gMjAwXG5leHBvcnQgY29uc3QgRElTQ09OTkVDVEVEX1RJTUVPVVQgPSA1MDBcbmV4cG9ydCBjb25zdCBCSU5ESU5HX1BSRUZJWCA9IFwicGh4LVwiXG5leHBvcnQgY29uc3QgUFVTSF9USU1FT1VUID0gMzAwMDBcbmV4cG9ydCBjb25zdCBMSU5LX0hFQURFUiA9IFwieC1yZXF1ZXN0ZWQtd2l0aFwiXG5leHBvcnQgY29uc3QgUkVTUE9OU0VfVVJMX0hFQURFUiA9IFwieC1yZXNwb25zZS11cmxcIlxuZXhwb3J0IGNvbnN0IERFQk9VTkNFX1RSSUdHRVIgPSBcImRlYm91bmNlLXRyaWdnZXJcIlxuZXhwb3J0IGNvbnN0IFRIUk9UVExFRCA9IFwidGhyb3R0bGVkXCJcbmV4cG9ydCBjb25zdCBERUJPVU5DRV9QUkVWX0tFWSA9IFwiZGVib3VuY2UtcHJldi1rZXlcIlxuZXhwb3J0IGNvbnN0IERFRkFVTFRTID0ge1xuICBkZWJvdW5jZTogMzAwLFxuICB0aHJvdHRsZTogMzAwXG59XG5leHBvcnQgY29uc3QgUEhYX1BFTkRJTkdfQVRUUlMgPSBbUEhYX1JFRl9MT0FESU5HLCBQSFhfUkVGX1NSQywgUEhYX1JFRl9MT0NLXVxuLy8gUmVuZGVyZWRcbmV4cG9ydCBjb25zdCBEWU5BTUlDUyA9IFwiZFwiXG5leHBvcnQgY29uc3QgU1RBVElDID0gXCJzXCJcbmV4cG9ydCBjb25zdCBST09UID0gXCJyXCJcbmV4cG9ydCBjb25zdCBDT01QT05FTlRTID0gXCJjXCJcbmV4cG9ydCBjb25zdCBFVkVOVFMgPSBcImVcIlxuZXhwb3J0IGNvbnN0IFJFUExZID0gXCJyXCJcbmV4cG9ydCBjb25zdCBUSVRMRSA9IFwidFwiXG5leHBvcnQgY29uc3QgVEVNUExBVEVTID0gXCJwXCJcbmV4cG9ydCBjb25zdCBTVFJFQU0gPSBcInN0cmVhbVwiXG4iLCAiaW1wb3J0IHtcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRyeVVwbG9hZGVyIHtcbiAgY29uc3RydWN0b3IoZW50cnksIGNvbmZpZywgbGl2ZVNvY2tldCl7XG4gICAgbGV0IHtjaHVua19zaXplLCBjaHVua190aW1lb3V0fSA9IGNvbmZpZ1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXRcbiAgICB0aGlzLmVudHJ5ID0gZW50cnlcbiAgICB0aGlzLm9mZnNldCA9IDBcbiAgICB0aGlzLmNodW5rU2l6ZSA9IGNodW5rX3NpemVcbiAgICB0aGlzLmNodW5rVGltZW91dCA9IGNodW5rX3RpbWVvdXRcbiAgICB0aGlzLmNodW5rVGltZXIgPSBudWxsXG4gICAgdGhpcy5lcnJvcmVkID0gZmFsc2VcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwgPSBsaXZlU29ja2V0LmNoYW5uZWwoYGx2dToke2VudHJ5LnJlZn1gLCB7dG9rZW46IGVudHJ5Lm1ldGFkYXRhKCl9KVxuICB9XG5cbiAgZXJyb3IocmVhc29uKXtcbiAgICBpZih0aGlzLmVycm9yZWQpeyByZXR1cm4gfVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5sZWF2ZSgpXG4gICAgdGhpcy5lcnJvcmVkID0gdHJ1ZVxuICAgIGNsZWFyVGltZW91dCh0aGlzLmNodW5rVGltZXIpXG4gICAgdGhpcy5lbnRyeS5lcnJvcihyZWFzb24pXG4gIH1cblxuICB1cGxvYWQoKXtcbiAgICB0aGlzLnVwbG9hZENoYW5uZWwub25FcnJvcihyZWFzb24gPT4gdGhpcy5lcnJvcihyZWFzb24pKVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5qb2luKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgX2RhdGEgPT4gdGhpcy5yZWFkTmV4dENodW5rKCkpXG4gICAgICAucmVjZWl2ZShcImVycm9yXCIsIHJlYXNvbiA9PiB0aGlzLmVycm9yKHJlYXNvbikpXG4gIH1cblxuICBpc0RvbmUoKXsgcmV0dXJuIHRoaXMub2Zmc2V0ID49IHRoaXMuZW50cnkuZmlsZS5zaXplIH1cblxuICByZWFkTmV4dENodW5rKCl7XG4gICAgbGV0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpXG4gICAgbGV0IGJsb2IgPSB0aGlzLmVudHJ5LmZpbGUuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMuY2h1bmtTaXplICsgdGhpcy5vZmZzZXQpXG4gICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICBpZihlLnRhcmdldC5lcnJvciA9PT0gbnVsbCl7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGUudGFyZ2V0LnJlc3VsdC5ieXRlTGVuZ3RoXG4gICAgICAgIHRoaXMucHVzaENodW5rKGUudGFyZ2V0LnJlc3VsdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsb2dFcnJvcihcIlJlYWQgZXJyb3I6IFwiICsgZS50YXJnZXQuZXJyb3IpXG4gICAgICB9XG4gICAgfVxuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKVxuICB9XG5cbiAgcHVzaENodW5rKGNodW5rKXtcbiAgICBpZighdGhpcy51cGxvYWRDaGFubmVsLmlzSm9pbmVkKCkpeyByZXR1cm4gfVxuICAgIHRoaXMudXBsb2FkQ2hhbm5lbC5wdXNoKFwiY2h1bmtcIiwgY2h1bmssIHRoaXMuY2h1bmtUaW1lb3V0KVxuICAgICAgLnJlY2VpdmUoXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZW50cnkucHJvZ3Jlc3MoKHRoaXMub2Zmc2V0IC8gdGhpcy5lbnRyeS5maWxlLnNpemUpICogMTAwKVxuICAgICAgICBpZighdGhpcy5pc0RvbmUoKSl7XG4gICAgICAgICAgdGhpcy5jaHVua1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlYWROZXh0Q2h1bmsoKSwgdGhpcy5saXZlU29ja2V0LmdldExhdGVuY3lTaW0oKSB8fCAwKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnJlY2VpdmUoXCJlcnJvclwiLCAoe3JlYXNvbn0pID0+IHRoaXMuZXJyb3IocmVhc29uKSlcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFBIWF9WSUVXX1NFTEVDVE9SXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBFbnRyeVVwbG9hZGVyIGZyb20gXCIuL2VudHJ5X3VwbG9hZGVyXCJcblxuZXhwb3J0IGxldCBsb2dFcnJvciA9IChtc2csIG9iaikgPT4gY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKG1zZywgb2JqKVxuXG5leHBvcnQgbGV0IGlzQ2lkID0gKGNpZCkgPT4ge1xuICBsZXQgdHlwZSA9IHR5cGVvZihjaWQpXG4gIHJldHVybiB0eXBlID09PSBcIm51bWJlclwiIHx8ICh0eXBlID09PSBcInN0cmluZ1wiICYmIC9eKDB8WzEtOV1cXGQqKSQvLnRlc3QoY2lkKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdER1cGxpY2F0ZUlkcygpe1xuICBsZXQgaWRzID0gbmV3IFNldCgpXG4gIGxldCBlbGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkXVwiKVxuICBmb3IobGV0IGkgPSAwLCBsZW4gPSBlbGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgaWYoaWRzLmhhcyhlbGVtc1tpXS5pZCkpe1xuICAgICAgY29uc29sZS5lcnJvcihgTXVsdGlwbGUgSURzIGRldGVjdGVkOiAke2VsZW1zW2ldLmlkfS4gRW5zdXJlIHVuaXF1ZSBlbGVtZW50IGlkcy5gKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZHMuYWRkKGVsZW1zW2ldLmlkKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0SW52YWxpZFN0cmVhbUluc2VydHMoaW5zZXJ0cyl7XG4gIGNvbnN0IGVycm9ycyA9IG5ldyBTZXQoKVxuICBPYmplY3Qua2V5cyhpbnNlcnRzKS5mb3JFYWNoKChpZCkgPT4ge1xuICAgIGNvbnN0IHN0cmVhbUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpXG4gICAgaWYoc3RyZWFtRWwgJiYgc3RyZWFtRWwucGFyZW50RWxlbWVudCAmJiBzdHJlYW1FbC5wYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcInBoeC11cGRhdGVcIikgIT09IFwic3RyZWFtXCIpe1xuICAgICAgZXJyb3JzLmFkZChgVGhlIHN0cmVhbSBjb250YWluZXIgd2l0aCBpZCBcIiR7c3RyZWFtRWwucGFyZW50RWxlbWVudC5pZH1cIiBpcyBtaXNzaW5nIHRoZSBwaHgtdXBkYXRlPVwic3RyZWFtXCIgYXR0cmlidXRlLiBFbnN1cmUgaXQgaXMgc2V0IGZvciBzdHJlYW1zIHRvIHdvcmsgcHJvcGVybHkuYClcbiAgICB9XG4gIH0pXG4gIGVycm9ycy5mb3JFYWNoKGVycm9yID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpKVxufVxuXG5leHBvcnQgbGV0IGRlYnVnID0gKHZpZXcsIGtpbmQsIG1zZywgb2JqKSA9PiB7XG4gIGlmKHZpZXcubGl2ZVNvY2tldC5pc0RlYnVnRW5hYmxlZCgpKXtcbiAgICBjb25zb2xlLmxvZyhgJHt2aWV3LmlkfSAke2tpbmR9OiAke21zZ30gLSBgLCBvYmopXG4gIH1cbn1cblxuLy8gd3JhcHMgdmFsdWUgaW4gY2xvc3VyZSBvciByZXR1cm5zIGNsb3N1cmVcbmV4cG9ydCBsZXQgY2xvc3VyZSA9ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIiA/IHZhbCA6IGZ1bmN0aW9uICgpeyByZXR1cm4gdmFsIH1cblxuZXhwb3J0IGxldCBjbG9uZSA9IChvYmopID0+IHsgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkgfVxuXG5leHBvcnQgbGV0IGNsb3Nlc3RQaHhCaW5kaW5nID0gKGVsLCBiaW5kaW5nLCBib3JkZXJFbCkgPT4ge1xuICBkbyB7XG4gICAgaWYoZWwubWF0Y2hlcyhgWyR7YmluZGluZ31dYCkgJiYgIWVsLmRpc2FibGVkKXsgcmV0dXJuIGVsIH1cbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZVxuICB9IHdoaWxlKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxICYmICEoKGJvcmRlckVsICYmIGJvcmRlckVsLmlzU2FtZU5vZGUoZWwpKSB8fCBlbC5tYXRjaGVzKFBIWF9WSUVXX1NFTEVDVE9SKSkpXG4gIHJldHVybiBudWxsXG59XG5cbmV4cG9ydCBsZXQgaXNPYmplY3QgPSAob2JqKSA9PiB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KVxufVxuXG5leHBvcnQgbGV0IGlzRXF1YWxPYmogPSAob2JqMSwgb2JqMikgPT4gSlNPTi5zdHJpbmdpZnkob2JqMSkgPT09IEpTT04uc3RyaW5naWZ5KG9iajIpXG5cbmV4cG9ydCBsZXQgaXNFbXB0eSA9IChvYmopID0+IHtcbiAgZm9yKGxldCB4IGluIG9iail7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBsZXQgbWF5YmUgPSAoZWwsIGNhbGxiYWNrKSA9PiBlbCAmJiBjYWxsYmFjayhlbClcblxuZXhwb3J0IGxldCBjaGFubmVsVXBsb2FkZXIgPSBmdW5jdGlvbiAoZW50cmllcywgb25FcnJvciwgcmVzcCwgbGl2ZVNvY2tldCl7XG4gIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgbGV0IGVudHJ5VXBsb2FkZXIgPSBuZXcgRW50cnlVcGxvYWRlcihlbnRyeSwgcmVzcC5jb25maWcsIGxpdmVTb2NrZXQpXG4gICAgZW50cnlVcGxvYWRlci51cGxvYWQoKVxuICB9KVxufVxuIiwgImxldCBCcm93c2VyID0ge1xuICBjYW5QdXNoU3RhdGUoKXsgcmV0dXJuICh0eXBlb2YgKGhpc3RvcnkucHVzaFN0YXRlKSAhPT0gXCJ1bmRlZmluZWRcIikgfSxcblxuICBkcm9wTG9jYWwobG9jYWxTdG9yYWdlLCBuYW1lc3BhY2UsIHN1YmtleSl7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKVxuICB9LFxuXG4gIHVwZGF0ZUxvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXksIGluaXRpYWwsIGZ1bmMpe1xuICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRMb2NhbChsb2NhbFN0b3JhZ2UsIG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBrZXkgPSB0aGlzLmxvY2FsS2V5KG5hbWVzcGFjZSwgc3Via2V5KVxuICAgIGxldCBuZXdWYWwgPSBjdXJyZW50ID09PSBudWxsID8gaW5pdGlhbCA6IGZ1bmMoY3VycmVudClcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KG5ld1ZhbCkpXG4gICAgcmV0dXJuIG5ld1ZhbFxuICB9LFxuXG4gIGdldExvY2FsKGxvY2FsU3RvcmFnZSwgbmFtZXNwYWNlLCBzdWJrZXkpe1xuICAgIHJldHVybiBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHRoaXMubG9jYWxLZXkobmFtZXNwYWNlLCBzdWJrZXkpKSlcbiAgfSxcblxuICB1cGRhdGVDdXJyZW50U3RhdGUoY2FsbGJhY2spe1xuICAgIGlmKCF0aGlzLmNhblB1c2hTdGF0ZSgpKXsgcmV0dXJuIH1cbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjYWxsYmFjayhoaXN0b3J5LnN0YXRlIHx8IHt9KSwgXCJcIiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIH0sXG5cbiAgcHVzaFN0YXRlKGtpbmQsIG1ldGEsIHRvKXtcbiAgICBpZih0aGlzLmNhblB1c2hTdGF0ZSgpKXtcbiAgICAgIGlmKHRvICE9PSB3aW5kb3cubG9jYXRpb24uaHJlZil7XG4gICAgICAgIGlmKG1ldGEudHlwZSA9PSBcInJlZGlyZWN0XCIgJiYgbWV0YS5zY3JvbGwpe1xuICAgICAgICAgIC8vIElmIHdlJ3JlIHJlZGlyZWN0aW5nIHN0b3JlIHRoZSBjdXJyZW50IHNjcm9sbFkgZm9yIHRoZSBjdXJyZW50IGhpc3Rvcnkgc3RhdGUuXG4gICAgICAgICAgbGV0IGN1cnJlbnRTdGF0ZSA9IGhpc3Rvcnkuc3RhdGUgfHwge31cbiAgICAgICAgICBjdXJyZW50U3RhdGUuc2Nyb2xsID0gbWV0YS5zY3JvbGxcbiAgICAgICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShjdXJyZW50U3RhdGUsIFwiXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIG1ldGEuc2Nyb2xsIC8vIE9ubHkgc3RvcmUgdGhlIHNjcm9sbCBpbiB0aGUgcmVkaXJlY3QgY2FzZS5cbiAgICAgICAgaGlzdG9yeVtraW5kICsgXCJTdGF0ZVwiXShtZXRhLCBcIlwiLCB0byB8fCBudWxsKSAvLyBJRSB3aWxsIGNvZXJjZSB1bmRlZmluZWQgdG8gc3RyaW5nXG5cbiAgICAgICAgLy8gd2hlbiB1c2luZyBuYXZpZ2F0ZSwgd2UnZCBjYWxsIHB1c2hTdGF0ZSBpbW1lZGlhdGVseSBiZWZvcmUgcGF0Y2hpbmcgdGhlIERPTSxcbiAgICAgICAgLy8ganVtcGluZyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGVmZmVjdGl2ZWx5IGlnbm9yaW5nIHRoZSBzY3JvbGxJbnRvVmlldztcbiAgICAgICAgLy8gdGhlcmVmb3JlIHdlIHdhaXQgZm9yIHRoZSBuZXh0IGZyYW1lIChhZnRlciB0aGUgRE9NIHBhdGNoKSBhbmQgb25seSB0aGVuIHRyeVxuICAgICAgICAvLyB0byBzY3JvbGwgdG8gdGhlIGhhc2hFbFxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBsZXQgaGFzaEVsID0gdGhpcy5nZXRIYXNoVGFyZ2V0RWwod2luZG93LmxvY2F0aW9uLmhhc2gpXG4gIFxuICAgICAgICAgIGlmKGhhc2hFbCl7XG4gICAgICAgICAgICBoYXNoRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICAgIH0gZWxzZSBpZihtZXRhLnR5cGUgPT09IFwicmVkaXJlY3RcIil7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIDApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZGlyZWN0KHRvKVxuICAgIH1cbiAgfSxcblxuICBzZXRDb29raWUobmFtZSwgdmFsdWUsIG1heEFnZVNlY29uZHMpe1xuICAgIGxldCBleHBpcmVzID0gdHlwZW9mKG1heEFnZVNlY29uZHMpID09PSBcIm51bWJlclwiID8gYCBtYXgtYWdlPSR7bWF4QWdlU2Vjb25kc307YCA6IFwiXCJcbiAgICBkb2N1bWVudC5jb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfTske2V4cGlyZXN9IHBhdGg9L2BcbiAgfSxcblxuICBnZXRDb29raWUobmFtZSl7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNvb2tpZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCg/Oig/Ol58Lio7XFxzKikke25hbWV9XFxzKlxcPVxccyooW147XSopLiokKXxeLiokYCksIFwiJDFcIilcbiAgfSxcblxuICBkZWxldGVDb29raWUobmFtZSl7XG4gICAgZG9jdW1lbnQuY29va2llID0gYCR7bmFtZX09OyBtYXgtYWdlPS0xOyBwYXRoPS9gXG4gIH0sXG5cbiAgcmVkaXJlY3QodG9VUkwsIGZsYXNoKXtcbiAgICBpZihmbGFzaCl7IHRoaXMuc2V0Q29va2llKFwiX19waG9lbml4X2ZsYXNoX19cIiwgZmxhc2gsIDYwKSB9XG4gICAgd2luZG93LmxvY2F0aW9uID0gdG9VUkxcbiAgfSxcblxuICBsb2NhbEtleShuYW1lc3BhY2UsIHN1YmtleSl7IHJldHVybiBgJHtuYW1lc3BhY2V9LSR7c3Via2V5fWAgfSxcblxuICBnZXRIYXNoVGFyZ2V0RWwobWF5YmVIYXNoKXtcbiAgICBsZXQgaGFzaCA9IG1heWJlSGFzaC50b1N0cmluZygpLnN1YnN0cmluZygxKVxuICAgIGlmKGhhc2ggPT09IFwiXCIpeyByZXR1cm4gfVxuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKSB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBhW25hbWU9XCIke2hhc2h9XCJdYClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCcm93c2VyXG4iLCAiaW1wb3J0IHtcbiAgQ0hFQ0tBQkxFX0lOUFVUUyxcbiAgREVCT1VOQ0VfUFJFVl9LRVksXG4gIERFQk9VTkNFX1RSSUdHRVIsXG4gIEZPQ1VTQUJMRV9JTlBVVFMsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9IQVNfRk9DVVNFRCxcbiAgUEhYX0hBU19TVUJNSVRURUQsXG4gIFBIWF9NQUlOLFxuICBQSFhfUEFSRU5UX0lELFxuICBQSFhfUFJJVkFURSxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9SRUZfTE9DSyxcbiAgUEhYX1BFTkRJTkdfQVRUUlMsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfU0VTU0lPTixcbiAgUEhYX1NUQVRJQyxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfU1RJQ0tZLFxuICBQSFhfRVZFTlRfQ0xBU1NFUyxcbiAgVEhST1RUTEVELFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBsb2dFcnJvclxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmxldCBET00gPSB7XG4gIGJ5SWQoaWQpeyByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpIHx8IGxvZ0Vycm9yKGBubyBpZCBmb3VuZCBmb3IgJHtpZH1gKSB9LFxuXG4gIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpe1xuICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgIGlmKGVsLmNsYXNzTGlzdC5sZW5ndGggPT09IDApeyBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKSB9XG4gIH0sXG5cbiAgYWxsKG5vZGUsIHF1ZXJ5LCBjYWxsYmFjayl7XG4gICAgaWYoIW5vZGUpeyByZXR1cm4gW10gfVxuICAgIGxldCBhcnJheSA9IEFycmF5LmZyb20obm9kZS5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KSlcbiAgICByZXR1cm4gY2FsbGJhY2sgPyBhcnJheS5mb3JFYWNoKGNhbGxiYWNrKSA6IGFycmF5XG4gIH0sXG5cbiAgY2hpbGROb2RlTGVuZ3RoKGh0bWwpe1xuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZEVsZW1lbnRDb3VudFxuICB9LFxuXG4gIGlzVXBsb2FkSW5wdXQoZWwpeyByZXR1cm4gZWwudHlwZSA9PT0gXCJmaWxlXCIgJiYgZWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSAhPT0gbnVsbCB9LFxuXG4gIGlzQXV0b1VwbG9hZChpbnB1dEVsKXsgcmV0dXJuIGlucHV0RWwuaGFzQXR0cmlidXRlKFwiZGF0YS1waHgtYXV0by11cGxvYWRcIikgfSxcblxuICBmaW5kVXBsb2FkSW5wdXRzKG5vZGUpe1xuICAgIGNvbnN0IGZvcm1JZCA9IG5vZGUuaWRcbiAgICBjb25zdCBpbnB1dHNPdXRzaWRlRm9ybSA9IHRoaXMuYWxsKGRvY3VtZW50LCBgaW5wdXRbdHlwZT1cImZpbGVcIl1bJHtQSFhfVVBMT0FEX1JFRn1dW2Zvcm09XCIke2Zvcm1JZH1cIl1gKVxuICAgIHJldHVybiB0aGlzLmFsbChub2RlLCBgaW5wdXRbdHlwZT1cImZpbGVcIl1bJHtQSFhfVVBMT0FEX1JFRn1dYCkuY29uY2F0KGlucHV0c091dHNpZGVGb3JtKVxuICB9LFxuXG4gIGZpbmRDb21wb25lbnROb2RlTGlzdChub2RlLCBjaWQpe1xuICAgIHJldHVybiB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChub2RlLCBgWyR7UEhYX0NPTVBPTkVOVH09XCIke2NpZH1cIl1gKSwgbm9kZSlcbiAgfSxcblxuICBpc1BoeERlc3Ryb3llZChub2RlKXtcbiAgICByZXR1cm4gbm9kZS5pZCAmJiBET00ucHJpdmF0ZShub2RlLCBcImRlc3Ryb3llZFwiKSA/IHRydWUgOiBmYWxzZVxuICB9LFxuXG4gIHdhbnRzTmV3VGFiKGUpe1xuICAgIGxldCB3YW50c05ld1RhYiA9IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5IHx8IGUubWV0YUtleSB8fCAoZS5idXR0b24gJiYgZS5idXR0b24gPT09IDEpXG4gICAgbGV0IGlzRG93bmxvYWQgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCAmJiBlLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkb3dubG9hZFwiKSlcbiAgICBsZXQgaXNUYXJnZXRCbGFuayA9IGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShcInRhcmdldFwiKSAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJfYmxhbmtcIlxuICAgIGxldCBpc1RhcmdldE5hbWVkVGFiID0gZS50YXJnZXQuaGFzQXR0cmlidXRlKFwidGFyZ2V0XCIpICYmICFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIikuc3RhcnRzV2l0aChcIl9cIilcbiAgICByZXR1cm4gd2FudHNOZXdUYWIgfHwgaXNUYXJnZXRCbGFuayB8fCBpc0Rvd25sb2FkIHx8IGlzVGFyZ2V0TmFtZWRUYWJcbiAgfSxcblxuICBpc1VubG9hZGFibGVGb3JtU3VibWl0KGUpe1xuICAgIC8vIElnbm9yZSBmb3JtIHN1Ym1pc3Npb25zIGludGVuZGVkIHRvIGNsb3NlIGEgbmF0aXZlIDxkaWFsb2c+IGVsZW1lbnRcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvZGlhbG9nI3VzYWdlX25vdGVzXG4gICAgbGV0IGlzRGlhbG9nU3VibWl0ID0gKGUudGFyZ2V0ICYmIGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSA9PT0gXCJkaWFsb2dcIikgfHxcbiAgICAgIChlLnN1Ym1pdHRlciAmJiBlLnN1Ym1pdHRlci5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpID09PSBcImRpYWxvZ1wiKVxuXG4gICAgaWYoaXNEaWFsb2dTdWJtaXQpe1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAhZS5kZWZhdWx0UHJldmVudGVkICYmICF0aGlzLndhbnRzTmV3VGFiKGUpXG4gICAgfVxuICB9LFxuXG4gIGlzTmV3UGFnZUNsaWNrKGUsIGN1cnJlbnRMb2NhdGlvbil7XG4gICAgbGV0IGhyZWYgPSBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50ID8gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA6IG51bGxcbiAgICBsZXQgdXJsXG5cbiAgICBpZihlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgaHJlZiA9PT0gbnVsbCB8fCB0aGlzLndhbnRzTmV3VGFiKGUpKXsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZihocmVmLnN0YXJ0c1dpdGgoXCJtYWlsdG86XCIpIHx8IGhyZWYuc3RhcnRzV2l0aChcInRlbDpcIikpeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmKGUudGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgIHRyeSB7XG4gICAgICB1cmwgPSBuZXcgVVJMKGhyZWYpXG4gICAgfSBjYXRjaCB7XG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKGhyZWYsIGN1cnJlbnRMb2NhdGlvbilcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBiYWQgVVJMLCBmYWxsYmFjayB0byBsZXQgYnJvd3NlciB0cnkgaXQgYXMgZXh0ZXJuYWxcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZih1cmwuaG9zdCA9PT0gY3VycmVudExvY2F0aW9uLmhvc3QgJiYgdXJsLnByb3RvY29sID09PSBjdXJyZW50TG9jYXRpb24ucHJvdG9jb2wpe1xuICAgICAgaWYodXJsLnBhdGhuYW1lID09PSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUgJiYgdXJsLnNlYXJjaCA9PT0gY3VycmVudExvY2F0aW9uLnNlYXJjaCl7XG4gICAgICAgIHJldHVybiB1cmwuaGFzaCA9PT0gXCJcIiAmJiAhdXJsLmhyZWYuZW5kc1dpdGgoXCIjXCIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1cmwucHJvdG9jb2wuc3RhcnRzV2l0aChcImh0dHBcIilcbiAgfSxcblxuICBtYXJrUGh4Q2hpbGREZXN0cm95ZWQoZWwpe1xuICAgIGlmKHRoaXMuaXNQaHhDaGlsZChlbCkpeyBlbC5zZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04sIFwiXCIpIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIFwiZGVzdHJveWVkXCIsIHRydWUpXG4gIH0sXG5cbiAgZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCBwYXJlbnRJZCl7XG4gICAgbGV0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpXG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbFxuICAgIHJldHVybiB0aGlzLmZpbmRQaHhDaGlsZHJlbih0ZW1wbGF0ZS5jb250ZW50LCBwYXJlbnRJZClcbiAgfSxcblxuICBpc0lnbm9yZWQoZWwsIHBoeFVwZGF0ZSl7XG4gICAgcmV0dXJuIChlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSB8fCBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC11cGRhdGVcIikpID09PSBcImlnbm9yZVwiXG4gIH0sXG5cbiAgaXNQaHhVcGRhdGUoZWwsIHBoeFVwZGF0ZSwgdXBkYXRlVHlwZXMpe1xuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUgJiYgdXBkYXRlVHlwZXMuaW5kZXhPZihlbC5nZXRBdHRyaWJ1dGUocGh4VXBkYXRlKSkgPj0gMFxuICB9LFxuXG4gIGZpbmRQaHhTdGlja3koZWwpeyByZXR1cm4gdGhpcy5hbGwoZWwsIGBbJHtQSFhfU1RJQ0tZfV1gKSB9LFxuXG4gIGZpbmRQaHhDaGlsZHJlbihlbCwgcGFyZW50SWQpe1xuICAgIHJldHVybiB0aGlzLmFsbChlbCwgYCR7UEhYX1ZJRVdfU0VMRUNUT1J9WyR7UEhYX1BBUkVOVF9JRH09XCIke3BhcmVudElkfVwiXWApXG4gIH0sXG5cbiAgZmluZEV4aXN0aW5nUGFyZW50Q0lEcyhub2RlLCBjaWRzKXtcbiAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gZmluZCBwYXJlbnRzIHRoYXQgZXhpc3Qgb24gdGhlIHBhZ2VcbiAgICAvLyBpZiBhIGNpZCBpcyBub3Qgb24gdGhlIHBhZ2UsIHRoZSBvbmx5IHdheSBpdCBjYW4gYmUgYWRkZWQgYmFjayB0byB0aGUgcGFnZVxuICAgIC8vIGlzIGlmIGEgcGFyZW50IGFkZHMgaXQgYmFjaywgdGhlcmVmb3JlIGlmIGEgY2lkIGRvZXMgbm90IGV4aXN0IG9uIHRoZSBwYWdlLFxuICAgIC8vIHdlIHNob3VsZCBub3QgdHJ5IHRvIHJlbmRlciBpdCBieSBpdHNlbGYgKGJlY2F1c2UgaXQgd291bGQgYmUgcmVuZGVyZWQgdHdpY2UsXG4gICAgLy8gb25lIGJ5IHRoZSBwYXJlbnQsIGFuZCBhIHNlY29uZCB0aW1lIGJ5IGl0c2VsZilcbiAgICBsZXQgcGFyZW50Q2lkcyA9IG5ldyBTZXQoKVxuICAgIGxldCBjaGlsZHJlbkNpZHMgPSBuZXcgU2V0KClcblxuICAgIGNpZHMuZm9yRWFjaChjaWQgPT4ge1xuICAgICAgdGhpcy5maWx0ZXJXaXRoaW5TYW1lTGl2ZVZpZXcodGhpcy5hbGwobm9kZSwgYFske1BIWF9DT01QT05FTlR9PVwiJHtjaWR9XCJdYCksIG5vZGUpLmZvckVhY2gocGFyZW50ID0+IHtcbiAgICAgICAgcGFyZW50Q2lkcy5hZGQoY2lkKVxuICAgICAgICB0aGlzLmZpbHRlcldpdGhpblNhbWVMaXZlVmlldyh0aGlzLmFsbChwYXJlbnQsIGBbJHtQSFhfQ09NUE9ORU5UfV1gKSwgcGFyZW50KVxuICAgICAgICAgIC5tYXAoZWwgPT4gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9DT01QT05FTlQpKSlcbiAgICAgICAgICAuZm9yRWFjaChjaGlsZENJRCA9PiBjaGlsZHJlbkNpZHMuYWRkKGNoaWxkQ0lEKSlcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGNoaWxkcmVuQ2lkcy5mb3JFYWNoKGNoaWxkQ2lkID0+IHBhcmVudENpZHMuZGVsZXRlKGNoaWxkQ2lkKSlcblxuICAgIHJldHVybiBwYXJlbnRDaWRzXG4gIH0sXG5cbiAgZmlsdGVyV2l0aGluU2FtZUxpdmVWaWV3KG5vZGVzLCBwYXJlbnQpe1xuICAgIGlmKHBhcmVudC5xdWVyeVNlbGVjdG9yKFBIWF9WSUVXX1NFTEVDVE9SKSl7XG4gICAgICByZXR1cm4gbm9kZXMuZmlsdGVyKGVsID0+IHRoaXMud2l0aGluU2FtZUxpdmVWaWV3KGVsLCBwYXJlbnQpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gIH0sXG5cbiAgd2l0aGluU2FtZUxpdmVWaWV3KG5vZGUsIHBhcmVudCl7XG4gICAgd2hpbGUobm9kZSA9IG5vZGUucGFyZW50Tm9kZSl7XG4gICAgICBpZihub2RlLmlzU2FtZU5vZGUocGFyZW50KSl7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmKG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSAhPT0gbnVsbCl7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICB9LFxuXG4gIHByaXZhdGUoZWwsIGtleSl7IHJldHVybiBlbFtQSFhfUFJJVkFURV0gJiYgZWxbUEhYX1BSSVZBVEVdW2tleV0gfSxcblxuICBkZWxldGVQcml2YXRlKGVsLCBrZXkpeyBlbFtQSFhfUFJJVkFURV0gJiYgZGVsZXRlIChlbFtQSFhfUFJJVkFURV1ba2V5XSkgfSxcblxuICBwdXRQcml2YXRlKGVsLCBrZXksIHZhbHVlKXtcbiAgICBpZighZWxbUEhYX1BSSVZBVEVdKXsgZWxbUEhYX1BSSVZBVEVdID0ge30gfVxuICAgIGVsW1BIWF9QUklWQVRFXVtrZXldID0gdmFsdWVcbiAgfSxcblxuICB1cGRhdGVQcml2YXRlKGVsLCBrZXksIGRlZmF1bHRWYWwsIHVwZGF0ZUZ1bmMpe1xuICAgIGxldCBleGlzdGluZyA9IHRoaXMucHJpdmF0ZShlbCwga2V5KVxuICAgIGlmKGV4aXN0aW5nID09PSB1bmRlZmluZWQpe1xuICAgICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIHVwZGF0ZUZ1bmMoZGVmYXVsdFZhbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwga2V5LCB1cGRhdGVGdW5jKGV4aXN0aW5nKSlcbiAgICB9XG4gIH0sXG5cbiAgc3luY1BlbmRpbmdBdHRycyhmcm9tRWwsIHRvRWwpe1xuICAgIGlmKCFmcm9tRWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSl7IHJldHVybiB9XG4gICAgUEhYX0VWRU5UX0NMQVNTRVMuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgZnJvbUVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpICYmIHRvRWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgfSlcbiAgICBQSFhfUEVORElOR19BVFRSUy5maWx0ZXIoYXR0ciA9PiBmcm9tRWwuaGFzQXR0cmlidXRlKGF0dHIpKS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoYXR0ciwgZnJvbUVsLmdldEF0dHJpYnV0ZShhdHRyKSlcbiAgICB9KVxuICB9LFxuXG4gIGNvcHlQcml2YXRlcyh0YXJnZXQsIHNvdXJjZSl7XG4gICAgaWYoc291cmNlW1BIWF9QUklWQVRFXSl7XG4gICAgICB0YXJnZXRbUEhYX1BSSVZBVEVdID0gc291cmNlW1BIWF9QUklWQVRFXVxuICAgIH1cbiAgfSxcblxuICBwdXRUaXRsZShzdHIpe1xuICAgIGxldCB0aXRsZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpXG4gICAgaWYodGl0bGVFbCl7XG4gICAgICBsZXQge3ByZWZpeCwgc3VmZml4LCBkZWZhdWx0OiBkZWZhdWx0VGl0bGV9ID0gdGl0bGVFbC5kYXRhc2V0XG4gICAgICBsZXQgaXNFbXB0eSA9IHR5cGVvZihzdHIpICE9PSBcInN0cmluZ1wiIHx8IHN0ci50cmltKCkgPT09IFwiXCJcbiAgICAgIGlmKGlzRW1wdHkgJiYgdHlwZW9mKGRlZmF1bHRUaXRsZSkgIT09IFwic3RyaW5nXCIpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgaW5uZXIgPSBpc0VtcHR5ID8gZGVmYXVsdFRpdGxlIDogc3RyXG4gICAgICBkb2N1bWVudC50aXRsZSA9IGAke3ByZWZpeCB8fCBcIlwifSR7aW5uZXIgfHwgXCJcIn0ke3N1ZmZpeCB8fCBcIlwifWBcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQudGl0bGUgPSBzdHJcbiAgICB9XG4gIH0sXG5cbiAgZGVib3VuY2UoZWwsIGV2ZW50LCBwaHhEZWJvdW5jZSwgZGVmYXVsdERlYm91bmNlLCBwaHhUaHJvdHRsZSwgZGVmYXVsdFRocm90dGxlLCBhc3luY0ZpbHRlciwgY2FsbGJhY2spe1xuICAgIGxldCBkZWJvdW5jZSA9IGVsLmdldEF0dHJpYnV0ZShwaHhEZWJvdW5jZSlcbiAgICBsZXQgdGhyb3R0bGUgPSBlbC5nZXRBdHRyaWJ1dGUocGh4VGhyb3R0bGUpXG5cbiAgICBpZihkZWJvdW5jZSA9PT0gXCJcIil7IGRlYm91bmNlID0gZGVmYXVsdERlYm91bmNlIH1cbiAgICBpZih0aHJvdHRsZSA9PT0gXCJcIil7IHRocm90dGxlID0gZGVmYXVsdFRocm90dGxlIH1cbiAgICBsZXQgdmFsdWUgPSBkZWJvdW5jZSB8fCB0aHJvdHRsZVxuICAgIHN3aXRjaCh2YWx1ZSl7XG4gICAgICBjYXNlIG51bGw6IHJldHVybiBjYWxsYmFjaygpXG5cbiAgICAgIGNhc2UgXCJibHVyXCI6XG4gICAgICAgIHRoaXMuaW5jQ3ljbGUoZWwsIFwiZGVib3VuY2UtYmx1ci1jeWNsZVwiLCAoKSA9PiB7XG4gICAgICAgICAgaWYoYXN5bmNGaWx0ZXIoKSl7IGNhbGxiYWNrKCkgfVxuICAgICAgICB9KVxuICAgICAgICBpZih0aGlzLm9uY2UoZWwsIFwiZGVib3VuY2UtYmx1clwiKSl7XG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gdGhpcy50cmlnZ2VyQ3ljbGUoZWwsIFwiZGVib3VuY2UtYmx1ci1jeWNsZVwiKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBwYXJzZUludCh2YWx1ZSlcbiAgICAgICAgbGV0IHRyaWdnZXIgPSAoKSA9PiB0aHJvdHRsZSA/IHRoaXMuZGVsZXRlUHJpdmF0ZShlbCwgVEhST1RUTEVEKSA6IGNhbGxiYWNrKClcbiAgICAgICAgbGV0IGN1cnJlbnRDeWNsZSA9IHRoaXMuaW5jQ3ljbGUoZWwsIERFQk9VTkNFX1RSSUdHRVIsIHRyaWdnZXIpXG4gICAgICAgIGlmKGlzTmFOKHRpbWVvdXQpKXsgcmV0dXJuIGxvZ0Vycm9yKGBpbnZhbGlkIHRocm90dGxlL2RlYm91bmNlIHZhbHVlOiAke3ZhbHVlfWApIH1cbiAgICAgICAgaWYodGhyb3R0bGUpe1xuICAgICAgICAgIGxldCBuZXdLZXlEb3duID0gZmFsc2VcbiAgICAgICAgICBpZihldmVudC50eXBlID09PSBcImtleWRvd25cIil7XG4gICAgICAgICAgICBsZXQgcHJldktleSA9IHRoaXMucHJpdmF0ZShlbCwgREVCT1VOQ0VfUFJFVl9LRVkpXG4gICAgICAgICAgICB0aGlzLnB1dFByaXZhdGUoZWwsIERFQk9VTkNFX1BSRVZfS0VZLCBldmVudC5rZXkpXG4gICAgICAgICAgICBuZXdLZXlEb3duID0gcHJldktleSAhPT0gZXZlbnQua2V5XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIW5ld0tleURvd24gJiYgdGhpcy5wcml2YXRlKGVsLCBUSFJPVFRMRUQpKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUikgfVxuICAgICAgICAgICAgfSwgdGltZW91dClcbiAgICAgICAgICAgIHRoaXMucHV0UHJpdmF0ZShlbCwgVEhST1RUTEVELCB0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmKGFzeW5jRmlsdGVyKCkpeyB0aGlzLnRyaWdnZXJDeWNsZShlbCwgREVCT1VOQ0VfVFJJR0dFUiwgY3VycmVudEN5Y2xlKSB9XG4gICAgICAgICAgfSwgdGltZW91dClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmb3JtID0gZWwuZm9ybVxuICAgICAgICBpZihmb3JtICYmIHRoaXMub25jZShmb3JtLCBcImJpbmQtZGVib3VuY2VcIikpe1xuICAgICAgICAgIGZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBBcnJheS5mcm9tKChuZXcgRm9ybURhdGEoZm9ybSkpLmVudHJpZXMoKSwgKFtuYW1lXSkgPT4ge1xuICAgICAgICAgICAgICBsZXQgaW5wdXQgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoYFtuYW1lPVwiJHtuYW1lfVwiXWApXG4gICAgICAgICAgICAgIHRoaXMuaW5jQ3ljbGUoaW5wdXQsIERFQk9VTkNFX1RSSUdHRVIpXG4gICAgICAgICAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgVEhST1RUTEVEKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMub25jZShlbCwgXCJiaW5kLWRlYm91bmNlXCIpKXtcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIHRyaWdnZXIgdGhlIGNhbGxiYWNrIGhlcmUsXG4gICAgICAgICAgICAvLyB3ZSBhbHNvIGNsZWFyIHRoZSB0aHJvdHRsZSB0aW1lb3V0IHRvIHByZXZlbnQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAvLyBmcm9tIGJlaW5nIGNhbGxlZCBhZ2FpbiBhZnRlciB0aGUgdGltZW91dCBmaXJlc1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucHJpdmF0ZShlbCwgVEhST1RUTEVEKSlcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN5Y2xlKGVsLCBERUJPVU5DRV9UUklHR0VSKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJpZ2dlckN5Y2xlKGVsLCBrZXksIGN1cnJlbnRDeWNsZSl7XG4gICAgbGV0IFtjeWNsZSwgdHJpZ2dlcl0gPSB0aGlzLnByaXZhdGUoZWwsIGtleSlcbiAgICBpZighY3VycmVudEN5Y2xlKXsgY3VycmVudEN5Y2xlID0gY3ljbGUgfVxuICAgIGlmKGN1cnJlbnRDeWNsZSA9PT0gY3ljbGUpe1xuICAgICAgdGhpcy5pbmNDeWNsZShlbCwga2V5KVxuICAgICAgdHJpZ2dlcigpXG4gICAgfVxuICB9LFxuXG4gIG9uY2UoZWwsIGtleSl7XG4gICAgaWYodGhpcy5wcml2YXRlKGVsLCBrZXkpID09PSB0cnVlKXsgcmV0dXJuIGZhbHNlIH1cbiAgICB0aGlzLnB1dFByaXZhdGUoZWwsIGtleSwgdHJ1ZSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9LFxuXG4gIGluY0N5Y2xlKGVsLCBrZXksIHRyaWdnZXIgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgbGV0IFtjdXJyZW50Q3ljbGVdID0gdGhpcy5wcml2YXRlKGVsLCBrZXkpIHx8IFswLCB0cmlnZ2VyXVxuICAgIGN1cnJlbnRDeWNsZSsrXG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBrZXksIFtjdXJyZW50Q3ljbGUsIHRyaWdnZXJdKVxuICAgIHJldHVybiBjdXJyZW50Q3ljbGVcbiAgfSxcblxuICAvLyBtYWludGFpbnMgb3IgYWRkcyBwcml2YXRlbHkgdXNlZCBob29rIGluZm9ybWF0aW9uXG4gIC8vIGZyb21FbCBhbmQgdG9FbCBjYW4gYmUgdGhlIHNhbWUgZWxlbWVudCBpbiB0aGUgY2FzZSBvZiBhIG5ld2x5IGFkZGVkIG5vZGVcbiAgLy8gZnJvbUVsIGFuZCB0b0VsIGNhbiBiZSBhbnkgSFRNTCBub2RlIHR5cGUsIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBhbiBlbGVtZW50IG5vZGVcbiAgbWFpbnRhaW5Qcml2YXRlSG9va3MoZnJvbUVsLCB0b0VsLCBwaHhWaWV3cG9ydFRvcCwgcGh4Vmlld3BvcnRCb3R0b20pe1xuICAgIC8vIG1haW50YWluIHRoZSBob29rcyBjcmVhdGVkIHdpdGggY3JlYXRlSG9va1xuICAgIGlmKGZyb21FbC5oYXNBdHRyaWJ1dGUgJiYgZnJvbUVsLmhhc0F0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIikgJiYgIXRvRWwuaGFzQXR0cmlidXRlKFwiZGF0YS1waHgtaG9va1wiKSl7XG4gICAgICB0b0VsLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIiwgZnJvbUVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIikpXG4gICAgfVxuICAgIC8vIGFkZCBob29rcyB0byBlbGVtZW50cyB3aXRoIHZpZXdwb3J0IGF0dHJpYnV0ZXNcbiAgICBpZih0b0VsLmhhc0F0dHJpYnV0ZSAmJiAodG9FbC5oYXNBdHRyaWJ1dGUocGh4Vmlld3BvcnRUb3ApIHx8IHRvRWwuaGFzQXR0cmlidXRlKHBoeFZpZXdwb3J0Qm90dG9tKSkpe1xuICAgICAgdG9FbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBoeC1ob29rXCIsIFwiUGhvZW5peC5JbmZpbml0ZVNjcm9sbFwiKVxuICAgIH1cbiAgfSxcblxuICBwdXRDdXN0b21FbEhvb2soZWwsIGhvb2spe1xuICAgIGlmKGVsLmlzQ29ubmVjdGVkKXtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcImRhdGEtcGh4LWhvb2tcIiwgXCJcIilcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgXG4gICAgICAgIGhvb2sgYXR0YWNoZWQgdG8gbm9uLWNvbm5lY3RlZCBET00gZWxlbWVudFxuICAgICAgICBlbnN1cmUgeW91IGFyZSBjYWxsaW5nIGNyZWF0ZUhvb2sgd2l0aGluIHlvdXIgY29ubmVjdGVkQ2FsbGJhY2suICR7ZWwub3V0ZXJIVE1MfVxuICAgICAgYClcbiAgICB9XG4gICAgdGhpcy5wdXRQcml2YXRlKGVsLCBcImN1c3RvbS1lbC1ob29rXCIsIGhvb2spXG4gIH0sXG5cbiAgZ2V0Q3VzdG9tRWxIb29rKGVsKXsgcmV0dXJuIHRoaXMucHJpdmF0ZShlbCwgXCJjdXN0b20tZWwtaG9va1wiKSB9LFxuXG4gIGlzVXNlZElucHV0KGVsKXtcbiAgICByZXR1cm4gKGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJlxuICAgICAgKHRoaXMucHJpdmF0ZShlbCwgUEhYX0hBU19GT0NVU0VEKSB8fCB0aGlzLnByaXZhdGUoZWwsIFBIWF9IQVNfU1VCTUlUVEVEKSkpXG4gIH0sXG5cbiAgcmVzZXRGb3JtKGZvcm0pe1xuICAgIEFycmF5LmZyb20oZm9ybS5lbGVtZW50cykuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICB0aGlzLmRlbGV0ZVByaXZhdGUoaW5wdXQsIFBIWF9IQVNfRk9DVVNFRClcbiAgICAgIHRoaXMuZGVsZXRlUHJpdmF0ZShpbnB1dCwgUEhYX0hBU19TVUJNSVRURUQpXG4gICAgfSlcbiAgfSxcblxuICBpc1BoeENoaWxkKG5vZGUpe1xuICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKVxuICB9LFxuXG4gIGlzUGh4U3RpY2t5KG5vZGUpe1xuICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShQSFhfU1RJQ0tZKSAhPT0gbnVsbFxuICB9LFxuXG4gIGlzQ2hpbGRPZkFueShlbCwgcGFyZW50cyl7XG4gICAgcmV0dXJuICEhcGFyZW50cy5maW5kKHBhcmVudCA9PiBwYXJlbnQuY29udGFpbnMoZWwpKVxuICB9LFxuXG4gIGZpcnN0UGh4Q2hpbGQoZWwpe1xuICAgIHJldHVybiB0aGlzLmlzUGh4Q2hpbGQoZWwpID8gZWwgOiB0aGlzLmFsbChlbCwgYFske1BIWF9QQVJFTlRfSUR9XWApWzBdXG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudCh0YXJnZXQsIG5hbWUsIG9wdHMgPSB7fSl7XG4gICAgbGV0IGRlZmF1bHRCdWJibGUgPSB0cnVlXG4gICAgbGV0IGlzVXBsb2FkVGFyZ2V0ID0gdGFyZ2V0Lm5vZGVOYW1lID09PSBcIklOUFVUXCIgJiYgdGFyZ2V0LnR5cGUgPT09IFwiZmlsZVwiXG4gICAgaWYoaXNVcGxvYWRUYXJnZXQgJiYgbmFtZSA9PT0gXCJjbGlja1wiKXtcbiAgICAgIGRlZmF1bHRCdWJibGUgPSBmYWxzZVxuICAgIH1cbiAgICBsZXQgYnViYmxlcyA9IG9wdHMuYnViYmxlcyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdEJ1YmJsZSA6ICEhb3B0cy5idWJibGVzXG4gICAgbGV0IGV2ZW50T3B0cyA9IHtidWJibGVzOiBidWJibGVzLCBjYW5jZWxhYmxlOiB0cnVlLCBkZXRhaWw6IG9wdHMuZGV0YWlsIHx8IHt9fVxuICAgIGxldCBldmVudCA9IG5hbWUgPT09IFwiY2xpY2tcIiA/IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIiwgZXZlbnRPcHRzKSA6IG5ldyBDdXN0b21FdmVudChuYW1lLCBldmVudE9wdHMpXG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gIH0sXG5cbiAgY2xvbmVOb2RlKG5vZGUsIGh0bWwpe1xuICAgIGlmKHR5cGVvZiAoaHRtbCkgPT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjbG9uZWQgPSBub2RlLmNsb25lTm9kZShmYWxzZSlcbiAgICAgIGNsb25lZC5pbm5lckhUTUwgPSBodG1sXG4gICAgICByZXR1cm4gY2xvbmVkXG4gICAgfVxuICB9LFxuXG4gIC8vIG1lcmdlIGF0dHJpYnV0ZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0XG4gIC8vIGlmIGFuIGVsZW1lbnQgaXMgaWdub3JlZCwgd2Ugb25seSBtZXJnZSBkYXRhIGF0dHJpYnV0ZXNcbiAgLy8gaW5jbHVkaW5nIHJlbW92aW5nIGRhdGEgYXR0cmlidXRlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIHNvdXJjZVxuICBtZXJnZUF0dHJzKHRhcmdldCwgc291cmNlLCBvcHRzID0ge30pe1xuICAgIGxldCBleGNsdWRlID0gbmV3IFNldChvcHRzLmV4Y2x1ZGUgfHwgW10pXG4gICAgbGV0IGlzSWdub3JlZCA9IG9wdHMuaXNJZ25vcmVkXG4gICAgbGV0IHNvdXJjZUF0dHJzID0gc291cmNlLmF0dHJpYnV0ZXNcbiAgICBmb3IobGV0IGkgPSBzb3VyY2VBdHRycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICBsZXQgbmFtZSA9IHNvdXJjZUF0dHJzW2ldLm5hbWVcbiAgICAgIGlmKCFleGNsdWRlLmhhcyhuYW1lKSl7XG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlLmdldEF0dHJpYnV0ZShuYW1lKVxuICAgICAgICBpZih0YXJnZXQuZ2V0QXR0cmlidXRlKG5hbWUpICE9PSBzb3VyY2VWYWx1ZSAmJiAoIWlzSWdub3JlZCB8fCAoaXNJZ25vcmVkICYmIG5hbWUuc3RhcnRzV2l0aChcImRhdGEtXCIpKSkpe1xuICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUobmFtZSwgc291cmNlVmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGV4Y2x1ZGUgdGhlIHZhbHVlIGZyb20gYmVpbmcgbWVyZ2VkIG9uIGZvY3VzZWQgaW5wdXRzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyB1c2VyJ3MgaW5wdXQgc2hvdWxkIGFsd2F5cyB3aW4uXG4gICAgICAgIC8vIFdlIGNhbiBzdGlsbCBhc3NpZ24gaXQgYXMgbG9uZyBhcyB0aGUgdmFsdWUgcHJvcGVydHkgaXMgdGhlIHNhbWUsIHRob3VnaC5cbiAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBhIHNpdHVhdGlvbiB3aGVyZSB0aGUgdXBkYXRlZCBob29rIGlzIG5vdCBiZWluZyB0cmlnZ2VyZWRcbiAgICAgICAgLy8gd2hlbiBhbiBpbnB1dCBpcyBiYWNrIGluIGl0cyBcIm9yaWdpbmFsIHN0YXRlXCIsIGJlY2F1c2UgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAvLyB3YXMgbmV2ZXIgY2hhbmdlZCwgc2VlOlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4X2xpdmVfdmlldy9pc3N1ZXMvMjE2M1xuICAgICAgICBpZihuYW1lID09PSBcInZhbHVlXCIgJiYgdGFyZ2V0LnZhbHVlID09PSBzb3VyY2UudmFsdWUpe1xuICAgICAgICAgIC8vIGFjdHVhbGx5IHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHN5bmMgaXQgd2l0aCB0aGUgdmFsdWUgcHJvcGVydHlcbiAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc291cmNlLmdldEF0dHJpYnV0ZShuYW1lKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB0YXJnZXRBdHRycyA9IHRhcmdldC5hdHRyaWJ1dGVzXG4gICAgZm9yKGxldCBpID0gdGFyZ2V0QXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgbGV0IG5hbWUgPSB0YXJnZXRBdHRyc1tpXS5uYW1lXG4gICAgICBpZihpc0lnbm9yZWQpe1xuICAgICAgICBpZihuYW1lLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSAmJiAhc291cmNlLmhhc0F0dHJpYnV0ZShuYW1lKSAmJiAhUEhYX1BFTkRJTkdfQVRUUlMuaW5jbHVkZXMobmFtZSkpeyB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKG5hbWUpIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKCFzb3VyY2UuaGFzQXR0cmlidXRlKG5hbWUpKXsgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShuYW1lKSB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1lcmdlRm9jdXNlZElucHV0KHRhcmdldCwgc291cmNlKXtcbiAgICAvLyBza2lwIHNlbGVjdHMgYmVjYXVzZSBGRiB3aWxsIHJlc2V0IGhpZ2hsaWdodGVkIGluZGV4IGZvciBhbnkgc2V0QXR0cmlidXRlXG4gICAgaWYoISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MU2VsZWN0RWxlbWVudCkpeyBET00ubWVyZ2VBdHRycyh0YXJnZXQsIHNvdXJjZSwge2V4Y2x1ZGU6IFtcInZhbHVlXCJdfSkgfVxuXG4gICAgaWYoc291cmNlLnJlYWRPbmx5KXtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwicmVhZG9ubHlcIilcbiAgICB9XG4gIH0sXG5cbiAgaGFzU2VsZWN0aW9uUmFuZ2UoZWwpe1xuICAgIHJldHVybiBlbC5zZXRTZWxlY3Rpb25SYW5nZSAmJiAoZWwudHlwZSA9PT0gXCJ0ZXh0XCIgfHwgZWwudHlwZSA9PT0gXCJ0ZXh0YXJlYVwiKVxuICB9LFxuXG4gIHJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKXtcbiAgICBpZihmb2N1c2VkIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpeyBmb2N1c2VkLmZvY3VzKCkgfVxuICAgIGlmKCFET00uaXNUZXh0dWFsSW5wdXQoZm9jdXNlZCkpeyByZXR1cm4gfVxuXG4gICAgbGV0IHdhc0ZvY3VzZWQgPSBmb2N1c2VkLm1hdGNoZXMoXCI6Zm9jdXNcIilcbiAgICBpZighd2FzRm9jdXNlZCl7IGZvY3VzZWQuZm9jdXMoKSB9XG4gICAgaWYodGhpcy5oYXNTZWxlY3Rpb25SYW5nZShmb2N1c2VkKSl7XG4gICAgICBmb2N1c2VkLnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpXG4gICAgfVxuICB9LFxuXG4gIGlzRm9ybUlucHV0KGVsKXsgcmV0dXJuIC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhKSQvaS50ZXN0KGVsLnRhZ05hbWUpICYmIGVsLnR5cGUgIT09IFwiYnV0dG9uXCIgfSxcblxuICBzeW5jQXR0cnNUb1Byb3BzKGVsKXtcbiAgICBpZihlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgJiYgQ0hFQ0tBQkxFX0lOUFVUUy5pbmRleE9mKGVsLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkgPj0gMCl7XG4gICAgICBlbC5jaGVja2VkID0gZWwuZ2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiKSAhPT0gbnVsbFxuICAgIH1cbiAgfSxcblxuICBpc1RleHR1YWxJbnB1dChlbCl7IHJldHVybiBGT0NVU0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCB9LFxuXG4gIGlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKXtcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShwaHhUcmlnZ2VyRXh0ZXJuYWwpICE9PSBudWxsICYmIGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWwpXG4gIH0sXG5cbiAgY2xlYW5DaGlsZE5vZGVzKGNvbnRhaW5lciwgcGh4VXBkYXRlKXtcbiAgICBpZihET00uaXNQaHhVcGRhdGUoY29udGFpbmVyLCBwaHhVcGRhdGUsIFtcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgIGxldCB0b1JlbW92ZSA9IFtdXG4gICAgICBjb250YWluZXIuY2hpbGROb2Rlcy5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgIGlmKCFjaGlsZE5vZGUuaWQpe1xuICAgICAgICAgIC8vIFNraXAgd2FybmluZyBpZiBpdCdzIGFuIGVtcHR5IHRleHQgbm9kZSAoZS5nLiBhIG5ldy1saW5lKVxuICAgICAgICAgIGxldCBpc0VtcHR5VGV4dE5vZGUgPSBjaGlsZE5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFICYmIGNoaWxkTm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSBcIlwiXG4gICAgICAgICAgaWYoIWlzRW1wdHlUZXh0Tm9kZSAmJiBjaGlsZE5vZGUubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKXtcbiAgICAgICAgICAgIGxvZ0Vycm9yKFwib25seSBIVE1MIGVsZW1lbnQgdGFncyB3aXRoIGFuIGlkIGFyZSBhbGxvd2VkIGluc2lkZSBjb250YWluZXJzIHdpdGggcGh4LXVwZGF0ZS5cXG5cXG5cIiArXG4gICAgICAgICAgICAgIGByZW1vdmluZyBpbGxlZ2FsIG5vZGU6IFwiJHsoY2hpbGROb2RlLm91dGVySFRNTCB8fCBjaGlsZE5vZGUubm9kZVZhbHVlKS50cmltKCl9XCJcXG5cXG5gKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKGNoaWxkTm9kZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRvUmVtb3ZlLmZvckVhY2goY2hpbGROb2RlID0+IGNoaWxkTm9kZS5yZW1vdmUoKSlcbiAgICB9XG4gIH0sXG5cbiAgcmVwbGFjZVJvb3RDb250YWluZXIoY29udGFpbmVyLCB0YWdOYW1lLCBhdHRycyl7XG4gICAgbGV0IHJldGFpbmVkQXR0cnMgPSBuZXcgU2V0KFtcImlkXCIsIFBIWF9TRVNTSU9OLCBQSFhfU1RBVElDLCBQSFhfTUFJTiwgUEhYX1JPT1RfSURdKVxuICAgIGlmKGNvbnRhaW5lci50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhZ05hbWUudG9Mb3dlckNhc2UoKSl7XG4gICAgICBBcnJheS5mcm9tKGNvbnRhaW5lci5hdHRyaWJ1dGVzKVxuICAgICAgICAuZmlsdGVyKGF0dHIgPT4gIXJldGFpbmVkQXR0cnMuaGFzKGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgLmZvckVhY2goYXR0ciA9PiBjb250YWluZXIucmVtb3ZlQXR0cmlidXRlKGF0dHIubmFtZSkpXG5cbiAgICAgIE9iamVjdC5rZXlzKGF0dHJzKVxuICAgICAgICAuZmlsdGVyKG5hbWUgPT4gIXJldGFpbmVkQXR0cnMuaGFzKG5hbWUudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgIC5mb3JFYWNoKGF0dHIgPT4gY29udGFpbmVyLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSkpXG5cbiAgICAgIHJldHVybiBjb250YWluZXJcblxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKVxuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goYXR0ciA9PiBuZXdDb250YWluZXIuc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJzW2F0dHJdKSlcbiAgICAgIHJldGFpbmVkQXR0cnMuZm9yRWFjaChhdHRyID0+IG5ld0NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoYXR0ciwgY29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyKSkpXG4gICAgICBuZXdDb250YWluZXIuaW5uZXJIVE1MID0gY29udGFpbmVyLmlubmVySFRNTFxuICAgICAgY29udGFpbmVyLnJlcGxhY2VXaXRoKG5ld0NvbnRhaW5lcilcbiAgICAgIHJldHVybiBuZXdDb250YWluZXJcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U3RpY2t5KGVsLCBuYW1lLCBkZWZhdWx0VmFsKXtcbiAgICBsZXQgb3AgPSAoRE9NLnByaXZhdGUoZWwsIFwic3RpY2t5XCIpIHx8IFtdKS5maW5kKChbZXhpc3RpbmdOYW1lLF0pID0+IG5hbWUgPT09IGV4aXN0aW5nTmFtZSlcbiAgICBpZihvcCl7XG4gICAgICBsZXQgW19uYW1lLCBfb3AsIHN0YXNoZWRSZXN1bHRdID0gb3BcbiAgICAgIHJldHVybiBzdGFzaGVkUmVzdWx0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0eXBlb2YoZGVmYXVsdFZhbCkgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWwoKSA6IGRlZmF1bHRWYWxcbiAgICB9XG4gIH0sXG5cbiAgZGVsZXRlU3RpY2t5KGVsLCBuYW1lKXtcbiAgICB0aGlzLnVwZGF0ZVByaXZhdGUoZWwsIFwic3RpY2t5XCIsIFtdLCBvcHMgPT4ge1xuICAgICAgcmV0dXJuIG9wcy5maWx0ZXIoKFtleGlzdGluZ05hbWUsIF9dKSA9PiBleGlzdGluZ05hbWUgIT09IG5hbWUpXG4gICAgfSlcbiAgfSxcblxuICBwdXRTdGlja3koZWwsIG5hbWUsIG9wKXtcbiAgICBsZXQgc3Rhc2hlZFJlc3VsdCA9IG9wKGVsKVxuICAgIHRoaXMudXBkYXRlUHJpdmF0ZShlbCwgXCJzdGlja3lcIiwgW10sIG9wcyA9PiB7XG4gICAgICBsZXQgZXhpc3RpbmdJbmRleCA9IG9wcy5maW5kSW5kZXgoKFtleGlzdGluZ05hbWUsXSkgPT4gbmFtZSA9PT0gZXhpc3RpbmdOYW1lKVxuICAgICAgaWYoZXhpc3RpbmdJbmRleCA+PSAwKXtcbiAgICAgICAgb3BzW2V4aXN0aW5nSW5kZXhdID0gW25hbWUsIG9wLCBzdGFzaGVkUmVzdWx0XVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BzLnB1c2goW25hbWUsIG9wLCBzdGFzaGVkUmVzdWx0XSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcHNcbiAgICB9KVxuICB9LFxuXG4gIGFwcGx5U3RpY2t5T3BlcmF0aW9ucyhlbCl7XG4gICAgbGV0IG9wcyA9IERPTS5wcml2YXRlKGVsLCBcInN0aWNreVwiKVxuICAgIGlmKCFvcHMpeyByZXR1cm4gfVxuXG4gICAgb3BzLmZvckVhY2goKFtuYW1lLCBvcCwgX3N0YXNoZWRdKSA9PiB0aGlzLnB1dFN0aWNreShlbCwgbmFtZSwgb3ApKVxuICB9LFxuXG4gIGlzTG9ja2VkKGVsKXtcbiAgICByZXR1cm4gZWwuaGFzQXR0cmlidXRlICYmIGVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX0xPQ0spXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgRE9NXG4iLCAiaW1wb3J0IHtcbiAgUEhYX0FDVElWRV9FTlRSWV9SRUZTLFxuICBQSFhfTElWRV9GSUxFX1VQREFURUQsXG4gIFBIWF9QUkVGTElHSFRFRF9SRUZTXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGNoYW5uZWxVcGxvYWRlcixcbiAgbG9nRXJyb3Jcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBVcGxvYWRFbnRyeSB7XG4gIHN0YXRpYyBpc0FjdGl2ZShmaWxlRWwsIGZpbGUpe1xuICAgIGxldCBpc05ldyA9IGZpbGUuX3BoeFJlZiA9PT0gdW5kZWZpbmVkXG4gICAgbGV0IGFjdGl2ZVJlZnMgPSBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzQWN0aXZlID0gYWN0aXZlUmVmcy5pbmRleE9mKExpdmVVcGxvYWRlci5nZW5GaWxlUmVmKGZpbGUpKSA+PSAwXG4gICAgcmV0dXJuIGZpbGUuc2l6ZSA+IDAgJiYgKGlzTmV3IHx8IGlzQWN0aXZlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0ZWQoZmlsZUVsLCBmaWxlKXtcbiAgICBsZXQgcHJlZmxpZ2h0ZWRSZWZzID0gZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfUFJFRkxJR0hURURfUkVGUykuc3BsaXQoXCIsXCIpXG4gICAgbGV0IGlzUHJlZmxpZ2h0ZWQgPSBwcmVmbGlnaHRlZFJlZnMuaW5kZXhPZihMaXZlVXBsb2FkZXIuZ2VuRmlsZVJlZihmaWxlKSkgPj0gMFxuICAgIHJldHVybiBpc1ByZWZsaWdodGVkICYmIHRoaXMuaXNBY3RpdmUoZmlsZUVsLCBmaWxlKVxuICB9XG5cbiAgc3RhdGljIGlzUHJlZmxpZ2h0SW5Qcm9ncmVzcyhmaWxlKXtcbiAgICByZXR1cm4gZmlsZS5fcHJlZmxpZ2h0SW5Qcm9ncmVzcyA9PT0gdHJ1ZVxuICB9XG5cbiAgc3RhdGljIG1hcmtQcmVmbGlnaHRJblByb2dyZXNzKGZpbGUpe1xuICAgIGZpbGUuX3ByZWZsaWdodEluUHJvZ3Jlc3MgPSB0cnVlXG4gIH1cblxuICBjb25zdHJ1Y3RvcihmaWxlRWwsIGZpbGUsIHZpZXcsIGF1dG9VcGxvYWQpe1xuICAgIHRoaXMucmVmID0gTGl2ZVVwbG9hZGVyLmdlbkZpbGVSZWYoZmlsZSlcbiAgICB0aGlzLmZpbGVFbCA9IGZpbGVFbFxuICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5tZXRhID0gbnVsbFxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gZmFsc2VcbiAgICB0aGlzLl9pc0RvbmUgPSBmYWxzZVxuICAgIHRoaXMuX3Byb2dyZXNzID0gMFxuICAgIHRoaXMuX2xhc3RQcm9ncmVzc1NlbnQgPSAtMVxuICAgIHRoaXMuX29uRG9uZSA9IGZ1bmN0aW9uKCl7IH1cbiAgICB0aGlzLl9vbkVsVXBkYXRlZCA9IHRoaXMub25FbFVwZGF0ZWQuYmluZCh0aGlzKVxuICAgIHRoaXMuZmlsZUVsLmFkZEV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICB0aGlzLmF1dG9VcGxvYWQgPSBhdXRvVXBsb2FkXG4gIH1cblxuICBtZXRhZGF0YSgpeyByZXR1cm4gdGhpcy5tZXRhIH1cblxuICBwcm9ncmVzcyhwcm9ncmVzcyl7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSBNYXRoLmZsb29yKHByb2dyZXNzKVxuICAgIGlmKHRoaXMuX3Byb2dyZXNzID4gdGhpcy5fbGFzdFByb2dyZXNzU2VudCl7XG4gICAgICBpZih0aGlzLl9wcm9ncmVzcyA+PSAxMDApe1xuICAgICAgICB0aGlzLl9wcm9ncmVzcyA9IDEwMFxuICAgICAgICB0aGlzLl9sYXN0UHJvZ3Jlc3NTZW50ID0gMTAwXG4gICAgICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICAgICAgdGhpcy52aWV3LnB1c2hGaWxlUHJvZ3Jlc3ModGhpcy5maWxlRWwsIHRoaXMucmVmLCAxMDAsICgpID0+IHtcbiAgICAgICAgICBMaXZlVXBsb2FkZXIudW50cmFja0ZpbGUodGhpcy5maWxlRWwsIHRoaXMuZmlsZSlcbiAgICAgICAgICB0aGlzLl9vbkRvbmUoKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzU2VudCA9IHRoaXMuX3Byb2dyZXNzXG4gICAgICAgIHRoaXMudmlldy5wdXNoRmlsZVByb2dyZXNzKHRoaXMuZmlsZUVsLCB0aGlzLnJlZiwgdGhpcy5fcHJvZ3Jlc3MpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNDYW5jZWxsZWQoKXsgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkIH1cblxuICBjYW5jZWwoKXtcbiAgICB0aGlzLmZpbGUuX3ByZWZsaWdodEluUHJvZ3Jlc3MgPSBmYWxzZVxuICAgIHRoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZVxuICAgIHRoaXMuX2lzRG9uZSA9IHRydWVcbiAgICB0aGlzLl9vbkRvbmUoKVxuICB9XG5cbiAgaXNEb25lKCl7IHJldHVybiB0aGlzLl9pc0RvbmUgfVxuXG4gIGVycm9yKHJlYXNvbiA9IFwiZmFpbGVkXCIpe1xuICAgIHRoaXMuZmlsZUVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoUEhYX0xJVkVfRklMRV9VUERBVEVELCB0aGlzLl9vbkVsVXBkYXRlZClcbiAgICB0aGlzLnZpZXcucHVzaEZpbGVQcm9ncmVzcyh0aGlzLmZpbGVFbCwgdGhpcy5yZWYsIHtlcnJvcjogcmVhc29ufSlcbiAgICBpZighdGhpcy5pc0F1dG9VcGxvYWQoKSl7IExpdmVVcGxvYWRlci5jbGVhckZpbGVzKHRoaXMuZmlsZUVsKSB9XG4gIH1cblxuICBpc0F1dG9VcGxvYWQoKXsgcmV0dXJuIHRoaXMuYXV0b1VwbG9hZCB9XG5cbiAgLy9wcml2YXRlXG5cbiAgb25Eb25lKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9vbkRvbmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmZpbGVFbC5yZW1vdmVFdmVudExpc3RlbmVyKFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCwgdGhpcy5fb25FbFVwZGF0ZWQpXG4gICAgICBjYWxsYmFjaygpXG4gICAgfVxuICB9XG5cbiAgb25FbFVwZGF0ZWQoKXtcbiAgICBsZXQgYWN0aXZlUmVmcyA9IHRoaXMuZmlsZUVsLmdldEF0dHJpYnV0ZShQSFhfQUNUSVZFX0VOVFJZX1JFRlMpLnNwbGl0KFwiLFwiKVxuICAgIGlmKGFjdGl2ZVJlZnMuaW5kZXhPZih0aGlzLnJlZikgPT09IC0xKXtcbiAgICAgIExpdmVVcGxvYWRlci51bnRyYWNrRmlsZSh0aGlzLmZpbGVFbCwgdGhpcy5maWxlKVxuICAgICAgdGhpcy5jYW5jZWwoKVxuICAgIH1cbiAgfVxuXG4gIHRvUHJlZmxpZ2h0UGF5bG9hZCgpe1xuICAgIHJldHVybiB7XG4gICAgICBsYXN0X21vZGlmaWVkOiB0aGlzLmZpbGUubGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZTogdGhpcy5maWxlLm5hbWUsXG4gICAgICByZWxhdGl2ZV9wYXRoOiB0aGlzLmZpbGUud2Via2l0UmVsYXRpdmVQYXRoLFxuICAgICAgc2l6ZTogdGhpcy5maWxlLnNpemUsXG4gICAgICB0eXBlOiB0aGlzLmZpbGUudHlwZSxcbiAgICAgIHJlZjogdGhpcy5yZWYsXG4gICAgICBtZXRhOiB0eXBlb2YodGhpcy5maWxlLm1ldGEpID09PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmZpbGUubWV0YSgpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkZXIodXBsb2FkZXJzKXtcbiAgICBpZih0aGlzLm1ldGEudXBsb2FkZXIpe1xuICAgICAgbGV0IGNhbGxiYWNrID0gdXBsb2FkZXJzW3RoaXMubWV0YS51cGxvYWRlcl0gfHwgbG9nRXJyb3IoYG5vIHVwbG9hZGVyIGNvbmZpZ3VyZWQgZm9yICR7dGhpcy5tZXRhLnVwbG9hZGVyfWApXG4gICAgICByZXR1cm4ge25hbWU6IHRoaXMubWV0YS51cGxvYWRlciwgY2FsbGJhY2s6IGNhbGxiYWNrfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4ge25hbWU6IFwiY2hhbm5lbFwiLCBjYWxsYmFjazogY2hhbm5lbFVwbG9hZGVyfVxuICAgIH1cbiAgfVxuXG4gIHppcFBvc3RGbGlnaHQocmVzcCl7XG4gICAgdGhpcy5tZXRhID0gcmVzcC5lbnRyaWVzW3RoaXMucmVmXVxuICAgIGlmKCF0aGlzLm1ldGEpeyBsb2dFcnJvcihgbm8gcHJlZmxpZ2h0IHVwbG9hZCByZXNwb25zZSByZXR1cm5lZCB3aXRoIHJlZiAke3RoaXMucmVmfWAsIHtpbnB1dDogdGhpcy5maWxlRWwsIHJlc3BvbnNlOiByZXNwfSkgfVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0RPTkVfUkVGUyxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IFVwbG9hZEVudHJ5IGZyb20gXCIuL3VwbG9hZF9lbnRyeVwiXG5cbmxldCBsaXZlVXBsb2FkZXJGaWxlUmVmID0gMFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXZlVXBsb2FkZXIge1xuICBzdGF0aWMgZ2VuRmlsZVJlZihmaWxlKXtcbiAgICBsZXQgcmVmID0gZmlsZS5fcGh4UmVmXG4gICAgaWYocmVmICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHJlZlxuICAgIH0gZWxzZSB7XG4gICAgICBmaWxlLl9waHhSZWYgPSAobGl2ZVVwbG9hZGVyRmlsZVJlZisrKS50b1N0cmluZygpXG4gICAgICByZXR1cm4gZmlsZS5fcGh4UmVmXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldEVudHJ5RGF0YVVSTChpbnB1dEVsLCByZWYsIGNhbGxiYWNrKXtcbiAgICBsZXQgZmlsZSA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmaWxlID0+IHRoaXMuZ2VuRmlsZVJlZihmaWxlKSA9PT0gcmVmKVxuICAgIGNhbGxiYWNrKFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSkpXG4gIH1cblxuICBzdGF0aWMgaGFzVXBsb2Fkc0luUHJvZ3Jlc3MoZm9ybUVsKXtcbiAgICBsZXQgYWN0aXZlID0gMFxuICAgIERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbCkuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpZihpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpICE9PSBpbnB1dC5nZXRBdHRyaWJ1dGUoUEhYX0RPTkVfUkVGUykpe1xuICAgICAgICBhY3RpdmUrK1xuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIGFjdGl2ZSA+IDBcbiAgfVxuXG4gIHN0YXRpYyBzZXJpYWxpemVVcGxvYWRzKGlucHV0RWwpe1xuICAgIGxldCBmaWxlcyA9IHRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbClcbiAgICBsZXQgZmlsZURhdGEgPSB7fVxuICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSB7cGF0aDogaW5wdXRFbC5uYW1lfVxuICAgICAgbGV0IHVwbG9hZFJlZiA9IGlucHV0RWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKVxuICAgICAgZmlsZURhdGFbdXBsb2FkUmVmXSA9IGZpbGVEYXRhW3VwbG9hZFJlZl0gfHwgW11cbiAgICAgIGVudHJ5LnJlZiA9IHRoaXMuZ2VuRmlsZVJlZihmaWxlKVxuICAgICAgZW50cnkubGFzdF9tb2RpZmllZCA9IGZpbGUubGFzdE1vZGlmaWVkXG4gICAgICBlbnRyeS5uYW1lID0gZmlsZS5uYW1lIHx8IGVudHJ5LnJlZlxuICAgICAgZW50cnkucmVsYXRpdmVfcGF0aCA9IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoXG4gICAgICBlbnRyeS50eXBlID0gZmlsZS50eXBlXG4gICAgICBlbnRyeS5zaXplID0gZmlsZS5zaXplXG4gICAgICBpZih0eXBlb2YoZmlsZS5tZXRhKSA9PT0gXCJmdW5jdGlvblwiKXsgZW50cnkubWV0YSA9IGZpbGUubWV0YSgpIH1cbiAgICAgIGZpbGVEYXRhW3VwbG9hZFJlZl0ucHVzaChlbnRyeSlcbiAgICB9KVxuICAgIHJldHVybiBmaWxlRGF0YVxuICB9XG5cbiAgc3RhdGljIGNsZWFyRmlsZXMoaW5wdXRFbCl7XG4gICAgaW5wdXRFbC52YWx1ZSA9IG51bGxcbiAgICBpbnB1dEVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRilcbiAgICBET00ucHV0UHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIFtdKVxuICB9XG5cbiAgc3RhdGljIHVudHJhY2tGaWxlKGlucHV0RWwsIGZpbGUpe1xuICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgRE9NLnByaXZhdGUoaW5wdXRFbCwgXCJmaWxlc1wiKS5maWx0ZXIoZiA9PiAhT2JqZWN0LmlzKGYsIGZpbGUpKSlcbiAgfVxuXG4gIHN0YXRpYyB0cmFja0ZpbGVzKGlucHV0RWwsIGZpbGVzLCBkYXRhVHJhbnNmZXIpe1xuICAgIGlmKGlucHV0RWwuZ2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIikgIT09IG51bGwpe1xuICAgICAgbGV0IG5ld0ZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT4gIXRoaXMuYWN0aXZlRmlsZXMoaW5wdXRFbCkuZmluZChmID0+IE9iamVjdC5pcyhmLCBmaWxlKSkpXG4gICAgICBET00udXBkYXRlUHJpdmF0ZShpbnB1dEVsLCBcImZpbGVzXCIsIFtdLCAoZXhpc3RpbmcpID0+IGV4aXN0aW5nLmNvbmNhdChuZXdGaWxlcykpXG4gICAgICBpbnB1dEVsLnZhbHVlID0gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCBpbnB1dEVsIGZpbGVzIHRvIGFsaWduIG91dHB1dCB3aXRoIHByb2dyYW1tYXRpYyBjaGFuZ2VzIChpLmUuIGRyYWcgYW5kIGRyb3ApXG4gICAgICBpZihkYXRhVHJhbnNmZXIgJiYgZGF0YVRyYW5zZmVyLmZpbGVzLmxlbmd0aCA+IDApeyBpbnB1dEVsLmZpbGVzID0gZGF0YVRyYW5zZmVyLmZpbGVzIH1cbiAgICAgIERPTS5wdXRQcml2YXRlKGlucHV0RWwsIFwiZmlsZXNcIiwgZmlsZXMpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFjdGl2ZUZpbGVJbnB1dHMoZm9ybUVsKXtcbiAgICBsZXQgZmlsZUlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKGZvcm1FbClcbiAgICByZXR1cm4gQXJyYXkuZnJvbShmaWxlSW5wdXRzKS5maWx0ZXIoZWwgPT4gZWwuZmlsZXMgJiYgdGhpcy5hY3RpdmVGaWxlcyhlbCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBhY3RpdmVGaWxlcyhpbnB1dCl7XG4gICAgcmV0dXJuIChET00ucHJpdmF0ZShpbnB1dCwgXCJmaWxlc1wiKSB8fCBbXSkuZmlsdGVyKGYgPT4gVXBsb2FkRW50cnkuaXNBY3RpdmUoaW5wdXQsIGYpKVxuICB9XG5cbiAgc3RhdGljIGlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCl7XG4gICAgbGV0IGZpbGVJbnB1dHMgPSBET00uZmluZFVwbG9hZElucHV0cyhmb3JtRWwpXG4gICAgcmV0dXJuIEFycmF5LmZyb20oZmlsZUlucHV0cykuZmlsdGVyKGlucHV0ID0+IHRoaXMuZmlsZXNBd2FpdGluZ1ByZWZsaWdodChpbnB1dCkubGVuZ3RoID4gMClcbiAgfVxuXG4gIHN0YXRpYyBmaWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0KXtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVGaWxlcyhpbnB1dCkuZmlsdGVyKGYgPT4gIVVwbG9hZEVudHJ5LmlzUHJlZmxpZ2h0ZWQoaW5wdXQsIGYpICYmICFVcGxvYWRFbnRyeS5pc1ByZWZsaWdodEluUHJvZ3Jlc3MoZikpXG4gIH1cblxuICBzdGF0aWMgbWFya1ByZWZsaWdodEluUHJvZ3Jlc3MoZW50cmllcyl7XG4gICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IFVwbG9hZEVudHJ5Lm1hcmtQcmVmbGlnaHRJblByb2dyZXNzKGVudHJ5LmZpbGUpKVxuICB9XG5cbiAgY29uc3RydWN0b3IoaW5wdXRFbCwgdmlldywgb25Db21wbGV0ZSl7XG4gICAgdGhpcy5hdXRvVXBsb2FkID0gRE9NLmlzQXV0b1VwbG9hZChpbnB1dEVsKVxuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlXG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICBBcnJheS5mcm9tKExpdmVVcGxvYWRlci5maWxlc0F3YWl0aW5nUHJlZmxpZ2h0KGlucHV0RWwpIHx8IFtdKVxuICAgICAgICAubWFwKGZpbGUgPT4gbmV3IFVwbG9hZEVudHJ5KGlucHV0RWwsIGZpbGUsIHZpZXcsIHRoaXMuYXV0b1VwbG9hZCkpXG5cbiAgICAvLyBwcmV2ZW50IHNlbmRpbmcgZHVwbGljYXRlIHByZWZsaWdodCByZXF1ZXN0c1xuICAgIExpdmVVcGxvYWRlci5tYXJrUHJlZmxpZ2h0SW5Qcm9ncmVzcyh0aGlzLl9lbnRyaWVzKVxuXG4gICAgdGhpcy5udW1FbnRyaWVzSW5Qcm9ncmVzcyA9IHRoaXMuX2VudHJpZXMubGVuZ3RoXG4gIH1cblxuICBpc0F1dG9VcGxvYWQoKXsgcmV0dXJuIHRoaXMuYXV0b1VwbG9hZCB9XG5cbiAgZW50cmllcygpeyByZXR1cm4gdGhpcy5fZW50cmllcyB9XG5cbiAgaW5pdEFkYXB0ZXJVcGxvYWQocmVzcCwgb25FcnJvciwgbGl2ZVNvY2tldCl7XG4gICAgdGhpcy5fZW50cmllcyA9XG4gICAgICB0aGlzLl9lbnRyaWVzLm1hcChlbnRyeSA9PiB7XG4gICAgICAgIGlmKGVudHJ5LmlzQ2FuY2VsbGVkKCkpe1xuICAgICAgICAgIHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MtLVxuICAgICAgICAgIGlmKHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPT09IDApeyB0aGlzLm9uQ29tcGxldGUoKSB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW50cnkuemlwUG9zdEZsaWdodChyZXNwKVxuICAgICAgICAgIGVudHJ5Lm9uRG9uZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm51bUVudHJpZXNJblByb2dyZXNzLS1cbiAgICAgICAgICAgIGlmKHRoaXMubnVtRW50cmllc0luUHJvZ3Jlc3MgPT09IDApeyB0aGlzLm9uQ29tcGxldGUoKSB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnlcbiAgICAgIH0pXG5cbiAgICBsZXQgZ3JvdXBlZEVudHJpZXMgPSB0aGlzLl9lbnRyaWVzLnJlZHVjZSgoYWNjLCBlbnRyeSkgPT4ge1xuICAgICAgaWYoIWVudHJ5Lm1ldGEpeyByZXR1cm4gYWNjIH1cbiAgICAgIGxldCB7bmFtZSwgY2FsbGJhY2t9ID0gZW50cnkudXBsb2FkZXIobGl2ZVNvY2tldC51cGxvYWRlcnMpXG4gICAgICBhY2NbbmFtZV0gPSBhY2NbbmFtZV0gfHwge2NhbGxiYWNrOiBjYWxsYmFjaywgZW50cmllczogW119XG4gICAgICBhY2NbbmFtZV0uZW50cmllcy5wdXNoKGVudHJ5KVxuICAgICAgcmV0dXJuIGFjY1xuICAgIH0sIHt9KVxuXG4gICAgZm9yKGxldCBuYW1lIGluIGdyb3VwZWRFbnRyaWVzKXtcbiAgICAgIGxldCB7Y2FsbGJhY2ssIGVudHJpZXN9ID0gZ3JvdXBlZEVudHJpZXNbbmFtZV1cbiAgICAgIGNhbGxiYWNrKGVudHJpZXMsIG9uRXJyb3IsIHJlc3AsIGxpdmVTb2NrZXQpXG4gICAgfVxuICB9XG59XG4iLCAibGV0IEFSSUEgPSB7XG4gIGFueU9mKGluc3RhbmNlLCBjbGFzc2VzKXsgcmV0dXJuIGNsYXNzZXMuZmluZChuYW1lID0+IGluc3RhbmNlIGluc3RhbmNlb2YgbmFtZSkgfSxcblxuICBpc0ZvY3VzYWJsZShlbCwgaW50ZXJhY3RpdmVPbmx5KXtcbiAgICByZXR1cm4gKFxuICAgICAgKGVsIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgJiYgZWwucmVsICE9PSBcImlnbm9yZVwiKSB8fFxuICAgICAgKGVsIGluc3RhbmNlb2YgSFRNTEFyZWFFbGVtZW50ICYmIGVsLmhyZWYgIT09IHVuZGVmaW5lZCkgfHxcbiAgICAgICghZWwuZGlzYWJsZWQgJiYgKHRoaXMuYW55T2YoZWwsIFtIVE1MSW5wdXRFbGVtZW50LCBIVE1MU2VsZWN0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCwgSFRNTEJ1dHRvbkVsZW1lbnRdKSkpIHx8XG4gICAgICAoZWwgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCkgfHxcbiAgICAgIChlbC50YWJJbmRleCA+IDAgfHwgKCFpbnRlcmFjdGl2ZU9ubHkgJiYgZWwuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgIT09IG51bGwgJiYgZWwuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIikgIT09IFwidHJ1ZVwiKSlcbiAgICApXG4gIH0sXG5cbiAgYXR0ZW1wdEZvY3VzKGVsLCBpbnRlcmFjdGl2ZU9ubHkpe1xuICAgIGlmKHRoaXMuaXNGb2N1c2FibGUoZWwsIGludGVyYWN0aXZlT25seSkpeyB0cnkgeyBlbC5mb2N1cygpIH0gY2F0Y2gge30gfVxuICAgIHJldHVybiAhIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5pc1NhbWVOb2RlKGVsKVxuICB9LFxuXG4gIGZvY3VzRmlyc3RJbnRlcmFjdGl2ZShlbCl7XG4gICAgbGV0IGNoaWxkID0gZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICB3aGlsZShjaGlsZCl7XG4gICAgICBpZih0aGlzLmF0dGVtcHRGb2N1cyhjaGlsZCwgdHJ1ZSkgfHwgdGhpcy5mb2N1c0ZpcnN0SW50ZXJhY3RpdmUoY2hpbGQsIHRydWUpKXtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nXG4gICAgfVxuICB9LFxuXG4gIGZvY3VzRmlyc3QoZWwpe1xuICAgIGxldCBjaGlsZCA9IGVsLmZpcnN0RWxlbWVudENoaWxkXG4gICAgd2hpbGUoY2hpbGQpe1xuICAgICAgaWYodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQpIHx8IHRoaXMuZm9jdXNGaXJzdChjaGlsZCkpe1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICB9XG4gIH0sXG5cbiAgZm9jdXNMYXN0KGVsKXtcbiAgICBsZXQgY2hpbGQgPSBlbC5sYXN0RWxlbWVudENoaWxkXG4gICAgd2hpbGUoY2hpbGQpe1xuICAgICAgaWYodGhpcy5hdHRlbXB0Rm9jdXMoY2hpbGQpIHx8IHRoaXMuZm9jdXNMYXN0KGNoaWxkKSl7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnByZXZpb3VzRWxlbWVudFNpYmxpbmdcbiAgICB9XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEFSSUFcbiIsICJpbXBvcnQge1xuICBQSFhfQUNUSVZFX0VOVFJZX1JFRlMsXG4gIFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCxcbiAgUEhYX1BSRUZMSUdIVEVEX1JFRlMsXG4gIFBIWF9VUExPQURfUkVGXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBMaXZlVXBsb2FkZXIgZnJvbSBcIi4vbGl2ZV91cGxvYWRlclwiXG5pbXBvcnQgQVJJQSBmcm9tIFwiLi9hcmlhXCJcblxubGV0IEhvb2tzID0ge1xuICBMaXZlRmlsZVVwbG9hZDoge1xuICAgIGFjdGl2ZVJlZnMoKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9BQ1RJVkVfRU5UUllfUkVGUykgfSxcblxuICAgIHByZWZsaWdodGVkUmVmcygpeyByZXR1cm4gdGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1BSRUZMSUdIVEVEX1JFRlMpIH0sXG5cbiAgICBtb3VudGVkKCl7IHRoaXMucHJlZmxpZ2h0ZWRXYXMgPSB0aGlzLnByZWZsaWdodGVkUmVmcygpIH0sXG5cbiAgICB1cGRhdGVkKCl7XG4gICAgICBsZXQgbmV3UHJlZmxpZ2h0cyA9IHRoaXMucHJlZmxpZ2h0ZWRSZWZzKClcbiAgICAgIGlmKHRoaXMucHJlZmxpZ2h0ZWRXYXMgIT09IG5ld1ByZWZsaWdodHMpe1xuICAgICAgICB0aGlzLnByZWZsaWdodGVkV2FzID0gbmV3UHJlZmxpZ2h0c1xuICAgICAgICBpZihuZXdQcmVmbGlnaHRzID09PSBcIlwiKXtcbiAgICAgICAgICB0aGlzLl9fdmlldygpLmNhbmNlbFN1Ym1pdCh0aGlzLmVsLmZvcm0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodGhpcy5hY3RpdmVSZWZzKCkgPT09IFwiXCIpeyB0aGlzLmVsLnZhbHVlID0gbnVsbCB9XG4gICAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFBIWF9MSVZFX0ZJTEVfVVBEQVRFRCkpXG4gICAgfVxuICB9LFxuXG4gIExpdmVJbWdQcmV2aWV3OiB7XG4gICAgbW91bnRlZCgpe1xuICAgICAgdGhpcy5yZWYgPSB0aGlzLmVsLmdldEF0dHJpYnV0ZShcImRhdGEtcGh4LWVudHJ5LXJlZlwiKVxuICAgICAgdGhpcy5pbnB1dEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5lbC5nZXRBdHRyaWJ1dGUoUEhYX1VQTE9BRF9SRUYpKVxuICAgICAgTGl2ZVVwbG9hZGVyLmdldEVudHJ5RGF0YVVSTCh0aGlzLmlucHV0RWwsIHRoaXMucmVmLCB1cmwgPT4ge1xuICAgICAgICB0aGlzLnVybCA9IHVybFxuICAgICAgICB0aGlzLmVsLnNyYyA9IHVybFxuICAgICAgfSlcbiAgICB9LFxuICAgIGRlc3Ryb3llZCgpe1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLnVybClcbiAgICB9XG4gIH0sXG4gIEZvY3VzV3JhcDoge1xuICAgIG1vdW50ZWQoKXtcbiAgICAgIHRoaXMuZm9jdXNTdGFydCA9IHRoaXMuZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgIHRoaXMuZm9jdXNFbmQgPSB0aGlzLmVsLmxhc3RFbGVtZW50Q2hpbGRcbiAgICAgIHRoaXMuZm9jdXNTdGFydC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKGUpID0+IHtcbiAgICAgICAgaWYoIWUucmVsYXRlZFRhcmdldCB8fCAhdGhpcy5lbC5jb250YWlucyhlLnJlbGF0ZWRUYXJnZXQpKXsgXG4gICAgICAgICAgLy8gSGFuZGxlIGZvY3VzIGVudGVyaW5nIGZyb20gb3V0c2lkZSAoZS5nLiBUYWIgd2hlbiBib2R5IGlzIGZvY3VzZWQpXG4gICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peF9saXZlX3ZpZXcvaXNzdWVzLzM2MzZcbiAgICAgICAgICBjb25zdCBuZXh0Rm9jdXMgPSBlLnRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmdcbiAgICAgICAgICBBUklBLmF0dGVtcHRGb2N1cyhuZXh0Rm9jdXMpIHx8IEFSSUEuZm9jdXNGaXJzdChuZXh0Rm9jdXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQVJJQS5mb2N1c0xhc3QodGhpcy5lbClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMuZm9jdXNFbmQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIChlKSA9PiB7XG4gICAgICAgIGlmKCFlLnJlbGF0ZWRUYXJnZXQgfHwgIXRoaXMuZWwuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSl7IFxuICAgICAgICAgIC8vIEhhbmRsZSBmb2N1cyBlbnRlcmluZyBmcm9tIG91dHNpZGUgKGUuZy4gU2hpZnQrVGFiIHdoZW4gYm9keSBpcyBmb2N1c2VkKVxuICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zNjM2XG4gICAgICAgICAgY29uc3QgbmV4dEZvY3VzID0gZS50YXJnZXQucHJldmlvdXNFbGVtZW50U2libGluZ1xuICAgICAgICAgIEFSSUEuYXR0ZW1wdEZvY3VzKG5leHRGb2N1cykgfHwgQVJJQS5mb2N1c0xhc3QobmV4dEZvY3VzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFSSUEuZm9jdXNGaXJzdCh0aGlzLmVsKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5lbC5hZGRFdmVudExpc3RlbmVyKFwicGh4OnNob3ctZW5kXCIsICgpID0+IHRoaXMuZWwuZm9jdXMoKSlcbiAgICAgIGlmKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWwpLmRpc3BsYXkgIT09IFwibm9uZVwiKXtcbiAgICAgICAgQVJJQS5mb2N1c0ZpcnN0KHRoaXMuZWwpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmxldCBmaW5kU2Nyb2xsQ29udGFpbmVyID0gKGVsKSA9PiB7XG4gIC8vIHRoZSBzY3JvbGwgZXZlbnQgd29uJ3QgYmUgZmlyZWQgb24gdGhlIGh0bWwvYm9keSBlbGVtZW50IGV2ZW4gaWYgb3ZlcmZsb3cgaXMgc2V0XG4gIC8vIHRoZXJlZm9yZSB3ZSByZXR1cm4gbnVsbCB0byBpbnN0ZWFkIGxpc3RlbiBmb3Igc2Nyb2xsIGV2ZW50cyBvbiBkb2N1bWVudFxuICBpZihbXCJIVE1MXCIsIFwiQk9EWVwiXS5pbmRleE9mKGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkpID49IDApIHJldHVybiBudWxsXG4gIGlmKFtcInNjcm9sbFwiLCBcImF1dG9cIl0uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsKS5vdmVyZmxvd1kpID49IDApIHJldHVybiBlbFxuICByZXR1cm4gZmluZFNjcm9sbENvbnRhaW5lcihlbC5wYXJlbnRFbGVtZW50KVxufVxuXG5sZXQgc2Nyb2xsVG9wID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3BcbiAgfVxufVxuXG5sZXQgYm90dG9tID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tXG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiB3ZSBoYXZlIG5vIGNvbnRhaW5lciwgdGhlIHdob2xlIHBhZ2Ugc2Nyb2xscyxcbiAgICAvLyB0aGVyZWZvcmUgdGhlIGJvdHRvbSBjb29yZGluYXRlIGlzIHRoZSB2aWV3cG9ydCBoZWlnaHRcbiAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgfVxufVxuXG5sZXQgdG9wID0gKHNjcm9sbENvbnRhaW5lcikgPT4ge1xuICBpZihzY3JvbGxDb250YWluZXIpe1xuICAgIHJldHVybiBzY3JvbGxDb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gIH0gZWxzZSB7XG4gICAgLy8gd2hlbiB3ZSBoYXZlIG5vIGNvbnRhaW5lciB0aGUgd2hvbGUgcGFnZSBzY3JvbGxzLFxuICAgIC8vIHRoZXJlZm9yZSB0aGUgdG9wIGNvb3JkaW5hdGUgaXMgMFxuICAgIHJldHVybiAwXG4gIH1cbn1cblxubGV0IGlzQXRWaWV3cG9ydFRvcCA9IChlbCwgc2Nyb2xsQ29udGFpbmVyKSA9PiB7XG4gIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgcmV0dXJuIE1hdGguY2VpbChyZWN0LnRvcCkgPj0gdG9wKHNjcm9sbENvbnRhaW5lcikgJiYgTWF0aC5jZWlsKHJlY3QubGVmdCkgPj0gMCAmJiBNYXRoLmZsb29yKHJlY3QudG9wKSA8PSBib3R0b20oc2Nyb2xsQ29udGFpbmVyKVxufVxuXG5sZXQgaXNBdFZpZXdwb3J0Qm90dG9tID0gKGVsLCBzY3JvbGxDb250YWluZXIpID0+IHtcbiAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gTWF0aC5jZWlsKHJlY3QuYm90dG9tKSA+PSB0b3Aoc2Nyb2xsQ29udGFpbmVyKSAmJiBNYXRoLmNlaWwocmVjdC5sZWZ0KSA+PSAwICYmIE1hdGguZmxvb3IocmVjdC5ib3R0b20pIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG59XG5cbmxldCBpc1dpdGhpblZpZXdwb3J0ID0gKGVsLCBzY3JvbGxDb250YWluZXIpID0+IHtcbiAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICByZXR1cm4gTWF0aC5jZWlsKHJlY3QudG9wKSA+PSB0b3Aoc2Nyb2xsQ29udGFpbmVyKSAmJiBNYXRoLmNlaWwocmVjdC5sZWZ0KSA+PSAwICYmIE1hdGguZmxvb3IocmVjdC50b3ApIDw9IGJvdHRvbShzY3JvbGxDb250YWluZXIpXG59XG5cbkhvb2tzLkluZmluaXRlU2Nyb2xsID0ge1xuICBtb3VudGVkKCl7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSBmaW5kU2Nyb2xsQ29udGFpbmVyKHRoaXMuZWwpXG4gICAgbGV0IHNjcm9sbEJlZm9yZSA9IHNjcm9sbFRvcCh0aGlzLnNjcm9sbENvbnRhaW5lcilcbiAgICBsZXQgdG9wT3ZlcnJhbiA9IGZhbHNlXG4gICAgbGV0IHRocm90dGxlSW50ZXJ2YWwgPSA1MDBcbiAgICBsZXQgcGVuZGluZ09wID0gbnVsbFxuXG4gICAgbGV0IG9uVG9wT3ZlcnJ1biA9IHRoaXMudGhyb3R0bGUodGhyb3R0bGVJbnRlcnZhbCwgKHRvcEV2ZW50LCBmaXJzdENoaWxkKSA9PiB7XG4gICAgICBwZW5kaW5nT3AgPSAoKSA9PiB0cnVlXG4gICAgICB0aGlzLmxpdmVTb2NrZXQuZXhlY0pTSG9va1B1c2godGhpcy5lbCwgdG9wRXZlbnQsIHtpZDogZmlyc3RDaGlsZC5pZCwgX292ZXJyYW46IHRydWV9LCAoKSA9PiB7XG4gICAgICAgIHBlbmRpbmdPcCA9IG51bGxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGxldCBvbkZpcnN0Q2hpbGRBdFRvcCA9IHRoaXMudGhyb3R0bGUodGhyb3R0bGVJbnRlcnZhbCwgKHRvcEV2ZW50LCBmaXJzdENoaWxkKSA9PiB7XG4gICAgICBwZW5kaW5nT3AgPSAoKSA9PiBmaXJzdENoaWxkLnNjcm9sbEludG9WaWV3KHtibG9jazogXCJzdGFydFwifSlcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5leGVjSlNIb29rUHVzaCh0aGlzLmVsLCB0b3BFdmVudCwge2lkOiBmaXJzdENoaWxkLmlkfSwgKCkgPT4ge1xuICAgICAgICBwZW5kaW5nT3AgPSBudWxsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBET00gaXMgcGF0Y2hlZCBieSB3YWl0aW5nIGZvciB0aGUgbmV4dCB0aWNrXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmKCFpc1dpdGhpblZpZXdwb3J0KGZpcnN0Q2hpbGQsIHRoaXMuc2Nyb2xsQ29udGFpbmVyKSl7XG4gICAgICAgICAgICBmaXJzdENoaWxkLnNjcm9sbEludG9WaWV3KHtibG9jazogXCJzdGFydFwifSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBsZXQgb25MYXN0Q2hpbGRBdEJvdHRvbSA9IHRoaXMudGhyb3R0bGUodGhyb3R0bGVJbnRlcnZhbCwgKGJvdHRvbUV2ZW50LCBsYXN0Q2hpbGQpID0+IHtcbiAgICAgIHBlbmRpbmdPcCA9ICgpID0+IGxhc3RDaGlsZC5zY3JvbGxJbnRvVmlldyh7YmxvY2s6IFwiZW5kXCJ9KVxuICAgICAgdGhpcy5saXZlU29ja2V0LmV4ZWNKU0hvb2tQdXNoKHRoaXMuZWwsIGJvdHRvbUV2ZW50LCB7aWQ6IGxhc3RDaGlsZC5pZH0sICgpID0+IHtcbiAgICAgICAgcGVuZGluZ09wID0gbnVsbFxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgRE9NIGlzIHBhdGNoZWQgYnkgd2FpdGluZyBmb3IgdGhlIG5leHQgdGlja1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpZighaXNXaXRoaW5WaWV3cG9ydChsYXN0Q2hpbGQsIHRoaXMuc2Nyb2xsQ29udGFpbmVyKSl7XG4gICAgICAgICAgICBsYXN0Q2hpbGQuc2Nyb2xsSW50b1ZpZXcoe2Jsb2NrOiBcImVuZFwifSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICB0aGlzLm9uU2Nyb2xsID0gKF9lKSA9PiB7XG4gICAgICBsZXQgc2Nyb2xsTm93ID0gc2Nyb2xsVG9wKHRoaXMuc2Nyb2xsQ29udGFpbmVyKVxuXG4gICAgICBpZihwZW5kaW5nT3Ape1xuICAgICAgICBzY3JvbGxCZWZvcmUgPSBzY3JvbGxOb3dcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdPcCgpXG4gICAgICB9XG4gICAgICBsZXQgcmVjdCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGxldCB0b3BFdmVudCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwidmlld3BvcnQtdG9wXCIpKVxuICAgICAgbGV0IGJvdHRvbUV2ZW50ID0gdGhpcy5lbC5nZXRBdHRyaWJ1dGUodGhpcy5saXZlU29ja2V0LmJpbmRpbmcoXCJ2aWV3cG9ydC1ib3R0b21cIikpXG4gICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy5lbC5sYXN0RWxlbWVudENoaWxkXG4gICAgICBsZXQgZmlyc3RDaGlsZCA9IHRoaXMuZWwuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgIGxldCBpc1Njcm9sbGluZ1VwID0gc2Nyb2xsTm93IDwgc2Nyb2xsQmVmb3JlXG4gICAgICBsZXQgaXNTY3JvbGxpbmdEb3duID0gc2Nyb2xsTm93ID4gc2Nyb2xsQmVmb3JlXG5cbiAgICAgIC8vIGVsIG92ZXJyYW4gd2hpbGUgc2Nyb2xsaW5nIHVwXG4gICAgICBpZihpc1Njcm9sbGluZ1VwICYmIHRvcEV2ZW50ICYmICF0b3BPdmVycmFuICYmIHJlY3QudG9wID49IDApe1xuICAgICAgICB0b3BPdmVycmFuID0gdHJ1ZVxuICAgICAgICBvblRvcE92ZXJydW4odG9wRXZlbnQsIGZpcnN0Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYoaXNTY3JvbGxpbmdEb3duICYmIHRvcE92ZXJyYW4gJiYgcmVjdC50b3AgPD0gMCl7XG4gICAgICAgIHRvcE92ZXJyYW4gPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBpZih0b3BFdmVudCAmJiBpc1Njcm9sbGluZ1VwICYmIGlzQXRWaWV3cG9ydFRvcChmaXJzdENoaWxkLCB0aGlzLnNjcm9sbENvbnRhaW5lcikpe1xuICAgICAgICBvbkZpcnN0Q2hpbGRBdFRvcCh0b3BFdmVudCwgZmlyc3RDaGlsZClcbiAgICAgIH0gZWxzZSBpZihib3R0b21FdmVudCAmJiBpc1Njcm9sbGluZ0Rvd24gJiYgaXNBdFZpZXdwb3J0Qm90dG9tKGxhc3RDaGlsZCwgdGhpcy5zY3JvbGxDb250YWluZXIpKXtcbiAgICAgICAgb25MYXN0Q2hpbGRBdEJvdHRvbShib3R0b21FdmVudCwgbGFzdENoaWxkKVxuICAgICAgfVxuICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsTm93XG4gICAgfVxuXG4gICAgaWYodGhpcy5zY3JvbGxDb250YWluZXIpe1xuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKVxuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsKVxuICAgIH1cbiAgfSxcbiAgXG4gIGRlc3Ryb3llZCgpe1xuICAgIGlmKHRoaXMuc2Nyb2xsQ29udGFpbmVyKXtcbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbClcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbClcbiAgICB9XG4gIH0sXG5cbiAgdGhyb3R0bGUoaW50ZXJ2YWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgbGFzdENhbGxBdCA9IDBcbiAgICBsZXQgdGltZXJcblxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgbGV0IG5vdyA9IERhdGUubm93KClcbiAgICAgIGxldCByZW1haW5pbmdUaW1lID0gaW50ZXJ2YWwgLSAobm93IC0gbGFzdENhbGxBdClcblxuICAgICAgaWYocmVtYWluaW5nVGltZSA8PSAwIHx8IHJlbWFpbmluZ1RpbWUgPiBpbnRlcnZhbCl7XG4gICAgICAgIGlmKHRpbWVyKXtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgICAgICAgdGltZXIgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgbGFzdENhbGxBdCA9IG5vd1xuICAgICAgICBjYWxsYmFjayguLi5hcmdzKVxuICAgICAgfSBlbHNlIGlmKCF0aW1lcil7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbGFzdENhbGxBdCA9IERhdGUubm93KClcbiAgICAgICAgICB0aW1lciA9IG51bGxcbiAgICAgICAgICBjYWxsYmFjayguLi5hcmdzKVxuICAgICAgICB9LCByZW1haW5pbmdUaW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgSG9va3NcbiIsICJpbXBvcnQge1xuICBQSFhfUkVGX0xPQURJTkcsXG4gIFBIWF9SRUZfTE9DSyxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9FVkVOVF9DTEFTU0VTLFxuICBQSFhfRElTQUJMRUQsXG4gIFBIWF9SRUFET05MWSxcbiAgUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudFJlZiB7XG4gIHN0YXRpYyBvblVubG9jayhlbCwgY2FsbGJhY2spe1xuICAgIGlmKCFET00uaXNMb2NrZWQoZWwpICYmICFlbC5jbG9zZXN0KGBbJHtQSFhfUkVGX0xPQ0t9XWApKXsgcmV0dXJuIGNhbGxiYWNrKCkgfVxuICAgIGNvbnN0IGNsb3Nlc3RMb2NrID0gZWwuY2xvc2VzdChgWyR7UEhYX1JFRl9MT0NLfV1gKVxuICAgIGNvbnN0IHJlZiA9IGNsb3Nlc3RMb2NrLmNsb3Nlc3QoYFske1BIWF9SRUZfTE9DS31dYCkuZ2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSylcbiAgICBjbG9zZXN0TG9jay5hZGRFdmVudExpc3RlbmVyKGBwaHg6dW5kby1sb2NrOiR7cmVmfWAsICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9LCB7b25jZTogdHJ1ZX0pXG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbCl7XG4gICAgdGhpcy5lbCA9IGVsXG4gICAgdGhpcy5sb2FkaW5nUmVmID0gZWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfTE9BRElORykgPyBwYXJzZUludChlbC5nZXRBdHRyaWJ1dGUoUEhYX1JFRl9MT0FESU5HKSwgMTApIDogbnVsbFxuICAgIHRoaXMubG9ja1JlZiA9IGVsLmhhc0F0dHJpYnV0ZShQSFhfUkVGX0xPQ0spID8gcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSyksIDEwKSA6IG51bGxcbiAgfVxuXG4gIC8vIHB1YmxpY1xuXG4gIG1heWJlVW5kbyhyZWYsIHBoeEV2ZW50LCBlYWNoQ2xvbmVDYWxsYmFjayl7XG4gICAgaWYoIXRoaXMuaXNXaXRoaW4ocmVmKSl7IHJldHVybiB9XG5cbiAgICAvLyB1bmRvIGxvY2tzIGFuZCBhcHBseSBjbG9uZXNcbiAgICB0aGlzLnVuZG9Mb2NrcyhyZWYsIHBoeEV2ZW50LCBlYWNoQ2xvbmVDYWxsYmFjaylcblxuICAgIC8vIHVuZG8gbG9hZGluZyBzdGF0ZXNcbiAgICB0aGlzLnVuZG9Mb2FkaW5nKHJlZiwgcGh4RXZlbnQpXG5cbiAgICAvLyBjbGVhbiB1cCBpZiBmdWxseSByZXNvbHZlZFxuICAgIGlmKHRoaXMuaXNGdWxseVJlc29sdmVkQnkocmVmKSl7IHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfU1JDKSB9XG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgaXNXaXRoaW4ocmVmKXtcbiAgICByZXR1cm4gISgodGhpcy5sb2FkaW5nUmVmICE9PSBudWxsICYmIHRoaXMubG9hZGluZ1JlZiA+IHJlZikgJiYgKHRoaXMubG9ja1JlZiAhPT0gbnVsbCAmJiB0aGlzLmxvY2tSZWYgPiByZWYpKVxuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGNsb25lZCBQSFhfUkVGX0xPQ0sgZWxlbWVudCB0aGF0IGhhcyBiZWVuIG1vcnBoZWQgYmVoaW5kXG4gIC8vIHRoZSBzY2VuZXMgd2hpbGUgdGhpcyBlbGVtZW50IHdhcyBsb2NrZWQgaW4gdGhlIERPTS5cbiAgLy8gV2hlbiB3ZSBhcHBseSB0aGUgY2xvbmVkIHRyZWUgdG8gdGhlIGFjdGl2ZSBET00gZWxlbWVudCwgd2UgbXVzdFxuICAvL1xuICAvLyAgIDEuIGV4ZWN1dGUgcGVuZGluZyBtb3VudGVkIGhvb2tzIGZvciBub2RlcyBub3cgaW4gdGhlIERPTVxuICAvLyAgIDIuIHVuZG8gYW55IHJlZiBpbnNpZGUgdGhlIGNsb25lZCB0cmVlIHRoYXQgaGFzIHNpbmNlIGJlZW4gYWNrJ2RcbiAgdW5kb0xvY2tzKHJlZiwgcGh4RXZlbnQsIGVhY2hDbG9uZUNhbGxiYWNrKXtcbiAgICBpZighdGhpcy5pc0xvY2tVbmRvbmVCeShyZWYpKXsgcmV0dXJuIH1cblxuICAgIGxldCBjbG9uZWRUcmVlID0gRE9NLnByaXZhdGUodGhpcy5lbCwgUEhYX1JFRl9MT0NLKVxuICAgIGlmKGNsb25lZFRyZWUpe1xuICAgICAgZWFjaENsb25lQ2FsbGJhY2soY2xvbmVkVHJlZSlcbiAgICAgIERPTS5kZWxldGVQcml2YXRlKHRoaXMuZWwsIFBIWF9SRUZfTE9DSylcbiAgICB9XG4gICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKVxuXG4gICAgbGV0IG9wdHMgPSB7ZGV0YWlsOiB7cmVmOiByZWYsIGV2ZW50OiBwaHhFdmVudH0sIGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IGZhbHNlfVxuICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoYHBoeDp1bmRvLWxvY2s6JHt0aGlzLmxvY2tSZWZ9YCwgb3B0cykpXG4gIH1cblxuICB1bmRvTG9hZGluZyhyZWYsIHBoeEV2ZW50KXtcbiAgICBpZighdGhpcy5pc0xvYWRpbmdVbmRvbmVCeShyZWYpKXtcbiAgICAgIGlmKHRoaXMuY2FuVW5kb0xvYWRpbmcocmVmKSAmJiB0aGlzLmVsLmNsYXNzTGlzdC5jb250YWlucyhcInBoeC1zdWJtaXQtbG9hZGluZ1wiKSl7XG4gICAgICAgIHRoaXMuZWwuY2xhc3NMaXN0LnJlbW92ZShcInBoeC1jaGFuZ2UtbG9hZGluZ1wiKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYodGhpcy5jYW5VbmRvTG9hZGluZyhyZWYpKXtcbiAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9SRUZfTE9BRElORylcbiAgICAgIGxldCBkaXNhYmxlZFZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIGxldCByZWFkT25seVZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9SRUFET05MWSlcbiAgICAgIC8vIHJlc3RvcmUgaW5wdXRzXG4gICAgICBpZihyZWFkT25seVZhbCAhPT0gbnVsbCl7XG4gICAgICAgIHRoaXMuZWwucmVhZE9ubHkgPSByZWFkT25seVZhbCA9PT0gXCJ0cnVlXCIgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgdGhpcy5lbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFQURPTkxZKVxuICAgICAgfVxuICAgICAgaWYoZGlzYWJsZWRWYWwgIT09IG51bGwpe1xuICAgICAgICB0aGlzLmVsLmRpc2FibGVkID0gZGlzYWJsZWRWYWwgPT09IFwidHJ1ZVwiID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIHRoaXMuZWwucmVtb3ZlQXR0cmlidXRlKFBIWF9ESVNBQkxFRClcbiAgICAgIH1cbiAgICAgIC8vIHJlc3RvcmUgZGlzYWJsZXNcbiAgICAgIGxldCBkaXNhYmxlUmVzdG9yZSA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSlcbiAgICAgIGlmKGRpc2FibGVSZXN0b3JlICE9PSBudWxsKXtcbiAgICAgICAgdGhpcy5lbC5pbm5lclRleHQgPSBkaXNhYmxlUmVzdG9yZVxuICAgICAgICB0aGlzLmVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfRElTQUJMRV9XSVRIX1JFU1RPUkUpXG4gICAgICB9XG5cbiAgICAgIGxldCBvcHRzID0ge2RldGFpbDoge3JlZjogcmVmLCBldmVudDogcGh4RXZlbnR9LCBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiBmYWxzZX1cbiAgICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoYHBoeDp1bmRvLWxvYWRpbmc6JHt0aGlzLmxvYWRpbmdSZWZ9YCwgb3B0cykpXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGNsYXNzZXNcbiAgICBQSFhfRVZFTlRfQ0xBU1NFUy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgaWYobmFtZSAhPT0gXCJwaHgtc3VibWl0LWxvYWRpbmdcIiB8fCB0aGlzLmNhblVuZG9Mb2FkaW5nKHJlZikpe1xuICAgICAgICBET00ucmVtb3ZlQ2xhc3ModGhpcy5lbCwgbmFtZSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgaXNMb2FkaW5nVW5kb25lQnkocmVmKXsgcmV0dXJuIHRoaXMubG9hZGluZ1JlZiA9PT0gbnVsbCA/IGZhbHNlIDogdGhpcy5sb2FkaW5nUmVmIDw9IHJlZiB9XG4gIGlzTG9ja1VuZG9uZUJ5KHJlZil7IHJldHVybiB0aGlzLmxvY2tSZWYgPT09IG51bGwgPyBmYWxzZSA6IHRoaXMubG9ja1JlZiA8PSByZWYgfVxuXG4gIGlzRnVsbHlSZXNvbHZlZEJ5KHJlZil7XG4gICAgcmV0dXJuICh0aGlzLmxvYWRpbmdSZWYgPT09IG51bGwgfHwgdGhpcy5sb2FkaW5nUmVmIDw9IHJlZikgJiYgKHRoaXMubG9ja1JlZiA9PT0gbnVsbCB8fCB0aGlzLmxvY2tSZWYgPD0gcmVmKVxuICB9XG5cbiAgLy8gb25seSByZW1vdmUgdGhlIHBoeC1zdWJtaXQtbG9hZGluZyBjbGFzcyBpZiB3ZSBhcmUgbm90IGxvY2tlZFxuICBjYW5VbmRvTG9hZGluZyhyZWYpeyByZXR1cm4gdGhpcy5sb2NrUmVmID09PSBudWxsIHx8IHRoaXMubG9ja1JlZiA8PSByZWYgfVxufVxuIiwgImltcG9ydCB7XG4gIG1heWJlXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01Qb3N0TW9ycGhSZXN0b3JlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lckJlZm9yZSwgY29udGFpbmVyQWZ0ZXIsIHVwZGF0ZVR5cGUpe1xuICAgIGxldCBpZHNCZWZvcmUgPSBuZXcgU2V0KClcbiAgICBsZXQgaWRzQWZ0ZXIgPSBuZXcgU2V0KFsuLi5jb250YWluZXJBZnRlci5jaGlsZHJlbl0ubWFwKGNoaWxkID0+IGNoaWxkLmlkKSlcblxuICAgIGxldCBlbGVtZW50c1RvTW9kaWZ5ID0gW11cblxuICAgIEFycmF5LmZyb20oY29udGFpbmVyQmVmb3JlLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmKGNoaWxkLmlkKXsgLy8gYWxsIG9mIG91ciBjaGlsZHJlbiBzaG91bGQgYmUgZWxlbWVudHMgd2l0aCBpZHNcbiAgICAgICAgaWRzQmVmb3JlLmFkZChjaGlsZC5pZClcbiAgICAgICAgaWYoaWRzQWZ0ZXIuaGFzKGNoaWxkLmlkKSl7XG4gICAgICAgICAgbGV0IHByZXZpb3VzRWxlbWVudElkID0gY2hpbGQucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLmlkXG4gICAgICAgICAgZWxlbWVudHNUb01vZGlmeS5wdXNoKHtlbGVtZW50SWQ6IGNoaWxkLmlkLCBwcmV2aW91c0VsZW1lbnRJZDogcHJldmlvdXNFbGVtZW50SWR9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuY29udGFpbmVySWQgPSBjb250YWluZXJBZnRlci5pZFxuICAgIHRoaXMudXBkYXRlVHlwZSA9IHVwZGF0ZVR5cGVcbiAgICB0aGlzLmVsZW1lbnRzVG9Nb2RpZnkgPSBlbGVtZW50c1RvTW9kaWZ5XG4gICAgdGhpcy5lbGVtZW50SWRzVG9BZGQgPSBbLi4uaWRzQWZ0ZXJdLmZpbHRlcihpZCA9PiAhaWRzQmVmb3JlLmhhcyhpZCkpXG4gIH1cblxuICAvLyBXZSBkbyB0aGUgZm9sbG93aW5nIHRvIG9wdGltaXplIGFwcGVuZC9wcmVwZW5kIG9wZXJhdGlvbnM6XG4gIC8vICAgMSkgVHJhY2sgaWRzIG9mIG1vZGlmaWVkIGVsZW1lbnRzICYgb2YgbmV3IGVsZW1lbnRzXG4gIC8vICAgMikgQWxsIHRoZSBtb2RpZmllZCBlbGVtZW50cyBhcmUgcHV0IGJhY2sgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlIERPTSB0cmVlXG4gIC8vICAgICAgYnkgc3RvcmluZyB0aGUgaWQgb2YgdGhlaXIgcHJldmlvdXMgc2libGluZ1xuICAvLyAgIDMpIE5ldyBlbGVtZW50cyBhcmUgZ29pbmcgdG8gYmUgcHV0IGluIHRoZSByaWdodCBwbGFjZSBieSBtb3JwaGRvbSBkdXJpbmcgYXBwZW5kLlxuICAvLyAgICAgIEZvciBwcmVwZW5kLCB3ZSBtb3ZlIHRoZW0gdG8gdGhlIGZpcnN0IHBvc2l0aW9uIGluIHRoZSBjb250YWluZXJcbiAgcGVyZm9ybSgpe1xuICAgIGxldCBjb250YWluZXIgPSBET00uYnlJZCh0aGlzLmNvbnRhaW5lcklkKVxuICAgIHRoaXMuZWxlbWVudHNUb01vZGlmeS5mb3JFYWNoKGVsZW1lbnRUb01vZGlmeSA9PiB7XG4gICAgICBpZihlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpe1xuICAgICAgICBtYXliZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50VG9Nb2RpZnkucHJldmlvdXNFbGVtZW50SWQpLCBwcmV2aW91c0VsZW0gPT4ge1xuICAgICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICAgIGxldCBpc0luUmlnaHRQbGFjZSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZyAmJiBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaWQgPT0gcHJldmlvdXNFbGVtLmlkXG4gICAgICAgICAgICBpZighaXNJblJpZ2h0UGxhY2Upe1xuICAgICAgICAgICAgICBwcmV2aW91c0VsZW0uaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgZWxlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgY29udGFpbmVyXG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnRUb01vZGlmeS5lbGVtZW50SWQpLCBlbGVtID0+IHtcbiAgICAgICAgICBsZXQgaXNJblJpZ2h0UGxhY2UgPSBlbGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgPT0gbnVsbFxuICAgICAgICAgIGlmKCFpc0luUmlnaHRQbGFjZSl7XG4gICAgICAgICAgICBjb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJiZWdpblwiLCBlbGVtKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYodGhpcy51cGRhdGVUeXBlID09IFwicHJlcGVuZFwiKXtcbiAgICAgIHRoaXMuZWxlbWVudElkc1RvQWRkLnJldmVyc2UoKS5mb3JFYWNoKGVsZW1JZCA9PiB7XG4gICAgICAgIG1heWJlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1JZCksIGVsZW0gPT4gY29udGFpbmVyLmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyYmVnaW5cIiwgZWxlbSkpXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuIiwgInZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbmZ1bmN0aW9uIG1vcnBoQXR0cnMoZnJvbU5vZGUsIHRvTm9kZSkge1xuICAgIHZhciB0b05vZGVBdHRycyA9IHRvTm9kZS5hdHRyaWJ1dGVzO1xuICAgIHZhciBhdHRyO1xuICAgIHZhciBhdHRyTmFtZTtcbiAgICB2YXIgYXR0ck5hbWVzcGFjZVVSSTtcbiAgICB2YXIgYXR0clZhbHVlO1xuICAgIHZhciBmcm9tVmFsdWU7XG5cbiAgICAvLyBkb2N1bWVudC1mcmFnbWVudHMgZG9udCBoYXZlIGF0dHJpYnV0ZXMgc28gbGV0cyBub3QgZG8gYW55dGhpbmdcbiAgICBpZiAodG9Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IGZyb21Ob2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnRcbiAgICBmb3IgKHZhciBpID0gdG9Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXR0ciA9IHRvTm9kZUF0dHJzW2ldO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuICAgICAgICBhdHRyVmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlTlMoYXR0ck5hbWVzcGFjZVVSSSwgYXR0ck5hbWUpO1xuXG4gICAgICAgICAgICBpZiAoZnJvbVZhbHVlICE9PSBhdHRyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5wcmVmaXggPT09ICd4bWxucycpe1xuICAgICAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTsgLy8gSXQncyBub3QgYWxsb3dlZCB0byBzZXQgYW4gYXR0cmlidXRlIHdpdGggdGhlIFhNTE5TIG5hbWVzcGFjZSB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGB4bWxuc2AgcHJlZml4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gZnJvbU5vZGUuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleHRyYSBhdHRyaWJ1dGVzIGZvdW5kIG9uIHRoZSBvcmlnaW5hbCBET00gZWxlbWVudCB0aGF0XG4gICAgLy8gd2VyZW4ndCBmb3VuZCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgdmFyIGZyb21Ob2RlQXR0cnMgPSBmcm9tTm9kZS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICh2YXIgZCA9IGZyb21Ob2RlQXR0cnMubGVuZ3RoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgYXR0ciA9IGZyb21Ob2RlQXR0cnNbZF07XG4gICAgICAgIGF0dHJOYW1lID0gYXR0ci5uYW1lO1xuICAgICAgICBhdHRyTmFtZXNwYWNlVVJJID0gYXR0ci5uYW1lc3BhY2VVUkk7XG5cbiAgICAgICAgaWYgKGF0dHJOYW1lc3BhY2VVUkkpIHtcbiAgICAgICAgICAgIGF0dHJOYW1lID0gYXR0ci5sb2NhbE5hbWUgfHwgYXR0ck5hbWU7XG5cbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnJlbW92ZUF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdG9Ob2RlLmhhc0F0dHJpYnV0ZShhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgcmFuZ2U7IC8vIENyZWF0ZSBhIHJhbmdlIG9iamVjdCBmb3IgZWZmaWNlbnRseSByZW5kZXJpbmcgc3RyaW5ncyB0byBlbGVtZW50cy5cbnZhciBOU19YSFRNTCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcblxudmFyIGRvYyA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBkb2N1bWVudDtcbnZhciBIQVNfVEVNUExBVEVfU1VQUE9SVCA9ICEhZG9jICYmICdjb250ZW50JyBpbiBkb2MuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbnZhciBIQVNfUkFOR0VfU1VQUE9SVCA9ICEhZG9jICYmIGRvYy5jcmVhdGVSYW5nZSAmJiAnY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50JyBpbiBkb2MuY3JlYXRlUmFuZ2UoKTtcblxuZnVuY3Rpb24gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cikge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShkb2MuYm9keSk7XG4gICAgfVxuXG4gICAgdmFyIGZyYWdtZW50ID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0cik7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2JvZHknKTtcbiAgICBmcmFnbWVudC5pbm5lckhUTUwgPSBzdHI7XG4gICAgcmV0dXJuIGZyYWdtZW50LmNoaWxkTm9kZXNbMF07XG59XG5cbi8qKlxuICogVGhpcyBpcyBhYm91dCB0aGUgc2FtZVxuICogdmFyIGh0bWwgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHN0ciwgJ3RleHQvaHRtbCcpO1xuICogcmV0dXJuIGh0bWwuYm9keS5maXJzdENoaWxkO1xuICpcbiAqIEBtZXRob2QgdG9FbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKi9cbmZ1bmN0aW9uIHRvRWxlbWVudChzdHIpIHtcbiAgICBzdHIgPSBzdHIudHJpbSgpO1xuICAgIGlmIChIQVNfVEVNUExBVEVfU1VQUE9SVCkge1xuICAgICAgLy8gYXZvaWQgcmVzdHJpY3Rpb25zIG9uIGNvbnRlbnQgZm9yIHRoaW5ncyBsaWtlIGA8dHI+PHRoPkhpPC90aD48L3RyPmAgd2hpY2hcbiAgICAgIC8vIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBkb2Vzbid0IHN1cHBvcnRcbiAgICAgIC8vIDx0ZW1wbGF0ZT4gc3VwcG9ydCBub3QgYXZhaWxhYmxlIGluIElFXG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tVGVtcGxhdGUoc3RyKTtcbiAgICB9IGVsc2UgaWYgKEhBU19SQU5HRV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tUmFuZ2Uoc3RyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRnJhZ21lbnRGcm9tV3JhcChzdHIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0d28gbm9kZSdzIG5hbWVzIGFyZSB0aGUgc2FtZS5cbiAqXG4gKiBOT1RFOiBXZSBkb24ndCBib3RoZXIgY2hlY2tpbmcgYG5hbWVzcGFjZVVSSWAgYmVjYXVzZSB5b3Ugd2lsbCBuZXZlciBmaW5kIHR3byBIVE1MIGVsZW1lbnRzIHdpdGggdGhlIHNhbWVcbiAqICAgICAgIG5vZGVOYW1lIGFuZCBkaWZmZXJlbnQgbmFtZXNwYWNlIFVSSXMuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGIgVGhlIHRhcmdldCBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlTm9kZU5hbWVzKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBmcm9tTm9kZU5hbWUgPSBmcm9tRWwubm9kZU5hbWU7XG4gICAgdmFyIHRvTm9kZU5hbWUgPSB0b0VsLm5vZGVOYW1lO1xuICAgIHZhciBmcm9tQ29kZVN0YXJ0LCB0b0NvZGVTdGFydDtcblxuICAgIGlmIChmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnJvbUNvZGVTdGFydCA9IGZyb21Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuICAgIHRvQ29kZVN0YXJ0ID0gdG9Ob2RlTmFtZS5jaGFyQ29kZUF0KDApO1xuXG4gICAgLy8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgdmlydHVhbCBET00gbm9kZSBvciBTVkcgbm9kZSB0aGVuIHdlIG1heVxuICAgIC8vIG5lZWQgdG8gbm9ybWFsaXplIHRoZSB0YWcgbmFtZSBiZWZvcmUgY29tcGFyaW5nLiBOb3JtYWwgSFRNTCBlbGVtZW50cyB0aGF0IGFyZVxuICAgIC8vIGluIHRoZSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIlxuICAgIC8vIGFyZSBjb252ZXJ0ZWQgdG8gdXBwZXIgY2FzZVxuICAgIGlmIChmcm9tQ29kZVN0YXJ0IDw9IDkwICYmIHRvQ29kZVN0YXJ0ID49IDk3KSB7IC8vIGZyb20gaXMgdXBwZXIgYW5kIHRvIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiBmcm9tTm9kZU5hbWUgPT09IHRvTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKHRvQ29kZVN0YXJ0IDw9IDkwICYmIGZyb21Db2RlU3RhcnQgPj0gOTcpIHsgLy8gdG8gaXMgdXBwZXIgYW5kIGZyb20gaXMgbG93ZXJcbiAgICAgICAgcmV0dXJuIHRvTm9kZU5hbWUgPT09IGZyb21Ob2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQsIG9wdGlvbmFsbHkgd2l0aCBhIGtub3duIG5hbWVzcGFjZSBVUkkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGVsZW1lbnQgbmFtZSwgZS5nLiAnZGl2JyBvciAnc3ZnJ1xuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lc3BhY2VVUkldIHRoZSBlbGVtZW50J3MgbmFtZXNwYWNlIFVSSSwgaS5lLiB0aGUgdmFsdWUgb2ZcbiAqIGl0cyBgeG1sbnNgIGF0dHJpYnV0ZSBvciBpdHMgaW5mZXJyZWQgbmFtZXNwYWNlLlxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyhuYW1lLCBuYW1lc3BhY2VVUkkpIHtcbiAgICByZXR1cm4gIW5hbWVzcGFjZVVSSSB8fCBuYW1lc3BhY2VVUkkgPT09IE5TX1hIVE1MID9cbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnQobmFtZSkgOlxuICAgICAgICBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgbmFtZSk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjaGlsZHJlbiBvZiBvbmUgRE9NIGVsZW1lbnQgdG8gYW5vdGhlciBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBtb3ZlQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgdmFyIGN1ckNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgdG9FbC5hcHBlbmRDaGlsZChjdXJDaGlsZCk7XG4gICAgICAgIGN1ckNoaWxkID0gbmV4dENoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gdG9FbDtcbn1cblxuZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsIG5hbWUpIHtcbiAgICBpZiAoZnJvbUVsW25hbWVdICE9PSB0b0VsW25hbWVdKSB7XG4gICAgICAgIGZyb21FbFtuYW1lXSA9IHRvRWxbbmFtZV07XG4gICAgICAgIGlmIChmcm9tRWxbbmFtZV0pIHtcbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHNwZWNpYWxFbEhhbmRsZXJzID0ge1xuICAgIE9QVElPTjogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHZhciBwYXJlbnROb2RlID0gZnJvbUVsLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBwYXJlbnROYW1lID0gcGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ1NFTEVDVCcgJiYgIXBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdtdWx0aXBsZScpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb21FbC5oYXNBdHRyaWJ1dGUoJ3NlbGVjdGVkJykgJiYgIXRvRWwuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgTVMgRWRnZSBidWcgd2hlcmUgdGhlICdzZWxlY3RlZCcgYXR0cmlidXRlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQgaWYgc2V0IHRvIGEgbm9uLWVtcHR5IHZhbHVlOlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjA4NzY3OS9cbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLnJlbW92ZUF0dHJpYnV0ZSgnc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byByZXNldCBzZWxlY3QgZWxlbWVudCdzIHNlbGVjdGVkSW5kZXggdG8gLTEsIG90aGVyd2lzZSBzZXR0aW5nXG4gICAgICAgICAgICAgICAgLy8gZnJvbUVsLnNlbGVjdGVkIHVzaW5nIHRoZSBzeW5jQm9vbGVhbkF0dHJQcm9wIGJlbG93IGhhcyBubyBlZmZlY3QuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvcnJlY3Qgc2VsZWN0ZWRJbmRleCB3aWxsIGJlIHNldCBpbiB0aGUgU0VMRUNUIHNwZWNpYWwgaGFuZGxlciBiZWxvdy5cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ3NlbGVjdGVkJyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgXCJ2YWx1ZVwiIGF0dHJpYnV0ZSBpcyBzcGVjaWFsIGZvciB0aGUgPGlucHV0PiBlbGVtZW50IHNpbmNlIGl0IHNldHNcbiAgICAgKiB0aGUgaW5pdGlhbCB2YWx1ZS4gQ2hhbmdpbmcgdGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgd2l0aG91dCBjaGFuZ2luZyB0aGVcbiAgICAgKiBcInZhbHVlXCIgcHJvcGVydHkgd2lsbCBoYXZlIG5vIGVmZmVjdCBzaW5jZSBpdCBpcyBvbmx5IHVzZWQgdG8gdGhlIHNldCB0aGVcbiAgICAgKiBpbml0aWFsIHZhbHVlLiAgU2ltaWxhciBmb3IgdGhlIFwiY2hlY2tlZFwiIGF0dHJpYnV0ZSwgYW5kIFwiZGlzYWJsZWRcIi5cbiAgICAgKi9cbiAgICBJTlBVVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCAnY2hlY2tlZCcpO1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2Rpc2FibGVkJyk7XG5cbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gdG9FbC52YWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgVEVYVEFSRUE6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0b0VsLnZhbHVlO1xuICAgICAgICBpZiAoZnJvbUVsLnZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZnJvbUVsLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgLy8gTmVlZGVkIGZvciBJRS4gQXBwYXJlbnRseSBJRSBzZXRzIHRoZSBwbGFjZWhvbGRlciBhcyB0aGVcbiAgICAgICAgICAgIC8vIG5vZGUgdmFsdWUgYW5kIHZpc2UgdmVyc2EuIFRoaXMgaWdub3JlcyBhbiBlbXB0eSB1cGRhdGUuXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBmaXJzdENoaWxkLm5vZGVWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09IG5ld1ZhbHVlIHx8ICghbmV3VmFsdWUgJiYgb2xkVmFsdWUgPT0gZnJvbUVsLnBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU0VMRUNUOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgaWYgKCF0b0VsLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gbG9vcCB0aHJvdWdoIGNoaWxkcmVuIG9mIGZyb21FbCwgbm90IHRvRWwgc2luY2Ugbm9kZXMgY2FuIGJlIG1vdmVkXG4gICAgICAgICAgICAvLyBmcm9tIHRvRWwgdG8gZnJvbUVsIGRpcmVjdGx5IHdoZW4gbW9ycGhpbmcuXG4gICAgICAgICAgICAvLyBBdCB0aGUgdGltZSB0aGlzIHNwZWNpYWwgaGFuZGxlciBpcyBpbnZva2VkLCBhbGwgY2hpbGRyZW4gaGF2ZSBhbHJlYWR5IGJlZW4gbW9ycGhlZFxuICAgICAgICAgICAgLy8gYW5kIGFwcGVuZGVkIHRvIC8gcmVtb3ZlZCBmcm9tIGZyb21FbCwgc28gdXNpbmcgZnJvbUVsIGhlcmUgaXMgc2FmZSBhbmQgY29ycmVjdC5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgdmFyIG9wdGdyb3VwO1xuICAgICAgICAgICAgdmFyIG5vZGVOYW1lO1xuICAgICAgICAgICAgd2hpbGUoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBub2RlTmFtZSA9IGN1ckNoaWxkLm5vZGVOYW1lICYmIGN1ckNoaWxkLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUR1JPVVAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gY3VyQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdPUFRJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hpbGQuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJDaGlsZCAmJiBvcHRncm91cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBvcHRncm91cC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGdyb3VwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnJvbUVsLnNlbGVjdGVkSW5kZXggPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSQxID0gMTE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gZGVmYXVsdEdldE5vZGVLZXkobm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHx8IG5vZGUuaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpIHtcblxuICByZXR1cm4gZnVuY3Rpb24gbW9ycGhkb20oZnJvbU5vZGUsIHRvTm9kZSwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdG9Ob2RlID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGZyb21Ob2RlLm5vZGVOYW1lID09PSAnI2RvY3VtZW50JyB8fCBmcm9tTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgdmFyIHRvTm9kZUh0bWwgPSB0b05vZGU7XG4gICAgICAgIHRvTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgICAgIHRvTm9kZS5pbm5lckhUTUwgPSB0b05vZGVIdG1sO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9Ob2RlID0gdG9FbGVtZW50KHRvTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0b05vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSkge1xuICAgICAgdG9Ob2RlID0gdG9Ob2RlLmZpcnN0RWxlbWVudENoaWxkO1xuICAgIH1cblxuICAgIHZhciBnZXROb2RlS2V5ID0gb3B0aW9ucy5nZXROb2RlS2V5IHx8IGRlZmF1bHRHZXROb2RlS2V5O1xuICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlQWRkZWQgfHwgbm9vcDtcbiAgICB2YXIgb25Ob2RlQWRkZWQgPSBvcHRpb25zLm9uTm9kZUFkZGVkIHx8IG5vb3A7XG4gICAgdmFyIG9uQmVmb3JlRWxVcGRhdGVkID0gb3B0aW9ucy5vbkJlZm9yZUVsVXBkYXRlZCB8fCBub29wO1xuICAgIHZhciBvbkVsVXBkYXRlZCA9IG9wdGlvbnMub25FbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICB2YXIgb25CZWZvcmVOb2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbkJlZm9yZU5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICB2YXIgb25Ob2RlRGlzY2FyZGVkID0gb3B0aW9ucy5vbk5vZGVEaXNjYXJkZWQgfHwgbm9vcDtcbiAgICB2YXIgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCB8fCBub29wO1xuICAgIHZhciBza2lwRnJvbUNoaWxkcmVuID0gb3B0aW9ucy5za2lwRnJvbUNoaWxkcmVuIHx8IG5vb3A7XG4gICAgdmFyIGFkZENoaWxkID0gb3B0aW9ucy5hZGRDaGlsZCB8fCBmdW5jdGlvbihwYXJlbnQsIGNoaWxkKXsgcmV0dXJuIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7IH07XG4gICAgdmFyIGNoaWxkcmVuT25seSA9IG9wdGlvbnMuY2hpbGRyZW5Pbmx5ID09PSB0cnVlO1xuXG4gICAgLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBhcyBhIGxvb2t1cCB0byBxdWlja2x5IGZpbmQgYWxsIGtleWVkIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICB2YXIgZnJvbU5vZGVzTG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5ZWRSZW1vdmFsTGlzdCA9IFtdO1xuXG4gICAgZnVuY3Rpb24gYWRkS2V5ZWRSZW1vdmFsKGtleSkge1xuICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgdmFyIGN1ckNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcblxuICAgICAgICAgIHZhciBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoc2tpcEtleWVkTm9kZXMgJiYgKGtleSA9IGdldE5vZGVLZXkoY3VyQ2hpbGQpKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHNraXBwaW5nIGtleWVkIG5vZGVzIHRoZW4gd2UgYWRkIHRoZSBrZXlcbiAgICAgICAgICAgIC8vIHRvIGEgbGlzdCBzbyB0aGF0IGl0IGNhbiBiZSBoYW5kbGVkIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5IHJlcG9ydCB0aGUgbm9kZSBhcyBkaXNjYXJkZWQgaWYgaXQgaXMgbm90IGtleWVkLiBXZSBkbyB0aGlzIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgd2UgbG9vcCB0aHJvdWdoIGFsbCBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgdW5tYXRjaGVkXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBkaXNjYXJkIHRoZW0gaW4gb25lIGZpbmFsIHBhc3MuXG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMoY3VyQ2hpbGQsIHNraXBLZXllZE5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBSZW1vdmVzIGEgRE9NIG5vZGUgb3V0IG9mIHRoZSBvcmlnaW5hbCBET01cbiAgICAqXG4gICAgKiBAcGFyYW0gIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICAgICogQHBhcmFtICB7Tm9kZX0gcGFyZW50Tm9kZSBUaGUgbm9kZXMgcGFyZW50XG4gICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwS2V5ZWROb2RlcyBJZiB0cnVlIHRoZW4gZWxlbWVudHMgd2l0aCBrZXlzIHdpbGwgYmUgc2tpcHBlZCBhbmQgbm90IGRpc2NhcmRlZC5cbiAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSwgcGFyZW50Tm9kZSwgc2tpcEtleWVkTm9kZXMpIHtcbiAgICAgIGlmIChvbkJlZm9yZU5vZGVEaXNjYXJkZWQobm9kZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cblxuICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgIH1cblxuICAgIC8vIC8vIFRyZWVXYWxrZXIgaW1wbGVtZW50YXRpb24gaXMgbm8gZmFzdGVyLCBidXQga2VlcGluZyB0aGlzIGFyb3VuZCBpbiBjYXNlIHRoaXMgY2hhbmdlcyBpbiB0aGUgZnV0dXJlXG4gICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKHJvb3QpIHtcbiAgICAvLyAgICAgdmFyIHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKFxuICAgIC8vICAgICAgICAgcm9vdCxcbiAgICAvLyAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAvL1xuICAgIC8vICAgICB2YXIgZWw7XG4gICAgLy8gICAgIHdoaWxlKChlbCA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAvLyAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGVsKTtcbiAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgIC8vICAgICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gfVxuXG4gICAgLy8gLy8gTm9kZUl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIGlzIG5vIGZhc3RlciwgYnV0IGtlZXBpbmcgdGhpcyBhcm91bmQgaW4gY2FzZSB0aGlzIGNoYW5nZXMgaW4gdGhlIGZ1dHVyZVxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAvLyAgICAgdmFyIG5vZGVJdGVyYXRvciA9IGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcihub2RlLCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCk7XG4gICAgLy8gICAgIHZhciBlbDtcbiAgICAvLyAgICAgd2hpbGUoKGVsID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpKSB7XG4gICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgLy8gICAgICAgICBpZiAoa2V5KSB7XG4gICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAvLyAgICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vIH1cblxuICAgIGZ1bmN0aW9uIGluZGV4VHJlZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSkge1xuICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGN1ckNoaWxkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdhbGsgcmVjdXJzaXZlbHlcbiAgICAgICAgICBpbmRleFRyZWUoY3VyQ2hpbGQpO1xuXG4gICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGluZGV4VHJlZShmcm9tTm9kZSk7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVOb2RlQWRkZWQoZWwpIHtcbiAgICAgIG9uTm9kZUFkZGVkKGVsKTtcblxuICAgICAgdmFyIGN1ckNoaWxkID0gZWwuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCk7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICB2YXIgdW5tYXRjaGVkRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2tleV07XG4gICAgICAgICAgLy8gaWYgd2UgZmluZCBhIGR1cGxpY2F0ZSAjaWQgbm9kZSBpbiBjYWNoZSwgcmVwbGFjZSBgZWxgIHdpdGggY2FjaGUgdmFsdWVcbiAgICAgICAgICAvLyBhbmQgbW9ycGggaXQgdG8gdGhlIGNoaWxkIG5vZGUuXG4gICAgICAgICAgaWYgKHVubWF0Y2hlZEZyb21FbCAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckNoaWxkLCB1bm1hdGNoZWRGcm9tRWwpKSB7XG4gICAgICAgICAgICBjdXJDaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgIG1vcnBoRWwodW5tYXRjaGVkRnJvbUVsLCBjdXJDaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgZm9yIGN1ckNoaWxkIGFuZCBpdCdzIGNoaWxkcmVuIHRvIHNlZSBpZiB3ZSBmaW5kIHNvbWV0aGluZyBpblxuICAgICAgICAgIC8vIGZyb21Ob2Rlc0xvb2t1cFxuICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJDaGlsZCA9IG5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBGcm9tRWwoZnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkLCBjdXJGcm9tTm9kZUtleSkge1xuICAgICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG9mIHRoZSBcInRvIG5vZGVzXCIuIElmIGN1ckZyb21Ob2RlQ2hpbGQgaXNcbiAgICAgIC8vIG5vbi1udWxsIHRoZW4gd2Ugc3RpbGwgaGF2ZSBzb21lIGZyb20gbm9kZXMgbGVmdCBvdmVyIHRoYXQgbmVlZFxuICAgICAgLy8gdG8gYmUgcmVtb3ZlZFxuICAgICAgd2hpbGUgKGN1ckZyb21Ob2RlQ2hpbGQpIHtcbiAgICAgICAgdmFyIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmICgoY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpKSkge1xuICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3JwaEVsKGZyb21FbCwgdG9FbCwgY2hpbGRyZW5Pbmx5KSB7XG4gICAgICB2YXIgdG9FbEtleSA9IGdldE5vZGVLZXkodG9FbCk7XG5cbiAgICAgIGlmICh0b0VsS2V5KSB7XG4gICAgICAgIC8vIElmIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBpcyBiZWluZyBtb3JwaGVkIHRoZW4gaXQgd2lsbCBiZSBpbiB0aGUgZmluYWxcbiAgICAgICAgLy8gRE9NIHNvIGNsZWFyIGl0IG91dCBvZiB0aGUgc2F2ZWQgZWxlbWVudHMgY29sbGVjdGlvblxuICAgICAgICBkZWxldGUgZnJvbU5vZGVzTG9va3VwW3RvRWxLZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNoaWxkcmVuT25seSkge1xuICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICB2YXIgYmVmb3JlVXBkYXRlUmVzdWx0ID0gb25CZWZvcmVFbFVwZGF0ZWQoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgaWYgKGJlZm9yZVVwZGF0ZVJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYmVmb3JlVXBkYXRlUmVzdWx0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBmcm9tRWwgPSBiZWZvcmVVcGRhdGVSZXN1bHQ7XG4gICAgICAgICAgLy8gcmVpbmRleCB0aGUgbmV3IGZyb21FbCBpbiBjYXNlIGl0J3Mgbm90IGluIHRoZSBzYW1lXG4gICAgICAgICAgLy8gdHJlZSBhcyB0aGUgb3JpZ2luYWwgZnJvbUVsXG4gICAgICAgICAgLy8gKFBob2VuaXggTGl2ZVZpZXcgc29tZXRpbWVzIHJldHVybnMgYSBjbG9uZWQgdHJlZSxcbiAgICAgICAgICAvLyAgYnV0IGtleWVkIGxvb2t1cHMgd291bGQgc3RpbGwgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIHRyZWUpXG4gICAgICAgICAgaW5kZXhUcmVlKGZyb21FbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgYXR0cmlidXRlcyBvbiBvcmlnaW5hbCBET00gZWxlbWVudCBmaXJzdFxuICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgIC8vIG9wdGlvbmFsXG4gICAgICAgIG9uRWxVcGRhdGVkKGZyb21FbCk7XG5cbiAgICAgICAgaWYgKG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZyb21FbC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGVjaWFsRWxIYW5kbGVycy5URVhUQVJFQShmcm9tRWwsIHRvRWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vcnBoQ2hpbGRyZW4oZnJvbUVsLCB0b0VsKSB7XG4gICAgICB2YXIgc2tpcEZyb20gPSBza2lwRnJvbUNoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICB2YXIgY3VyVG9Ob2RlQ2hpbGQgPSB0b0VsLmZpcnN0Q2hpbGQ7XG4gICAgICB2YXIgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgICAgdmFyIGN1clRvTm9kZUtleTtcbiAgICAgIHZhciBjdXJGcm9tTm9kZUtleTtcblxuICAgICAgdmFyIGZyb21OZXh0U2libGluZztcbiAgICAgIHZhciB0b05leHRTaWJsaW5nO1xuICAgICAgdmFyIG1hdGNoaW5nRnJvbUVsO1xuXG4gICAgICAvLyB3YWxrIHRoZSBjaGlsZHJlblxuICAgICAgb3V0ZXI6IHdoaWxlIChjdXJUb05vZGVDaGlsZCkge1xuICAgICAgICB0b05leHRTaWJsaW5nID0gY3VyVG9Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIGN1clRvTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyVG9Ob2RlQ2hpbGQpO1xuXG4gICAgICAgIC8vIHdhbGsgdGhlIGZyb21Ob2RlIGNoaWxkcmVuIGFsbCB0aGUgd2F5IHRocm91Z2hcbiAgICAgICAgd2hpbGUgKCFza2lwRnJvbSAmJiBjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgZnJvbU5leHRTaWJsaW5nID0gY3VyRnJvbU5vZGVDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgIGlmIChjdXJUb05vZGVDaGlsZC5pc1NhbWVOb2RlICYmIGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICB2YXIgY3VyRnJvbU5vZGVUeXBlID0gY3VyRnJvbU5vZGVDaGlsZC5ub2RlVHlwZTtcblxuICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaWYgdGhlIGN1ckZyb21Ob2RlQ2hpbGQgZG9lc250IGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJUb05vZGVDaGlsZFxuICAgICAgICAgIHZhciBpc0NvbXBhdGlibGUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBjdXJUb05vZGVDaGlsZC5ub2RlVHlwZSkge1xuICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIEVsZW1lbnQgbm9kZXNcblxuICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBub2RlIGhhcyBhIGtleSBzbyB3ZSB3YW50IHRvIG1hdGNoIGl0IHVwIHdpdGggdGhlIGNvcnJlY3QgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZVxuICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgIT09IGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBET00gdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcga2V5IHNvXG4gICAgICAgICAgICAgICAgICAvLyBsZXQncyBjaGVjayBvdXIgbG9va3VwIHRvIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAvLyBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbU5leHRTaWJsaW5nID09PSBtYXRjaGluZ0Zyb21FbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGVsZW1lbnQgcmVtb3ZhbHMuIFRvIGF2b2lkIHJlbW92aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIERPTSBub2RlIG91dCBvZiB0aGUgdHJlZSAoc2luY2UgdGhhdCBjYW4gYnJlYWsgQ1NTIHRyYW5zaXRpb25zLCBldGMuKSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIGluc3RlYWQgZGlzY2FyZCB0aGUgY3VycmVudCBub2RlIGFuZCB3YWl0IHVudGlsIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uIHRvIHByb3Blcmx5IG1hdGNoIHVwIHRoZSBrZXllZCB0YXJnZXQgZWxlbWVudCB3aXRoIGl0cyBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBmb3VuZCBhIG1hdGNoaW5nIGtleWVkIGVsZW1lbnQgc29tZXdoZXJlIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBtb3ZlIHRoZSBvcmlnaW5hbCBET00gbm9kZSBpbnRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBtb3JwaFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGl0LlxuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogV2UgdXNlIGluc2VydEJlZm9yZSBpbnN0ZWFkIG9mIHJlcGxhY2VDaGlsZCBiZWNhdXNlIHdlIHdhbnQgdG8gZ28gdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVtb3ZlTm9kZSgpYCBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkaXNjYXJkZWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBsaWZlY3ljbGUgaG9va3MgYXJlIGNvcnJlY3RseSBpbnZva2VkXG4gICAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmluc2VydEJlZm9yZShtYXRjaGluZ0Zyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgbm9kZSBpcyBrZXllZCBpdCBtaWdodCBiZSBtYXRjaGVkIHVwIGxhdGVyIHNvIHdlIGRlZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYWN0dWFsIHJlbW92YWwgdG8gbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBtYXRjaGluZ0Zyb21FbDtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBub2RlcyBhcmUgbm90IGNvbXBhdGlibGUgc2luY2UgdGhlIFwidG9cIiBub2RlIGhhcyBhIGtleSBhbmQgdGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gbWF0Y2hpbmcga2V5ZWQgbm9kZSBpbiB0aGUgc291cmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIGhhcyBhIGtleVxuICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaXNDb21wYXRpYmxlID0gaXNDb21wYXRpYmxlICE9PSBmYWxzZSAmJiBjb21wYXJlTm9kZU5hbWVzKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgaWYgKGlzQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGNvbXBhdGlibGUgRE9NIGVsZW1lbnRzIHNvIHRyYW5zZm9ybVxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IFwiZnJvbVwiIG5vZGUgdG8gbWF0Y2ggdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAvLyB0YXJnZXQgRE9NIG5vZGUuXG4gICAgICAgICAgICAgICAgLy8gTU9SUEhcbiAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1ckZyb21Ob2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IGN1ckZyb21Ob2RlVHlwZSA9PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgLy8gQm90aCBub2RlcyBiZWluZyBjb21wYXJlZCBhcmUgVGV4dCBvciBDb21tZW50IG5vZGVzXG4gICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIFNpbXBseSB1cGRhdGUgbm9kZVZhbHVlIG9uIHRoZSBvcmlnaW5hbCBub2RlIHRvXG4gICAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgdGV4dCB2YWx1ZVxuICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgIT09IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQubm9kZVZhbHVlID0gY3VyVG9Ob2RlQ2hpbGQubm9kZVZhbHVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAvLyBBZHZhbmNlIGJvdGggdGhlIFwidG9cIiBjaGlsZCBhbmQgdGhlIFwiZnJvbVwiIGNoaWxkIHNpbmNlIHdlIGZvdW5kIGEgbWF0Y2hcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgZWxzZSB0byBkbyBhcyB3ZSBhbHJlYWR5IHJlY3Vyc2l2ZWx5IGNhbGxlZCBtb3JwaENoaWxkcmVuIGFib3ZlXG4gICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTm8gY29tcGF0aWJsZSBtYXRjaCBzbyByZW1vdmUgdGhlIG9sZCBub2RlIGZyb20gdGhlIERPTSBhbmQgY29udGludWUgdHJ5aW5nIHRvIGZpbmQgYVxuICAgICAgICAgIC8vIG1hdGNoIGluIHRoZSBvcmlnaW5hbCBET00uIEhvd2V2ZXIsIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgZnJvbSBub2RlIGlzIG5vdCBrZXllZFxuICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBrZXllZCBub2RlIG1pZ2h0IG1hdGNoIHVwIHdpdGggYSBub2RlIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgICAgIC8vIHRhcmdldCB0cmVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGRpc2NhcmQgaXQganVzdCB5ZXQgc2luY2UgaXQgc3RpbGwgbWlnaHQgZmluZCBhXG4gICAgICAgICAgLy8gaG9tZSBpbiB0aGUgZmluYWwgRE9NIHRyZWUuIEFmdGVyIGV2ZXJ5dGhpbmcgaXMgZG9uZSB3ZSB3aWxsIHJlbW92ZSBhbnkga2V5ZWQgbm9kZXNcbiAgICAgICAgICAvLyB0aGF0IGRpZG4ndCBmaW5kIGEgaG9tZVxuICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSBza2lwIG5lc3RlZCBrZXllZCBub2RlcyBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgdGhlcmUgaXNcbiAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICByZW1vdmVOb2RlKGN1ckZyb21Ob2RlQ2hpbGQsIGZyb21FbCwgdHJ1ZSAvKiBza2lwIGtleWVkIG5vZGVzICovKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICB9IC8vIEVORDogd2hpbGUoY3VyRnJvbU5vZGVDaGlsZCkge31cblxuICAgICAgICAvLyBJZiB3ZSBnb3QgdGhpcyBmYXIgdGhlbiB3ZSBkaWQgbm90IGZpbmQgYSBjYW5kaWRhdGUgbWF0Y2ggZm9yXG4gICAgICAgIC8vIG91ciBcInRvIG5vZGVcIiBhbmQgd2UgZXhoYXVzdGVkIGFsbCBvZiB0aGUgY2hpbGRyZW4gXCJmcm9tXCJcbiAgICAgICAgLy8gbm9kZXMuIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IGFwcGVuZCB0aGUgY3VycmVudCBcInRvXCIgbm9kZVxuICAgICAgICAvLyB0byB0aGUgZW5kXG4gICAgICAgIGlmIChjdXJUb05vZGVLZXkgJiYgKG1hdGNoaW5nRnJvbUVsID0gZnJvbU5vZGVzTG9va3VwW2N1clRvTm9kZUtleV0pICYmIGNvbXBhcmVOb2RlTmFtZXMobWF0Y2hpbmdGcm9tRWwsIGN1clRvTm9kZUNoaWxkKSkge1xuICAgICAgICAgIC8vIE1PUlBIXG4gICAgICAgICAgaWYoIXNraXBGcm9tKXsgYWRkQ2hpbGQoZnJvbUVsLCBtYXRjaGluZ0Zyb21FbCk7IH1cbiAgICAgICAgICBtb3JwaEVsKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ID0gb25CZWZvcmVOb2RlQWRkZWQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCkge1xuICAgICAgICAgICAgICBjdXJUb05vZGVDaGlsZCA9IG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKSB7XG4gICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDaGlsZChmcm9tRWwsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgIGhhbmRsZU5vZGVBZGRlZChjdXJUb05vZGVDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpO1xuXG4gICAgICB2YXIgc3BlY2lhbEVsSGFuZGxlciA9IHNwZWNpYWxFbEhhbmRsZXJzW2Zyb21FbC5ub2RlTmFtZV07XG4gICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICBzcGVjaWFsRWxIYW5kbGVyKGZyb21FbCwgdG9FbCk7XG4gICAgICB9XG4gICAgfSAvLyBFTkQ6IG1vcnBoQ2hpbGRyZW4oLi4uKVxuXG4gICAgdmFyIG1vcnBoZWROb2RlID0gZnJvbU5vZGU7XG4gICAgdmFyIG1vcnBoZWROb2RlVHlwZSA9IG1vcnBoZWROb2RlLm5vZGVUeXBlO1xuICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuXG4gICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBhcmUgZ2l2ZW4gdHdvIERPTSBub2RlcyB0aGF0IGFyZSBub3RcbiAgICAgIC8vIGNvbXBhdGlibGUgKGUuZy4gPGRpdj4gLS0+IDxzcGFuPiBvciA8ZGl2PiAtLT4gVEVYVClcbiAgICAgIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKCFjb21wYXJlTm9kZU5hbWVzKGZyb21Ob2RlLCB0b05vZGUpKSB7XG4gICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoZnJvbU5vZGUpO1xuICAgICAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3ZlQ2hpbGRyZW4oZnJvbU5vZGUsIGNyZWF0ZUVsZW1lbnROUyh0b05vZGUubm9kZU5hbWUsIHRvTm9kZS5uYW1lc3BhY2VVUkkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gR29pbmcgZnJvbSBhbiBlbGVtZW50IG5vZGUgdG8gYSB0ZXh0IG5vZGVcbiAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtb3JwaGVkTm9kZVR5cGUgPT09IFRFWFRfTk9ERSB8fCBtb3JwaGVkTm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkgeyAvLyBUZXh0IG9yIGNvbW1lbnQgbm9kZVxuICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gbW9ycGhlZE5vZGVUeXBlKSB7XG4gICAgICAgICAgaWYgKG1vcnBoZWROb2RlLm5vZGVWYWx1ZSAhPT0gdG9Ob2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgbW9ycGhlZE5vZGUubm9kZVZhbHVlID0gdG9Ob2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGV4dCBub2RlIHRvIHNvbWV0aGluZyBlbHNlXG4gICAgICAgICAgbW9ycGhlZE5vZGUgPSB0b05vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9ycGhlZE5vZGUgPT09IHRvTm9kZSkge1xuICAgICAgLy8gVGhlIFwidG8gbm9kZVwiIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBcImZyb20gbm9kZVwiIHNvIHdlIGhhZCB0b1xuICAgICAgLy8gdG9zcyBvdXQgdGhlIFwiZnJvbSBub2RlXCIgYW5kIHVzZSB0aGUgXCJ0byBub2RlXCJcbiAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0b05vZGUuaXNTYW1lTm9kZSAmJiB0b05vZGUuaXNTYW1lTm9kZShtb3JwaGVkTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtb3JwaEVsKG1vcnBoZWROb2RlLCB0b05vZGUsIGNoaWxkcmVuT25seSk7XG5cbiAgICAgIC8vIFdlIG5vdyBuZWVkIHRvIGxvb3Agb3ZlciBhbnkga2V5ZWQgbm9kZXMgdGhhdCBtaWdodCBuZWVkIHRvIGJlXG4gICAgICAvLyByZW1vdmVkLiBXZSBvbmx5IGRvIHRoZSByZW1vdmFsIGlmIHdlIGtub3cgdGhhdCB0aGUga2V5ZWQgbm9kZVxuICAgICAgLy8gbmV2ZXIgZm91bmQgYSBtYXRjaC4gV2hlbiBhIGtleWVkIG5vZGUgaXMgbWF0Y2hlZCB1cCB3ZSByZW1vdmVcbiAgICAgIC8vIGl0IG91dCBvZiBmcm9tTm9kZXNMb29rdXAgYW5kIHdlIHVzZSBmcm9tTm9kZXNMb29rdXAgdG8gZGV0ZXJtaW5lXG4gICAgICAvLyBpZiBhIGtleWVkIG5vZGUgaGFzIGJlZW4gbWF0Y2hlZCB1cCBvciBub3RcbiAgICAgIGlmIChrZXllZFJlbW92YWxMaXN0KSB7XG4gICAgICAgIGZvciAodmFyIGk9MCwgbGVuPWtleWVkUmVtb3ZhbExpc3QubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5ZWRSZW1vdmFsTGlzdFtpXV07XG4gICAgICAgICAgaWYgKGVsVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZWxUb1JlbW92ZSwgZWxUb1JlbW92ZS5wYXJlbnROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZHJlbk9ubHkgJiYgbW9ycGhlZE5vZGUgIT09IGZyb21Ob2RlICYmIGZyb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChtb3JwaGVkTm9kZS5hY3R1YWxpemUpIHtcbiAgICAgICAgbW9ycGhlZE5vZGUgPSBtb3JwaGVkTm9kZS5hY3R1YWxpemUoZnJvbU5vZGUub3duZXJEb2N1bWVudCB8fCBkb2MpO1xuICAgICAgfVxuICAgICAgLy8gSWYgd2UgaGFkIHRvIHN3YXAgb3V0IHRoZSBmcm9tIG5vZGUgd2l0aCBhIG5ldyBub2RlIGJlY2F1c2UgdGhlIG9sZFxuICAgICAgLy8gbm9kZSB3YXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgdGFyZ2V0IG5vZGUgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAvLyByZXBsYWNlIHRoZSBvbGQgRE9NIG5vZGUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLiBUaGlzIGlzIG9ubHlcbiAgICAgIC8vIHBvc3NpYmxlIGlmIHRoZSBvcmlnaW5hbCBET00gbm9kZSB3YXMgcGFydCBvZiBhIERPTSB0cmVlIHdoaWNoXG4gICAgICAvLyB3ZSBrbm93IGlzIHRoZSBjYXNlIGlmIGl0IGhhcyBhIHBhcmVudCBub2RlLlxuICAgICAgZnJvbU5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobW9ycGhlZE5vZGUsIGZyb21Ob2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9ycGhlZE5vZGU7XG4gIH07XG59XG5cbnZhciBtb3JwaGRvbSA9IG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKTtcblxuZXhwb3J0IGRlZmF1bHQgbW9ycGhkb207XG4iLCAiaW1wb3J0IHtcbiAgUEhYX0NPTVBPTkVOVCxcbiAgUEhYX1BSVU5FLFxuICBQSFhfUk9PVF9JRCxcbiAgUEhYX1NFU1NJT04sXG4gIFBIWF9TS0lQLFxuICBQSFhfTUFHSUNfSUQsXG4gIFBIWF9TVEFUSUMsXG4gIFBIWF9UUklHR0VSX0FDVElPTixcbiAgUEhYX1VQREFURSxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9SRUZfTE9DSyxcbiAgUEhYX1NUUkVBTSxcbiAgUEhYX1NUUkVBTV9SRUYsXG4gIFBIWF9WSUVXUE9SVF9UT1AsXG4gIFBIWF9WSUVXUE9SVF9CT1RUT00sXG59IGZyb20gXCIuL2NvbnN0YW50c1wiXG5cbmltcG9ydCB7XG4gIGRldGVjdER1cGxpY2F0ZUlkcyxcbiAgZGV0ZWN0SW52YWxpZFN0cmVhbUluc2VydHMsXG4gIGlzQ2lkXG59IGZyb20gXCIuL3V0aWxzXCJcblxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IERPTVBvc3RNb3JwaFJlc3RvcmVyIGZyb20gXCIuL2RvbV9wb3N0X21vcnBoX3Jlc3RvcmVyXCJcbmltcG9ydCBtb3JwaGRvbSBmcm9tIFwibW9ycGhkb21cIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBET01QYXRjaCB7XG4gIGNvbnN0cnVjdG9yKHZpZXcsIGNvbnRhaW5lciwgaWQsIGh0bWwsIHN0cmVhbXMsIHRhcmdldENJRCwgb3B0cz17fSl7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyXG4gICAgdGhpcy5pZCA9IGlkXG4gICAgdGhpcy5yb290SUQgPSB2aWV3LnJvb3QuaWRcbiAgICB0aGlzLmh0bWwgPSBodG1sXG4gICAgdGhpcy5zdHJlYW1zID0gc3RyZWFtc1xuICAgIHRoaXMuc3RyZWFtSW5zZXJ0cyA9IHt9XG4gICAgdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlID0ge31cbiAgICB0aGlzLnRhcmdldENJRCA9IHRhcmdldENJRFxuICAgIHRoaXMuY2lkUGF0Y2ggPSBpc0NpZCh0aGlzLnRhcmdldENJRClcbiAgICB0aGlzLnBlbmRpbmdSZW1vdmVzID0gW11cbiAgICB0aGlzLnBoeFJlbW92ZSA9IHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgdGhpcy50YXJnZXRDb250YWluZXIgPSB0aGlzLmlzQ0lEUGF0Y2goKSA/IHRoaXMudGFyZ2V0Q0lEQ29udGFpbmVyKGh0bWwpIDogY29udGFpbmVyXG4gICAgdGhpcy5jYWxsYmFja3MgPSB7XG4gICAgICBiZWZvcmVhZGRlZDogW10sIGJlZm9yZXVwZGF0ZWQ6IFtdLCBiZWZvcmVwaHhDaGlsZEFkZGVkOiBbXSxcbiAgICAgIGFmdGVyYWRkZWQ6IFtdLCBhZnRlcnVwZGF0ZWQ6IFtdLCBhZnRlcmRpc2NhcmRlZDogW10sIGFmdGVycGh4Q2hpbGRBZGRlZDogW10sXG4gICAgICBhZnRlcnRyYW5zaXRpb25zRGlzY2FyZGVkOiBbXVxuICAgIH1cbiAgICB0aGlzLndpdGhDaGlsZHJlbiA9IG9wdHMud2l0aENoaWxkcmVuIHx8IG9wdHMudW5kb1JlZiB8fCBmYWxzZVxuICAgIHRoaXMudW5kb1JlZiA9IG9wdHMudW5kb1JlZlxuICB9XG5cbiAgYmVmb3JlKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGJlZm9yZSR7a2luZH1gXS5wdXNoKGNhbGxiYWNrKSB9XG4gIGFmdGVyKGtpbmQsIGNhbGxiYWNrKXsgdGhpcy5jYWxsYmFja3NbYGFmdGVyJHtraW5kfWBdLnB1c2goY2FsbGJhY2spIH1cblxuICB0cmFja0JlZm9yZShraW5kLCAuLi5hcmdzKXtcbiAgICB0aGlzLmNhbGxiYWNrc1tgYmVmb3JlJHtraW5kfWBdLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soLi4uYXJncykpXG4gIH1cblxuICB0cmFja0FmdGVyKGtpbmQsIC4uLmFyZ3Mpe1xuICAgIHRoaXMuY2FsbGJhY2tzW2BhZnRlciR7a2luZH1gXS5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKC4uLmFyZ3MpKVxuICB9XG5cbiAgbWFya1BydW5hYmxlQ29udGVudEZvclJlbW92YWwoKXtcbiAgICBsZXQgcGh4VXBkYXRlID0gdGhpcy5saXZlU29ja2V0LmJpbmRpbmcoUEhYX1VQREFURSlcbiAgICBET00uYWxsKHRoaXMuY29udGFpbmVyLCBgWyR7cGh4VXBkYXRlfT1hcHBlbmRdID4gKiwgWyR7cGh4VXBkYXRlfT1wcmVwZW5kXSA+ICpgLCBlbCA9PiB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoUEhYX1BSVU5FLCBcIlwiKVxuICAgIH0pXG4gIH1cblxuICBwZXJmb3JtKGlzSm9pblBhdGNoKXtcbiAgICBsZXQge3ZpZXcsIGxpdmVTb2NrZXQsIGh0bWwsIGNvbnRhaW5lciwgdGFyZ2V0Q29udGFpbmVyfSA9IHRoaXNcbiAgICBpZih0aGlzLmlzQ0lEUGF0Y2goKSAmJiAhdGFyZ2V0Q29udGFpbmVyKXsgcmV0dXJuIH1cblxuICAgIGxldCBmb2N1c2VkID0gbGl2ZVNvY2tldC5nZXRBY3RpdmVFbGVtZW50KClcbiAgICBsZXQge3NlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmR9ID0gZm9jdXNlZCAmJiBET00uaGFzU2VsZWN0aW9uUmFuZ2UoZm9jdXNlZCkgPyBmb2N1c2VkIDoge31cbiAgICBsZXQgcGh4VXBkYXRlID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9VUERBVEUpXG4gICAgbGV0IHBoeFZpZXdwb3J0VG9wID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9WSUVXUE9SVF9UT1ApXG4gICAgbGV0IHBoeFZpZXdwb3J0Qm90dG9tID0gbGl2ZVNvY2tldC5iaW5kaW5nKFBIWF9WSUVXUE9SVF9CT1RUT00pXG4gICAgbGV0IHBoeFRyaWdnZXJFeHRlcm5hbCA9IGxpdmVTb2NrZXQuYmluZGluZyhQSFhfVFJJR0dFUl9BQ1RJT04pXG4gICAgbGV0IGFkZGVkID0gW11cbiAgICBsZXQgdXBkYXRlcyA9IFtdXG4gICAgbGV0IGFwcGVuZFByZXBlbmRVcGRhdGVzID0gW11cblxuICAgIGxldCBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBudWxsXG5cbiAgICBmdW5jdGlvbiBtb3JwaCh0YXJnZXRDb250YWluZXIsIHNvdXJjZSwgd2l0aENoaWxkcmVuPXRoaXMud2l0aENoaWxkcmVuKXtcbiAgICAgIGxldCBtb3JwaENhbGxiYWNrcyA9IHtcbiAgICAgICAgLy8gbm9ybWFsbHksIHdlIGFyZSBydW5uaW5nIHdpdGggY2hpbGRyZW5Pbmx5LCBhcyB0aGUgcGF0Y2ggSFRNTCBmb3IgYSBMVlxuICAgICAgICAvLyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBMViBhdHRycyAoZGF0YS1waHgtc2Vzc2lvbiwgZXRjLilcbiAgICAgICAgLy8gd2hlbiB3ZSBhcmUgcGF0Y2hpbmcgYSBsaXZlIGNvbXBvbmVudCwgd2UgZG8gd2FudCB0byBwYXRjaCB0aGUgcm9vdCBlbGVtZW50IGFzIHdlbGw7XG4gICAgICAgIC8vIGFub3RoZXIgY2FzZSBpcyB0aGUgcmVjdXJzaXZlIHBhdGNoIG9mIGEgc3RyZWFtIGl0ZW0gdGhhdCB3YXMga2VwdCBvbiByZXNldCAoLT4gb25CZWZvcmVOb2RlQWRkZWQpXG4gICAgICAgIGNoaWxkcmVuT25seTogdGFyZ2V0Q29udGFpbmVyLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKSA9PT0gbnVsbCAmJiAhd2l0aENoaWxkcmVuLFxuICAgICAgICBnZXROb2RlS2V5OiAobm9kZSkgPT4ge1xuICAgICAgICAgIGlmKERPTS5pc1BoeERlc3Ryb3llZChub2RlKSl7IHJldHVybiBudWxsIH1cbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgam9pbiBwYXRjaCwgdGhlbiBieSBkZWZpbml0aW9uIHRoZXJlIHdhcyBubyBQSFhfTUFHSUNfSUQuXG4gICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgdG8gcmVkdWNlIHRoZSBhbW91bnQgb2YgZWxlbWVudHMgbW9ycGhkb20gZGlzY2FyZHMuXG4gICAgICAgICAgaWYoaXNKb2luUGF0Y2gpeyByZXR1cm4gbm9kZS5pZCB9XG4gICAgICAgICAgcmV0dXJuIG5vZGUuaWQgfHwgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKFBIWF9NQUdJQ19JRCkpXG4gICAgICAgIH0sXG4gICAgICAgIC8vIHNraXAgaW5kZXhpbmcgZnJvbSBjaGlsZHJlbiB3aGVuIGNvbnRhaW5lciBpcyBzdHJlYW1cbiAgICAgICAgc2tpcEZyb21DaGlsZHJlbjogKGZyb20pID0+IHsgcmV0dXJuIGZyb20uZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkgPT09IFBIWF9TVFJFQU0gfSxcbiAgICAgICAgLy8gdGVsbCBtb3JwaGRvbSBob3cgdG8gYWRkIGEgY2hpbGRcbiAgICAgICAgYWRkQ2hpbGQ6IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gICAgICAgICAgbGV0IHtyZWYsIHN0cmVhbUF0fSA9IHRoaXMuZ2V0U3RyZWFtSW5zZXJ0KGNoaWxkKVxuICAgICAgICAgIGlmKHJlZiA9PT0gdW5kZWZpbmVkKXsgcmV0dXJuIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCkgfVxuXG4gICAgICAgICAgdGhpcy5zZXRTdHJlYW1SZWYoY2hpbGQsIHJlZilcblxuICAgICAgICAgIC8vIHN0cmVhbWluZ1xuICAgICAgICAgIGlmKHN0cmVhbUF0ID09PSAwKXtcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRBZGphY2VudEVsZW1lbnQoXCJhZnRlcmJlZ2luXCIsIGNoaWxkKVxuICAgICAgICAgIH0gZWxzZSBpZihzdHJlYW1BdCA9PT0gLTEpe1xuICAgICAgICAgICAgbGV0IGxhc3RDaGlsZCA9IHBhcmVudC5sYXN0RWxlbWVudENoaWxkXG4gICAgICAgICAgICBpZihsYXN0Q2hpbGQgJiYgIWxhc3RDaGlsZC5oYXNBdHRyaWJ1dGUoUEhYX1NUUkVBTV9SRUYpKXtcbiAgICAgICAgICAgICAgbGV0IG5vblN0cmVhbUNoaWxkID0gQXJyYXkuZnJvbShwYXJlbnQuY2hpbGRyZW4pLmZpbmQoYyA9PiAhYy5oYXNBdHRyaWJ1dGUoUEhYX1NUUkVBTV9SRUYpKVxuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCBub25TdHJlYW1DaGlsZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoc3RyZWFtQXQgPiAwKXtcbiAgICAgICAgICAgIGxldCBzaWJsaW5nID0gQXJyYXkuZnJvbShwYXJlbnQuY2hpbGRyZW4pW3N0cmVhbUF0XVxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgc2libGluZylcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlTm9kZUFkZGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBET00ubWFpbnRhaW5Qcml2YXRlSG9va3MoZWwsIGVsLCBwaHhWaWV3cG9ydFRvcCwgcGh4Vmlld3BvcnRCb3R0b20pXG4gICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcImFkZGVkXCIsIGVsKVxuXG4gICAgICAgICAgbGV0IG1vcnBoZWRFbCA9IGVsXG4gICAgICAgICAgLy8gdGhpcyBpcyBhIHN0cmVhbSBpdGVtIHRoYXQgd2FzIGtlcHQgb24gcmVzZXQsIHJlY3Vyc2l2ZWx5IG1vcnBoIGl0XG4gICAgICAgICAgaWYodGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXSl7XG4gICAgICAgICAgICBtb3JwaGVkRWwgPSB0aGlzLnN0cmVhbUNvbXBvbmVudFJlc3RvcmVbZWwuaWRdXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1Db21wb25lbnRSZXN0b3JlW2VsLmlkXVxuICAgICAgICAgICAgbW9ycGguY2FsbCh0aGlzLCBtb3JwaGVkRWwsIGVsLCB0cnVlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtb3JwaGVkRWxcbiAgICAgICAgfSxcbiAgICAgICAgb25Ob2RlQWRkZWQ6IChlbCkgPT4ge1xuICAgICAgICAgIGlmKGVsLmdldEF0dHJpYnV0ZSl7IHRoaXMubWF5YmVSZU9yZGVyU3RyZWFtKGVsLCB0cnVlKSB9XG5cbiAgICAgICAgICAvLyBoYWNrIHRvIGZpeCBTYWZhcmkgaGFuZGxpbmcgb2YgaW1nIHNyY3NldCBhbmQgdmlkZW8gdGFnc1xuICAgICAgICAgIGlmKGVsIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCAmJiBlbC5zcmNzZXQpe1xuICAgICAgICAgICAgZWwuc3Jjc2V0ID0gZWwuc3Jjc2V0XG4gICAgICAgICAgfSBlbHNlIGlmKGVsIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCAmJiBlbC5hdXRvcGxheSl7XG4gICAgICAgICAgICBlbC5wbGF5KClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoRE9NLmlzTm93VHJpZ2dlckZvcm1FeHRlcm5hbChlbCwgcGh4VHJpZ2dlckV4dGVybmFsKSl7XG4gICAgICAgICAgICBleHRlcm5hbEZvcm1UcmlnZ2VyZWQgPSBlbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIG5lc3RlZCB2aWV3IGhhbmRsaW5nXG4gICAgICAgICAgaWYoKERPTS5pc1BoeENoaWxkKGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsKSkgfHwgRE9NLmlzUGh4U3RpY2t5KGVsKSAmJiB2aWV3Lm93bnNFbGVtZW50KGVsLnBhcmVudE5vZGUpKXtcbiAgICAgICAgICAgIHRoaXMudHJhY2tBZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwpXG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZGVkLnB1c2goZWwpXG4gICAgICAgIH0sXG4gICAgICAgIG9uTm9kZURpc2NhcmRlZDogKGVsKSA9PiB0aGlzLm9uTm9kZURpc2NhcmRlZChlbCksXG4gICAgICAgIG9uQmVmb3JlTm9kZURpc2NhcmRlZDogKGVsKSA9PiB7XG4gICAgICAgICAgaWYoZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfUFJVTkUpICE9PSBudWxsKXsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmKGVsLnBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgZWwuaWQgJiZcbiAgICAgICAgICAgIERPTS5pc1BoeFVwZGF0ZShlbC5wYXJlbnRFbGVtZW50LCBwaHhVcGRhdGUsIFtQSFhfU1RSRUFNLCBcImFwcGVuZFwiLCBcInByZXBlbmRcIl0pKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLm1heWJlUGVuZGluZ1JlbW92ZShlbCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIGlmKHRoaXMuc2tpcENJRFNpYmxpbmcoZWwpKXsgcmV0dXJuIGZhbHNlIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIG9uRWxVcGRhdGVkOiAoZWwpID0+IHtcbiAgICAgICAgICBpZihET00uaXNOb3dUcmlnZ2VyRm9ybUV4dGVybmFsKGVsLCBwaHhUcmlnZ2VyRXh0ZXJuYWwpKXtcbiAgICAgICAgICAgIGV4dGVybmFsRm9ybVRyaWdnZXJlZCA9IGVsXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZXMucHVzaChlbClcbiAgICAgICAgICB0aGlzLm1heWJlUmVPcmRlclN0cmVhbShlbCwgZmFsc2UpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQmVmb3JlRWxVcGRhdGVkOiAoZnJvbUVsLCB0b0VsKSA9PiB7XG4gICAgICAgICAgLy8gaWYgd2UgYXJlIHBhdGNoaW5nIHRoZSByb290IHRhcmdldCBjb250YWluZXIgYW5kIHRoZSBpZCBoYXMgY2hhbmdlZCwgdHJlYXQgaXQgYXMgYSBuZXcgbm9kZVxuICAgICAgICAgIC8vIGJ5IHJlcGxhY2luZyB0aGUgZnJvbUVsIHdpdGggdGhlIHRvRWwsIHdoaWNoIGVuc3VyZXMgaG9va3MgYXJlIHRvcm4gZG93biBhbmQgcmUtY3JlYXRlZFxuICAgICAgICAgIGlmKGZyb21FbC5pZCAmJiBmcm9tRWwuaXNTYW1lTm9kZSh0YXJnZXRDb250YWluZXIpICYmIGZyb21FbC5pZCAhPT0gdG9FbC5pZCl7XG4gICAgICAgICAgICBtb3JwaENhbGxiYWNrcy5vbk5vZGVEaXNjYXJkZWQoZnJvbUVsKVxuICAgICAgICAgICAgZnJvbUVsLnJlcGxhY2VXaXRoKHRvRWwpXG4gICAgICAgICAgICByZXR1cm4gbW9ycGhDYWxsYmFja3Mub25Ob2RlQWRkZWQodG9FbClcbiAgICAgICAgICB9XG4gICAgICAgICAgRE9NLnN5bmNQZW5kaW5nQXR0cnMoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgIERPTS5tYWludGFpblByaXZhdGVIb29rcyhmcm9tRWwsIHRvRWwsIHBoeFZpZXdwb3J0VG9wLCBwaHhWaWV3cG9ydEJvdHRvbSlcbiAgICAgICAgICBET00uY2xlYW5DaGlsZE5vZGVzKHRvRWwsIHBoeFVwZGF0ZSlcbiAgICAgICAgICBpZih0aGlzLnNraXBDSURTaWJsaW5nKHRvRWwpKXtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgYSBsaXZlIGNvbXBvbmVudCB1c2VkIGluIGEgc3RyZWFtLCB3ZSBtYXkgbmVlZCB0byByZW9yZGVyIGl0XG4gICAgICAgICAgICB0aGlzLm1heWJlUmVPcmRlclN0cmVhbShmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGZyb21FbCkpe1xuICAgICAgICAgICAgW1BIWF9TRVNTSU9OLCBQSFhfU1RBVElDLCBQSFhfUk9PVF9JRF1cbiAgICAgICAgICAgICAgLm1hcChhdHRyID0+IFthdHRyLCBmcm9tRWwuZ2V0QXR0cmlidXRlKGF0dHIpLCB0b0VsLmdldEF0dHJpYnV0ZShhdHRyKV0pXG4gICAgICAgICAgICAgIC5mb3JFYWNoKChbYXR0ciwgZnJvbVZhbCwgdG9WYWxdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYodG9WYWwgJiYgZnJvbVZhbCAhPT0gdG9WYWwpeyBmcm9tRWwuc2V0QXR0cmlidXRlKGF0dHIsIHRvVmFsKSB9XG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihET00uaXNJZ25vcmVkKGZyb21FbCwgcGh4VXBkYXRlKSB8fCAoZnJvbUVsLmZvcm0gJiYgZnJvbUVsLmZvcm0uaXNTYW1lTm9kZShleHRlcm5hbEZvcm1UcmlnZ2VyZWQpKSl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IERPTS5pc0lnbm9yZWQoZnJvbUVsLCBwaHhVcGRhdGUpfSlcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihmcm9tRWwudHlwZSA9PT0gXCJudW1iZXJcIiAmJiAoZnJvbUVsLnZhbGlkaXR5ICYmIGZyb21FbC52YWxpZGl0eS5iYWRJbnB1dCkpeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBQSFhfUkVGX1NSQywgaXQgaXMgbG9hZGluZyBvciBsb2NrZWQgYW5kIGF3YWl0aW5nIGFuIGFjay5cbiAgICAgICAgICAvLyBJZiBpdCdzIGxvY2tlZCwgd2UgY2xvbmUgdGhlIGZyb21FbCB0cmVlIGFuZCBpbnN0cnVjdCBtb3JwaGRvbSB0byB1c2VcbiAgICAgICAgICAvLyB0aGUgY2xvbmVkIHRyZWUgYXMgdGhlIHNvdXJjZSBvZiB0aGUgbW9ycGggZm9yIHRoaXMgYnJhbmNoIGZyb20gaGVyZSBvbiBvdXQuXG4gICAgICAgICAgLy8gV2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgY2xvbmVkIHRyZWUgaW4gdGhlIGVsZW1lbnQncyBwcml2YXRlIGRhdGEsIGFuZFxuICAgICAgICAgIC8vIG9uIGFjayAodmlldy51bmRvUmVmcyksIHdlIG1vcnBoIHRoZSBjbG9uZWQgdHJlZSB3aXRoIHRoZSB0cnVlIGZyb21FbCBpbiB0aGUgRE9NIHRvXG4gICAgICAgICAgLy8gYXBwbHkgYW55IGNoYW5nZXMgdGhhdCBoYXBwZW5lZCB3aGlsZSB0aGUgZWxlbWVudCB3YXMgbG9ja2VkLlxuICAgICAgICAgIGxldCBpc0ZvY3VzZWRGb3JtRWwgPSBmb2N1c2VkICYmIGZyb21FbC5pc1NhbWVOb2RlKGZvY3VzZWQpICYmIERPTS5pc0Zvcm1JbnB1dChmcm9tRWwpXG4gICAgICAgICAgbGV0IGZvY3VzZWRTZWxlY3RDaGFuZ2VkID0gaXNGb2N1c2VkRm9ybUVsICYmIHRoaXMuaXNDaGFuZ2VkU2VsZWN0KGZyb21FbCwgdG9FbClcbiAgICAgICAgICAvLyBvbmx5IHBlcmZvcm0gdGhlIGNsb25lIHN0ZXAgaWYgdGhpcyBpcyBub3QgYSBwYXRjaCB0aGF0IHVubG9ja3NcbiAgICAgICAgICBpZihmcm9tRWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSAmJiBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSykgIT0gdGhpcy51bmRvUmVmKXtcbiAgICAgICAgICAgIGlmKERPTS5pc1VwbG9hZElucHV0KGZyb21FbCkpe1xuICAgICAgICAgICAgICBET00ubWVyZ2VBdHRycyhmcm9tRWwsIHRvRWwsIHtpc0lnbm9yZWQ6IHRydWV9KVxuICAgICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICAgIHVwZGF0ZXMucHVzaChmcm9tRWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBET00uYXBwbHlTdGlja3lPcGVyYXRpb25zKGZyb21FbClcbiAgICAgICAgICAgIGxldCBpc0xvY2tlZCA9IGZyb21FbC5oYXNBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKVxuICAgICAgICAgICAgbGV0IGNsb25lID0gaXNMb2NrZWQgPyBET00ucHJpdmF0ZShmcm9tRWwsIFBIWF9SRUZfTE9DSykgfHwgZnJvbUVsLmNsb25lTm9kZSh0cnVlKSA6IG51bGxcbiAgICAgICAgICAgIGlmKGNsb25lKXtcbiAgICAgICAgICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGX0xPQ0ssIGNsb25lKVxuICAgICAgICAgICAgICBpZighaXNGb2N1c2VkRm9ybUVsKXtcbiAgICAgICAgICAgICAgICBmcm9tRWwgPSBjbG9uZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbmVzdGVkIHZpZXcgaGFuZGxpbmdcbiAgICAgICAgICBpZihET00uaXNQaHhDaGlsZCh0b0VsKSl7XG4gICAgICAgICAgICBsZXQgcHJldlNlc3Npb24gPSBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKVxuICAgICAgICAgICAgRE9NLm1lcmdlQXR0cnMoZnJvbUVsLCB0b0VsLCB7ZXhjbHVkZTogW1BIWF9TVEFUSUNdfSlcbiAgICAgICAgICAgIGlmKHByZXZTZXNzaW9uICE9PSBcIlwiKXsgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgcHJldlNlc3Npb24pIH1cbiAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdElEKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyhmcm9tRWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB3ZSBhcmUgdW5kb2luZyBhIGxvY2ssIGNvcHkgcG90ZW50aWFsbHkgbmVzdGVkIGNsb25lcyBvdmVyXG4gICAgICAgICAgaWYodGhpcy51bmRvUmVmICYmIERPTS5wcml2YXRlKHRvRWwsIFBIWF9SRUZfTE9DSykpe1xuICAgICAgICAgICAgRE9NLnB1dFByaXZhdGUoZnJvbUVsLCBQSFhfUkVGX0xPQ0ssIERPTS5wcml2YXRlKHRvRWwsIFBIWF9SRUZfTE9DSykpXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG5vdyBjb3B5IHJlZ3VsYXIgRE9NLnByaXZhdGUgZGF0YVxuICAgICAgICAgIERPTS5jb3B5UHJpdmF0ZXModG9FbCwgZnJvbUVsKVxuXG4gICAgICAgICAgLy8gc2tpcCBwYXRjaGluZyBmb2N1c2VkIGlucHV0cyB1bmxlc3MgZm9jdXMgaXMgYSBzZWxlY3QgdGhhdCBoYXMgY2hhbmdlZCBvcHRpb25zXG4gICAgICAgICAgaWYoaXNGb2N1c2VkRm9ybUVsICYmIGZyb21FbC50eXBlICE9PSBcImhpZGRlblwiICYmICFmb2N1c2VkU2VsZWN0Q2hhbmdlZCl7XG4gICAgICAgICAgICB0aGlzLnRyYWNrQmVmb3JlKFwidXBkYXRlZFwiLCBmcm9tRWwsIHRvRWwpXG4gICAgICAgICAgICBET00ubWVyZ2VGb2N1c2VkSW5wdXQoZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgRE9NLnN5bmNBdHRyc1RvUHJvcHMoZnJvbUVsKVxuICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGZyb21FbClcbiAgICAgICAgICAgIERPTS5hcHBseVN0aWNreU9wZXJhdGlvbnMoZnJvbUVsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJsdXIgZm9jdXNlZCBzZWxlY3QgaWYgaXQgY2hhbmdlZCBzbyBuYXRpdmUgVUkgaXMgdXBkYXRlZCAoaWUgc2FmYXJpIHdvbid0IHVwZGF0ZSB2aXNpYmxlIG9wdGlvbnMpXG4gICAgICAgICAgICBpZihmb2N1c2VkU2VsZWN0Q2hhbmdlZCl7IGZyb21FbC5ibHVyKCkgfVxuICAgICAgICAgICAgaWYoRE9NLmlzUGh4VXBkYXRlKHRvRWwsIHBoeFVwZGF0ZSwgW1wiYXBwZW5kXCIsIFwicHJlcGVuZFwiXSkpe1xuICAgICAgICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5wdXNoKG5ldyBET01Qb3N0TW9ycGhSZXN0b3Jlcihmcm9tRWwsIHRvRWwsIHRvRWwuZ2V0QXR0cmlidXRlKHBoeFVwZGF0ZSkpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBET00uc3luY0F0dHJzVG9Qcm9wcyh0b0VsKVxuICAgICAgICAgICAgRE9NLmFwcGx5U3RpY2t5T3BlcmF0aW9ucyh0b0VsKVxuICAgICAgICAgICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgZnJvbUVsLCB0b0VsKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21FbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbW9ycGhkb20odGFyZ2V0Q29udGFpbmVyLCBzb3VyY2UsIG1vcnBoQ2FsbGJhY2tzKVxuICAgIH1cblxuICAgIHRoaXMudHJhY2tCZWZvcmUoXCJhZGRlZFwiLCBjb250YWluZXIpXG4gICAgdGhpcy50cmFja0JlZm9yZShcInVwZGF0ZWRcIiwgY29udGFpbmVyLCBjb250YWluZXIpXG5cbiAgICBsaXZlU29ja2V0LnRpbWUoXCJtb3JwaGRvbVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN0cmVhbXMuZm9yRWFjaCgoW3JlZiwgaW5zZXJ0cywgZGVsZXRlSWRzLCByZXNldF0pID0+IHtcbiAgICAgICAgaW5zZXJ0cy5mb3JFYWNoKChba2V5LCBzdHJlYW1BdCwgbGltaXRdKSA9PiB7XG4gICAgICAgICAgdGhpcy5zdHJlYW1JbnNlcnRzW2tleV0gPSB7cmVmLCBzdHJlYW1BdCwgbGltaXQsIHJlc2V0fVxuICAgICAgICB9KVxuICAgICAgICBpZihyZXNldCAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICBET00uYWxsKGNvbnRhaW5lciwgYFske1BIWF9TVFJFQU1fUkVGfT1cIiR7cmVmfVwiXWAsIGNoaWxkID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlSWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgIGxldCBjaGlsZCA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKGBbaWQ9XCIke2lkfVwiXWApXG4gICAgICAgICAgaWYoY2hpbGQpeyB0aGlzLnJlbW92ZVN0cmVhbUNoaWxkRWxlbWVudChjaGlsZCkgfVxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgLy8gY2xlYXIgc3RyZWFtIGl0ZW1zIGZyb20gdGhlIGRlYWQgcmVuZGVyIGlmIHRoZXkgYXJlIG5vdCBpbnNlcnRlZCBhZ2FpblxuICAgICAgaWYoaXNKb2luUGF0Y2gpe1xuICAgICAgICBET00uYWxsKHRoaXMuY29udGFpbmVyLCBgWyR7cGh4VXBkYXRlfT0ke1BIWF9TVFJFQU19XWAsIGVsID0+IHtcbiAgICAgICAgICBBcnJheS5mcm9tKGVsLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU3RyZWFtQ2hpbGRFbGVtZW50KGNoaWxkKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIG1vcnBoLmNhbGwodGhpcywgdGFyZ2V0Q29udGFpbmVyLCBodG1sKVxuICAgIH0pXG5cbiAgICBpZihsaXZlU29ja2V0LmlzRGVidWdFbmFibGVkKCkpe1xuICAgICAgZGV0ZWN0RHVwbGljYXRlSWRzKClcbiAgICAgIGRldGVjdEludmFsaWRTdHJlYW1JbnNlcnRzKHRoaXMuc3RyZWFtSW5zZXJ0cylcbiAgICAgIC8vIHdhcm4gaWYgdGhlcmUgYXJlIGFueSBpbnB1dHMgbmFtZWQgXCJpZFwiXG4gICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lPWlkXVwiKSkuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYobm9kZS5mb3JtKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0ZWN0ZWQgYW4gaW5wdXQgd2l0aCBuYW1lPVxcXCJpZFxcXCIgaW5zaWRlIGEgZm9ybSEgVGhpcyB3aWxsIGNhdXNlIHByb2JsZW1zIHdoZW4gcGF0Y2hpbmcgdGhlIERPTS5cXG5cIiwgbm9kZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZihhcHBlbmRQcmVwZW5kVXBkYXRlcy5sZW5ndGggPiAwKXtcbiAgICAgIGxpdmVTb2NrZXQudGltZShcInBvc3QtbW9ycGggYXBwZW5kL3ByZXBlbmQgcmVzdG9yYXRpb25cIiwgKCkgPT4ge1xuICAgICAgICBhcHBlbmRQcmVwZW5kVXBkYXRlcy5mb3JFYWNoKHVwZGF0ZSA9PiB1cGRhdGUucGVyZm9ybSgpKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBsaXZlU29ja2V0LnNpbGVuY2VFdmVudHMoKCkgPT4gRE9NLnJlc3RvcmVGb2N1cyhmb2N1c2VkLCBzZWxlY3Rpb25TdGFydCwgc2VsZWN0aW9uRW5kKSlcbiAgICBET00uZGlzcGF0Y2hFdmVudChkb2N1bWVudCwgXCJwaHg6dXBkYXRlXCIpXG4gICAgYWRkZWQuZm9yRWFjaChlbCA9PiB0aGlzLnRyYWNrQWZ0ZXIoXCJhZGRlZFwiLCBlbCkpXG4gICAgdXBkYXRlcy5mb3JFYWNoKGVsID0+IHRoaXMudHJhY2tBZnRlcihcInVwZGF0ZWRcIiwgZWwpKVxuXG4gICAgdGhpcy50cmFuc2l0aW9uUGVuZGluZ1JlbW92ZXMoKVxuXG4gICAgaWYoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKXtcbiAgICAgIGxpdmVTb2NrZXQudW5sb2FkKClcbiAgICAgIC8vIHVzZSBwcm90b3R5cGUncyBzdWJtaXQgaW4gY2FzZSB0aGVyZSdzIGEgZm9ybSBjb250cm9sIHdpdGggbmFtZSBvciBpZCBvZiBcInN1Ym1pdFwiXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEZvcm1FbGVtZW50L3N1Ym1pdFxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKGV4dGVybmFsRm9ybVRyaWdnZXJlZCkuc3VibWl0LmNhbGwoZXh0ZXJuYWxGb3JtVHJpZ2dlcmVkKVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgb25Ob2RlRGlzY2FyZGVkKGVsKXtcbiAgICAvLyBuZXN0ZWQgdmlldyBoYW5kbGluZ1xuICAgIGlmKERPTS5pc1BoeENoaWxkKGVsKSB8fCBET00uaXNQaHhTdGlja3koZWwpKXsgdGhpcy5saXZlU29ja2V0LmRlc3Ryb3lWaWV3QnlFbChlbCkgfVxuICAgIHRoaXMudHJhY2tBZnRlcihcImRpc2NhcmRlZFwiLCBlbClcbiAgfVxuXG4gIG1heWJlUGVuZGluZ1JlbW92ZShub2RlKXtcbiAgICBpZihub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSh0aGlzLnBoeFJlbW92ZSkgIT09IG51bGwpe1xuICAgICAgdGhpcy5wZW5kaW5nUmVtb3Zlcy5wdXNoKG5vZGUpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpe1xuICAgIC8vIG1ha2Ugc3VyZSB0byBvbmx5IHJlbW92ZSBlbGVtZW50cyBvd25lZCBieSB0aGUgY3VycmVudCB2aWV3XG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zMDQ3XG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zNjgxXG4gICAgaWYoIXRoaXMudmlldy5vd25zRWxlbWVudChjaGlsZCkpeyByZXR1cm4gfVxuXG4gICAgLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgbm9kZSBpZiBpdCBpcyBhY3R1YWxseSByZS1hZGRlZCBpbiB0aGUgc2FtZSBwYXRjaFxuICAgIC8vIHdlIGRvIE5PVCB3YW50IHRvIGV4ZWN1dGUgcGh4LXJlbW92ZSwgd2UgZG8gTk9UIHdhbnQgdG8gY2FsbCBvbk5vZGVEaXNjYXJkZWRcbiAgICBpZih0aGlzLnN0cmVhbUluc2VydHNbY2hpbGQuaWRdKXtcbiAgICAgIHRoaXMuc3RyZWFtQ29tcG9uZW50UmVzdG9yZVtjaGlsZC5pZF0gPSBjaGlsZFxuICAgICAgY2hpbGQucmVtb3ZlKClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb25seSByZW1vdmUgdGhlIGVsZW1lbnQgbm93IGlmIGl0IGhhcyBubyBwaHgtcmVtb3ZlIGJpbmRpbmdcbiAgICAgIGlmKCF0aGlzLm1heWJlUGVuZGluZ1JlbW92ZShjaGlsZCkpe1xuICAgICAgICBjaGlsZC5yZW1vdmUoKVxuICAgICAgICB0aGlzLm9uTm9kZURpc2NhcmRlZChjaGlsZClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRTdHJlYW1JbnNlcnQoZWwpe1xuICAgIGxldCBpbnNlcnQgPSBlbC5pZCA/IHRoaXMuc3RyZWFtSW5zZXJ0c1tlbC5pZF0gOiB7fVxuICAgIHJldHVybiBpbnNlcnQgfHwge31cbiAgfVxuXG4gIHNldFN0cmVhbVJlZihlbCwgcmVmKXtcbiAgICBET00ucHV0U3RpY2t5KGVsLCBQSFhfU1RSRUFNX1JFRiwgZWwgPT4gZWwuc2V0QXR0cmlidXRlKFBIWF9TVFJFQU1fUkVGLCByZWYpKVxuICB9XG5cbiAgbWF5YmVSZU9yZGVyU3RyZWFtKGVsLCBpc05ldyl7XG4gICAgbGV0IHtyZWYsIHN0cmVhbUF0LCByZXNldH0gPSB0aGlzLmdldFN0cmVhbUluc2VydChlbClcbiAgICBpZihzdHJlYW1BdCA9PT0gdW5kZWZpbmVkKXsgcmV0dXJuIH1cblxuICAgIC8vIHdlIG5lZWQgdG8gc2V0IHRoZSBQSFhfU1RSRUFNX1JFRiBoZXJlIGFzIHdlbGwgYXMgYWRkQ2hpbGQgaXMgaW52b2tlZCBvbmx5IGZvciBwYXJlbnRzXG4gICAgdGhpcy5zZXRTdHJlYW1SZWYoZWwsIHJlZilcblxuICAgIGlmKCFyZXNldCAmJiAhaXNOZXcpe1xuICAgICAgLy8gd2Ugb25seSByZW9yZGVyIGlmIHRoZSBlbGVtZW50IGlzIG5ldyBvciBpdCdzIGEgc3RyZWFtIHJlc2V0XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgZWxlbWVudCBoYXMgYSBwYXJlbnQgZWxlbWVudDtcbiAgICAvLyBpdCBkb2Vzbid0IGlmIHdlIGFyZSBjdXJyZW50bHkgcmVjdXJzaXZlbHkgbW9ycGhpbmcgKHJlc3RvcmluZyBhIHNhdmVkIHN0cmVhbSBjaGlsZClcbiAgICAvLyBiZWNhdXNlIHRoZSBlbGVtZW50IGlzIG5vdCB5ZXQgYWRkZWQgdG8gdGhlIHJlYWwgZG9tO1xuICAgIC8vIHJlb3JkZXJpbmcgZG9lcyBub3QgbWFrZSBzZW5zZSBpbiB0aGF0IGNhc2UgYW55d2F5XG4gICAgaWYoIWVsLnBhcmVudEVsZW1lbnQpeyByZXR1cm4gfVxuXG4gICAgaWYoc3RyZWFtQXQgPT09IDApe1xuICAgICAgZWwucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoZWwsIGVsLnBhcmVudEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpXG4gICAgfSBlbHNlIGlmKHN0cmVhbUF0ID4gMCl7XG4gICAgICBsZXQgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4pXG4gICAgICBsZXQgb2xkSW5kZXggPSBjaGlsZHJlbi5pbmRleE9mKGVsKVxuICAgICAgaWYoc3RyZWFtQXQgPj0gY2hpbGRyZW4ubGVuZ3RoIC0gMSl7XG4gICAgICAgIGVsLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoZWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgc2libGluZyA9IGNoaWxkcmVuW3N0cmVhbUF0XVxuICAgICAgICBpZihvbGRJbmRleCA+IHN0cmVhbUF0KXtcbiAgICAgICAgICBlbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShlbCwgc2libGluZylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShlbCwgc2libGluZy5uZXh0RWxlbWVudFNpYmxpbmcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1heWJlTGltaXRTdHJlYW0oZWwpXG4gIH1cblxuICBtYXliZUxpbWl0U3RyZWFtKGVsKXtcbiAgICBsZXQge2xpbWl0fSA9IHRoaXMuZ2V0U3RyZWFtSW5zZXJ0KGVsKVxuICAgIGxldCBjaGlsZHJlbiA9IGxpbWl0ICE9PSBudWxsICYmIEFycmF5LmZyb20oZWwucGFyZW50RWxlbWVudC5jaGlsZHJlbilcbiAgICBpZihsaW1pdCAmJiBsaW1pdCA8IDAgJiYgY2hpbGRyZW4ubGVuZ3RoID4gbGltaXQgKiAtMSl7XG4gICAgICBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5sZW5ndGggKyBsaW1pdCkuZm9yRWFjaChjaGlsZCA9PiB0aGlzLnJlbW92ZVN0cmVhbUNoaWxkRWxlbWVudChjaGlsZCkpXG4gICAgfSBlbHNlIGlmKGxpbWl0ICYmIGxpbWl0ID49IDAgJiYgY2hpbGRyZW4ubGVuZ3RoID4gbGltaXQpe1xuICAgICAgY2hpbGRyZW4uc2xpY2UobGltaXQpLmZvckVhY2goY2hpbGQgPT4gdGhpcy5yZW1vdmVTdHJlYW1DaGlsZEVsZW1lbnQoY2hpbGQpKVxuICAgIH1cbiAgfVxuXG4gIHRyYW5zaXRpb25QZW5kaW5nUmVtb3Zlcygpe1xuICAgIGxldCB7cGVuZGluZ1JlbW92ZXMsIGxpdmVTb2NrZXR9ID0gdGhpc1xuICAgIGlmKHBlbmRpbmdSZW1vdmVzLmxlbmd0aCA+IDApe1xuICAgICAgbGl2ZVNvY2tldC50cmFuc2l0aW9uUmVtb3ZlcyhwZW5kaW5nUmVtb3ZlcywgKCkgPT4ge1xuICAgICAgICBwZW5kaW5nUmVtb3Zlcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBsZXQgY2hpbGQgPSBET00uZmlyc3RQaHhDaGlsZChlbClcbiAgICAgICAgICBpZihjaGlsZCl7IGxpdmVTb2NrZXQuZGVzdHJveVZpZXdCeUVsKGNoaWxkKSB9XG4gICAgICAgICAgZWwucmVtb3ZlKClcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy50cmFja0FmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgcGVuZGluZ1JlbW92ZXMpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlzQ2hhbmdlZFNlbGVjdChmcm9tRWwsIHRvRWwpe1xuICAgIGlmKCEoZnJvbUVsIGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpIHx8IGZyb21FbC5tdWx0aXBsZSl7IHJldHVybiBmYWxzZSB9XG4gICAgaWYoZnJvbUVsLm9wdGlvbnMubGVuZ3RoICE9PSB0b0VsLm9wdGlvbnMubGVuZ3RoKXsgcmV0dXJuIHRydWUgfVxuXG4gICAgLy8ga2VlcCB0aGUgY3VycmVudCB2YWx1ZVxuICAgIHRvRWwudmFsdWUgPSBmcm9tRWwudmFsdWVcblxuICAgIC8vIGluIGdlbmVyYWwgd2UgaGF2ZSB0byBiZSB2ZXJ5IGNhcmVmdWwgd2l0aCB1c2luZyBpc0VxdWFsTm9kZSBhcyBpdCBkb2VzIG5vdCBhIHJlbGlhYmxlXG4gICAgLy8gRE9NIHRyZWUgZXF1YWxpdHkgY2hlY2ssIGJ1dCBmb3Igc2VsZWN0aW9uIGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMgaXQgd29ya3MgZmluZVxuICAgIHJldHVybiAhZnJvbUVsLmlzRXF1YWxOb2RlKHRvRWwpXG4gIH1cblxuICBpc0NJRFBhdGNoKCl7IHJldHVybiB0aGlzLmNpZFBhdGNoIH1cblxuICBza2lwQ0lEU2libGluZyhlbCl7XG4gICAgcmV0dXJuIGVsLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlbC5oYXNBdHRyaWJ1dGUoUEhYX1NLSVApXG4gIH1cblxuICB0YXJnZXRDSURDb250YWluZXIoaHRtbCl7XG4gICAgaWYoIXRoaXMuaXNDSURQYXRjaCgpKXsgcmV0dXJuIH1cbiAgICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3QodGhpcy5jb250YWluZXIsIHRoaXMudGFyZ2V0Q0lEKVxuICAgIGlmKHJlc3QubGVuZ3RoID09PSAwICYmIERPTS5jaGlsZE5vZGVMZW5ndGgoaHRtbCkgPT09IDEpe1xuICAgICAgcmV0dXJuIGZpcnN0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC5wYXJlbnROb2RlXG4gICAgfVxuICB9XG5cbiAgaW5kZXhPZihwYXJlbnQsIGNoaWxkKXsgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LmNoaWxkcmVuKS5pbmRleE9mKGNoaWxkKSB9XG59XG4iLCAiaW1wb3J0IHtcbiAgQ09NUE9ORU5UUyxcbiAgRFlOQU1JQ1MsXG4gIFRFTVBMQVRFUyxcbiAgRVZFTlRTLFxuICBQSFhfQ09NUE9ORU5ULFxuICBQSFhfU0tJUCxcbiAgUEhYX01BR0lDX0lELFxuICBSRVBMWSxcbiAgU1RBVElDLFxuICBUSVRMRSxcbiAgU1RSRUFNLFxuICBST09ULFxufSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG5pbXBvcnQge1xuICBpc09iamVjdCxcbiAgbG9nRXJyb3IsXG4gIGlzQ2lkLFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmNvbnN0IFZPSURfVEFHUyA9IG5ldyBTZXQoW1xuICBcImFyZWFcIixcbiAgXCJiYXNlXCIsXG4gIFwiYnJcIixcbiAgXCJjb2xcIixcbiAgXCJjb21tYW5kXCIsXG4gIFwiZW1iZWRcIixcbiAgXCJoclwiLFxuICBcImltZ1wiLFxuICBcImlucHV0XCIsXG4gIFwia2V5Z2VuXCIsXG4gIFwibGlua1wiLFxuICBcIm1ldGFcIixcbiAgXCJwYXJhbVwiLFxuICBcInNvdXJjZVwiLFxuICBcInRyYWNrXCIsXG4gIFwid2JyXCJcbl0pXG5jb25zdCBxdW90ZUNoYXJzID0gbmV3IFNldChbXCInXCIsIFwiXFxcIlwiXSlcblxuZXhwb3J0IGxldCBtb2RpZnlSb290ID0gKGh0bWwsIGF0dHJzLCBjbGVhcklubmVySFRNTCkgPT4ge1xuICBsZXQgaSA9IDBcbiAgbGV0IGluc2lkZUNvbW1lbnQgPSBmYWxzZVxuICBsZXQgYmVmb3JlVGFnLCBhZnRlclRhZywgdGFnLCB0YWdOYW1lRW5kc0F0LCBpZCwgbmV3SFRNTFxuXG4gIGxldCBsb29rYWhlYWQgPSBodG1sLm1hdGNoKC9eKFxccyooPzo8IS0tLio/LS0+XFxzKikqKTwoW15cXHNcXC8+XSspLylcbiAgaWYobG9va2FoZWFkID09PSBudWxsKXsgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgaHRtbCAke2h0bWx9YCkgfVxuXG4gIGkgPSBsb29rYWhlYWRbMF0ubGVuZ3RoXG4gIGJlZm9yZVRhZyA9IGxvb2thaGVhZFsxXVxuICB0YWcgPSBsb29rYWhlYWRbMl1cbiAgdGFnTmFtZUVuZHNBdCA9IGlcblxuICAvLyBTY2FuIHRoZSBvcGVuaW5nIHRhZyBmb3IgaWQsIGlmIHRoZXJlIGlzIGFueVxuICBmb3IoaTsgaSA8IGh0bWwubGVuZ3RoOyBpKyspe1xuICAgIGlmKGh0bWwuY2hhckF0KGkpID09PSBcIj5cIiApeyBicmVhayB9XG4gICAgaWYoaHRtbC5jaGFyQXQoaSkgPT09IFwiPVwiKXtcbiAgICAgIGxldCBpc0lkID0gaHRtbC5zbGljZShpIC0gMywgaSkgPT09IFwiIGlkXCJcbiAgICAgIGkrK1xuICAgICAgbGV0IGNoYXIgPSBodG1sLmNoYXJBdChpKVxuICAgICAgaWYocXVvdGVDaGFycy5oYXMoY2hhcikpe1xuICAgICAgICBsZXQgYXR0clN0YXJ0c0F0ID0gaVxuICAgICAgICBpKytcbiAgICAgICAgZm9yKGk7IGkgPCBodG1sLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICBpZihodG1sLmNoYXJBdChpKSA9PT0gY2hhcil7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZihpc0lkKXtcbiAgICAgICAgICBpZCA9IGh0bWwuc2xpY2UoYXR0clN0YXJ0c0F0ICsgMSwgaSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IGNsb3NlQXQgPSBodG1sLmxlbmd0aCAtIDFcbiAgaW5zaWRlQ29tbWVudCA9IGZhbHNlXG4gIHdoaWxlKGNsb3NlQXQgPj0gYmVmb3JlVGFnLmxlbmd0aCArIHRhZy5sZW5ndGgpe1xuICAgIGxldCBjaGFyID0gaHRtbC5jaGFyQXQoY2xvc2VBdClcbiAgICBpZihpbnNpZGVDb21tZW50KXtcbiAgICAgIGlmKGNoYXIgPT09IFwiLVwiICYmIGh0bWwuc2xpY2UoY2xvc2VBdCAtIDMsIGNsb3NlQXQpID09PSBcIjwhLVwiKXtcbiAgICAgICAgaW5zaWRlQ29tbWVudCA9IGZhbHNlXG4gICAgICAgIGNsb3NlQXQgLT0gNFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VBdCAtPSAxXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGNoYXIgPT09IFwiPlwiICYmIGh0bWwuc2xpY2UoY2xvc2VBdCAtIDIsIGNsb3NlQXQpID09PSBcIi0tXCIpe1xuICAgICAgaW5zaWRlQ29tbWVudCA9IHRydWVcbiAgICAgIGNsb3NlQXQgLT0gM1xuICAgIH0gZWxzZSBpZihjaGFyID09PSBcIj5cIil7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZUF0IC09IDFcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUYWcgPSBodG1sLnNsaWNlKGNsb3NlQXQgKyAxLCBodG1sLmxlbmd0aClcblxuICBsZXQgYXR0cnNTdHIgPVxuICAgIE9iamVjdC5rZXlzKGF0dHJzKVxuICAgICAgLm1hcChhdHRyID0+IGF0dHJzW2F0dHJdID09PSB0cnVlID8gYXR0ciA6IGAke2F0dHJ9PVwiJHthdHRyc1thdHRyXX1cImApXG4gICAgICAuam9pbihcIiBcIilcblxuICBpZihjbGVhcklubmVySFRNTCl7XG4gICAgLy8gS2VlcCB0aGUgaWQgaWYgYW55XG4gICAgbGV0IGlkQXR0clN0ciA9IGlkID8gYCBpZD1cIiR7aWR9XCJgIDogXCJcIlxuICAgIGlmKFZPSURfVEFHUy5oYXModGFnKSl7XG4gICAgICBuZXdIVE1MID0gYDwke3RhZ30ke2lkQXR0clN0cn0ke2F0dHJzU3RyID09PSBcIlwiID8gXCJcIiA6IFwiIFwifSR7YXR0cnNTdHJ9Lz5gXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0hUTUwgPSBgPCR7dGFnfSR7aWRBdHRyU3RyfSR7YXR0cnNTdHIgPT09IFwiXCIgPyBcIlwiIDogXCIgXCJ9JHthdHRyc1N0cn0+PC8ke3RhZ30+YFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgcmVzdCA9IGh0bWwuc2xpY2UodGFnTmFtZUVuZHNBdCwgY2xvc2VBdCArIDEpXG4gICAgbmV3SFRNTCA9IGA8JHt0YWd9JHthdHRyc1N0ciA9PT0gXCJcIiA/IFwiXCIgOiBcIiBcIn0ke2F0dHJzU3RyfSR7cmVzdH1gXG4gIH1cblxuICByZXR1cm4gW25ld0hUTUwsIGJlZm9yZVRhZywgYWZ0ZXJUYWddXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVkIHtcbiAgc3RhdGljIGV4dHJhY3QoZGlmZil7XG4gICAgbGV0IHtbUkVQTFldOiByZXBseSwgW0VWRU5UU106IGV2ZW50cywgW1RJVExFXTogdGl0bGV9ID0gZGlmZlxuICAgIGRlbGV0ZSBkaWZmW1JFUExZXVxuICAgIGRlbGV0ZSBkaWZmW0VWRU5UU11cbiAgICBkZWxldGUgZGlmZltUSVRMRV1cbiAgICByZXR1cm4ge2RpZmYsIHRpdGxlLCByZXBseTogcmVwbHkgfHwgbnVsbCwgZXZlbnRzOiBldmVudHMgfHwgW119XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih2aWV3SWQsIHJlbmRlcmVkKXtcbiAgICB0aGlzLnZpZXdJZCA9IHZpZXdJZFxuICAgIHRoaXMucmVuZGVyZWQgPSB7fVxuICAgIHRoaXMubWFnaWNJZCA9IDBcbiAgICB0aGlzLm1lcmdlRGlmZihyZW5kZXJlZClcbiAgfVxuXG4gIHBhcmVudFZpZXdJZCgpeyByZXR1cm4gdGhpcy52aWV3SWQgfVxuXG4gIHRvU3RyaW5nKG9ubHlDaWRzKXtcbiAgICBsZXQgW3N0ciwgc3RyZWFtc10gPSB0aGlzLnJlY3Vyc2l2ZVRvU3RyaW5nKHRoaXMucmVuZGVyZWQsIHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzLCB0cnVlLCB7fSlcbiAgICByZXR1cm4gW3N0ciwgc3RyZWFtc11cbiAgfVxuXG4gIHJlY3Vyc2l2ZVRvU3RyaW5nKHJlbmRlcmVkLCBjb21wb25lbnRzID0gcmVuZGVyZWRbQ09NUE9ORU5UU10sIG9ubHlDaWRzLCBjaGFuZ2VUcmFja2luZywgcm9vdEF0dHJzKXtcbiAgICBvbmx5Q2lkcyA9IG9ubHlDaWRzID8gbmV3IFNldChvbmx5Q2lkcykgOiBudWxsXG4gICAgbGV0IG91dHB1dCA9IHtidWZmZXI6IFwiXCIsIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsIG9ubHlDaWRzOiBvbmx5Q2lkcywgc3RyZWFtczogbmV3IFNldCgpfVxuICAgIHRoaXMudG9PdXRwdXRCdWZmZXIocmVuZGVyZWQsIG51bGwsIG91dHB1dCwgY2hhbmdlVHJhY2tpbmcsIHJvb3RBdHRycylcbiAgICByZXR1cm4gW291dHB1dC5idWZmZXIsIG91dHB1dC5zdHJlYW1zXVxuICB9XG5cbiAgY29tcG9uZW50Q0lEcyhkaWZmKXsgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmZbQ09NUE9ORU5UU10gfHwge30pLm1hcChpID0+IHBhcnNlSW50KGkpKSB9XG5cbiAgaXNDb21wb25lbnRPbmx5RGlmZihkaWZmKXtcbiAgICBpZighZGlmZltDT01QT05FTlRTXSl7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA9PT0gMVxuICB9XG5cbiAgZ2V0Q29tcG9uZW50KGRpZmYsIGNpZCl7IHJldHVybiBkaWZmW0NPTVBPTkVOVFNdW2NpZF0gfVxuXG4gIHJlc2V0UmVuZGVyKGNpZCl7XG4gICAgLy8gd2UgYXJlIHJhY2luZyBhIGNvbXBvbmVudCBkZXN0cm95LCBpdCBjb3VsZCBub3QgZXhpc3QsIHNvXG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgZG9uJ3QgdHJ5IHRvIHNldCByZXNldCBvbiB1bmRlZmluZWRcbiAgICBpZih0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pe1xuICAgICAgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXVtjaWRdLnJlc2V0ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIG1lcmdlRGlmZihkaWZmKXtcbiAgICBsZXQgbmV3YyA9IGRpZmZbQ09NUE9ORU5UU11cbiAgICBsZXQgY2FjaGUgPSB7fVxuICAgIGRlbGV0ZSBkaWZmW0NPTVBPTkVOVFNdXG4gICAgdGhpcy5yZW5kZXJlZCA9IHRoaXMubXV0YWJsZU1lcmdlKHRoaXMucmVuZGVyZWQsIGRpZmYpXG4gICAgdGhpcy5yZW5kZXJlZFtDT01QT05FTlRTXSA9IHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10gfHwge31cblxuICAgIGlmKG5ld2Mpe1xuICAgICAgbGV0IG9sZGMgPSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdXG5cbiAgICAgIGZvcihsZXQgY2lkIGluIG5ld2Mpe1xuICAgICAgICBuZXdjW2NpZF0gPSB0aGlzLmNhY2hlZEZpbmRDb21wb25lbnQoY2lkLCBuZXdjW2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgfVxuXG4gICAgICBmb3IobGV0IGNpZCBpbiBuZXdjKXsgb2xkY1tjaWRdID0gbmV3Y1tjaWRdIH1cbiAgICAgIGRpZmZbQ09NUE9ORU5UU10gPSBuZXdjXG4gICAgfVxuICB9XG5cbiAgY2FjaGVkRmluZENvbXBvbmVudChjaWQsIGNkaWZmLCBvbGRjLCBuZXdjLCBjYWNoZSl7XG4gICAgaWYoY2FjaGVbY2lkXSl7XG4gICAgICByZXR1cm4gY2FjaGVbY2lkXVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmRpZmYsIHN0YXQsIHNjaWQgPSBjZGlmZltTVEFUSUNdXG5cbiAgICAgIGlmKGlzQ2lkKHNjaWQpKXtcbiAgICAgICAgbGV0IHRkaWZmXG5cbiAgICAgICAgaWYoc2NpZCA+IDApe1xuICAgICAgICAgIHRkaWZmID0gdGhpcy5jYWNoZWRGaW5kQ29tcG9uZW50KHNjaWQsIG5ld2Nbc2NpZF0sIG9sZGMsIG5ld2MsIGNhY2hlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRkaWZmID0gb2xkY1stc2NpZF1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXQgPSB0ZGlmZltTVEFUSUNdXG4gICAgICAgIG5kaWZmID0gdGhpcy5jbG9uZU1lcmdlKHRkaWZmLCBjZGlmZiwgdHJ1ZSlcbiAgICAgICAgbmRpZmZbU1RBVElDXSA9IHN0YXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5kaWZmID0gY2RpZmZbU1RBVElDXSAhPT0gdW5kZWZpbmVkIHx8IG9sZGNbY2lkXSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICBjZGlmZiA6IHRoaXMuY2xvbmVNZXJnZShvbGRjW2NpZF0sIGNkaWZmLCBmYWxzZSlcbiAgICAgIH1cblxuICAgICAgY2FjaGVbY2lkXSA9IG5kaWZmXG4gICAgICByZXR1cm4gbmRpZmZcbiAgICB9XG4gIH1cblxuICBtdXRhYmxlTWVyZ2UodGFyZ2V0LCBzb3VyY2Upe1xuICAgIGlmKHNvdXJjZVtTVEFUSUNdICE9PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cbiAgfVxuXG4gIGRvTXV0YWJsZU1lcmdlKHRhcmdldCwgc291cmNlKXtcbiAgICBmb3IobGV0IGtleSBpbiBzb3VyY2Upe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGxldCBpc09ialZhbCA9IGlzT2JqZWN0KHZhbClcbiAgICAgIGlmKGlzT2JqVmFsICYmIHZhbFtTVEFUSUNdID09PSB1bmRlZmluZWQgJiYgaXNPYmplY3QodGFyZ2V0VmFsKSl7XG4gICAgICAgIHRoaXMuZG9NdXRhYmxlTWVyZ2UodGFyZ2V0VmFsLCB2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbFxuICAgICAgfVxuICAgIH1cbiAgICBpZih0YXJnZXRbUk9PVF0pe1xuICAgICAgdGFyZ2V0Lm5ld1JlbmRlciA9IHRydWVcbiAgICB9XG4gIH1cblxuICAvLyBNZXJnZXMgY2lkIHRyZWVzIHRvZ2V0aGVyLCBjb3B5aW5nIHN0YXRpY3MgZnJvbSBzb3VyY2UgdHJlZS5cbiAgLy9cbiAgLy8gVGhlIGBwcnVuZU1hZ2ljSWRgIGlzIHBhc3NlZCB0byBjb250cm9sIHBydW5pbmcgdGhlIG1hZ2ljSWQgb2YgdGhlXG4gIC8vIHRhcmdldC4gV2UgbXVzdCBhbHdheXMgcHJ1bmUgdGhlIG1hZ2ljSWQgd2hlbiB3ZSBhcmUgc2hhcmluZyBzdGF0aWNzXG4gIC8vIGZyb20gYW5vdGhlciBjb21wb25lbnQuIElmIG5vdCBwcnVuaW5nLCB3ZSByZXBsaWNhdGUgdGhlIGxvZ2ljIGZyb21cbiAgLy8gbXV0YWJsZU1lcmdlLCB3aGVyZSB3ZSBzZXQgbmV3UmVuZGVyIHRvIHRydWUgaWYgdGhlcmUgaXMgYSByb290XG4gIC8vIChlZmZlY3RpdmVseSBmb3JjaW5nIHRoZSBuZXcgdmVyc2lvbiB0byBiZSByZW5kZXJlZCBpbnN0ZWFkIG9mIHNraXBwZWQpXG4gIC8vXG4gIGNsb25lTWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHBydW5lTWFnaWNJZCl7XG4gICAgbGV0IG1lcmdlZCA9IHsuLi50YXJnZXQsIC4uLnNvdXJjZX1cbiAgICBmb3IobGV0IGtleSBpbiBtZXJnZWQpe1xuICAgICAgbGV0IHZhbCA9IHNvdXJjZVtrZXldXG4gICAgICBsZXQgdGFyZ2V0VmFsID0gdGFyZ2V0W2tleV1cbiAgICAgIGlmKGlzT2JqZWN0KHZhbCkgJiYgdmFsW1NUQVRJQ10gPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB2YWwsIHBydW5lTWFnaWNJZClcbiAgICAgIH0gZWxzZSBpZih2YWwgPT09IHVuZGVmaW5lZCAmJiBpc09iamVjdCh0YXJnZXRWYWwpKXtcbiAgICAgICAgbWVyZ2VkW2tleV0gPSB0aGlzLmNsb25lTWVyZ2UodGFyZ2V0VmFsLCB7fSwgcHJ1bmVNYWdpY0lkKVxuICAgICAgfVxuICAgIH1cbiAgICBpZihwcnVuZU1hZ2ljSWQpe1xuICAgICAgZGVsZXRlIG1lcmdlZC5tYWdpY0lkXG4gICAgICBkZWxldGUgbWVyZ2VkLm5ld1JlbmRlclxuICAgIH0gZWxzZSBpZih0YXJnZXRbUk9PVF0pe1xuICAgICAgbWVyZ2VkLm5ld1JlbmRlciA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZFxuICB9XG5cbiAgY29tcG9uZW50VG9TdHJpbmcoY2lkKXtcbiAgICBsZXQgW3N0ciwgc3RyZWFtc10gPSB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKHRoaXMucmVuZGVyZWRbQ09NUE9ORU5UU10sIGNpZCwgbnVsbClcbiAgICBsZXQgW3N0cmlwcGVkSFRNTCwgX2JlZm9yZSwgX2FmdGVyXSA9IG1vZGlmeVJvb3Qoc3RyLCB7fSlcbiAgICByZXR1cm4gW3N0cmlwcGVkSFRNTCwgc3RyZWFtc11cbiAgfVxuXG4gIHBydW5lQ0lEcyhjaWRzKXtcbiAgICBjaWRzLmZvckVhY2goY2lkID0+IGRlbGV0ZSB0aGlzLnJlbmRlcmVkW0NPTVBPTkVOVFNdW2NpZF0pXG4gIH1cblxuICAvLyBwcml2YXRlXG5cbiAgZ2V0KCl7IHJldHVybiB0aGlzLnJlbmRlcmVkIH1cblxuICBpc05ld0ZpbmdlcnByaW50KGRpZmYgPSB7fSl7IHJldHVybiAhIWRpZmZbU1RBVElDXSB9XG5cbiAgdGVtcGxhdGVTdGF0aWMocGFydCwgdGVtcGxhdGVzKXtcbiAgICBpZih0eXBlb2YgKHBhcnQpID09PSBcIm51bWJlclwiKXtcbiAgICAgIHJldHVybiB0ZW1wbGF0ZXNbcGFydF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnRcbiAgICB9XG4gIH1cblxuICBuZXh0TWFnaWNJRCgpe1xuICAgIHRoaXMubWFnaWNJZCsrXG4gICAgcmV0dXJuIGBtJHt0aGlzLm1hZ2ljSWR9LSR7dGhpcy5wYXJlbnRWaWV3SWQoKX1gXG4gIH1cblxuICAvLyBDb252ZXJ0cyByZW5kZXJlZCB0cmVlIHRvIG91dHB1dCBidWZmZXIuXG4gIC8vXG4gIC8vIGNoYW5nZVRyYWNraW5nIGNvbnRyb2xzIGlmIHdlIGNhbiBhcHBseSB0aGUgUEhYX1NLSVAgb3B0aW1pemF0aW9uLlxuICAvLyBJdCBpcyBkaXNhYmxlZCBmb3IgY29tcHJlaGVuc2lvbnMgc2luY2Ugd2UgbXVzdCByZS1yZW5kZXIgdGhlIGVudGlyZSBjb2xsZWN0aW9uXG4gIC8vIGFuZCBubyBpbmRpdmlkdWFsIGVsZW1lbnQgaXMgdHJhY2tlZCBpbnNpZGUgdGhlIGNvbXByZWhlbnNpb24uXG4gIHRvT3V0cHV0QnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCwgY2hhbmdlVHJhY2tpbmcsIHJvb3RBdHRycyA9IHt9KXtcbiAgICBpZihyZW5kZXJlZFtEWU5BTUlDU10peyByZXR1cm4gdGhpcy5jb21wcmVoZW5zaW9uVG9CdWZmZXIocmVuZGVyZWQsIHRlbXBsYXRlcywgb3V0cHV0KSB9XG4gICAgbGV0IHtbU1RBVElDXTogc3RhdGljc30gPSByZW5kZXJlZFxuICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcylcbiAgICBsZXQgaXNSb290ID0gcmVuZGVyZWRbUk9PVF1cbiAgICBsZXQgcHJldkJ1ZmZlciA9IG91dHB1dC5idWZmZXJcbiAgICBpZihpc1Jvb3QpeyBvdXRwdXQuYnVmZmVyID0gXCJcIiB9XG5cbiAgICAvLyB0aGlzIGNvbmRpdGlvbiBpcyBjYWxsZWQgd2hlbiBmaXJzdCByZW5kZXJpbmcgYW4gb3B0aW1pemFibGUgZnVuY3Rpb24gY29tcG9uZW50LlxuICAgIC8vIExDIGhhdmUgdGhlaXIgbWFnaWNJZCBwcmV2aW91c2x5IHNldFxuICAgIGlmKGNoYW5nZVRyYWNraW5nICYmIGlzUm9vdCAmJiAhcmVuZGVyZWQubWFnaWNJZCl7XG4gICAgICByZW5kZXJlZC5uZXdSZW5kZXIgPSB0cnVlXG4gICAgICByZW5kZXJlZC5tYWdpY0lkID0gdGhpcy5uZXh0TWFnaWNJRCgpXG4gICAgfVxuXG4gICAgb3V0cHV0LmJ1ZmZlciArPSBzdGF0aWNzWzBdXG4gICAgZm9yKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspe1xuICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIocmVuZGVyZWRbaSAtIDFdLCB0ZW1wbGF0ZXMsIG91dHB1dCwgY2hhbmdlVHJhY2tpbmcpXG4gICAgICBvdXRwdXQuYnVmZmVyICs9IHN0YXRpY3NbaV1cbiAgICB9XG5cbiAgICAvLyBBcHBsaWVzIHRoZSByb290IHRhZyBcInNraXBcIiBvcHRpbWl6YXRpb24gaWYgc3VwcG9ydGVkLCB3aGljaCBjbGVhcnNcbiAgICAvLyB0aGUgcm9vdCB0YWcgYXR0cmlidXRlcyBhbmQgaW5uZXJIVE1MLCBhbmQgb25seSBtYWludGFpbnMgdGhlIG1hZ2ljSWQuXG4gICAgLy8gV2UgY2FuIG9ubHkgc2tpcCB3aGVuIGNoYW5nZVRyYWNraW5nIGlzIHN1cHBvcnRlZCAob3V0c2lkZSBvZiBhIGNvbXByZWhlbnNpb24pLFxuICAgIC8vIGFuZCB3aGVuIHRoZSByb290IGVsZW1lbnQgaGFzbid0IGV4cGVyaWVuY2VkIGFuIHVucmVuZGVyZWQgbWVyZ2UgKG5ld1JlbmRlciB0cnVlKS5cbiAgICBpZihpc1Jvb3Qpe1xuICAgICAgbGV0IHNraXAgPSBmYWxzZVxuICAgICAgbGV0IGF0dHJzXG4gICAgICAvLyBXaGVuIGEgTEMgaXMgcmUtYWRkZWQgdG8gdGhlIHBhZ2UsIHdlIG5lZWQgdG8gcmUtcmVuZGVyIHRoZSBlbnRpcmUgTEMgdHJlZSxcbiAgICAgIC8vIHRoZXJlZm9yZSBjaGFuZ2VUcmFja2luZyBpcyBmYWxzZTsgaG93ZXZlciwgd2UgbmVlZCB0byBrZWVwIGFsbCB0aGUgbWFnaWNJZHNcbiAgICAgIC8vIGZyb20gYW55IGZ1bmN0aW9uIGNvbXBvbmVudCBzbyB0aGUgbmV4dCB0aW1lIHRoZSBMQyBpcyB1cGRhdGVkLCB3ZSBjYW4gYXBwbHlcbiAgICAgIC8vIHRoZSBza2lwIG9wdGltaXphdGlvblxuICAgICAgaWYoY2hhbmdlVHJhY2tpbmcgfHwgcmVuZGVyZWQubWFnaWNJZCl7XG4gICAgICAgIHNraXAgPSBjaGFuZ2VUcmFja2luZyAmJiAhcmVuZGVyZWQubmV3UmVuZGVyXG4gICAgICAgIGF0dHJzID0ge1tQSFhfTUFHSUNfSURdOiByZW5kZXJlZC5tYWdpY0lkLCAuLi5yb290QXR0cnN9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRycyA9IHJvb3RBdHRyc1xuICAgICAgfVxuICAgICAgaWYoc2tpcCl7IGF0dHJzW1BIWF9TS0lQXSA9IHRydWUgfVxuICAgICAgbGV0IFtuZXdSb290LCBjb21tZW50QmVmb3JlLCBjb21tZW50QWZ0ZXJdID0gbW9kaWZ5Um9vdChvdXRwdXQuYnVmZmVyLCBhdHRycywgc2tpcClcbiAgICAgIHJlbmRlcmVkLm5ld1JlbmRlciA9IGZhbHNlXG4gICAgICBvdXRwdXQuYnVmZmVyID0gcHJldkJ1ZmZlciArIGNvbW1lbnRCZWZvcmUgKyBuZXdSb290ICsgY29tbWVudEFmdGVyXG4gICAgfVxuICB9XG5cbiAgY29tcHJlaGVuc2lvblRvQnVmZmVyKHJlbmRlcmVkLCB0ZW1wbGF0ZXMsIG91dHB1dCl7XG4gICAgbGV0IHtbRFlOQU1JQ1NdOiBkeW5hbWljcywgW1NUQVRJQ106IHN0YXRpY3MsIFtTVFJFQU1dOiBzdHJlYW19ID0gcmVuZGVyZWRcbiAgICBsZXQgW19yZWYsIF9pbnNlcnRzLCBkZWxldGVJZHMsIHJlc2V0XSA9IHN0cmVhbSB8fCBbbnVsbCwge30sIFtdLCBudWxsXVxuICAgIHN0YXRpY3MgPSB0aGlzLnRlbXBsYXRlU3RhdGljKHN0YXRpY3MsIHRlbXBsYXRlcylcbiAgICBsZXQgY29tcFRlbXBsYXRlcyA9IHRlbXBsYXRlcyB8fCByZW5kZXJlZFtURU1QTEFURVNdXG4gICAgZm9yKGxldCBkID0gMDsgZCA8IGR5bmFtaWNzLmxlbmd0aDsgZCsrKXtcbiAgICAgIGxldCBkeW5hbWljID0gZHluYW1pY3NbZF1cbiAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1swXVxuICAgICAgZm9yKGxldCBpID0gMTsgaSA8IHN0YXRpY3MubGVuZ3RoOyBpKyspe1xuICAgICAgICAvLyBJbnNpZGUgYSBjb21wcmVoZW5zaW9uLCB3ZSBkb24ndCB0cmFjayBob3cgZHluYW1pY3MgY2hhbmdlXG4gICAgICAgIC8vIG92ZXIgdGltZSAoYW5kIGZlYXR1cmVzIGxpa2Ugc3RyZWFtcyB3b3VsZCBtYWtlIHRoYXQgaW1wb3NzaWJsZVxuICAgICAgICAvLyB1bmxlc3Mgd2UgbW92ZSB0aGUgc3RyZWFtIGRpZmZpbmcgYXdheSBmcm9tIG1vcnBoZG9tKSxcbiAgICAgICAgLy8gc28gd2UgY2FuJ3QgcGVyZm9ybSByb290IGNoYW5nZSB0cmFja2luZy5cbiAgICAgICAgbGV0IGNoYW5nZVRyYWNraW5nID0gZmFsc2VcbiAgICAgICAgdGhpcy5keW5hbWljVG9CdWZmZXIoZHluYW1pY1tpIC0gMV0sIGNvbXBUZW1wbGF0ZXMsIG91dHB1dCwgY2hhbmdlVHJhY2tpbmcpXG4gICAgICAgIG91dHB1dC5idWZmZXIgKz0gc3RhdGljc1tpXVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKHN0cmVhbSAhPT0gdW5kZWZpbmVkICYmIChyZW5kZXJlZFtEWU5BTUlDU10ubGVuZ3RoID4gMCB8fCBkZWxldGVJZHMubGVuZ3RoID4gMCB8fCByZXNldCkpe1xuICAgICAgZGVsZXRlIHJlbmRlcmVkW1NUUkVBTV1cbiAgICAgIHJlbmRlcmVkW0RZTkFNSUNTXSA9IFtdXG4gICAgICBvdXRwdXQuc3RyZWFtcy5hZGQoc3RyZWFtKVxuICAgIH1cbiAgfVxuXG4gIGR5bmFtaWNUb0J1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nKXtcbiAgICBpZih0eXBlb2YgKHJlbmRlcmVkKSA9PT0gXCJudW1iZXJcIil7XG4gICAgICBsZXQgW3N0ciwgc3RyZWFtc10gPSB0aGlzLnJlY3Vyc2l2ZUNJRFRvU3RyaW5nKG91dHB1dC5jb21wb25lbnRzLCByZW5kZXJlZCwgb3V0cHV0Lm9ubHlDaWRzKVxuICAgICAgb3V0cHV0LmJ1ZmZlciArPSBzdHJcbiAgICAgIG91dHB1dC5zdHJlYW1zID0gbmV3IFNldChbLi4ub3V0cHV0LnN0cmVhbXMsIC4uLnN0cmVhbXNdKVxuICAgIH0gZWxzZSBpZihpc09iamVjdChyZW5kZXJlZCkpe1xuICAgICAgdGhpcy50b091dHB1dEJ1ZmZlcihyZW5kZXJlZCwgdGVtcGxhdGVzLCBvdXRwdXQsIGNoYW5nZVRyYWNraW5nLCB7fSlcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LmJ1ZmZlciArPSByZW5kZXJlZFxuICAgIH1cbiAgfVxuXG4gIHJlY3Vyc2l2ZUNJRFRvU3RyaW5nKGNvbXBvbmVudHMsIGNpZCwgb25seUNpZHMpe1xuICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2NpZF0gfHwgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3IgQ0lEICR7Y2lkfWAsIGNvbXBvbmVudHMpXG4gICAgbGV0IGF0dHJzID0ge1tQSFhfQ09NUE9ORU5UXTogY2lkfVxuICAgIGxldCBza2lwID0gb25seUNpZHMgJiYgIW9ubHlDaWRzLmhhcyhjaWQpXG4gICAgLy8gVHdvIG9wdGltaXphdGlvbiBwYXRocyBhcHBseSBoZXJlOlxuICAgIC8vXG4gICAgLy8gICAxLiBUaGUgb25seUNpZHMgb3B0aW1pemF0aW9uIHdvcmtzIGJ5IHRoZSBzZXJ2ZXIgZGlmZiB0ZWxsaW5nIHVzIG9ubHkgc3BlY2lmaWNcbiAgICAvLyAgICAgY2lkJ3MgaGF2ZSBjaGFuZ2VkLiBUaGlzIGFsbG93cyB1cyB0byBza2lwIHJlbmRlcmluZyBhbnkgY29tcG9uZW50IHRoYXQgaGFzbid0IGNoYW5nZWQsXG4gICAgLy8gICAgIHdoaWNoIHVsdGltYXRlbHkgc2V0cyBQSFhfU0tJUCByb290IGF0dHJpYnV0ZSBhbmQgYXZvaWRzIHJlbmRlcmluZyB0aGUgaW5uZXJIVE1MLlxuICAgIC8vXG4gICAgLy8gICAyLiBUaGUgcm9vdCBQSFhfU0tJUCBvcHRpbWl6YXRpb24gZ2VuZXJhbGl6ZXMgdG8gYWxsIEhFRXggZnVuY3Rpb24gY29tcG9uZW50cywgYW5kXG4gICAgLy8gICAgIHdvcmtzIGluIHRoZSBzYW1lIFBIWF9TS0lQIGF0dHJpYnV0ZSBmYXNoaW9uIGFzIDEsIGJ1dCB0aGUgbmV3UmVuZGVyIHRyYWNraW5nIGlzIGRvbmVcbiAgICAvLyAgICAgYXQgdGhlIGdlbmVyYWwgZGlmZiBtZXJnZSBsZXZlbC4gSWYgd2UgbWVyZ2UgYSBkaWZmIHdpdGggbmV3IGR5bmFtaWNzLCB3ZSBuZWNlc3NhcmlseSBoYXZlXG4gICAgLy8gICAgIGV4cGVyaWVuY2VkIGEgY2hhbmdlIHdoaWNoIG11c3QgYmUgYSBuZXdSZW5kZXIsIGFuZCB0aHVzIHdlIGNhbid0IHNraXAgdGhlIHJlbmRlci5cbiAgICAvL1xuICAgIC8vIEJvdGggb3B0aW1pemF0aW9uIGZsb3dzIGFwcGx5IGhlcmUuIG5ld1JlbmRlciBpcyBzZXQgYmFzZWQgb24gdGhlIG9ubHlDaWRzIG9wdGltaXphdGlvbiwgYW5kXG4gICAgLy8gd2UgdHJhY2sgYSBkZXRlcm1pbmlzdGljIG1hZ2ljSWQgYmFzZWQgb24gdGhlIGNpZC5cbiAgICAvL1xuICAgIC8vIGNoYW5nZVRyYWNraW5nIGlzIGFib3V0IHRoZSBlbnRpcmUgdHJlZVxuICAgIC8vIG5ld1JlbmRlciBpcyBhYm91dCB0aGUgY3VycmVudCByb290IGluIHRoZSB0cmVlXG4gICAgLy9cbiAgICAvLyBCeSBkZWZhdWx0IGNoYW5nZVRyYWNraW5nIGlzIGVuYWJsZWQsIGJ1dCB3ZSBzcGVjaWFsIGNhc2UgdGhlIGZsb3cgd2hlcmUgdGhlIGNsaWVudCBpcyBwcnVuaW5nXG4gICAgLy8gY2lkcyBhbmQgdGhlIHNlcnZlciBhZGRzIHRoZSBjb21wb25lbnQgYmFjay4gSW4gc3VjaCBjYXNlcywgd2UgZXhwbGljaXRseSBkaXNhYmxlIGNoYW5nZVRyYWNraW5nXG4gICAgLy8gd2l0aCByZXNldFJlbmRlciBmb3IgdGhpcyBjaWQsIHRoZW4gcmUtZW5hYmxlIGl0IGFmdGVyIHRoZSByZWN1cnNpdmUgY2FsbCB0byBza2lwIHRoZSBvcHRpbWl6YXRpb25cbiAgICAvLyBmb3IgdGhlIGVudGlyZSBjb21wb25lbnQgdHJlZS5cbiAgICBjb21wb25lbnQubmV3UmVuZGVyID0gIXNraXBcbiAgICBjb21wb25lbnQubWFnaWNJZCA9IGBjJHtjaWR9LSR7dGhpcy5wYXJlbnRWaWV3SWQoKX1gXG4gICAgLy8gZW5hYmxlIGNoYW5nZSB0cmFja2luZyBhcyBsb25nIGFzIHRoZSBjb21wb25lbnQgaGFzbid0IGJlZW4gcmVzZXRcbiAgICBsZXQgY2hhbmdlVHJhY2tpbmcgPSAhY29tcG9uZW50LnJlc2V0XG4gICAgbGV0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVjdXJzaXZlVG9TdHJpbmcoY29tcG9uZW50LCBjb21wb25lbnRzLCBvbmx5Q2lkcywgY2hhbmdlVHJhY2tpbmcsIGF0dHJzKVxuICAgIC8vIGRpc2FibGUgcmVzZXQgYWZ0ZXIgd2UndmUgcmVuZGVyZWRcbiAgICBkZWxldGUgY29tcG9uZW50LnJlc2V0XG5cbiAgICByZXR1cm4gW2h0bWwsIHN0cmVhbXNdXG4gIH1cbn1cbiIsICJpbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgQVJJQSBmcm9tIFwiLi9hcmlhXCJcblxubGV0IGZvY3VzU3RhY2sgPSBbXVxubGV0IGRlZmF1bHRfdHJhbnNpdGlvbl90aW1lID0gMjAwXG5cbmxldCBKUyA9IHtcbiAgLy8gcHJpdmF0ZVxuICBleGVjKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBkZWZhdWx0cyl7XG4gICAgbGV0IFtkZWZhdWx0S2luZCwgZGVmYXVsdEFyZ3NdID0gZGVmYXVsdHMgfHwgW251bGwsIHtjYWxsYmFjazogZGVmYXVsdHMgJiYgZGVmYXVsdHMuY2FsbGJhY2t9XVxuICAgIGxldCBjb21tYW5kcyA9IHBoeEV2ZW50LmNoYXJBdCgwKSA9PT0gXCJbXCIgP1xuICAgICAgSlNPTi5wYXJzZShwaHhFdmVudCkgOiBbW2RlZmF1bHRLaW5kLCBkZWZhdWx0QXJnc11dXG5cbiAgICBjb21tYW5kcy5mb3JFYWNoKChba2luZCwgYXJnc10pID0+IHtcbiAgICAgIGlmKGtpbmQgPT09IGRlZmF1bHRLaW5kKXtcbiAgICAgICAgLy8gYWx3YXlzIHByZWZlciB0aGUgYXJncywgYnV0IGtlZXAgZXhpc3Rpbmcga2V5cyBmcm9tIHRoZSBkZWZhdWx0QXJnc1xuICAgICAgICBhcmdzID0gey4uLmRlZmF1bHRBcmdzLCAuLi5hcmdzfVxuICAgICAgICBhcmdzLmNhbGxiYWNrID0gYXJncy5jYWxsYmFjayB8fCBkZWZhdWx0QXJncy5jYWxsYmFja1xuICAgICAgfVxuICAgICAgdGhpcy5maWx0ZXJUb0Vscyh2aWV3LmxpdmVTb2NrZXQsIHNvdXJjZUVsLCBhcmdzKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgdGhpc1tgZXhlY18ke2tpbmR9YF0oZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCBhcmdzKVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIGlzVmlzaWJsZShlbCl7XG4gICAgcmV0dXJuICEhKGVsLm9mZnNldFdpZHRoIHx8IGVsLm9mZnNldEhlaWdodCB8fCBlbC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA+IDApXG4gIH0sXG5cbiAgLy8gcmV0dXJucyB0cnVlIGlmIGFueSBwYXJ0IG9mIHRoZSBlbGVtZW50IGlzIGluc2lkZSB0aGUgdmlld3BvcnRcbiAgaXNJblZpZXdwb3J0KGVsKXtcbiAgICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCB3aW5kb3dIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgIGNvbnN0IHdpbmRvd1dpZHRoID0gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG5cbiAgICByZXR1cm4gKFxuICAgICAgcmVjdC5yaWdodCA+IDAgJiZcbiAgICAgIHJlY3QuYm90dG9tID4gMCAmJlxuICAgICAgcmVjdC5sZWZ0IDwgd2luZG93V2lkdGggJiZcbiAgICAgIHJlY3QudG9wIDwgd2luZG93SGVpZ2h0XG4gICAgKVxuICB9LFxuXG4gIC8vIHByaXZhdGVcblxuICAvLyBjb21tYW5kc1xuXG4gIGV4ZWNfZXhlYyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHthdHRyLCB0b30pe1xuICAgIGxldCBlbmNvZGVkSlMgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cilcbiAgICBpZighZW5jb2RlZEpTKXsgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke2F0dHJ9IHRvIGNvbnRhaW4gSlMgY29tbWFuZCBvbiBcIiR7dG99XCJgKSB9XG4gICAgdmlldy5saXZlU29ja2V0LmV4ZWNKUyhlbCwgZW5jb2RlZEpTLCBldmVudFR5cGUpXG4gIH0sXG5cbiAgZXhlY19kaXNwYXRjaChlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtldmVudCwgZGV0YWlsLCBidWJibGVzfSl7XG4gICAgZGV0YWlsID0gZGV0YWlsIHx8IHt9XG4gICAgZGV0YWlsLmRpc3BhdGNoZXIgPSBzb3VyY2VFbFxuICAgIERPTS5kaXNwYXRjaEV2ZW50KGVsLCBldmVudCwge2RldGFpbCwgYnViYmxlc30pXG4gIH0sXG5cbiAgZXhlY19wdXNoKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwgYXJncyl7XG4gICAgbGV0IHtldmVudCwgZGF0YSwgdGFyZ2V0LCBwYWdlX2xvYWRpbmcsIGxvYWRpbmcsIHZhbHVlLCBkaXNwYXRjaGVyLCBjYWxsYmFja30gPSBhcmdzXG4gICAgbGV0IHB1c2hPcHRzID0ge2xvYWRpbmcsIHZhbHVlLCB0YXJnZXQsIHBhZ2VfbG9hZGluZzogISFwYWdlX2xvYWRpbmd9XG4gICAgbGV0IHRhcmdldFNyYyA9IGV2ZW50VHlwZSA9PT0gXCJjaGFuZ2VcIiAmJiBkaXNwYXRjaGVyID8gZGlzcGF0Y2hlciA6IHNvdXJjZUVsXG4gICAgbGV0IHBoeFRhcmdldCA9IHRhcmdldCB8fCB0YXJnZXRTcmMuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhcInRhcmdldFwiKSkgfHwgdGFyZ2V0U3JjXG4gICAgY29uc3QgaGFuZGxlciA9ICh0YXJnZXRWaWV3LCB0YXJnZXRDdHgpID0+IHtcbiAgICAgIGlmKCF0YXJnZXRWaWV3LmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gfVxuICAgICAgaWYoZXZlbnRUeXBlID09PSBcImNoYW5nZVwiKXtcbiAgICAgICAgbGV0IHtuZXdDaWQsIF90YXJnZXR9ID0gYXJnc1xuICAgICAgICBfdGFyZ2V0ID0gX3RhcmdldCB8fCAoRE9NLmlzRm9ybUlucHV0KHNvdXJjZUVsKSA/IHNvdXJjZUVsLm5hbWUgOiB1bmRlZmluZWQpXG4gICAgICAgIGlmKF90YXJnZXQpeyBwdXNoT3B0cy5fdGFyZ2V0ID0gX3RhcmdldCB9XG4gICAgICAgIHRhcmdldFZpZXcucHVzaElucHV0KHNvdXJjZUVsLCB0YXJnZXRDdHgsIG5ld0NpZCwgZXZlbnQgfHwgcGh4RXZlbnQsIHB1c2hPcHRzLCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSBpZihldmVudFR5cGUgPT09IFwic3VibWl0XCIpe1xuICAgICAgICBsZXQge3N1Ym1pdHRlcn0gPSBhcmdzXG4gICAgICAgIHRhcmdldFZpZXcuc3VibWl0Rm9ybShzb3VyY2VFbCwgdGFyZ2V0Q3R4LCBldmVudCB8fCBwaHhFdmVudCwgc3VibWl0dGVyLCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRWaWV3LnB1c2hFdmVudChldmVudFR5cGUsIHNvdXJjZUVsLCB0YXJnZXRDdHgsIGV2ZW50IHx8IHBoeEV2ZW50LCBkYXRhLCBwdXNoT3B0cywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfVxuICAgIC8vIGluIGNhc2Ugb2YgZm9ybVJlY292ZXJ5LCB0YXJnZXRWaWV3IGFuZCB0YXJnZXRDdHggYXJlIHBhc3NlZCBhcyBhcmd1bWVudFxuICAgIC8vIGFzIHRoZXkgYXJlIGxvb2tlZCB1cCBpbiBhIHRlbXBsYXRlIGVsZW1lbnQsIG5vdCB0aGUgcmVhbCBET01cbiAgICBpZihhcmdzLnRhcmdldFZpZXcgJiYgYXJncy50YXJnZXRDdHgpe1xuICAgICAgaGFuZGxlcihhcmdzLnRhcmdldFZpZXcsIGFyZ3MudGFyZ2V0Q3R4KVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBoYW5kbGVyKVxuICAgIH1cbiAgfSxcblxuICBleGVjX25hdmlnYXRlKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2hyZWYsIHJlcGxhY2V9KXtcbiAgICB2aWV3LmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KGUsIGhyZWYsIHJlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiLCBudWxsLCBzb3VyY2VFbClcbiAgfSxcblxuICBleGVjX3BhdGNoKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2hyZWYsIHJlcGxhY2V9KXtcbiAgICB2aWV3LmxpdmVTb2NrZXQucHVzaEhpc3RvcnlQYXRjaChlLCBocmVmLCByZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcInB1c2hcIiwgc291cmNlRWwpXG4gIH0sXG5cbiAgZXhlY19mb2N1cyhlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwpe1xuICAgIEFSSUEuYXR0ZW1wdEZvY3VzKGVsKVxuICAgIC8vIGluIGNhc2UgdGhlIEpTLmZvY3VzIGNvbW1hbmQgaXMgaW4gYSBKUy5zaG93L2hpZGUvdG9nZ2xlIGNoYWluLCBmb3Igc2hvdyB3ZSBuZWVkXG4gICAgLy8gdG8gd2FpdCBmb3IgSlMuc2hvdyB0byBoYXZlIHVwZGF0ZWQgdGhlIGVsZW1lbnQncyBkaXNwbGF5IHByb3BlcnR5IChzZWUgZXhlY190b2dnbGUpXG4gICAgLy8gYnV0IHRoYXQgcnVuIGluIG5lc3RlZCBhbmltYXRpb24gZnJhbWVzLCB0aGVyZWZvcmUgd2UgbmVlZCB0byB1c2UgdGhlbSBoZXJlIGFzIHdlbGxcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gQVJJQS5hdHRlbXB0Rm9jdXMoZWwpKVxuICAgIH0pXG4gIH0sXG5cbiAgZXhlY19mb2N1c19maXJzdChlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwpe1xuICAgIEFSSUEuZm9jdXNGaXJzdEludGVyYWN0aXZlKGVsKSB8fCBBUklBLmZvY3VzRmlyc3QoZWwpXG4gICAgLy8gaWYgeW91IHdvbmRlciBhYm91dCB0aGUgbmVzdGVkIGFuaW1hdGlvbiBmcmFtZXMsIHNlZSBleGVjX2ZvY3VzXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IEFSSUEuZm9jdXNGaXJzdEludGVyYWN0aXZlKGVsKSB8fCBBUklBLmZvY3VzRmlyc3QoZWwpKVxuICAgIH0pXG4gIH0sXG5cbiAgZXhlY19wdXNoX2ZvY3VzKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCl7XG4gICAgZm9jdXNTdGFjay5wdXNoKGVsIHx8IHNvdXJjZUVsKVxuICB9LFxuXG4gIGV4ZWNfcG9wX2ZvY3VzKF9lLCBfZXZlbnRUeXBlLCBfcGh4RXZlbnQsIF92aWV3LCBfc291cmNlRWwsIF9lbCl7XG4gICAgY29uc3QgZWwgPSBmb2N1c1N0YWNrLnBvcCgpXG4gICAgaWYoZWwpe1xuICAgICAgZWwuZm9jdXMoKVxuICAgICAgLy8gaWYgeW91IHdvbmRlciBhYm91dCB0aGUgbmVzdGVkIGFuaW1hdGlvbiBmcmFtZXMsIHNlZSBleGVjX2ZvY3VzXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBlbC5mb2N1cygpKVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgZXhlY19hZGRfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG5hbWVzLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY19yZW1vdmVfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGVfY2xhc3MoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7bmFtZXMsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy50b2dnbGVDbGFzc2VzKGVsLCBuYW1lcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGVfYXR0cihlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHthdHRyOiBbYXR0ciwgdmFsMSwgdmFsMl19KXtcbiAgICB0aGlzLnRvZ2dsZUF0dHIoZWwsIGF0dHIsIHZhbDEsIHZhbDIpXG4gIH0sXG5cbiAgZXhlY190cmFuc2l0aW9uKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge3RpbWUsIHRyYW5zaXRpb24sIGJsb2NraW5nfSl7XG4gICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBbXSwgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY190b2dnbGUoZSwgZXZlbnRUeXBlLCBwaHhFdmVudCwgdmlldywgc291cmNlRWwsIGVsLCB7ZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lLCBibG9ja2luZ30pe1xuICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIGlucywgb3V0cywgdGltZSwgYmxvY2tpbmcpXG4gIH0sXG5cbiAgZXhlY19zaG93KGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2Rpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nfSl7XG4gICAgdGhpcy5zaG93KGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nKVxuICB9LFxuXG4gIGV4ZWNfaGlkZShlLCBldmVudFR5cGUsIHBoeEV2ZW50LCB2aWV3LCBzb3VyY2VFbCwgZWwsIHtkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZ30pe1xuICAgIHRoaXMuaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZylcbiAgfSxcblxuICBleGVjX3NldF9hdHRyKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHI6IFthdHRyLCB2YWxdfSl7XG4gICAgdGhpcy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSlcbiAgfSxcblxuICBleGVjX3JlbW92ZV9hdHRyKGUsIGV2ZW50VHlwZSwgcGh4RXZlbnQsIHZpZXcsIHNvdXJjZUVsLCBlbCwge2F0dHJ9KXtcbiAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pXG4gIH0sXG5cbiAgLy8gdXRpbHMgZm9yIGNvbW1hbmRzXG5cbiAgc2hvdyhldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZyl7XG4gICAgaWYoIXRoaXMuaXNWaXNpYmxlKGVsKSl7XG4gICAgICB0aGlzLnRvZ2dsZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCBudWxsLCB0aW1lLCBibG9ja2luZylcbiAgICB9XG4gIH0sXG5cbiAgaGlkZShldmVudFR5cGUsIHZpZXcsIGVsLCBkaXNwbGF5LCB0cmFuc2l0aW9uLCB0aW1lLCBibG9ja2luZyl7XG4gICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgIHRoaXMudG9nZ2xlKGV2ZW50VHlwZSwgdmlldywgZWwsIGRpc3BsYXksIG51bGwsIHRyYW5zaXRpb24sIHRpbWUsIGJsb2NraW5nKVxuICAgIH1cbiAgfSxcblxuICB0b2dnbGUoZXZlbnRUeXBlLCB2aWV3LCBlbCwgZGlzcGxheSwgaW5zLCBvdXRzLCB0aW1lLCBibG9ja2luZyl7XG4gICAgdGltZSA9IHRpbWUgfHwgZGVmYXVsdF90cmFuc2l0aW9uX3RpbWVcbiAgICBsZXQgW2luQ2xhc3NlcywgaW5TdGFydENsYXNzZXMsIGluRW5kQ2xhc3Nlc10gPSBpbnMgfHwgW1tdLCBbXSwgW11dXG4gICAgbGV0IFtvdXRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMsIG91dEVuZENsYXNzZXNdID0gb3V0cyB8fCBbW10sIFtdLCBbXV1cbiAgICBpZihpbkNsYXNzZXMubGVuZ3RoID4gMCB8fCBvdXRDbGFzc2VzLmxlbmd0aCA+IDApe1xuICAgICAgaWYodGhpcy5pc1Zpc2libGUoZWwpKXtcbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIG91dFN0YXJ0Q2xhc3NlcywgaW5DbGFzc2VzLmNvbmNhdChpblN0YXJ0Q2xhc3NlcykuY29uY2F0KGluRW5kQ2xhc3NlcykpXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcywgW10pXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBvdXRFbmRDbGFzc2VzLCBvdXRTdGFydENsYXNzZXMpKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9uRW5kID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgb3V0Q2xhc3Nlcy5jb25jYXQob3V0RW5kQ2xhc3NlcykpXG4gICAgICAgICAgRE9NLnB1dFN0aWNreShlbCwgXCJ0b2dnbGVcIiwgY3VycmVudEVsID0+IGN1cnJlbnRFbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCIpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1lbmRcIikpXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6aGlkZS1zdGFydFwiKSlcbiAgICAgICAgaWYoYmxvY2tpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgICBvblN0YXJ0KClcbiAgICAgICAgICBzZXRUaW1lb3V0KG9uRW5kLCB0aW1lKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkVuZClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoZXZlbnRUeXBlID09PSBcInJlbW92ZVwiKXsgcmV0dXJuIH1cbiAgICAgICAgbGV0IG9uU3RhcnQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluU3RhcnRDbGFzc2VzLCBvdXRDbGFzc2VzLmNvbmNhdChvdXRTdGFydENsYXNzZXMpLmNvbmNhdChvdXRFbmRDbGFzc2VzKSlcbiAgICAgICAgICBjb25zdCBzdGlja3lEaXNwbGF5ID0gZGlzcGxheSB8fCB0aGlzLmRlZmF1bHREaXNwbGF5KGVsKVxuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZmlyc3QgYWRkIHRoZSBzdGFydGluZyArIGFjdGl2ZSBjbGFzcywgVEhFTiBtYWtlIHRoZSBlbGVtZW50IHZpc2libGVcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBpZiB3ZSB0b2dnbGVkIHRoZSB2aXNpYmlsaXR5IGVhcmxpZXIgY3NzIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIC8vIHdvdWxkIGZsaWNrZXIsIGFzIHRoZSBlbGVtZW50IGJlY29tZXMgdmlzaWJsZSBiZWZvcmUgdGhlIGFjdGl2ZSBhbmltYXRpb25cbiAgICAgICAgICAgIC8vIGNsYXNzIGlzIHNldCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zNDU2KVxuICAgICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIGluQ2xhc3NlcywgW10pXG4gICAgICAgICAgICAvLyBhZGRPclJlbW92ZUNsYXNzZXMgdXNlcyBhIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpdHNlbGYsIHRoZXJlZm9yZSB3ZSBuZWVkIHRvIG1vdmUgdGhlIHB1dFN0aWNreVxuICAgICAgICAgICAgLy8gaW50byB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuLi5cbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBzdGlja3lEaXNwbGF5KVxuICAgICAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgaW5FbmRDbGFzc2VzLCBpblN0YXJ0Q2xhc3NlcylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25FbmQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGRPclJlbW92ZUNsYXNzZXMoZWwsIFtdLCBpbkNsYXNzZXMuY29uY2F0KGluRW5kQ2xhc3NlcykpXG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1lbmRcIikpXG4gICAgICAgIH1cbiAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1zdGFydFwiKSlcbiAgICAgICAgaWYoYmxvY2tpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgICBvblN0YXJ0KClcbiAgICAgICAgICBzZXRUaW1lb3V0KG9uRW5kLCB0aW1lKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZpZXcudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkVuZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih0aGlzLmlzVmlzaWJsZShlbCkpe1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInBoeDpoaWRlLXN0YXJ0XCIpKVxuICAgICAgICAgIERPTS5wdXRTdGlja3koZWwsIFwidG9nZ2xlXCIsIGN1cnJlbnRFbCA9PiBjdXJyZW50RWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiKVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OmhpZGUtZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJwaHg6c2hvdy1zdGFydFwiKSlcbiAgICAgICAgICBsZXQgc3RpY2t5RGlzcGxheSA9IGRpc3BsYXkgfHwgdGhpcy5kZWZhdWx0RGlzcGxheShlbClcbiAgICAgICAgICBET00ucHV0U3RpY2t5KGVsLCBcInRvZ2dsZVwiLCBjdXJyZW50RWwgPT4gY3VycmVudEVsLnN0eWxlLmRpc3BsYXkgPSBzdGlja3lEaXNwbGF5KVxuICAgICAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicGh4OnNob3ctZW5kXCIpKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB0b2dnbGVDbGFzc2VzKGVsLCBjbGFzc2VzLCB0cmFuc2l0aW9uLCB0aW1lLCB2aWV3LCBibG9ja2luZyl7XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBsZXQgW3ByZXZBZGRzLCBwcmV2UmVtb3Zlc10gPSBET00uZ2V0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgW1tdLCBbXV0pXG4gICAgICBsZXQgbmV3QWRkcyA9IGNsYXNzZXMuZmlsdGVyKG5hbWUgPT4gcHJldkFkZHMuaW5kZXhPZihuYW1lKSA8IDAgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSlcbiAgICAgIGxldCBuZXdSZW1vdmVzID0gY2xhc3Nlcy5maWx0ZXIobmFtZSA9PiBwcmV2UmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMCAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgbmV3QWRkcywgbmV3UmVtb3ZlcywgdHJhbnNpdGlvbiwgdGltZSwgdmlldywgYmxvY2tpbmcpXG4gICAgfSlcbiAgfSxcblxuICB0b2dnbGVBdHRyKGVsLCBhdHRyLCB2YWwxLCB2YWwyKXtcbiAgICBpZihlbC5oYXNBdHRyaWJ1dGUoYXR0cikpe1xuICAgICAgaWYodmFsMiAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgLy8gdG9nZ2xlIGJldHdlZW4gdmFsMSBhbmQgdmFsMlxuICAgICAgICBpZihlbC5nZXRBdHRyaWJ1dGUoYXR0cikgPT09IHZhbDEpe1xuICAgICAgICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW1thdHRyLCB2YWwyXV0sIFtdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW1thdHRyLCB2YWwxXV0sIFtdKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgYXR0clxuICAgICAgICB0aGlzLnNldE9yUmVtb3ZlQXR0cnMoZWwsIFtdLCBbYXR0cl0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0T3JSZW1vdmVBdHRycyhlbCwgW1thdHRyLCB2YWwxXV0sIFtdKVxuICAgIH1cbiAgfSxcblxuICBhZGRPclJlbW92ZUNsYXNzZXMoZWwsIGFkZHMsIHJlbW92ZXMsIHRyYW5zaXRpb24sIHRpbWUsIHZpZXcsIGJsb2NraW5nKXtcbiAgICB0aW1lID0gdGltZSB8fCBkZWZhdWx0X3RyYW5zaXRpb25fdGltZVxuICAgIGxldCBbdHJhbnNpdGlvblJ1biwgdHJhbnNpdGlvblN0YXJ0LCB0cmFuc2l0aW9uRW5kXSA9IHRyYW5zaXRpb24gfHwgW1tdLCBbXSwgW11dXG4gICAgaWYodHJhbnNpdGlvblJ1bi5sZW5ndGggPiAwKXtcbiAgICAgIGxldCBvblN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvblN0YXJ0LCBbXS5jb25jYXQodHJhbnNpdGlvblJ1bikuY29uY2F0KHRyYW5zaXRpb25FbmQpKVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvblJ1biwgW10pXG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgdHJhbnNpdGlvbkVuZCwgdHJhbnNpdGlvblN0YXJ0KSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGxldCBvbkRvbmUgPSAoKSA9PiB0aGlzLmFkZE9yUmVtb3ZlQ2xhc3NlcyhlbCwgYWRkcy5jb25jYXQodHJhbnNpdGlvbkVuZCksIHJlbW92ZXMuY29uY2F0KHRyYW5zaXRpb25SdW4pLmNvbmNhdCh0cmFuc2l0aW9uU3RhcnQpKVxuICAgICAgaWYoYmxvY2tpbmcgPT09IGZhbHNlKXtcbiAgICAgICAgb25TdGFydCgpXG4gICAgICAgIHNldFRpbWVvdXQob25Eb25lLCB0aW1lKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlldy50cmFuc2l0aW9uKHRpbWUsIG9uU3RhcnQsIG9uRG9uZSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgbGV0IFtwcmV2QWRkcywgcHJldlJlbW92ZXNdID0gRE9NLmdldFN0aWNreShlbCwgXCJjbGFzc2VzXCIsIFtbXSwgW11dKVxuICAgICAgbGV0IGtlZXBBZGRzID0gYWRkcy5maWx0ZXIobmFtZSA9PiBwcmV2QWRkcy5pbmRleE9mKG5hbWUpIDwgMCAmJiAhZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpKVxuICAgICAgbGV0IGtlZXBSZW1vdmVzID0gcmVtb3Zlcy5maWx0ZXIobmFtZSA9PiBwcmV2UmVtb3Zlcy5pbmRleE9mKG5hbWUpIDwgMCAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMobmFtZSkpXG4gICAgICBsZXQgbmV3QWRkcyA9IHByZXZBZGRzLmZpbHRlcihuYW1lID0+IHJlbW92ZXMuaW5kZXhPZihuYW1lKSA8IDApLmNvbmNhdChrZWVwQWRkcylcbiAgICAgIGxldCBuZXdSZW1vdmVzID0gcHJldlJlbW92ZXMuZmlsdGVyKG5hbWUgPT4gYWRkcy5pbmRleE9mKG5hbWUpIDwgMCkuY29uY2F0KGtlZXBSZW1vdmVzKVxuXG4gICAgICBET00ucHV0U3RpY2t5KGVsLCBcImNsYXNzZXNcIiwgY3VycmVudEVsID0+IHtcbiAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5yZW1vdmUoLi4ubmV3UmVtb3ZlcylcbiAgICAgICAgY3VycmVudEVsLmNsYXNzTGlzdC5hZGQoLi4ubmV3QWRkcylcbiAgICAgICAgcmV0dXJuIFtuZXdBZGRzLCBuZXdSZW1vdmVzXVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuXG4gIHNldE9yUmVtb3ZlQXR0cnMoZWwsIHNldHMsIHJlbW92ZXMpe1xuICAgIGxldCBbcHJldlNldHMsIHByZXZSZW1vdmVzXSA9IERPTS5nZXRTdGlja3koZWwsIFwiYXR0cnNcIiwgW1tdLCBbXV0pXG5cbiAgICBsZXQgYWx0ZXJlZEF0dHJzID0gc2V0cy5tYXAoKFthdHRyLCBfdmFsXSkgPT4gYXR0cikuY29uY2F0KHJlbW92ZXMpXG4gICAgbGV0IG5ld1NldHMgPSBwcmV2U2V0cy5maWx0ZXIoKFthdHRyLCBfdmFsXSkgPT4gIWFsdGVyZWRBdHRycy5pbmNsdWRlcyhhdHRyKSkuY29uY2F0KHNldHMpXG4gICAgbGV0IG5ld1JlbW92ZXMgPSBwcmV2UmVtb3Zlcy5maWx0ZXIoKGF0dHIpID0+ICFhbHRlcmVkQXR0cnMuaW5jbHVkZXMoYXR0cikpLmNvbmNhdChyZW1vdmVzKVxuXG4gICAgRE9NLnB1dFN0aWNreShlbCwgXCJhdHRyc1wiLCBjdXJyZW50RWwgPT4ge1xuICAgICAgbmV3UmVtb3Zlcy5mb3JFYWNoKGF0dHIgPT4gY3VycmVudEVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSlcbiAgICAgIG5ld1NldHMuZm9yRWFjaCgoW2F0dHIsIHZhbF0pID0+IGN1cnJlbnRFbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsKSlcbiAgICAgIHJldHVybiBbbmV3U2V0cywgbmV3UmVtb3Zlc11cbiAgICB9KVxuICB9LFxuXG4gIGhhc0FsbENsYXNzZXMoZWwsIGNsYXNzZXMpeyByZXR1cm4gY2xhc3Nlcy5ldmVyeShuYW1lID0+IGVsLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKSkgfSxcblxuICBpc1RvZ2dsZWRPdXQoZWwsIG91dENsYXNzZXMpe1xuICAgIHJldHVybiAhdGhpcy5pc1Zpc2libGUoZWwpIHx8IHRoaXMuaGFzQWxsQ2xhc3NlcyhlbCwgb3V0Q2xhc3NlcylcbiAgfSxcblxuICBmaWx0ZXJUb0VscyhsaXZlU29ja2V0LCBzb3VyY2VFbCwge3RvfSl7XG4gICAgbGV0IGRlZmF1bHRRdWVyeSA9ICgpID0+IHtcbiAgICAgIGlmKHR5cGVvZih0bykgPT09IFwic3RyaW5nXCIpe1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0bylcbiAgICAgIH0gZWxzZSBpZih0by5jbG9zZXN0KXtcbiAgICAgICAgbGV0IHRvRWwgPSBzb3VyY2VFbC5jbG9zZXN0KHRvLmNsb3Nlc3QpXG4gICAgICAgIHJldHVybiB0b0VsID8gW3RvRWxdIDogW11cbiAgICAgIH0gZWxzZSBpZih0by5pbm5lcil7XG4gICAgICAgIHJldHVybiBzb3VyY2VFbC5xdWVyeVNlbGVjdG9yQWxsKHRvLmlubmVyKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8gPyBsaXZlU29ja2V0LmpzUXVlcnlTZWxlY3RvckFsbChzb3VyY2VFbCwgdG8sIGRlZmF1bHRRdWVyeSkgOiBbc291cmNlRWxdXG4gIH0sXG5cbiAgZGVmYXVsdERpc3BsYXkoZWwpe1xuICAgIHJldHVybiB7dHI6IFwidGFibGUtcm93XCIsIHRkOiBcInRhYmxlLWNlbGxcIn1bZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpXSB8fCBcImJsb2NrXCJcbiAgfSxcblxuICB0cmFuc2l0aW9uQ2xhc3Nlcyh2YWwpe1xuICAgIGlmKCF2YWwpeyByZXR1cm4gbnVsbCB9XG5cbiAgICBsZXQgW3RyYW5zLCB0U3RhcnQsIHRFbmRdID0gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbC5zcGxpdChcIiBcIiksIFtdLCBbXV1cbiAgICB0cmFucyA9IEFycmF5LmlzQXJyYXkodHJhbnMpID8gdHJhbnMgOiB0cmFucy5zcGxpdChcIiBcIilcbiAgICB0U3RhcnQgPSBBcnJheS5pc0FycmF5KHRTdGFydCkgPyB0U3RhcnQgOiB0U3RhcnQuc3BsaXQoXCIgXCIpXG4gICAgdEVuZCA9IEFycmF5LmlzQXJyYXkodEVuZCkgPyB0RW5kIDogdEVuZC5zcGxpdChcIiBcIilcbiAgICByZXR1cm4gW3RyYW5zLCB0U3RhcnQsIHRFbmRdXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgSlNcbiIsICJpbXBvcnQgSlMgZnJvbSBcIi4vanNcIlxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuXG5jb25zdCBIT09LX0lEID0gXCJob29rSWRcIlxuXG5sZXQgdmlld0hvb2tJRCA9IDFcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpZXdIb29rIHtcbiAgc3RhdGljIG1ha2VJRCgpeyByZXR1cm4gdmlld0hvb2tJRCsrIH1cbiAgc3RhdGljIGVsZW1lbnRJRChlbCl7IHJldHVybiBET00ucHJpdmF0ZShlbCwgSE9PS19JRCkgfVxuXG4gIGNvbnN0cnVjdG9yKHZpZXcsIGVsLCBjYWxsYmFja3Mpe1xuICAgIHRoaXMuZWwgPSBlbFxuICAgIHRoaXMuX19hdHRhY2hWaWV3KHZpZXcpXG4gICAgdGhpcy5fX2NhbGxiYWNrcyA9IGNhbGxiYWNrc1xuICAgIHRoaXMuX19saXN0ZW5lcnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLl9faXNEaXNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIERPTS5wdXRQcml2YXRlKHRoaXMuZWwsIEhPT0tfSUQsIHRoaXMuY29uc3RydWN0b3IubWFrZUlEKCkpXG4gICAgZm9yKGxldCBrZXkgaW4gdGhpcy5fX2NhbGxiYWNrcyl7IHRoaXNba2V5XSA9IHRoaXMuX19jYWxsYmFja3Nba2V5XSB9XG4gIH1cblxuICBfX2F0dGFjaFZpZXcodmlldyl7XG4gICAgaWYodmlldyl7XG4gICAgICB0aGlzLl9fdmlldyA9ICgpID0+IHZpZXdcbiAgICAgIHRoaXMubGl2ZVNvY2tldCA9IHZpZXcubGl2ZVNvY2tldFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fdmlldyA9ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBob29rIG5vdCB5ZXQgYXR0YWNoZWQgdG8gYSBsaXZlIHZpZXc6ICR7dGhpcy5lbC5vdXRlckhUTUx9YClcbiAgICAgIH1cbiAgICAgIHRoaXMubGl2ZVNvY2tldCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBfX21vdW50ZWQoKXsgdGhpcy5tb3VudGVkICYmIHRoaXMubW91bnRlZCgpIH1cbiAgX191cGRhdGVkKCl7IHRoaXMudXBkYXRlZCAmJiB0aGlzLnVwZGF0ZWQoKSB9XG4gIF9fYmVmb3JlVXBkYXRlKCl7IHRoaXMuYmVmb3JlVXBkYXRlICYmIHRoaXMuYmVmb3JlVXBkYXRlKCkgfVxuICBfX2Rlc3Ryb3llZCgpe1xuICAgIHRoaXMuZGVzdHJveWVkICYmIHRoaXMuZGVzdHJveWVkKClcbiAgICBET00uZGVsZXRlUHJpdmF0ZSh0aGlzLmVsLCBIT09LX0lEKSAvLyBodHRwczovL2dpdGh1Yi5jb20vcGhvZW5peGZyYW1ld29yay9waG9lbml4X2xpdmVfdmlldy9pc3N1ZXMvMzQ5NlxuICB9XG4gIF9fcmVjb25uZWN0ZWQoKXtcbiAgICBpZih0aGlzLl9faXNEaXNjb25uZWN0ZWQpe1xuICAgICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgIHRoaXMucmVjb25uZWN0ZWQgJiYgdGhpcy5yZWNvbm5lY3RlZCgpXG4gICAgfVxuICB9XG4gIF9fZGlzY29ubmVjdGVkKCl7XG4gICAgdGhpcy5fX2lzRGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgIHRoaXMuZGlzY29ubmVjdGVkICYmIHRoaXMuZGlzY29ubmVjdGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyB0aGUgaG9vayB0byBKUyBjb21tYW5kcy5cbiAgICpcbiAgICogQHBhcmFtIHtWaWV3SG9va30gaG9vayAtIFRoZSBWaWV3SG9vayBpbnN0YW5jZSB0byBiaW5kLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBtZXRob2RzIHRvIG1hbmlwdWxhdGUgdGhlIERPTSBhbmQgZXhlY3V0ZSBKYXZhU2NyaXB0LlxuICAgKi9cbiAganMoKXtcbiAgICBsZXQgaG9vayA9IHRoaXNcblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4ZWN1dGVzIGVuY29kZWQgSmF2YVNjcmlwdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgaG9vayBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGVkSlMgLSBUaGUgZW5jb2RlZCBKYXZhU2NyaXB0IHN0cmluZyB0byBleGVjdXRlLlxuICAgICAgICovXG4gICAgICBleGVjKGVuY29kZWRKUyl7XG4gICAgICAgIGhvb2suX192aWV3KCkubGl2ZVNvY2tldC5leGVjSlMoaG9vay5lbCwgZW5jb2RlZEpTLCBcImhvb2tcIilcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogU2hvd3MgYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIHNob3cuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZGlzcGxheV0gLSBUaGUgQ1NTIGRpc3BsYXkgdmFsdWUgdG8gc2V0LiBEZWZhdWx0cyBcImJsb2NrXCIuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHJhbnNpdGlvbl0gLSBUaGUgQ1NTIHRyYW5zaXRpb24gY2xhc3NlcyB0byBzZXQgd2hlbiBzaG93aW5nLlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLnRpbWVdIC0gVGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLiBEZWZhdWx0cyAyMDAuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmJsb2NraW5nXSAtIFRoZSBib29sZWFuIGZsYWcgdG8gYmxvY2sgdGhlIFVJIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAqICBEZWZhdWx0cyBgdHJ1ZWAuXG4gICAgICAgKi9cbiAgICAgIHNob3coZWwsIG9wdHMgPSB7fSl7XG4gICAgICAgIGxldCBvd25lciA9IGhvb2suX192aWV3KCkubGl2ZVNvY2tldC5vd25lcihlbClcbiAgICAgICAgSlMuc2hvdyhcImhvb2tcIiwgb3duZXIsIGVsLCBvcHRzLmRpc3BsYXksIG9wdHMudHJhbnNpdGlvbiwgb3B0cy50aW1lLCBvcHRzLmJsb2NraW5nKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBIaWRlcyBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gaGlkZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy50cmFuc2l0aW9uXSAtIFRoZSBDU1MgdHJhbnNpdGlvbiBjbGFzc2VzIHRvIHNldCB3aGVuIGhpZGluZy5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lXSAtIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy4gRGVmYXVsdHMgMjAwLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5ibG9ja2luZ10gLSBUaGUgYm9vbGVhbiBmbGFnIHRvIGJsb2NrIHRoZSBVSSBkdXJpbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgKiAgIERlZmF1bHRzIGB0cnVlYC5cbiAgICAgICAqL1xuICAgICAgaGlkZShlbCwgb3B0cyA9IHt9KXtcbiAgICAgICAgbGV0IG93bmVyID0gaG9vay5fX3ZpZXcoKS5saXZlU29ja2V0Lm93bmVyKGVsKVxuICAgICAgICBKUy5oaWRlKFwiaG9va1wiLCBvd25lciwgZWwsIG51bGwsIG9wdHMudHJhbnNpdGlvbiwgb3B0cy50aW1lLCBvcHRzLmJsb2NraW5nKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byB0b2dnbGUuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZGlzcGxheV0gLSBUaGUgQ1NTIGRpc3BsYXkgdmFsdWUgdG8gc2V0LiBEZWZhdWx0cyBcImJsb2NrXCIuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuaW5dIC0gVGhlIENTUyB0cmFuc2l0aW9uIGNsYXNzZXMgZm9yIHNob3dpbmcuXG4gICAgICAgKiAgIEFjY2VwdHMgZWl0aGVyIHRoZSBzdHJpbmcgb2YgY2xhc3NlcyB0byBhcHBseSB3aGVuIHRvZ2dsaW5nIGluLCBvclxuICAgICAgICogICBhIDMtdHVwbGUgY29udGFpbmluZyB0aGUgdHJhbnNpdGlvbiBjbGFzcywgdGhlIGNsYXNzIHRvIGFwcGx5XG4gICAgICAgKiAgIHRvIHN0YXJ0IHRoZSB0cmFuc2l0aW9uLCBhbmQgdGhlIGVuZGluZyB0cmFuc2l0aW9uIGNsYXNzLCBzdWNoIGFzOlxuICAgICAgICpcbiAgICAgICAqICAgICAgIFtcImVhc2Utb3V0IGR1cmF0aW9uLTMwMFwiLCBcIm9wYWNpdHktMFwiLCBcIm9wYWNpdHktMTAwXCJdXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dF0gLSBUaGUgQ1NTIHRyYW5zaXRpb24gY2xhc3NlcyBmb3IgaGlkaW5nLlxuICAgICAgICogICBBY2NlcHRzIGVpdGhlciBzdHJpbmcgb2YgY2xhc3NlcyB0byBhcHBseSB3aGVuIHRvZ2dsaW5nIG91dCwgb3JcbiAgICAgICAqICAgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHRyYW5zaXRpb24gY2xhc3MsIHRoZSBjbGFzcyB0byBhcHBseVxuICAgICAgICogICB0byBzdGFydCB0aGUgdHJhbnNpdGlvbiwgYW5kIHRoZSBlbmRpbmcgdHJhbnNpdGlvbiBjbGFzcywgc3VjaCBhczpcbiAgICAgICAqXG4gICAgICAgKiAgICAgICBbXCJlYXNlLW91dCBkdXJhdGlvbi0zMDBcIiwgXCJvcGFjaXR5LTEwMFwiLCBcIm9wYWNpdHktMFwiXVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lXSAtIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmJsb2NraW5nXSAtIFRoZSBib29sZWFuIGZsYWcgdG8gYmxvY2sgdGhlIFVJIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAqICAgRGVmYXVsdHMgYHRydWVgLlxuICAgICAgICovXG4gICAgICB0b2dnbGUoZWwsIG9wdHMgPSB7fSl7XG4gICAgICAgIGxldCBvd25lciA9IGhvb2suX192aWV3KCkubGl2ZVNvY2tldC5vd25lcihlbClcbiAgICAgICAgb3B0cy5pbiA9IEpTLnRyYW5zaXRpb25DbGFzc2VzKG9wdHMuaW4pXG4gICAgICAgIG9wdHMub3V0ID0gSlMudHJhbnNpdGlvbkNsYXNzZXMob3B0cy5vdXQpXG4gICAgICAgIEpTLnRvZ2dsZShcImhvb2tcIiwgb3duZXIsIGVsLCBvcHRzLmRpc3BsYXksIG9wdHMuaW4sIG9wdHMub3V0LCBvcHRzLnRpbWUsIG9wdHMuYmxvY2tpbmcpXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFkZHMgQ1NTIGNsYXNzZXMgdG8gYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIGFkZCBjbGFzc2VzIHRvLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG5hbWVzIC0gVGhlIGNsYXNzIG5hbWUocykgdG8gYWRkLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRyYW5zaXRpb25dIC0gVGhlIENTUyB0cmFuc2l0aW9uIHByb3BlcnR5IHRvIHNldC5cbiAgICAgICAqICAgQWNjZXB0cyBhIHN0cmluZyBvZiBjbGFzc2VzIHRvIGFwcGx5IHdoZW4gYWRkaW5nIGNsYXNzZXMgb3JcbiAgICAgICAqICAgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHRyYW5zaXRpb24gY2xhc3MsIHRoZSBjbGFzcyB0byBhcHBseVxuICAgICAgICogICB0byBzdGFydCB0aGUgdHJhbnNpdGlvbiwgYW5kIHRoZSBlbmRpbmcgdHJhbnNpdGlvbiBjbGFzcywgc3VjaCBhczpcbiAgICAgICAqXG4gICAgICAgKiAgICAgICBbXCJlYXNlLW91dCBkdXJhdGlvbi0zMDBcIiwgXCJvcGFjaXR5LTBcIiwgXCJvcGFjaXR5LTEwMFwiXVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lXSAtIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYmxvY2tpbmddIC0gVGhlIGJvb2xlYW4gZmxhZyB0byBibG9jayB0aGUgVUkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICogICBEZWZhdWx0cyBgdHJ1ZWAuXG4gICAgICAgKi9cbiAgICAgIGFkZENsYXNzKGVsLCBuYW1lcywgb3B0cyA9IHt9KXtcbiAgICAgICAgbmFtZXMgPSBBcnJheS5pc0FycmF5KG5hbWVzKSA/IG5hbWVzIDogbmFtZXMuc3BsaXQoXCIgXCIpXG4gICAgICAgIGxldCBvd25lciA9IGhvb2suX192aWV3KCkubGl2ZVNvY2tldC5vd25lcihlbClcbiAgICAgICAgSlMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBuYW1lcywgW10sIG9wdHMudHJhbnNpdGlvbiwgb3B0cy50aW1lLCBvd25lciwgb3B0cy5ibG9ja2luZylcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmVtb3ZlcyBDU1MgY2xhc3NlcyBmcm9tIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byByZW1vdmUgY2xhc3NlcyBmcm9tLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG5hbWVzIC0gVGhlIGNsYXNzIG5hbWUocykgdG8gcmVtb3ZlLlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnRyYW5zaXRpb25dIC0gVGhlIENTUyB0cmFuc2l0aW9uIGNsYXNzZXMgdG8gc2V0LlxuICAgICAgICogICBBY2NlcHRzIGEgc3RyaW5nIG9mIGNsYXNzZXMgdG8gYXBwbHkgd2hlbiByZW1vdmluZyBjbGFzc2VzIG9yXG4gICAgICAgKiAgIGEgMy10dXBsZSBjb250YWluaW5nIHRoZSB0cmFuc2l0aW9uIGNsYXNzLCB0aGUgY2xhc3MgdG8gYXBwbHlcbiAgICAgICAqICAgdG8gc3RhcnQgdGhlIHRyYW5zaXRpb24sIGFuZCB0aGUgZW5kaW5nIHRyYW5zaXRpb24gY2xhc3MsIHN1Y2ggYXM6XG4gICAgICAgKlxuICAgICAgICogICAgICAgW1wiZWFzZS1vdXQgZHVyYXRpb24tMzAwXCIsIFwib3BhY2l0eS0xMDBcIiwgXCJvcGFjaXR5LTBcIl1cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZV0gLSBUaGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmJsb2NraW5nXSAtIFRoZSBib29sZWFuIGZsYWcgdG8gYmxvY2sgdGhlIFVJIGR1cmluZyB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAqICAgRGVmYXVsdHMgYHRydWVgLlxuICAgICAgICovXG4gICAgICByZW1vdmVDbGFzcyhlbCwgbmFtZXMsIG9wdHMgPSB7fSl7XG4gICAgICAgIG9wdHMudHJhbnNpdGlvbiA9IEpTLnRyYW5zaXRpb25DbGFzc2VzKG9wdHMudHJhbnNpdGlvbilcbiAgICAgICAgbmFtZXMgPSBBcnJheS5pc0FycmF5KG5hbWVzKSA/IG5hbWVzIDogbmFtZXMuc3BsaXQoXCIgXCIpXG4gICAgICAgIGxldCBvd25lciA9IGhvb2suX192aWV3KCkubGl2ZVNvY2tldC5vd25lcihlbClcbiAgICAgICAgSlMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgbmFtZXMsIG9wdHMudHJhbnNpdGlvbiwgb3B0cy50aW1lLCBvd25lciwgb3B0cy5ibG9ja2luZylcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVG9nZ2xlcyBDU1MgY2xhc3NlcyBvbiBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gdG9nZ2xlIGNsYXNzZXMgb24uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gbmFtZXMgLSBUaGUgY2xhc3MgbmFtZShzKSB0byB0b2dnbGUuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMudHJhbnNpdGlvbl0gLSBUaGUgQ1NTIHRyYW5zaXRpb24gY2xhc3NlcyB0byBzZXQuXG4gICAgICAgKiAgIEFjY2VwdHMgYSBzdHJpbmcgb2YgY2xhc3NlcyB0byBhcHBseSB3aGVuIHRvZ2dsaW5nIGNsYXNzZXMgb3JcbiAgICAgICAqICAgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHRyYW5zaXRpb24gY2xhc3MsIHRoZSBjbGFzcyB0byBhcHBseVxuICAgICAgICogICB0byBzdGFydCB0aGUgdHJhbnNpdGlvbiwgYW5kIHRoZSBlbmRpbmcgdHJhbnNpdGlvbiBjbGFzcywgc3VjaCBhczpcbiAgICAgICAqXG4gICAgICAgKiAgICAgICBbXCJlYXNlLW91dCBkdXJhdGlvbi0zMDBcIiwgXCJvcGFjaXR5LTEwMFwiLCBcIm9wYWNpdHktMFwiXVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lXSAtIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYmxvY2tpbmddIC0gVGhlIGJvb2xlYW4gZmxhZyB0byBibG9jayB0aGUgVUkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICogICBEZWZhdWx0cyBgdHJ1ZWAuXG4gICAgICAgKi9cbiAgICAgIHRvZ2dsZUNsYXNzKGVsLCBuYW1lcywgb3B0cyA9IHt9KXtcbiAgICAgICAgb3B0cy50cmFuc2l0aW9uID0gSlMudHJhbnNpdGlvbkNsYXNzZXMob3B0cy50cmFuc2l0aW9uKVxuICAgICAgICBuYW1lcyA9IEFycmF5LmlzQXJyYXkobmFtZXMpID8gbmFtZXMgOiBuYW1lcy5zcGxpdChcIiBcIilcbiAgICAgICAgbGV0IG93bmVyID0gaG9vay5fX3ZpZXcoKS5saXZlU29ja2V0Lm93bmVyKGVsKVxuICAgICAgICBKUy50b2dnbGVDbGFzc2VzKGVsLCBuYW1lcywgb3B0cy50cmFuc2l0aW9uLCBvcHRzLnRpbWUsIG93bmVyLCBvcHRzLmJsb2NraW5nKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBcHBsaWVzIGEgQ1NTIHRyYW5zaXRpb24gdG8gYW4gZWxlbWVudC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCAtIFRoZSBlbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2l0aW9uIHRvLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRyYW5zaXRpb24gLSBUaGUgdHJhbnNpdGlvbiBjbGFzcyhlcykgdG8gYXBwbHkuXG4gICAgICAgKiAgIEFjY2VwdHMgYSBzdHJpbmcgb2YgY2xhc3NlcyB0byBhcHBseSB3aGVuIHRyYW5zaXRpb25pbmcgb3JcbiAgICAgICAqICAgYSAzLXR1cGxlIGNvbnRhaW5pbmcgdGhlIHRyYW5zaXRpb24gY2xhc3MsIHRoZSBjbGFzcyB0byBhcHBseVxuICAgICAgICogICB0byBzdGFydCB0aGUgdHJhbnNpdGlvbiwgYW5kIHRoZSBlbmRpbmcgdHJhbnNpdGlvbiBjbGFzcywgc3VjaCBhczpcbiAgICAgICAqXG4gICAgICAgKiAgICAgICBbXCJlYXNlLW91dCBkdXJhdGlvbi0zMDBcIiwgXCJvcGFjaXR5LTEwMFwiLCBcIm9wYWNpdHktMFwiXVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cz17fV0gLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lXSAtIFRoZSB0cmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYmxvY2tpbmddIC0gVGhlIGJvb2xlYW4gZmxhZyB0byBibG9jayB0aGUgVUkgZHVyaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICogICBEZWZhdWx0cyBgdHJ1ZWAuXG4gICAgICAgKi9cbiAgICAgIHRyYW5zaXRpb24oZWwsIHRyYW5zaXRpb24sIG9wdHMgPSB7fSl7XG4gICAgICAgIGxldCBvd25lciA9IGhvb2suX192aWV3KCkubGl2ZVNvY2tldC5vd25lcihlbClcbiAgICAgICAgSlMuYWRkT3JSZW1vdmVDbGFzc2VzKGVsLCBbXSwgW10sIEpTLnRyYW5zaXRpb25DbGFzc2VzKHRyYW5zaXRpb24pLCBvcHRzLnRpbWUsIG93bmVyLCBvcHRzLmJsb2NraW5nKVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhbiBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gc2V0IHRoZSBhdHRyaWJ1dGUgb24uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciAtIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBzZXQuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsIC0gVGhlIHZhbHVlIHRvIHNldCBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAqL1xuICAgICAgc2V0QXR0cmlidXRlKGVsLCBhdHRyLCB2YWwpeyBKUy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbW2F0dHIsIHZhbF1dLCBbXSkgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIGFuIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgLSBUaGUgZWxlbWVudCB0byByZW1vdmUgdGhlIGF0dHJpYnV0ZSBmcm9tLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSBUaGUgYXR0cmlidXRlIG5hbWUgdG8gcmVtb3ZlLlxuICAgICAgICovXG4gICAgICByZW1vdmVBdHRyaWJ1dGUoZWwsIGF0dHIpeyBKUy5zZXRPclJlbW92ZUF0dHJzKGVsLCBbXSwgW2F0dHJdKSB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRvZ2dsZXMgYW4gYXR0cmlidXRlIG9uIGFuIGVsZW1lbnQgYmV0d2VlbiB0d28gdmFsdWVzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gdG9nZ2xlIHRoZSBhdHRyaWJ1dGUgb24uXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciAtIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byB0b2dnbGUuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsMSAtIFRoZSBmaXJzdCB2YWx1ZSB0byB0b2dnbGUgYmV0d2Vlbi5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWwyIC0gVGhlIHNlY29uZCB2YWx1ZSB0byB0b2dnbGUgYmV0d2Vlbi5cbiAgICAgICAqL1xuICAgICAgdG9nZ2xlQXR0cmlidXRlKGVsLCBhdHRyLCB2YWwxLCB2YWwyKXsgSlMudG9nZ2xlQXR0cihlbCwgYXR0ciwgdmFsMSwgdmFsMikgfSxcbiAgICB9XG4gIH1cblxuICBwdXNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSwgb25SZXBseSl7XG4gICAgaWYob25SZXBseSA9PT0gdW5kZWZpbmVkKXtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fX3ZpZXcoKS5wdXNoSG9va0V2ZW50KHRoaXMuZWwsIG51bGwsIGV2ZW50LCBwYXlsb2FkLCAocmVwbHksIF9yZWYpID0+IHJlc29sdmUocmVwbHkpKVxuICAgICAgICAgIGlmKHJlZiA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInVuYWJsZSB0byBwdXNoIGhvb2sgZXZlbnQuIExpdmVWaWV3IG5vdCBjb25uZWN0ZWRcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcil7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcoKS5wdXNoSG9va0V2ZW50KHRoaXMuZWwsIG51bGwsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICB9XG5cbiAgcHVzaEV2ZW50VG8ocGh4VGFyZ2V0LCBldmVudCwgcGF5bG9hZCA9IHt9LCBvblJlcGx5KXtcbiAgICBpZihvblJlcGx5ID09PSB1bmRlZmluZWQpe1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLl9fdmlldygpLndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSB2aWV3LnB1c2hIb29rRXZlbnQodGhpcy5lbCwgdGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgKHJlcGx5LCBfcmVmKSA9PiByZXNvbHZlKHJlcGx5KSlcbiAgICAgICAgICAgIGlmKHJlZiA9PT0gZmFsc2Upe1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnJvcil7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX3ZpZXcoKS53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgcmV0dXJuIHZpZXcucHVzaEhvb2tFdmVudCh0aGlzLmVsLCB0YXJnZXRDdHgsIGV2ZW50LCBwYXlsb2FkLCBvblJlcGx5KVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVFdmVudChldmVudCwgY2FsbGJhY2spe1xuICAgIGxldCBjYWxsYmFja1JlZiA9IChjdXN0b21FdmVudCwgYnlwYXNzKSA9PiBieXBhc3MgPyBldmVudCA6IGNhbGxiYWNrKGN1c3RvbUV2ZW50LmRldGFpbClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5hZGQoY2FsbGJhY2tSZWYpXG4gICAgcmV0dXJuIGNhbGxiYWNrUmVmXG4gIH1cblxuICByZW1vdmVIYW5kbGVFdmVudChjYWxsYmFja1JlZil7XG4gICAgbGV0IGV2ZW50ID0gY2FsbGJhY2tSZWYobnVsbCwgdHJ1ZSlcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihgcGh4OiR7ZXZlbnR9YCwgY2FsbGJhY2tSZWYpXG4gICAgdGhpcy5fX2xpc3RlbmVycy5kZWxldGUoY2FsbGJhY2tSZWYpXG4gIH1cblxuICB1cGxvYWQobmFtZSwgZmlsZXMpe1xuICAgIHJldHVybiB0aGlzLl9fdmlldygpLmRpc3BhdGNoVXBsb2FkcyhudWxsLCBuYW1lLCBmaWxlcylcbiAgfVxuXG4gIHVwbG9hZFRvKHBoeFRhcmdldCwgbmFtZSwgZmlsZXMpe1xuICAgIHJldHVybiB0aGlzLl9fdmlldygpLndpdGhpblRhcmdldHMocGh4VGFyZ2V0LCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICB2aWV3LmRpc3BhdGNoVXBsb2Fkcyh0YXJnZXRDdHgsIG5hbWUsIGZpbGVzKVxuICAgIH0pXG4gIH1cblxuICBfX2NsZWFudXBfXygpe1xuICAgIHRoaXMuX19saXN0ZW5lcnMuZm9yRWFjaChjYWxsYmFja1JlZiA9PiB0aGlzLnJlbW92ZUhhbmRsZUV2ZW50KGNhbGxiYWNrUmVmKSlcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIEJFRk9SRV9VTkxPQURfTE9BREVSX1RJTUVPVVQsXG4gIENIRUNLQUJMRV9JTlBVVFMsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIFBIWF9BVVRPX1JFQ09WRVIsXG4gIFBIWF9DT01QT05FTlQsXG4gIFBIWF9DT05ORUNURURfQ0xBU1MsXG4gIFBIWF9ESVNBQkxFX1dJVEgsXG4gIFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSxcbiAgUEhYX0RJU0FCTEVELFxuICBQSFhfTE9BRElOR19DTEFTUyxcbiAgUEhYX0VSUk9SX0NMQVNTLFxuICBQSFhfQ0xJRU5UX0VSUk9SX0NMQVNTLFxuICBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTLFxuICBQSFhfSEFTX0ZPQ1VTRUQsXG4gIFBIWF9IQVNfU1VCTUlUVEVELFxuICBQSFhfSE9PSyxcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1BST0dSRVNTLFxuICBQSFhfUkVBRE9OTFksXG4gIFBIWF9SRUZfTE9BRElORyxcbiAgUEhYX1JFRl9TUkMsXG4gIFBIWF9SRUZfTE9DSyxcbiAgUEhYX1JPT1RfSUQsXG4gIFBIWF9TRVNTSU9OLFxuICBQSFhfU1RBVElDLFxuICBQSFhfVFJBQ0tfU1RBVElDLFxuICBQSFhfVFJBQ0tfVVBMT0FEUyxcbiAgUEhYX1VQREFURSxcbiAgUEhYX1VQTE9BRF9SRUYsXG4gIFBIWF9WSUVXX1NFTEVDVE9SLFxuICBQSFhfTUFJTixcbiAgUEhYX01PVU5URUQsXG4gIFBVU0hfVElNRU9VVCxcbiAgUEhYX1ZJRVdQT1JUX1RPUCxcbiAgUEhYX1ZJRVdQT1JUX0JPVFRPTSxcbiAgTUFYX0NISUxEX0pPSU5fQVRURU1QVFNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBpc0VtcHR5LFxuICBpc0VxdWFsT2JqLFxuICBsb2dFcnJvcixcbiAgbWF5YmUsXG4gIGlzQ2lkLFxufSBmcm9tIFwiLi91dGlsc1wiXG5cbmltcG9ydCBCcm93c2VyIGZyb20gXCIuL2Jyb3dzZXJcIlxuaW1wb3J0IERPTSBmcm9tIFwiLi9kb21cIlxuaW1wb3J0IEVsZW1lbnRSZWYgZnJvbSBcIi4vZWxlbWVudF9yZWZcIlxuaW1wb3J0IERPTVBhdGNoIGZyb20gXCIuL2RvbV9wYXRjaFwiXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuaW1wb3J0IFJlbmRlcmVkIGZyb20gXCIuL3JlbmRlcmVkXCJcbmltcG9ydCBWaWV3SG9vayBmcm9tIFwiLi92aWV3X2hvb2tcIlxuaW1wb3J0IEpTIGZyb20gXCIuL2pzXCJcblxuZXhwb3J0IGxldCBwcmVwZW5kRm9ybURhdGFLZXkgPSAoa2V5LCBwcmVmaXgpID0+IHtcbiAgbGV0IGlzQXJyYXkgPSBrZXkuZW5kc1dpdGgoXCJbXVwiKVxuICAvLyBSZW1vdmUgdGhlIFwiW11cIiBpZiBpdCdzIGFuIGFycmF5XG4gIGxldCBiYXNlS2V5ID0gaXNBcnJheSA/IGtleS5zbGljZSgwLCAtMikgOiBrZXlcbiAgLy8gUmVwbGFjZSBsYXN0IG9jY3VycmVuY2Ugb2Yga2V5IGJlZm9yZSBhIGNsb3NpbmcgYnJhY2tldCBvciB0aGUgZW5kIHdpdGgga2V5IHBsdXMgc3VmZml4XG4gIGJhc2VLZXkgPSBiYXNlS2V5LnJlcGxhY2UoLyhbXlxcW1xcXV0rKShcXF0/JCkvLCBgJHtwcmVmaXh9JDEkMmApXG4gIC8vIEFkZCBiYWNrIHRoZSBcIltdXCIgaWYgaXQgd2FzIGFuIGFycmF5XG4gIGlmKGlzQXJyYXkpeyBiYXNlS2V5ICs9IFwiW11cIiB9XG4gIHJldHVybiBiYXNlS2V5XG59XG5cbmxldCBzZXJpYWxpemVGb3JtID0gKGZvcm0sIG9wdHMsIG9ubHlOYW1lcyA9IFtdKSA9PiB7XG4gIGNvbnN0IHtzdWJtaXR0ZXJ9ID0gb3B0c1xuXG4gIC8vIFdlIG11c3QgaW5qZWN0IHRoZSBzdWJtaXR0ZXIgaW4gdGhlIG9yZGVyIHRoYXQgaXQgZXhpc3RzIGluIHRoZSBET01cbiAgLy8gcmVsYXRpdmUgdG8gb3RoZXIgaW5wdXRzLiBGb3IgZXhhbXBsZSwgZm9yIGNoZWNrYm94IGdyb3VwcywgdGhlIG9yZGVyIG11c3QgYmUgbWFpbnRhaW5lZC5cbiAgbGV0IGluamVjdGVkRWxlbWVudFxuICBpZihzdWJtaXR0ZXIgJiYgc3VibWl0dGVyLm5hbWUpe1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpXG4gICAgaW5wdXQudHlwZSA9IFwiaGlkZGVuXCJcbiAgICAvLyBzZXQgdGhlIGZvcm0gYXR0cmlidXRlIGlmIHRoZSBzdWJtaXR0ZXIgaGFzIG9uZTtcbiAgICAvLyB0aGlzIGNhbiBoYXBwZW4gaWYgdGhlIGVsZW1lbnQgaXMgb3V0c2lkZSB0aGUgYWN0dWFsIGZvcm0gZWxlbWVudFxuICAgIGNvbnN0IGZvcm1JZCA9IHN1Ym1pdHRlci5nZXRBdHRyaWJ1dGUoXCJmb3JtXCIpXG4gICAgaWYoZm9ybUlkKXtcbiAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcImZvcm1cIiwgZm9ybUlkKVxuICAgIH1cbiAgICBpbnB1dC5uYW1lID0gc3VibWl0dGVyLm5hbWVcbiAgICBpbnB1dC52YWx1ZSA9IHN1Ym1pdHRlci52YWx1ZVxuICAgIHN1Ym1pdHRlci5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShpbnB1dCwgc3VibWl0dGVyKVxuICAgIGluamVjdGVkRWxlbWVudCA9IGlucHV0XG4gIH1cblxuICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YShmb3JtKVxuICBjb25zdCB0b1JlbW92ZSA9IFtdXG5cbiAgZm9ybURhdGEuZm9yRWFjaCgodmFsLCBrZXksIF9pbmRleCkgPT4ge1xuICAgIGlmKHZhbCBpbnN0YW5jZW9mIEZpbGUpeyB0b1JlbW92ZS5wdXNoKGtleSkgfVxuICB9KVxuXG4gIC8vIENsZWFudXAgYWZ0ZXIgYnVpbGRpbmcgZmlsZURhdGFcbiAgdG9SZW1vdmUuZm9yRWFjaChrZXkgPT4gZm9ybURhdGEuZGVsZXRlKGtleSkpXG5cbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpXG5cbiAgY29uc3Qge2lucHV0c1VudXNlZCwgb25seUhpZGRlbklucHV0c30gPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpLnJlZHVjZSgoYWNjLCBpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHtpbnB1dHNVbnVzZWQsIG9ubHlIaWRkZW5JbnB1dHN9ID0gYWNjXG4gICAgY29uc3Qga2V5ID0gaW5wdXQubmFtZVxuICAgIGlmKCFrZXkpeyByZXR1cm4gYWNjIH1cblxuICAgIGlmKGlucHV0c1VudXNlZFtrZXldID09PSB1bmRlZmluZWQpeyBpbnB1dHNVbnVzZWRba2V5XSA9IHRydWUgfVxuICAgIGlmKG9ubHlIaWRkZW5JbnB1dHNba2V5XSA9PT0gdW5kZWZpbmVkKXsgb25seUhpZGRlbklucHV0c1trZXldID0gdHJ1ZSB9XG5cbiAgICBjb25zdCBpc1VzZWQgPSBET00ucHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VEKSB8fCBET00ucHJpdmF0ZShpbnB1dCwgUEhYX0hBU19TVUJNSVRURUQpXG4gICAgY29uc3QgaXNIaWRkZW4gPSBpbnB1dC50eXBlID09PSBcImhpZGRlblwiXG4gICAgaW5wdXRzVW51c2VkW2tleV0gPSBpbnB1dHNVbnVzZWRba2V5XSAmJiAhaXNVc2VkXG4gICAgb25seUhpZGRlbklucHV0c1trZXldID0gb25seUhpZGRlbklucHV0c1trZXldICYmIGlzSGlkZGVuXG5cbiAgICByZXR1cm4gYWNjXG4gIH0sIHtpbnB1dHNVbnVzZWQ6IHt9LCBvbmx5SGlkZGVuSW5wdXRzOiB7fX0pXG5cbiAgZm9yKGxldCBba2V5LCB2YWxdIG9mIGZvcm1EYXRhLmVudHJpZXMoKSl7XG4gICAgaWYob25seU5hbWVzLmxlbmd0aCA9PT0gMCB8fCBvbmx5TmFtZXMuaW5kZXhPZihrZXkpID49IDApe1xuICAgICAgbGV0IGlzVW51c2VkID0gaW5wdXRzVW51c2VkW2tleV1cbiAgICAgIGxldCBoaWRkZW4gPSBvbmx5SGlkZGVuSW5wdXRzW2tleV1cbiAgICAgIGlmKGlzVW51c2VkICYmICEoc3VibWl0dGVyICYmIHN1Ym1pdHRlci5uYW1lID09IGtleSkgJiYgIWhpZGRlbil7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQocHJlcGVuZEZvcm1EYXRhS2V5KGtleSwgXCJfdW51c2VkX1wiKSwgXCJcIilcbiAgICAgIH1cbiAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCB2YWwpXG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIHRoZSBpbmplY3RlZCBlbGVtZW50IGFnYWluXG4gIC8vIChpdCB3b3VsZCBiZSByZW1vdmVkIGJ5IHRoZSBuZXh0IGRvbSBwYXRjaCBhbnl3YXksIGJ1dCB0aGlzIGlzIGNsZWFuZXIpXG4gIGlmKHN1Ym1pdHRlciAmJiBpbmplY3RlZEVsZW1lbnQpe1xuICAgIHN1Ym1pdHRlci5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGluamVjdGVkRWxlbWVudClcbiAgfVxuXG4gIHJldHVybiBwYXJhbXMudG9TdHJpbmcoKVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWV3IHtcbiAgc3RhdGljIGNsb3Nlc3RWaWV3KGVsKXtcbiAgICBsZXQgbGl2ZVZpZXdFbCA9IGVsLmNsb3Nlc3QoUEhYX1ZJRVdfU0VMRUNUT1IpXG4gICAgcmV0dXJuIGxpdmVWaWV3RWwgPyBET00ucHJpdmF0ZShsaXZlVmlld0VsLCBcInZpZXdcIikgOiBudWxsXG4gIH1cblxuICBjb25zdHJ1Y3RvcihlbCwgbGl2ZVNvY2tldCwgcGFyZW50VmlldywgZmxhc2gsIGxpdmVSZWZlcmVyKXtcbiAgICB0aGlzLmlzRGVhZCA9IGZhbHNlXG4gICAgdGhpcy5saXZlU29ja2V0ID0gbGl2ZVNvY2tldFxuICAgIHRoaXMuZmxhc2ggPSBmbGFzaFxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Vmlld1xuICAgIHRoaXMucm9vdCA9IHBhcmVudFZpZXcgPyBwYXJlbnRWaWV3LnJvb3QgOiB0aGlzXG4gICAgdGhpcy5lbCA9IGVsXG4gICAgRE9NLnB1dFByaXZhdGUodGhpcy5lbCwgXCJ2aWV3XCIsIHRoaXMpXG4gICAgdGhpcy5pZCA9IHRoaXMuZWwuaWRcbiAgICB0aGlzLnJlZiA9IDBcbiAgICB0aGlzLmxhc3RBY2tSZWYgPSBudWxsXG4gICAgdGhpcy5jaGlsZEpvaW5zID0gMFxuICAgIHRoaXMubG9hZGVyVGltZXIgPSBudWxsXG4gICAgdGhpcy5kaXNjb25uZWN0ZWRUaW1lciA9IG51bGxcbiAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdXG4gICAgdGhpcy5wZW5kaW5nRm9ybXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLnJlZGlyZWN0ID0gZmFsc2VcbiAgICB0aGlzLmhyZWYgPSBudWxsXG4gICAgdGhpcy5qb2luQ291bnQgPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmpvaW5Db3VudCAtIDEgOiAwXG4gICAgdGhpcy5qb2luQXR0ZW1wdHMgPSAwXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IHRydWVcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlXG4gICAgdGhpcy5qb2luQ2FsbGJhY2sgPSBmdW5jdGlvbihvbkRvbmUpeyBvbkRvbmUgJiYgb25Eb25lKCkgfVxuICAgIHRoaXMuc3RvcENhbGxiYWNrID0gZnVuY3Rpb24oKXsgfVxuICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSB0aGlzLnBhcmVudCA/IG51bGwgOiBbXVxuICAgIHRoaXMudmlld0hvb2tzID0ge31cbiAgICB0aGlzLmZvcm1TdWJtaXRzID0gW11cbiAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5wYXJlbnQgPyBudWxsIDoge31cbiAgICB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF0gPSB7fVxuICAgIHRoaXMuZm9ybXNGb3JSZWNvdmVyeSA9IHt9XG4gICAgdGhpcy5jaGFubmVsID0gdGhpcy5saXZlU29ja2V0LmNoYW5uZWwoYGx2OiR7dGhpcy5pZH1gLCAoKSA9PiB7XG4gICAgICBsZXQgdXJsID0gdGhpcy5ocmVmICYmIHRoaXMuZXhwYW5kVVJMKHRoaXMuaHJlZilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlZGlyZWN0OiB0aGlzLnJlZGlyZWN0ID8gdXJsIDogdW5kZWZpbmVkLFxuICAgICAgICB1cmw6IHRoaXMucmVkaXJlY3QgPyB1bmRlZmluZWQgOiB1cmwgfHwgdW5kZWZpbmVkLFxuICAgICAgICBwYXJhbXM6IHRoaXMuY29ubmVjdFBhcmFtcyhsaXZlUmVmZXJlciksXG4gICAgICAgIHNlc3Npb246IHRoaXMuZ2V0U2Vzc2lvbigpLFxuICAgICAgICBzdGF0aWM6IHRoaXMuZ2V0U3RhdGljKCksXG4gICAgICAgIGZsYXNoOiB0aGlzLmZsYXNoLFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzZXRIcmVmKGhyZWYpeyB0aGlzLmhyZWYgPSBocmVmIH1cblxuICBzZXRSZWRpcmVjdChocmVmKXtcbiAgICB0aGlzLnJlZGlyZWN0ID0gdHJ1ZVxuICAgIHRoaXMuaHJlZiA9IGhyZWZcbiAgfVxuXG4gIGlzTWFpbigpeyByZXR1cm4gdGhpcy5lbC5oYXNBdHRyaWJ1dGUoUEhYX01BSU4pIH1cblxuICBjb25uZWN0UGFyYW1zKGxpdmVSZWZlcmVyKXtcbiAgICBsZXQgcGFyYW1zID0gdGhpcy5saXZlU29ja2V0LnBhcmFtcyh0aGlzLmVsKVxuICAgIGxldCBtYW5pZmVzdCA9XG4gICAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9UUkFDS19TVEFUSUMpfV1gKVxuICAgICAgICAubWFwKG5vZGUgPT4gbm9kZS5zcmMgfHwgbm9kZS5ocmVmKS5maWx0ZXIodXJsID0+IHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIilcblxuICAgIGlmKG1hbmlmZXN0Lmxlbmd0aCA+IDApeyBwYXJhbXNbXCJfdHJhY2tfc3RhdGljXCJdID0gbWFuaWZlc3QgfVxuICAgIHBhcmFtc1tcIl9tb3VudHNcIl0gPSB0aGlzLmpvaW5Db3VudFxuICAgIHBhcmFtc1tcIl9tb3VudF9hdHRlbXB0c1wiXSA9IHRoaXMuam9pbkF0dGVtcHRzXG4gICAgcGFyYW1zW1wiX2xpdmVfcmVmZXJlclwiXSA9IGxpdmVSZWZlcmVyXG4gICAgdGhpcy5qb2luQXR0ZW1wdHMrK1xuXG4gICAgcmV0dXJuIHBhcmFtc1xuICB9XG5cbiAgaXNDb25uZWN0ZWQoKXsgcmV0dXJuIHRoaXMuY2hhbm5lbC5jYW5QdXNoKCkgfVxuXG4gIGdldFNlc3Npb24oKXsgcmV0dXJuIHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TRVNTSU9OKSB9XG5cbiAgZ2V0U3RhdGljKCl7XG4gICAgbGV0IHZhbCA9IHRoaXMuZWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpXG4gICAgcmV0dXJuIHZhbCA9PT0gXCJcIiA/IG51bGwgOiB2YWxcbiAgfVxuXG4gIGRlc3Ryb3koY2FsbGJhY2sgPSBmdW5jdGlvbiAoKXsgfSl7XG4gICAgdGhpcy5kZXN0cm95QWxsQ2hpbGRyZW4oKVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgIGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5pZF1cbiAgICBpZih0aGlzLnBhcmVudCl7IGRlbGV0ZSB0aGlzLnJvb3QuY2hpbGRyZW5bdGhpcy5wYXJlbnQuaWRdW3RoaXMuaWRdIH1cbiAgICBjbGVhclRpbWVvdXQodGhpcy5sb2FkZXJUaW1lcilcbiAgICBsZXQgb25GaW5pc2hlZCA9ICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3Mpe1xuICAgICAgICB0aGlzLmRlc3Ryb3lIb29rKHRoaXMudmlld0hvb2tzW2lkXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBET00ubWFya1BoeENoaWxkRGVzdHJveWVkKHRoaXMuZWwpXG5cbiAgICB0aGlzLmxvZyhcImRlc3Ryb3llZFwiLCAoKSA9PiBbXCJ0aGUgY2hpbGQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXJlbnRcIl0pXG4gICAgdGhpcy5jaGFubmVsLmxlYXZlKClcbiAgICAgIC5yZWNlaXZlKFwib2tcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgb25GaW5pc2hlZClcbiAgICAgIC5yZWNlaXZlKFwidGltZW91dFwiLCBvbkZpbmlzaGVkKVxuICB9XG5cbiAgc2V0Q29udGFpbmVyQ2xhc3NlcyguLi5jbGFzc2VzKXtcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICBQSFhfQ09OTkVDVEVEX0NMQVNTLFxuICAgICAgUEhYX0xPQURJTkdfQ0xBU1MsXG4gICAgICBQSFhfRVJST1JfQ0xBU1MsXG4gICAgICBQSFhfQ0xJRU5UX0VSUk9SX0NMQVNTLFxuICAgICAgUEhYX1NFUlZFUl9FUlJPUl9DTEFTU1xuICAgIClcbiAgICB0aGlzLmVsLmNsYXNzTGlzdC5hZGQoLi4uY2xhc3NlcylcbiAgfVxuXG4gIHNob3dMb2FkZXIodGltZW91dCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgaWYodGltZW91dCl7XG4gICAgICB0aGlzLmxvYWRlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnNob3dMb2FkZXIoKSwgdGltZW91dClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKGxldCBpZCBpbiB0aGlzLnZpZXdIb29rcyl7IHRoaXMudmlld0hvb2tzW2lkXS5fX2Rpc2Nvbm5lY3RlZCgpIH1cbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyQ2xhc3NlcyhQSFhfTE9BRElOR19DTEFTUylcbiAgICB9XG4gIH1cblxuICBleGVjQWxsKGJpbmRpbmcpe1xuICAgIERPTS5hbGwodGhpcy5lbCwgYFske2JpbmRpbmd9XWAsIGVsID0+IHRoaXMubGl2ZVNvY2tldC5leGVjSlMoZWwsIGVsLmdldEF0dHJpYnV0ZShiaW5kaW5nKSkpXG4gIH1cblxuICBoaWRlTG9hZGVyKCl7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMubG9hZGVyVGltZXIpXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZGlzY29ubmVjdGVkVGltZXIpXG4gICAgdGhpcy5zZXRDb250YWluZXJDbGFzc2VzKFBIWF9DT05ORUNURURfQ0xBU1MpXG4gICAgdGhpcy5leGVjQWxsKHRoaXMuYmluZGluZyhcImNvbm5lY3RlZFwiKSlcbiAgfVxuXG4gIHRyaWdnZXJSZWNvbm5lY3RlZCgpe1xuICAgIGZvcihsZXQgaWQgaW4gdGhpcy52aWV3SG9va3MpeyB0aGlzLnZpZXdIb29rc1tpZF0uX19yZWNvbm5lY3RlZCgpIH1cbiAgfVxuXG4gIGxvZyhraW5kLCBtc2dDYWxsYmFjayl7XG4gICAgdGhpcy5saXZlU29ja2V0LmxvZyh0aGlzLCBraW5kLCBtc2dDYWxsYmFjaylcbiAgfVxuXG4gIHRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lID0gZnVuY3Rpb24oKXt9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQudHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH1cblxuICAvLyBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgdmlldyBhbmQgdGFyZ2V0IGVsZW1lbnQgZm9yIHRoZSBnaXZlbiBwaHhUYXJnZXRcbiAgLy8gdGFyZ2V0cyBjYW4gYmU6XG4gIC8vICAqIGFuIGVsZW1lbnQgaXRzZWxmLCB0aGVuIGl0IGlzIHNpbXBseSBwYXNzZWQgdG8gbGl2ZVNvY2tldC5vd25lcjtcbiAgLy8gICogYSBDSUQgKENvbXBvbmVudCBJRCksIHRoZW4gd2UgZmlyc3Qgc2VhcmNoIHRoZSBjb21wb25lbnQncyBlbGVtZW50IGluIHRoZSBET01cbiAgLy8gICogYSBzZWxlY3RvciwgdGhlbiB3ZSBzZWFyY2ggdGhlIHNlbGVjdG9yIGluIHRoZSBET00gYW5kIGNhbGwgdGhlIGNhbGxiYWNrXG4gIC8vICAgIGZvciBlYWNoIGVsZW1lbnQgZm91bmQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBvd25lciB2aWV3XG4gIHdpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBjYWxsYmFjaywgZG9tID0gZG9jdW1lbnQsIHZpZXdFbCl7XG4gICAgLy8gaW4gdGhlIGZvcm0gcmVjb3ZlcnkgY2FzZSB3ZSBzZWFyY2ggaW4gYSB0ZW1wbGF0ZSBmcmFnbWVudCBpbnN0ZWFkIG9mXG4gICAgLy8gdGhlIHJlYWwgZG9tLCB0aGVyZWZvcmUgd2Ugb3B0aW9uYWxseSBwYXNzIGRvbSBhbmQgdmlld0VsXG5cbiAgICBpZihwaHhUYXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCBwaHhUYXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50KXtcbiAgICAgIHJldHVybiB0aGlzLmxpdmVTb2NrZXQub3duZXIocGh4VGFyZ2V0LCB2aWV3ID0+IGNhbGxiYWNrKHZpZXcsIHBoeFRhcmdldCkpXG4gICAgfVxuXG4gICAgaWYoaXNDaWQocGh4VGFyZ2V0KSl7XG4gICAgICBsZXQgdGFyZ2V0cyA9IERPTS5maW5kQ29tcG9uZW50Tm9kZUxpc3Qodmlld0VsIHx8IHRoaXMuZWwsIHBoeFRhcmdldClcbiAgICAgIGlmKHRhcmdldHMubGVuZ3RoID09PSAwKXtcbiAgICAgICAgbG9nRXJyb3IoYG5vIGNvbXBvbmVudCBmb3VuZCBtYXRjaGluZyBwaHgtdGFyZ2V0IG9mICR7cGh4VGFyZ2V0fWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayh0aGlzLCBwYXJzZUludChwaHhUYXJnZXQpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdGFyZ2V0cyA9IEFycmF5LmZyb20oZG9tLnF1ZXJ5U2VsZWN0b3JBbGwocGh4VGFyZ2V0KSlcbiAgICAgIGlmKHRhcmdldHMubGVuZ3RoID09PSAwKXsgbG9nRXJyb3IoYG5vdGhpbmcgZm91bmQgbWF0Y2hpbmcgdGhlIHBoeC10YXJnZXQgc2VsZWN0b3IgXCIke3BoeFRhcmdldH1cImApIH1cbiAgICAgIHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4gdGhpcy5saXZlU29ja2V0Lm93bmVyKHRhcmdldCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCB0YXJnZXQpKSlcbiAgICB9XG4gIH1cblxuICBhcHBseURpZmYodHlwZSwgcmF3RGlmZiwgY2FsbGJhY2spe1xuICAgIHRoaXMubG9nKHR5cGUsICgpID0+IFtcIlwiLCBjbG9uZShyYXdEaWZmKV0pXG4gICAgbGV0IHtkaWZmLCByZXBseSwgZXZlbnRzLCB0aXRsZX0gPSBSZW5kZXJlZC5leHRyYWN0KHJhd0RpZmYpXG4gICAgY2FsbGJhY2soe2RpZmYsIHJlcGx5LCBldmVudHN9KVxuICAgIGlmKHR5cGVvZiB0aXRsZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09IFwibW91bnRcIil7IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gRE9NLnB1dFRpdGxlKHRpdGxlKSkgfVxuICB9XG5cbiAgb25Kb2luKHJlc3Ape1xuICAgIGxldCB7cmVuZGVyZWQsIGNvbnRhaW5lciwgbGl2ZXZpZXdfdmVyc2lvbn0gPSByZXNwXG4gICAgaWYoY29udGFpbmVyKXtcbiAgICAgIGxldCBbdGFnLCBhdHRyc10gPSBjb250YWluZXJcbiAgICAgIHRoaXMuZWwgPSBET00ucmVwbGFjZVJvb3RDb250YWluZXIodGhpcy5lbCwgdGFnLCBhdHRycylcbiAgICB9XG4gICAgdGhpcy5jaGlsZEpvaW5zID0gMFxuICAgIHRoaXMuam9pblBlbmRpbmcgPSB0cnVlXG4gICAgdGhpcy5mbGFzaCA9IG51bGxcbiAgICBpZih0aGlzLnJvb3QgPT09IHRoaXMpe1xuICAgICAgdGhpcy5mb3Jtc0ZvclJlY292ZXJ5ID0gdGhpcy5nZXRGb3Jtc0ZvclJlY292ZXJ5KClcbiAgICB9XG4gICAgaWYodGhpcy5pc01haW4oKSAmJiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSA9PT0gbnVsbCl7XG4gICAgICAvLyBzZXQgaW5pdGlhbCBoaXN0b3J5IGVudHJ5IGlmIHRoaXMgaXMgdGhlIGZpcnN0IHBhZ2UgbG9hZCAobm8gaGlzdG9yeSlcbiAgICAgIEJyb3dzZXIucHVzaFN0YXRlKFwicmVwbGFjZVwiLCB7XG4gICAgICAgIHR5cGU6IFwicGF0Y2hcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLmxpdmVTb2NrZXQuY3VycmVudEhpc3RvcnlQb3NpdGlvblxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZihsaXZldmlld192ZXJzaW9uICE9PSB0aGlzLmxpdmVTb2NrZXQudmVyc2lvbigpKXtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYExpdmVWaWV3IGFzc2V0IHZlcnNpb24gbWlzbWF0Y2guIEphdmFTY3JpcHQgdmVyc2lvbiAke3RoaXMubGl2ZVNvY2tldC52ZXJzaW9uKCl9IHZzLiBzZXJ2ZXIgJHtsaXZldmlld192ZXJzaW9ufS4gVG8gYXZvaWQgaXNzdWVzLCBwbGVhc2UgZW5zdXJlIHRoYXQgeW91ciBhc3NldHMgdXNlIHRoZSBzYW1lIHZlcnNpb24gYXMgdGhlIHNlcnZlci5gKVxuICAgIH1cblxuICAgIEJyb3dzZXIuZHJvcExvY2FsKHRoaXMubGl2ZVNvY2tldC5sb2NhbFN0b3JhZ2UsIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwgQ09OU0VDVVRJVkVfUkVMT0FEUylcbiAgICB0aGlzLmFwcGx5RGlmZihcIm1vdW50XCIsIHJlbmRlcmVkLCAoe2RpZmYsIGV2ZW50c30pID0+IHtcbiAgICAgIHRoaXMucmVuZGVyZWQgPSBuZXcgUmVuZGVyZWQodGhpcy5pZCwgZGlmZilcbiAgICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlbmRlckNvbnRhaW5lcihudWxsLCBcImpvaW5cIilcbiAgICAgIHRoaXMuZHJvcFBlbmRpbmdSZWZzKClcbiAgICAgIHRoaXMuam9pbkNvdW50KytcbiAgICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMFxuXG4gICAgICB0aGlzLm1heWJlUmVjb3ZlckZvcm1zKGh0bWwsICgpID0+IHtcbiAgICAgICAgdGhpcy5vbkpvaW5Db21wbGV0ZShyZXNwLCBodG1sLCBzdHJlYW1zLCBldmVudHMpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBkcm9wUGVuZGluZ1JlZnMoKXtcbiAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLnJlZlNyYygpfVwiXWAsIGVsID0+IHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShQSFhfUkVGX0xPQURJTkcpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9TUkMpXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoUEhYX1JFRl9MT0NLKVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW5Db21wbGV0ZSh7bGl2ZV9wYXRjaH0sIGh0bWwsIHN0cmVhbXMsIGV2ZW50cyl7XG4gICAgLy8gSW4gb3JkZXIgdG8gcHJvdmlkZSBhIGJldHRlciBleHBlcmllbmNlLCB3ZSB3YW50IHRvIGpvaW5cbiAgICAvLyBhbGwgTGl2ZVZpZXdzIGZpcnN0IGFuZCBvbmx5IHRoZW4gYXBwbHkgdGhlaXIgcGF0Y2hlcy5cbiAgICBpZih0aGlzLmpvaW5Db3VudCA+IDEgfHwgKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5pc0pvaW5QZW5kaW5nKCkpKXtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cylcbiAgICB9XG5cbiAgICAvLyBPbmUgZG93bnNpZGUgb2YgdGhpcyBhcHByb2FjaCBpcyB0aGF0IHdlIG5lZWQgdG8gZmluZCBwaHhDaGlsZHJlblxuICAgIC8vIGluIHRoZSBodG1sIGZyYWdtZW50LCBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBET00uIFRoZSBmcmFnbWVudFxuICAgIC8vIGFsc28gZG9lcyBub3QgaW5jbHVkZSBQSFhfU1RBVElDLCBzbyB3ZSBuZWVkIHRvIGNvcHkgaXQgb3ZlciBmcm9tXG4gICAgLy8gdGhlIERPTS5cbiAgICBsZXQgbmV3Q2hpbGRyZW4gPSBET00uZmluZFBoeENoaWxkcmVuSW5GcmFnbWVudChodG1sLCB0aGlzLmlkKS5maWx0ZXIodG9FbCA9PiB7XG4gICAgICBsZXQgZnJvbUVsID0gdG9FbC5pZCAmJiB0aGlzLmVsLnF1ZXJ5U2VsZWN0b3IoYFtpZD1cIiR7dG9FbC5pZH1cIl1gKVxuICAgICAgbGV0IHBoeFN0YXRpYyA9IGZyb21FbCAmJiBmcm9tRWwuZ2V0QXR0cmlidXRlKFBIWF9TVEFUSUMpXG4gICAgICBpZihwaHhTdGF0aWMpeyB0b0VsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCBwaHhTdGF0aWMpIH1cbiAgICAgIC8vIHNldCBQSFhfUk9PVF9JRCB0byBwcmV2ZW50IGV2ZW50cyBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgdG8gdGhlIHJvb3Qgdmlld1xuICAgICAgLy8gd2hpbGUgdGhlIGNoaWxkIGpvaW4gaXMgc3RpbGwgcGVuZGluZ1xuICAgICAgaWYoZnJvbUVsKXsgZnJvbUVsLnNldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCwgdGhpcy5yb290LmlkKSB9XG4gICAgICByZXR1cm4gdGhpcy5qb2luQ2hpbGQodG9FbClcbiAgICB9KVxuXG4gICAgaWYobmV3Q2hpbGRyZW4ubGVuZ3RoID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKV0pXG4gICAgICAgIHRoaXMucGFyZW50LmFja0pvaW4odGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKVxuICAgICAgICB0aGlzLmFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IHRoaXMuYXBwbHlKb2luUGF0Y2gobGl2ZV9wYXRjaCwgaHRtbCwgc3RyZWFtcywgZXZlbnRzKV0pXG4gICAgfVxuICB9XG5cbiAgYXR0YWNoVHJ1ZURvY0VsKCl7XG4gICAgdGhpcy5lbCA9IERPTS5ieUlkKHRoaXMuaWQpXG4gICAgdGhpcy5lbC5zZXRBdHRyaWJ1dGUoUEhYX1JPT1RfSUQsIHRoaXMucm9vdC5pZClcbiAgfVxuXG4gIC8vIHRoaXMgaXMgaW52b2tlZCBmb3IgZGVhZCBhbmQgbGl2ZSB2aWV3cywgc28gd2UgbXVzdCBmaWx0ZXIgYnlcbiAgLy8gYnkgb3duZXIgdG8gZW5zdXJlIHdlIGFyZW4ndCBkdXBsaWNhdGluZyBob29rcyBhY3Jvc3MgZGlzY29ubmVjdFxuICAvLyBhbmQgY29ubmVjdGVkIHN0YXRlcy4gVGhpcyBhbHNvIGhhbmRsZXMgY2FzZXMgd2hlcmUgaG9va3MgZXhpc3RcbiAgLy8gaW4gYSByb290IGxheW91dCB3aXRoIGEgTFYgaW4gdGhlIGJvZHlcbiAgZXhlY05ld01vdW50ZWQocGFyZW50ID0gdGhpcy5lbCl7XG4gICAgbGV0IHBoeFZpZXdwb3J0VG9wID0gdGhpcy5iaW5kaW5nKFBIWF9WSUVXUE9SVF9UT1ApXG4gICAgbGV0IHBoeFZpZXdwb3J0Qm90dG9tID0gdGhpcy5iaW5kaW5nKFBIWF9WSUVXUE9SVF9CT1RUT00pXG4gICAgRE9NLmFsbChwYXJlbnQsIGBbJHtwaHhWaWV3cG9ydFRvcH1dLCBbJHtwaHhWaWV3cG9ydEJvdHRvbX1dYCwgaG9va0VsID0+IHtcbiAgICAgIGlmKHRoaXMub3duc0VsZW1lbnQoaG9va0VsKSl7XG4gICAgICAgIERPTS5tYWludGFpblByaXZhdGVIb29rcyhob29rRWwsIGhvb2tFbCwgcGh4Vmlld3BvcnRUb3AsIHBoeFZpZXdwb3J0Qm90dG9tKVxuICAgICAgICB0aGlzLm1heWJlQWRkTmV3SG9vayhob29rRWwpXG4gICAgICB9XG4gICAgfSlcbiAgICBET00uYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfSE9PSyl9XSwgW2RhdGEtcGh4LSR7UEhYX0hPT0t9XWAsIGhvb2tFbCA9PiB7XG4gICAgICBpZih0aGlzLm93bnNFbGVtZW50KGhvb2tFbCkpe1xuICAgICAgICB0aGlzLm1heWJlQWRkTmV3SG9vayhob29rRWwpXG4gICAgICB9XG4gICAgfSlcbiAgICBET00uYWxsKHBhcmVudCwgYFske3RoaXMuYmluZGluZyhQSFhfTU9VTlRFRCl9XWAsIGVsID0+IHtcbiAgICAgIGlmKHRoaXMub3duc0VsZW1lbnQoZWwpKXtcbiAgICAgICAgdGhpcy5tYXliZU1vdW50ZWQoZWwpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFwcGx5Sm9pblBhdGNoKGxpdmVfcGF0Y2gsIGh0bWwsIHN0cmVhbXMsIGV2ZW50cyl7XG4gICAgdGhpcy5hdHRhY2hUcnVlRG9jRWwoKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBzdHJlYW1zLCBudWxsKVxuICAgIHBhdGNoLm1hcmtQcnVuYWJsZUNvbnRlbnRGb3JSZW1vdmFsKClcbiAgICB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgZmFsc2UsIHRydWUpXG4gICAgdGhpcy5qb2luTmV3Q2hpbGRyZW4oKVxuICAgIHRoaXMuZXhlY05ld01vdW50ZWQoKVxuXG4gICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5saXZlU29ja2V0LmRpc3BhdGNoRXZlbnRzKGV2ZW50cylcbiAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKVxuXG4gICAgaWYobGl2ZV9wYXRjaCl7XG4gICAgICBsZXQge2tpbmQsIHRvfSA9IGxpdmVfcGF0Y2hcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpXG4gICAgfVxuICAgIHRoaXMuaGlkZUxvYWRlcigpXG4gICAgaWYodGhpcy5qb2luQ291bnQgPiAxKXsgdGhpcy50cmlnZ2VyUmVjb25uZWN0ZWQoKSB9XG4gICAgdGhpcy5zdG9wQ2FsbGJhY2soKVxuICB9XG5cbiAgdHJpZ2dlckJlZm9yZVVwZGF0ZUhvb2soZnJvbUVsLCB0b0VsKXtcbiAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uQmVmb3JlRWxVcGRhdGVkXCIsIFtmcm9tRWwsIHRvRWxdKVxuICAgIGxldCBob29rID0gdGhpcy5nZXRIb29rKGZyb21FbClcbiAgICBsZXQgaXNJZ25vcmVkID0gaG9vayAmJiBET00uaXNJZ25vcmVkKGZyb21FbCwgdGhpcy5iaW5kaW5nKFBIWF9VUERBVEUpKVxuICAgIGlmKGhvb2sgJiYgIWZyb21FbC5pc0VxdWFsTm9kZSh0b0VsKSAmJiAhKGlzSWdub3JlZCAmJiBpc0VxdWFsT2JqKGZyb21FbC5kYXRhc2V0LCB0b0VsLmRhdGFzZXQpKSl7XG4gICAgICBob29rLl9fYmVmb3JlVXBkYXRlKClcbiAgICAgIHJldHVybiBob29rXG4gICAgfVxuICB9XG5cbiAgbWF5YmVNb3VudGVkKGVsKXtcbiAgICBsZXQgcGh4TW91bnRlZCA9IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX01PVU5URUQpKVxuICAgIGxldCBoYXNCZWVuSW52b2tlZCA9IHBoeE1vdW50ZWQgJiYgRE9NLnByaXZhdGUoZWwsIFwibW91bnRlZFwiKVxuICAgIGlmKHBoeE1vdW50ZWQgJiYgIWhhc0JlZW5JbnZva2VkKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5leGVjSlMoZWwsIHBoeE1vdW50ZWQpXG4gICAgICBET00ucHV0UHJpdmF0ZShlbCwgXCJtb3VudGVkXCIsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgbWF5YmVBZGROZXdIb29rKGVsKXtcbiAgICBsZXQgbmV3SG9vayA9IHRoaXMuYWRkSG9vayhlbClcbiAgICBpZihuZXdIb29rKXsgbmV3SG9vay5fX21vdW50ZWQoKSB9XG4gIH1cblxuICBwZXJmb3JtUGF0Y2gocGF0Y2gsIHBydW5lQ2lkcywgaXNKb2luUGF0Y2ggPSBmYWxzZSl7XG4gICAgbGV0IHJlbW92ZWRFbHMgPSBbXVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcbiAgICBsZXQgdXBkYXRlZEhvb2tJZHMgPSBuZXcgU2V0KClcblxuICAgIHRoaXMubGl2ZVNvY2tldC50cmlnZ2VyRE9NKFwib25QYXRjaFN0YXJ0XCIsIFtwYXRjaC50YXJnZXRDb250YWluZXJdKVxuXG4gICAgcGF0Y2guYWZ0ZXIoXCJhZGRlZFwiLCBlbCA9PiB7XG4gICAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uTm9kZUFkZGVkXCIsIFtlbF0pXG4gICAgICBsZXQgcGh4Vmlld3BvcnRUb3AgPSB0aGlzLmJpbmRpbmcoUEhYX1ZJRVdQT1JUX1RPUClcbiAgICAgIGxldCBwaHhWaWV3cG9ydEJvdHRvbSA9IHRoaXMuYmluZGluZyhQSFhfVklFV1BPUlRfQk9UVE9NKVxuICAgICAgRE9NLm1haW50YWluUHJpdmF0ZUhvb2tzKGVsLCBlbCwgcGh4Vmlld3BvcnRUb3AsIHBoeFZpZXdwb3J0Qm90dG9tKVxuICAgICAgdGhpcy5tYXliZUFkZE5ld0hvb2soZWwpXG4gICAgICBpZihlbC5nZXRBdHRyaWJ1dGUpeyB0aGlzLm1heWJlTW91bnRlZChlbCkgfVxuICAgIH0pXG5cbiAgICBwYXRjaC5hZnRlcihcInBoeENoaWxkQWRkZWRcIiwgZWwgPT4ge1xuICAgICAgaWYoRE9NLmlzUGh4U3RpY2t5KGVsKSl7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5qb2luUm9vdFZpZXdzKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcblxuICAgIHBhdGNoLmJlZm9yZShcInVwZGF0ZWRcIiwgKGZyb21FbCwgdG9FbCkgPT4ge1xuICAgICAgbGV0IGhvb2sgPSB0aGlzLnRyaWdnZXJCZWZvcmVVcGRhdGVIb29rKGZyb21FbCwgdG9FbClcbiAgICAgIGlmKGhvb2speyB1cGRhdGVkSG9va0lkcy5hZGQoZnJvbUVsLmlkKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidXBkYXRlZFwiLCBlbCA9PiB7XG4gICAgICBpZih1cGRhdGVkSG9va0lkcy5oYXMoZWwuaWQpKXsgdGhpcy5nZXRIb29rKGVsKS5fX3VwZGF0ZWQoKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwiZGlzY2FyZGVkXCIsIChlbCkgPT4ge1xuICAgICAgaWYoZWwubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKXsgcmVtb3ZlZEVscy5wdXNoKGVsKSB9XG4gICAgfSlcblxuICAgIHBhdGNoLmFmdGVyKFwidHJhbnNpdGlvbnNEaXNjYXJkZWRcIiwgZWxzID0+IHRoaXMuYWZ0ZXJFbGVtZW50c1JlbW92ZWQoZWxzLCBwcnVuZUNpZHMpKVxuICAgIHBhdGNoLnBlcmZvcm0oaXNKb2luUGF0Y2gpXG4gICAgdGhpcy5hZnRlckVsZW1lbnRzUmVtb3ZlZChyZW1vdmVkRWxzLCBwcnVuZUNpZHMpXG5cbiAgICB0aGlzLmxpdmVTb2NrZXQudHJpZ2dlckRPTShcIm9uUGF0Y2hFbmRcIiwgW3BhdGNoLnRhcmdldENvbnRhaW5lcl0pXG4gICAgcmV0dXJuIHBoeENoaWxkcmVuQWRkZWRcbiAgfVxuXG4gIGFmdGVyRWxlbWVudHNSZW1vdmVkKGVsZW1lbnRzLCBwcnVuZUNpZHMpe1xuICAgIGxldCBkZXN0cm95ZWRDSURzID0gW11cbiAgICBlbGVtZW50cy5mb3JFYWNoKHBhcmVudCA9PiB7XG4gICAgICBsZXQgY29tcG9uZW50cyA9IERPTS5hbGwocGFyZW50LCBgWyR7UEhYX0NPTVBPTkVOVH1dYClcbiAgICAgIGxldCBob29rcyA9IERPTS5hbGwocGFyZW50LCBgWyR7dGhpcy5iaW5kaW5nKFBIWF9IT09LKX1dLCBbZGF0YS1waHgtaG9va11gKVxuICAgICAgY29tcG9uZW50cy5jb25jYXQocGFyZW50KS5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgbGV0IGNpZCA9IHRoaXMuY29tcG9uZW50SUQoZWwpXG4gICAgICAgIGlmKGlzQ2lkKGNpZCkgJiYgZGVzdHJveWVkQ0lEcy5pbmRleE9mKGNpZCkgPT09IC0xKXsgZGVzdHJveWVkQ0lEcy5wdXNoKGNpZCkgfVxuICAgICAgfSlcbiAgICAgIGhvb2tzLmNvbmNhdChwYXJlbnQpLmZvckVhY2goaG9va0VsID0+IHtcbiAgICAgICAgbGV0IGhvb2sgPSB0aGlzLmdldEhvb2soaG9va0VsKVxuICAgICAgICBob29rICYmIHRoaXMuZGVzdHJveUhvb2soaG9vaylcbiAgICAgIH0pXG4gICAgfSlcbiAgICAvLyBXZSBzaG91bGQgbm90IHBydW5lQ2lkcyBvbiBqb2lucy4gT3RoZXJ3aXNlLCBpbiBjYXNlIG9mXG4gICAgLy8gcmVqb2lucywgd2UgbWF5IG5vdGlmeSBjaWRzIHRoYXQgbm8gbG9uZ2VyIGJlbG9uZyB0byB0aGVcbiAgICAvLyBjdXJyZW50IExpdmVWaWV3IHRvIGJlIHJlbW92ZWQuXG4gICAgaWYocHJ1bmVDaWRzKXtcbiAgICAgIHRoaXMubWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKVxuICAgIH1cbiAgfVxuXG4gIGpvaW5OZXdDaGlsZHJlbigpe1xuICAgIERPTS5maW5kUGh4Q2hpbGRyZW4odGhpcy5lbCwgdGhpcy5pZCkuZm9yRWFjaChlbCA9PiB0aGlzLmpvaW5DaGlsZChlbCkpXG4gIH1cblxuICBtYXliZVJlY292ZXJGb3JtcyhodG1sLCBjYWxsYmFjayl7XG4gICAgY29uc3QgcGh4Q2hhbmdlID0gdGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpXG4gICAgY29uc3Qgb2xkRm9ybXMgPSB0aGlzLnJvb3QuZm9ybXNGb3JSZWNvdmVyeVxuICAgIC8vIFNvIHdoeSBkbyB3ZSBjcmVhdGUgYSB0ZW1wbGF0ZSBlbGVtZW50IGhlcmU/XG4gICAgLy8gT25lIHdheSB0byByZWNvdmVyIGZvcm1zIHdvdWxkIGJlIHRvIGltbWVkaWF0ZWx5IGFwcGx5IHRoZSBtb3VudFxuICAgIC8vIHBhdGNoIGFuZCB0aGVuIGFmdGVyd2FyZHMgcmVjb3ZlciB0aGUgZm9ybXMuIEhvd2V2ZXIsIHRoaXMgd291bGRcbiAgICAvLyBjYXVzZSBhIGZsaWNrZXIsIGJlY2F1c2UgdGhlIG1vdW50IHBhdGNoIHdvdWxkIHJlbW92ZSB0aGUgZm9ybSBjb250ZW50XG4gICAgLy8gdW50aWwgaXQgaXMgcmVzdG9yZWQuIFRoZXJlZm9yZSBMViBkZWNpZGVkIHRvIGRvIGZvcm0gcmVjb3Zlcnkgd2l0aCB0aGVcbiAgICAvLyByYXcgSFRNTCBiZWZvcmUgaXQgaXMgYXBwbGllZCBhbmQgZGVsYXkgdGhlIG1vdW50IHBhdGNoIHVudGlsIHRoZSBmb3JtXG4gICAgLy8gcmVjb3ZlcnkgZXZlbnRzIGFyZSBkb25lLlxuICAgIGxldCB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKVxuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWxcbiAgICAvLyBiZWNhdXNlIHdlIHdvcmsgd2l0aCBhIHRlbXBsYXRlIGVsZW1lbnQsIHdlIG11c3QgbWFudWFsbHkgY29weSB0aGUgYXR0cmlidXRlc1xuICAgIC8vIG90aGVyd2lzZSB0aGUgb3duZXIgLyB0YXJnZXQgaGVscGVycyBkb24ndCB3b3JrIHByb3Blcmx5XG4gICAgY29uc3Qgcm9vdEVsID0gdGVtcGxhdGUuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZFxuICAgIHJvb3RFbC5pZCA9IHRoaXMuaWRcbiAgICByb290RWwuc2V0QXR0cmlidXRlKFBIWF9ST09UX0lELCB0aGlzLnJvb3QuaWQpXG4gICAgcm9vdEVsLnNldEF0dHJpYnV0ZShQSFhfU0VTU0lPTiwgdGhpcy5nZXRTZXNzaW9uKCkpXG4gICAgcm9vdEVsLnNldEF0dHJpYnV0ZShQSFhfU1RBVElDLCB0aGlzLmdldFN0YXRpYygpKVxuICAgIHJvb3RFbC5zZXRBdHRyaWJ1dGUoUEhYX1BBUkVOVF9JRCwgdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5pZCA6IG51bGwpXG5cbiAgICAvLyB3ZSBnbyBvdmVyIGFsbCBmb3JtIGVsZW1lbnRzIGluIHRoZSBuZXcgSFRNTCBmb3IgdGhlIExWXG4gICAgLy8gYW5kIGxvb2sgZm9yIG9sZCBmb3JtcyBpbiB0aGUgYGZvcm1zRm9yUmVjb3ZlcnlgIG9iamVjdDtcbiAgICAvLyB0aGUgZm9ybXNGb3JSZWNvdmVyeSBjYW4gYWxzbyBjb250YWluIGZvcm1zIGZyb20gY2hpbGQgdmlld3NcbiAgICBjb25zdCBmb3Jtc1RvUmVjb3ZlciA9XG4gICAgICAvLyB3ZSBnbyBvdmVyIGFsbCBmb3JtcyBpbiB0aGUgbmV3IERPTTsgYmVjYXVzZSB0aGlzIGlzIG9ubHkgdGhlIEhUTUwgZm9yIHRoZSBjdXJyZW50XG4gICAgICAvLyB2aWV3LCB3ZSBjYW4gYmUgc3VyZSB0aGF0IGFsbCBmb3JtcyBhcmUgb3duZWQgYnkgdGhpcyB2aWV3OlxuICAgICAgRE9NLmFsbCh0ZW1wbGF0ZS5jb250ZW50LCBcImZvcm1cIilcbiAgICAgICAgLy8gb25seSByZWNvdmVyIGZvcm1zIHRoYXQgaGF2ZSBhbiBpZCBhbmQgYXJlIGluIHRoZSBvbGQgRE9NXG4gICAgICAgIC5maWx0ZXIobmV3Rm9ybSA9PiBuZXdGb3JtLmlkICYmIG9sZEZvcm1zW25ld0Zvcm0uaWRdKVxuICAgICAgICAvLyBhYmFuZG9uIGZvcm1zIHdlIGFscmVhZHkgdHJpZWQgdG8gcmVjb3ZlciB0byBwcmV2ZW50IGxvb3BpbmcgYSBmYWlsZWQgc3RhdGVcbiAgICAgICAgLmZpbHRlcihuZXdGb3JtID0+ICF0aGlzLnBlbmRpbmdGb3Jtcy5oYXMobmV3Rm9ybS5pZCkpXG4gICAgICAgIC8vIG9ubHkgcmVjb3ZlciBpZiB0aGUgZm9ybSBoYXMgdGhlIHNhbWUgcGh4LWNoYW5nZSB2YWx1ZVxuICAgICAgICAuZmlsdGVyKG5ld0Zvcm0gPT4gb2xkRm9ybXNbbmV3Rm9ybS5pZF0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSkgPT09IG5ld0Zvcm0uZ2V0QXR0cmlidXRlKHBoeENoYW5nZSkpXG4gICAgICAgIC5tYXAobmV3Rm9ybSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtvbGRGb3Jtc1tuZXdGb3JtLmlkXSwgbmV3Rm9ybV1cbiAgICAgICAgfSlcblxuICAgIGlmKGZvcm1zVG9SZWNvdmVyLmxlbmd0aCA9PT0gMCl7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgIH1cblxuICAgIGZvcm1zVG9SZWNvdmVyLmZvckVhY2goKFtvbGRGb3JtLCBuZXdGb3JtXSwgaSkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nRm9ybXMuYWRkKG5ld0Zvcm0uaWQpXG4gICAgICAvLyBpdCBpcyBpbXBvcnRhbnQgdG8gdXNlIHRoZSBmaXJzdEVsZW1lbnRDaGlsZCBvZiB0aGUgdGVtcGxhdGUgY29udGVudFxuICAgICAgLy8gYmVjYXVzZSB3aGVuIHRyYXZlcnNpbmcgYSBkb2N1bWVudEZyYWdtZW50IHVzaW5nIHBhcmVudE5vZGUsIHdlIHdvbid0IGV2ZXIgYXJyaXZlIGF0XG4gICAgICAvLyB0aGUgZnJhZ21lbnQ7IGFzIHRoZSB0ZW1wbGF0ZSBpcyBhbHdheXMgYSBMaXZlVmlldywgd2UgY2FuIGJlIHN1cmUgdGhhdCB0aGVyZSBpcyBvbmx5XG4gICAgICAvLyBvbmUgY2hpbGQgb24gdGhlIHJvb3QgbGV2ZWxcbiAgICAgIHRoaXMucHVzaEZvcm1SZWNvdmVyeShvbGRGb3JtLCBuZXdGb3JtLCB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucGVuZGluZ0Zvcm1zLmRlbGV0ZShuZXdGb3JtLmlkKVxuICAgICAgICAvLyB3ZSBvbmx5IGNhbGwgdGhlIGNhbGxiYWNrIG9uY2UgYWxsIGZvcm1zIGhhdmUgYmVlbiByZWNvdmVyZWRcbiAgICAgICAgaWYoaSA9PT0gZm9ybXNUb1JlY292ZXIubGVuZ3RoIC0gMSl7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBnZXRDaGlsZEJ5SWQoaWQpeyByZXR1cm4gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW2lkXSB9XG5cbiAgZ2V0RGVzY2VuZGVudEJ5RWwoZWwpe1xuICAgIGlmKGVsLmlkID09PSB0aGlzLmlkKXtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2VsLmdldEF0dHJpYnV0ZShQSFhfUEFSRU5UX0lEKV0/LltlbC5pZF1cbiAgICB9XG4gIH1cblxuICBkZXN0cm95RGVzY2VuZGVudChpZCl7XG4gICAgZm9yKGxldCBwYXJlbnRJZCBpbiB0aGlzLnJvb3QuY2hpbGRyZW4pe1xuICAgICAgZm9yKGxldCBjaGlsZElkIGluIHRoaXMucm9vdC5jaGlsZHJlbltwYXJlbnRJZF0pe1xuICAgICAgICBpZihjaGlsZElkID09PSBpZCl7IHJldHVybiB0aGlzLnJvb3QuY2hpbGRyZW5bcGFyZW50SWRdW2NoaWxkSWRdLmRlc3Ryb3koKSB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgam9pbkNoaWxkKGVsKXtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldENoaWxkQnlJZChlbC5pZClcbiAgICBpZighY2hpbGQpe1xuICAgICAgbGV0IHZpZXcgPSBuZXcgVmlldyhlbCwgdGhpcy5saXZlU29ja2V0LCB0aGlzKVxuICAgICAgdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdW3ZpZXcuaWRdID0gdmlld1xuICAgICAgdmlldy5qb2luKClcbiAgICAgIHRoaXMuY2hpbGRKb2lucysrXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIGlzSm9pblBlbmRpbmcoKXsgcmV0dXJuIHRoaXMuam9pblBlbmRpbmcgfVxuXG4gIGFja0pvaW4oX2NoaWxkKXtcbiAgICB0aGlzLmNoaWxkSm9pbnMtLVxuXG4gICAgaWYodGhpcy5jaGlsZEpvaW5zID09PSAwKXtcbiAgICAgIGlmKHRoaXMucGFyZW50KXtcbiAgICAgICAgdGhpcy5wYXJlbnQuYWNrSm9pbih0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5vbkFsbENoaWxkSm9pbnNDb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25BbGxDaGlsZEpvaW5zQ29tcGxldGUoKXtcbiAgICAvLyB3ZSBjYW4gY2xlYXIgcGVuZGluZyBmb3JtIHJlY292ZXJpZXMgbm93IHRoYXQgd2UndmUgam9pbmVkLlxuICAgIC8vIFRoZXkgZWl0aGVyIGFsbCByZXNvbHZlZCBvciB3ZXJlIGFiYW5kb25lZFxuICAgIHRoaXMucGVuZGluZ0Zvcm1zLmNsZWFyKClcbiAgICAvLyB3ZSBjYW4gYWxzbyBjbGVhciB0aGUgZm9ybXNGb3JSZWNvdmVyeSBvYmplY3QgdG8gbm90IGtlZXAgb2xkIGZvcm0gZWxlbWVudHMgYXJvdW5kXG4gICAgdGhpcy5mb3Jtc0ZvclJlY292ZXJ5ID0ge31cbiAgICB0aGlzLmpvaW5DYWxsYmFjaygoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmdKb2luT3BzLmZvckVhY2goKFt2aWV3LCBvcF0pID0+IHtcbiAgICAgICAgaWYoIXZpZXcuaXNEZXN0cm95ZWQoKSl7IG9wKCkgfVxuICAgICAgfSlcbiAgICAgIHRoaXMucGVuZGluZ0pvaW5PcHMgPSBbXVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGUoZGlmZiwgZXZlbnRzKXtcbiAgICBpZih0aGlzLmlzSm9pblBlbmRpbmcoKSB8fCAodGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgdGhpcy5yb290LmlzTWFpbigpKSl7XG4gICAgICByZXR1cm4gdGhpcy5wZW5kaW5nRGlmZnMucHVzaCh7ZGlmZiwgZXZlbnRzfSlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkLm1lcmdlRGlmZihkaWZmKVxuICAgIGxldCBwaHhDaGlsZHJlbkFkZGVkID0gZmFsc2VcblxuICAgIC8vIFdoZW4gdGhlIGRpZmYgb25seSBjb250YWlucyBjb21wb25lbnQgZGlmZnMsIHRoZW4gd2FsayBjb21wb25lbnRzXG4gICAgLy8gYW5kIHBhdGNoIG9ubHkgdGhlIHBhcmVudCBjb21wb25lbnQgY29udGFpbmVycyBmb3VuZCBpbiB0aGUgZGlmZi5cbiAgICAvLyBPdGhlcndpc2UsIHBhdGNoIGVudGlyZSBMViBjb250YWluZXIuXG4gICAgaWYodGhpcy5yZW5kZXJlZC5pc0NvbXBvbmVudE9ubHlEaWZmKGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiY29tcG9uZW50IHBhdGNoIGNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgbGV0IHBhcmVudENpZHMgPSBET00uZmluZEV4aXN0aW5nUGFyZW50Q0lEcyh0aGlzLmVsLCB0aGlzLnJlbmRlcmVkLmNvbXBvbmVudENJRHMoZGlmZikpXG4gICAgICAgIHBhcmVudENpZHMuZm9yRWFjaChwYXJlbnRDSUQgPT4ge1xuICAgICAgICAgIGlmKHRoaXMuY29tcG9uZW50UGF0Y2godGhpcy5yZW5kZXJlZC5nZXRDb21wb25lbnQoZGlmZiwgcGFyZW50Q0lEKSwgcGFyZW50Q0lEKSl7IHBoeENoaWxkcmVuQWRkZWQgPSB0cnVlIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmKCFpc0VtcHR5KGRpZmYpKXtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC50aW1lKFwiZnVsbCBwYXRjaCBjb21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgIGxldCBbaHRtbCwgc3RyZWFtc10gPSB0aGlzLnJlbmRlckNvbnRhaW5lcihkaWZmLCBcInVwZGF0ZVwiKVxuICAgICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgdGhpcy5lbCwgdGhpcy5pZCwgaHRtbCwgc3RyZWFtcywgbnVsbClcbiAgICAgICAgcGh4Q2hpbGRyZW5BZGRlZCA9IHRoaXMucGVyZm9ybVBhdGNoKHBhdGNoLCB0cnVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmxpdmVTb2NrZXQuZGlzcGF0Y2hFdmVudHMoZXZlbnRzKVxuICAgIGlmKHBoeENoaWxkcmVuQWRkZWQpeyB0aGlzLmpvaW5OZXdDaGlsZHJlbigpIH1cbiAgfVxuXG4gIHJlbmRlckNvbnRhaW5lcihkaWZmLCBraW5kKXtcbiAgICByZXR1cm4gdGhpcy5saXZlU29ja2V0LnRpbWUoYHRvU3RyaW5nIGRpZmYgKCR7a2luZH0pYCwgKCkgPT4ge1xuICAgICAgbGV0IHRhZyA9IHRoaXMuZWwudGFnTmFtZVxuICAgICAgLy8gRG9uJ3Qgc2tpcCBhbnkgY29tcG9uZW50IGluIHRoZSBkaWZmIG5vciBhbnkgbWFya2VkIGFzIHBydW5lZFxuICAgICAgLy8gKGFzIHRoZXkgbWF5IGhhdmUgYmVlbiBhZGRlZCBiYWNrKVxuICAgICAgbGV0IGNpZHMgPSBkaWZmID8gdGhpcy5yZW5kZXJlZC5jb21wb25lbnRDSURzKGRpZmYpIDogbnVsbFxuICAgICAgbGV0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVuZGVyZWQudG9TdHJpbmcoY2lkcylcbiAgICAgIHJldHVybiBbYDwke3RhZ30+JHtodG1sfTwvJHt0YWd9PmAsIHN0cmVhbXNdXG4gICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudFBhdGNoKGRpZmYsIGNpZCl7XG4gICAgaWYoaXNFbXB0eShkaWZmKSkgcmV0dXJuIGZhbHNlXG4gICAgbGV0IFtodG1sLCBzdHJlYW1zXSA9IHRoaXMucmVuZGVyZWQuY29tcG9uZW50VG9TdHJpbmcoY2lkKVxuICAgIGxldCBwYXRjaCA9IG5ldyBET01QYXRjaCh0aGlzLCB0aGlzLmVsLCB0aGlzLmlkLCBodG1sLCBzdHJlYW1zLCBjaWQpXG4gICAgbGV0IGNoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICByZXR1cm4gY2hpbGRyZW5BZGRlZFxuICB9XG5cbiAgZ2V0SG9vayhlbCl7IHJldHVybiB0aGlzLnZpZXdIb29rc1tWaWV3SG9vay5lbGVtZW50SUQoZWwpXSB9XG5cbiAgYWRkSG9vayhlbCl7XG4gICAgbGV0IGhvb2tFbElkID0gVmlld0hvb2suZWxlbWVudElEKGVsKVxuXG4gICAgLy8gb25seSBldmVyIHRyeSB0byBhZGQgaG9va3MgdG8gZWxlbWVudHMgb3duZWQgYnkgdGhpcyB2aWV3XG4gICAgaWYoZWwuZ2V0QXR0cmlidXRlICYmICF0aGlzLm93bnNFbGVtZW50KGVsKSl7IHJldHVybiB9XG5cbiAgICBpZihob29rRWxJZCAmJiAhdGhpcy52aWV3SG9va3NbaG9va0VsSWRdKXtcbiAgICAgIC8vIGhvb2sgY3JlYXRlZCwgYnV0IG5vdCBhdHRhY2hlZCAoY3JlYXRlSG9vayBmb3Igd2ViIGNvbXBvbmVudClcbiAgICAgIGxldCBob29rID0gRE9NLmdldEN1c3RvbUVsSG9vayhlbCkgfHwgbG9nRXJyb3IoYG5vIGhvb2sgZm91bmQgZm9yIGN1c3RvbSBlbGVtZW50OiAke2VsLmlkfWApXG4gICAgICB0aGlzLnZpZXdIb29rc1tob29rRWxJZF0gPSBob29rXG4gICAgICBob29rLl9fYXR0YWNoVmlldyh0aGlzKVxuICAgICAgcmV0dXJuIGhvb2tcbiAgICB9XG4gICAgZWxzZSBpZihob29rRWxJZCB8fCAhZWwuZ2V0QXR0cmlidXRlKXtcbiAgICAgIC8vIG5vIGhvb2sgZm91bmRcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXcgaG9vayBmb3VuZCB3aXRoIHBoeC1ob29rIGF0dHJpYnV0ZVxuICAgICAgbGV0IGhvb2tOYW1lID0gZWwuZ2V0QXR0cmlidXRlKGBkYXRhLXBoeC0ke1BIWF9IT09LfWApIHx8IGVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoUEhYX0hPT0spKVxuICAgICAgbGV0IGNhbGxiYWNrcyA9IHRoaXMubGl2ZVNvY2tldC5nZXRIb29rQ2FsbGJhY2tzKGhvb2tOYW1lKVxuXG4gICAgICBpZihjYWxsYmFja3Mpe1xuICAgICAgICBpZighZWwuaWQpeyBsb2dFcnJvcihgbm8gRE9NIElEIGZvciBob29rIFwiJHtob29rTmFtZX1cIi4gSG9va3MgcmVxdWlyZSBhIHVuaXF1ZSBJRCBvbiBlYWNoIGVsZW1lbnQuYCwgZWwpIH1cbiAgICAgICAgbGV0IGhvb2sgPSBuZXcgVmlld0hvb2sodGhpcywgZWwsIGNhbGxiYWNrcylcbiAgICAgICAgdGhpcy52aWV3SG9va3NbVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXSA9IGhvb2tcbiAgICAgICAgcmV0dXJuIGhvb2tcbiAgICAgIH0gZWxzZSBpZihob29rTmFtZSAhPT0gbnVsbCl7XG4gICAgICAgIGxvZ0Vycm9yKGB1bmtub3duIGhvb2sgZm91bmQgZm9yIFwiJHtob29rTmFtZX1cImAsIGVsKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3lIb29rKGhvb2spe1xuICAgIC8vIF9fZGVzdHJveWVkIGNsZWFycyB0aGUgZWxlbWVudElEIGZyb20gdGhlIGhvb2ssIHRoZXJlZm9yZVxuICAgIC8vIHdlIG5lZWQgdG8gZ2V0IGl0IGJlZm9yZSBjYWxsaW5nIF9fZGVzdHJveWVkXG4gICAgY29uc3QgaG9va0lkID0gVmlld0hvb2suZWxlbWVudElEKGhvb2suZWwpXG4gICAgaG9vay5fX2Rlc3Ryb3llZCgpXG4gICAgaG9vay5fX2NsZWFudXBfXygpXG4gICAgZGVsZXRlIHRoaXMudmlld0hvb2tzW2hvb2tJZF1cbiAgfVxuXG4gIGFwcGx5UGVuZGluZ1VwZGF0ZXMoKXtcbiAgICAvLyBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyB3aGVyZSB3ZSBtaWdodCBzdGlsbCBiZSBwZW5kaW5nIGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiBhZnRlciBhcHBseWluZyB0aGUgY3VycmVudCBvbmU7XG4gICAgLy8gaWYgd2UgY2FsbCB1cGRhdGUgYW5kIGEgcGVuZGluZ0RpZmYgaXMgbm90IGFwcGxpZWQsIGl0IHdvdWxkXG4gICAgLy8gYmUgc2lsZW50bHkgZHJvcHBlZCBvdGhlcndpc2UsIGFzIHVwZGF0ZSB3b3VsZCBwdXNoIGl0IGJhY2sgdG9cbiAgICAvLyBwZW5kaW5nRGlmZnMsIGJ1dCB3ZSBjbGVhciBpdCBpbW1lZGlhdGVseSBhZnRlclxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5oYXNQZW5kaW5nTGluaygpICYmIHRoaXMucm9vdC5pc01haW4oKSl7IHJldHVybiB9XG4gICAgdGhpcy5wZW5kaW5nRGlmZnMuZm9yRWFjaCgoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXVxuICAgIHRoaXMuZWFjaENoaWxkKGNoaWxkID0+IGNoaWxkLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKSlcbiAgfVxuXG4gIGVhY2hDaGlsZChjYWxsYmFjayl7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5yb290LmNoaWxkcmVuW3RoaXMuaWRdIHx8IHt9XG4gICAgZm9yKGxldCBpZCBpbiBjaGlsZHJlbil7IGNhbGxiYWNrKHRoaXMuZ2V0Q2hpbGRCeUlkKGlkKSkgfVxuICB9XG5cbiAgb25DaGFubmVsKGV2ZW50LCBjYil7XG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIGV2ZW50LCByZXNwID0+IHtcbiAgICAgIGlmKHRoaXMuaXNKb2luUGVuZGluZygpKXtcbiAgICAgICAgdGhpcy5yb290LnBlbmRpbmdKb2luT3BzLnB1c2goW3RoaXMsICgpID0+IGNiKHJlc3ApXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IGNiKHJlc3ApKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBiaW5kQ2hhbm5lbCgpe1xuICAgIC8vIFRoZSBkaWZmIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSByZWd1bGFyIHVwZGF0ZSBvcGVyYXRpb25zLlxuICAgIC8vIEFsbCBvdGhlciBvcGVyYXRpb25zIGFyZSBxdWV1ZWQgdG8gYmUgYXBwbGllZCBvbmx5IGFmdGVyIGpvaW4uXG4gICAgdGhpcy5saXZlU29ja2V0Lm9uQ2hhbm5lbCh0aGlzLmNoYW5uZWwsIFwiZGlmZlwiLCAocmF3RGlmZikgPT4ge1xuICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFwcGx5RGlmZihcInVwZGF0ZVwiLCByYXdEaWZmLCAoe2RpZmYsIGV2ZW50c30pID0+IHRoaXMudXBkYXRlKGRpZmYsIGV2ZW50cykpXG4gICAgICB9KVxuICAgIH0pXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJyZWRpcmVjdFwiLCAoe3RvLCBmbGFzaH0pID0+IHRoaXMub25SZWRpcmVjdCh7dG8sIGZsYXNofSkpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3BhdGNoXCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVQYXRjaChyZWRpcikpXG4gICAgdGhpcy5vbkNoYW5uZWwoXCJsaXZlX3JlZGlyZWN0XCIsIChyZWRpcikgPT4gdGhpcy5vbkxpdmVSZWRpcmVjdChyZWRpcikpXG4gICAgdGhpcy5jaGFubmVsLm9uRXJyb3IocmVhc29uID0+IHRoaXMub25FcnJvcihyZWFzb24pKVxuICAgIHRoaXMuY2hhbm5lbC5vbkNsb3NlKHJlYXNvbiA9PiB0aGlzLm9uQ2xvc2UocmVhc29uKSlcbiAgfVxuXG4gIGRlc3Ryb3lBbGxDaGlsZHJlbigpeyB0aGlzLmVhY2hDaGlsZChjaGlsZCA9PiBjaGlsZC5kZXN0cm95KCkpIH1cblxuICBvbkxpdmVSZWRpcmVjdChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZCwgZmxhc2h9ID0gcmVkaXJcbiAgICBsZXQgdXJsID0gdGhpcy5leHBhbmRVUkwodG8pXG4gICAgbGV0IGUgPSBuZXcgQ3VzdG9tRXZlbnQoXCJwaHg6c2VydmVyLW5hdmlnYXRlXCIsIHtkZXRhaWw6IHt0bywga2luZCwgZmxhc2h9fSlcbiAgICB0aGlzLmxpdmVTb2NrZXQuaGlzdG9yeVJlZGlyZWN0KGUsIHVybCwga2luZCwgZmxhc2gpXG4gIH1cblxuICBvbkxpdmVQYXRjaChyZWRpcil7XG4gICAgbGV0IHt0bywga2luZH0gPSByZWRpclxuICAgIHRoaXMuaHJlZiA9IHRoaXMuZXhwYW5kVVJMKHRvKVxuICAgIHRoaXMubGl2ZVNvY2tldC5oaXN0b3J5UGF0Y2godG8sIGtpbmQpXG4gIH1cblxuICBleHBhbmRVUkwodG8pe1xuICAgIHJldHVybiB0by5zdGFydHNXaXRoKFwiL1wiKSA/IGAke3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbH0vLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9JHt0b31gIDogdG9cbiAgfVxuXG4gIG9uUmVkaXJlY3Qoe3RvLCBmbGFzaCwgcmVsb2FkVG9rZW59KXsgdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHRvLCBmbGFzaCwgcmVsb2FkVG9rZW4pIH1cblxuICBpc0Rlc3Ryb3llZCgpeyByZXR1cm4gdGhpcy5kZXN0cm95ZWQgfVxuXG4gIGpvaW5EZWFkKCl7IHRoaXMuaXNEZWFkID0gdHJ1ZSB9XG5cbiAgam9pblB1c2goKXtcbiAgICB0aGlzLmpvaW5QdXNoID0gdGhpcy5qb2luUHVzaCB8fCB0aGlzLmNoYW5uZWwuam9pbigpXG4gICAgcmV0dXJuIHRoaXMuam9pblB1c2hcbiAgfVxuXG4gIGpvaW4oY2FsbGJhY2spe1xuICAgIHRoaXMuc2hvd0xvYWRlcih0aGlzLmxpdmVTb2NrZXQubG9hZGVyVGltZW91dClcbiAgICB0aGlzLmJpbmRDaGFubmVsKClcbiAgICBpZih0aGlzLmlzTWFpbigpKXtcbiAgICAgIHRoaXMuc3RvcENhbGxiYWNrID0gdGhpcy5saXZlU29ja2V0LndpdGhQYWdlTG9hZGluZyh7dG86IHRoaXMuaHJlZiwga2luZDogXCJpbml0aWFsXCJ9KVxuICAgIH1cbiAgICB0aGlzLmpvaW5DYWxsYmFjayA9IChvbkRvbmUpID0+IHtcbiAgICAgIG9uRG9uZSA9IG9uRG9uZSB8fCBmdW5jdGlvbigpe31cbiAgICAgIGNhbGxiYWNrID8gY2FsbGJhY2sodGhpcy5qb2luQ291bnQsIG9uRG9uZSkgOiBvbkRvbmUoKVxuICAgIH1cblxuICAgIHRoaXMud3JhcFB1c2goKCkgPT4gdGhpcy5jaGFubmVsLmpvaW4oKSwge1xuICAgICAgb2s6IChyZXNwKSA9PiB0aGlzLmxpdmVTb2NrZXQucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB0aGlzLm9uSm9pbihyZXNwKSksXG4gICAgICBlcnJvcjogKGVycm9yKSA9PiB0aGlzLm9uSm9pbkVycm9yKGVycm9yKSxcbiAgICAgIHRpbWVvdXQ6ICgpID0+IHRoaXMub25Kb2luRXJyb3Ioe3JlYXNvbjogXCJ0aW1lb3V0XCJ9KVxuICAgIH0pXG4gIH1cblxuICBvbkpvaW5FcnJvcihyZXNwKXtcbiAgICBpZihyZXNwLnJlYXNvbiA9PT0gXCJyZWxvYWRcIil7XG4gICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtgZmFpbGVkIG1vdW50IHdpdGggJHtyZXNwLnN0YXR1c30uIEZhbGxpbmcgYmFjayB0byBwYWdlIHJlbG9hZGAsIHJlc3BdKVxuICAgICAgdGhpcy5vblJlZGlyZWN0KHt0bzogdGhpcy5yb290LmhyZWYsIHJlbG9hZFRva2VuOiByZXNwLnRva2VufSlcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSBpZihyZXNwLnJlYXNvbiA9PT0gXCJ1bmF1dGhvcml6ZWRcIiB8fCByZXNwLnJlYXNvbiA9PT0gXCJzdGFsZVwiKXtcbiAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgKCkgPT4gW1widW5hdXRob3JpemVkIGxpdmVfcmVkaXJlY3QuIEZhbGxpbmcgYmFjayB0byBwYWdlIHJlcXVlc3RcIiwgcmVzcF0pXG4gICAgICB0aGlzLm9uUmVkaXJlY3Qoe3RvOiB0aGlzLnJvb3QuaHJlZn0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYocmVzcC5yZWRpcmVjdCB8fCByZXNwLmxpdmVfcmVkaXJlY3Qpe1xuICAgICAgdGhpcy5qb2luUGVuZGluZyA9IGZhbHNlXG4gICAgICB0aGlzLmNoYW5uZWwubGVhdmUoKVxuICAgIH1cbiAgICBpZihyZXNwLnJlZGlyZWN0KXsgcmV0dXJuIHRoaXMub25SZWRpcmVjdChyZXNwLnJlZGlyZWN0KSB9XG4gICAgaWYocmVzcC5saXZlX3JlZGlyZWN0KXsgcmV0dXJuIHRoaXMub25MaXZlUmVkaXJlY3QocmVzcC5saXZlX3JlZGlyZWN0KSB9XG4gICAgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ1bmFibGUgdG8gam9pblwiLCByZXNwXSlcbiAgICBpZih0aGlzLmlzTWFpbigpKXtcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKFtQSFhfTE9BRElOR19DTEFTUywgUEhYX0VSUk9SX0NMQVNTLCBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTXSlcbiAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5saXZlU29ja2V0LnJlbG9hZFdpdGhKaXR0ZXIodGhpcykgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZih0aGlzLmpvaW5BdHRlbXB0cyA+PSBNQVhfQ0hJTERfSk9JTl9BVFRFTVBUUyl7XG4gICAgICAgIC8vIHB1dCB0aGUgcm9vdCByZXZpZXcgaW50byBwZXJtYW5lbnQgZXJyb3Igc3RhdGUsIGJ1dCBkb24ndCBkZXN0cm95IGl0IGFzIGl0IGNhbiByZW1haW4gYWN0aXZlXG4gICAgICAgIHRoaXMucm9vdC5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NdKVxuICAgICAgICB0aGlzLmxvZyhcImVycm9yXCIsICgpID0+IFtgZ2l2aW5nIHVwIHRyeWluZyB0byBtb3VudCBhZnRlciAke01BWF9DSElMRF9KT0lOX0FUVEVNUFRTfSB0cmllc2AsIHJlc3BdKVxuICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgfVxuICAgICAgbGV0IHRydWVDaGlsZEVsID0gRE9NLmJ5SWQodGhpcy5lbC5pZClcbiAgICAgIGlmKHRydWVDaGlsZEVsKXtcbiAgICAgICAgRE9NLm1lcmdlQXR0cnModHJ1ZUNoaWxkRWwsIHRoaXMuZWwpXG4gICAgICAgIHRoaXMuZGlzcGxheUVycm9yKFtQSFhfTE9BRElOR19DTEFTUywgUEhYX0VSUk9SX0NMQVNTLCBQSFhfU0VSVkVSX0VSUk9SX0NMQVNTXSlcbiAgICAgICAgdGhpcy5lbCA9IHRydWVDaGlsZEVsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9uQ2xvc2UocmVhc29uKXtcbiAgICBpZih0aGlzLmlzRGVzdHJveWVkKCkpeyByZXR1cm4gfVxuICAgIGlmKHRoaXMuaXNNYWluKCkgJiYgdGhpcy5saXZlU29ja2V0Lmhhc1BlbmRpbmdMaW5rKCkgJiYgcmVhc29uICE9PSBcImxlYXZlXCIpe1xuICAgICAgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMpXG4gICAgfVxuICAgIHRoaXMuZGVzdHJveUFsbENoaWxkcmVuKClcbiAgICB0aGlzLmxpdmVTb2NrZXQuZHJvcEFjdGl2ZUVsZW1lbnQodGhpcylcbiAgICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsIGluIEludGVybmV0IEV4cGxvcmVyIDExXG4gICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCl7IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpIH1cbiAgICBpZih0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXtcbiAgICAgIHRoaXMuc2hvd0xvYWRlcihCRUZPUkVfVU5MT0FEX0xPQURFUl9USU1FT1VUKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IocmVhc29uKXtcbiAgICB0aGlzLm9uQ2xvc2UocmVhc29uKVxuICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXsgdGhpcy5sb2coXCJlcnJvclwiLCAoKSA9PiBbXCJ2aWV3IGNyYXNoZWRcIiwgcmVhc29uXSkgfVxuICAgIGlmKCF0aGlzLmxpdmVTb2NrZXQuaXNVbmxvYWRlZCgpKXtcbiAgICAgIGlmKHRoaXMubGl2ZVNvY2tldC5pc0Nvbm5lY3RlZCgpKXtcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9TRVJWRVJfRVJST1JfQ0xBU1NdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3IoW1BIWF9MT0FESU5HX0NMQVNTLCBQSFhfRVJST1JfQ0xBU1MsIFBIWF9DTElFTlRfRVJST1JfQ0xBU1NdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRpc3BsYXlFcnJvcihjbGFzc2VzKXtcbiAgICBpZih0aGlzLmlzTWFpbigpKXsgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpwYWdlLWxvYWRpbmctc3RhcnRcIiwge2RldGFpbDoge3RvOiB0aGlzLmhyZWYsIGtpbmQ6IFwiZXJyb3JcIn19KSB9XG4gICAgdGhpcy5zaG93TG9hZGVyKClcbiAgICB0aGlzLnNldENvbnRhaW5lckNsYXNzZXMoLi4uY2xhc3NlcylcbiAgICB0aGlzLmRlbGF5ZWREaXNjb25uZWN0ZWQoKVxuICB9XG5cbiAgZGVsYXllZERpc2Nvbm5lY3RlZCgpe1xuICAgIHRoaXMuZGlzY29ubmVjdGVkVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZXhlY0FsbCh0aGlzLmJpbmRpbmcoXCJkaXNjb25uZWN0ZWRcIikpXG4gICAgfSwgdGhpcy5saXZlU29ja2V0LmRpc2Nvbm5lY3RlZFRpbWVvdXQpXG4gIH1cblxuICB3cmFwUHVzaChjYWxsZXJQdXNoLCByZWNlaXZlcyl7XG4gICAgbGV0IGxhdGVuY3kgPSB0aGlzLmxpdmVTb2NrZXQuZ2V0TGF0ZW5jeVNpbSgpXG4gICAgbGV0IHdpdGhMYXRlbmN5ID0gbGF0ZW5jeSA/XG4gICAgICAoY2IpID0+IHNldFRpbWVvdXQoKCkgPT4gIXRoaXMuaXNEZXN0cm95ZWQoKSAmJiBjYigpLCBsYXRlbmN5KSA6XG4gICAgICAoY2IpID0+ICF0aGlzLmlzRGVzdHJveWVkKCkgJiYgY2IoKVxuXG4gICAgd2l0aExhdGVuY3koKCkgPT4ge1xuICAgICAgY2FsbGVyUHVzaCgpXG4gICAgICAgIC5yZWNlaXZlKFwib2tcIiwgcmVzcCA9PiB3aXRoTGF0ZW5jeSgoKSA9PiByZWNlaXZlcy5vayAmJiByZWNlaXZlcy5vayhyZXNwKSkpXG4gICAgICAgIC5yZWNlaXZlKFwiZXJyb3JcIiwgcmVhc29uID0+IHdpdGhMYXRlbmN5KCgpID0+IHJlY2VpdmVzLmVycm9yICYmIHJlY2VpdmVzLmVycm9yKHJlYXNvbikpKVxuICAgICAgICAucmVjZWl2ZShcInRpbWVvdXRcIiwgKCkgPT4gd2l0aExhdGVuY3koKCkgPT4gcmVjZWl2ZXMudGltZW91dCAmJiByZWNlaXZlcy50aW1lb3V0KCkpKVxuICAgIH0pXG4gIH1cblxuICBwdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgZXZlbnQsIHBheWxvYWQpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkpeyByZXR1cm4gUHJvbWlzZS5yZWplY3Qoe2Vycm9yOiBcIm5vY29ubmVjdGlvblwifSkgfVxuXG4gICAgbGV0IFtyZWYsIFtlbF0sIG9wdHNdID0gcmVmR2VuZXJhdG9yID8gcmVmR2VuZXJhdG9yKCkgOiBbbnVsbCwgW10sIHt9XVxuICAgIGxldCBvbGRKb2luQ291bnQgPSB0aGlzLmpvaW5Db3VudFxuICAgIGxldCBvbkxvYWRpbmdEb25lID0gZnVuY3Rpb24oKXt9XG4gICAgaWYob3B0cy5wYWdlX2xvYWRpbmcpe1xuICAgICAgb25Mb2FkaW5nRG9uZSA9IHRoaXMubGl2ZVNvY2tldC53aXRoUGFnZUxvYWRpbmcoe2tpbmQ6IFwiZWxlbWVudFwiLCB0YXJnZXQ6IGVsfSlcbiAgICB9XG5cbiAgICBpZih0eXBlb2YgKHBheWxvYWQuY2lkKSAhPT0gXCJudW1iZXJcIil7IGRlbGV0ZSBwYXlsb2FkLmNpZCB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53cmFwUHVzaCgoKSA9PiB0aGlzLmNoYW5uZWwucHVzaChldmVudCwgcGF5bG9hZCwgUFVTSF9USU1FT1VUKSwge1xuICAgICAgICBvazogKHJlc3ApID0+IHtcbiAgICAgICAgICBpZihyZWYgIT09IG51bGwpeyB0aGlzLmxhc3RBY2tSZWYgPSByZWYgfVxuICAgICAgICAgIGxldCBmaW5pc2ggPSAoaG9va1JlcGx5KSA9PiB7XG4gICAgICAgICAgICBpZihyZXNwLnJlZGlyZWN0KXsgdGhpcy5vblJlZGlyZWN0KHJlc3AucmVkaXJlY3QpIH1cbiAgICAgICAgICAgIGlmKHJlc3AubGl2ZV9wYXRjaCl7IHRoaXMub25MaXZlUGF0Y2gocmVzcC5saXZlX3BhdGNoKSB9XG4gICAgICAgICAgICBpZihyZXNwLmxpdmVfcmVkaXJlY3QpeyB0aGlzLm9uTGl2ZVJlZGlyZWN0KHJlc3AubGl2ZV9yZWRpcmVjdCkgfVxuICAgICAgICAgICAgb25Mb2FkaW5nRG9uZSgpXG4gICAgICAgICAgICByZXNvbHZlKHtyZXNwOiByZXNwLCByZXBseTogaG9va1JlcGx5fSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYocmVzcC5kaWZmKXtcbiAgICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBseURpZmYoXCJ1cGRhdGVcIiwgcmVzcC5kaWZmLCAoe2RpZmYsIHJlcGx5LCBldmVudHN9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYocmVmICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwYXlsb2FkLmV2ZW50KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShkaWZmLCBldmVudHMpXG4gICAgICAgICAgICAgICAgZmluaXNoKHJlcGx5KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYocmVmICE9PSBudWxsKXsgdGhpcy51bmRvUmVmcyhyZWYsIHBheWxvYWQuZXZlbnQpIH1cbiAgICAgICAgICAgIGZpbmlzaChudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChyZWFzb24pID0+IHJlamVjdCh7ZXJyb3I6IHJlYXNvbn0pLFxuICAgICAgICB0aW1lb3V0OiAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KHt0aW1lb3V0OiB0cnVlfSlcbiAgICAgICAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gb2xkSm9pbkNvdW50KXtcbiAgICAgICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZWxvYWRXaXRoSml0dGVyKHRoaXMsICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5sb2coXCJ0aW1lb3V0XCIsICgpID0+IFtcInJlY2VpdmVkIHRpbWVvdXQgd2hpbGUgY29tbXVuaWNhdGluZyB3aXRoIHNlcnZlci4gRmFsbGluZyBiYWNrIHRvIGhhcmQgcmVmcmVzaCBmb3IgcmVjb3ZlcnlcIl0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdW5kb1JlZnMocmVmLCBwaHhFdmVudCwgb25seUVscyl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9IC8vIGV4aXQgaWYgZXh0ZXJuYWwgZm9ybSB0cmlnZ2VyZWRcbiAgICBsZXQgc2VsZWN0b3IgPSBgWyR7UEhYX1JFRl9TUkN9PVwiJHt0aGlzLnJlZlNyYygpfVwiXWBcblxuICAgIGlmKG9ubHlFbHMpe1xuICAgICAgb25seUVscyA9IG5ldyBTZXQob25seUVscylcbiAgICAgIERPTS5hbGwoZG9jdW1lbnQsIHNlbGVjdG9yLCBwYXJlbnQgPT4ge1xuICAgICAgICBpZihvbmx5RWxzICYmICFvbmx5RWxzLmhhcyhwYXJlbnQpKXsgcmV0dXJuIH1cbiAgICAgICAgLy8gdW5kbyBhbnkgY2hpbGQgcmVmcyB3aXRoaW4gcGFyZW50IGZpcnN0XG4gICAgICAgIERPTS5hbGwocGFyZW50LCBzZWxlY3RvciwgY2hpbGQgPT4gdGhpcy51bmRvRWxSZWYoY2hpbGQsIHJlZiwgcGh4RXZlbnQpKVxuICAgICAgICB0aGlzLnVuZG9FbFJlZihwYXJlbnQsIHJlZiwgcGh4RXZlbnQpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBET00uYWxsKGRvY3VtZW50LCBzZWxlY3RvciwgZWwgPT4gdGhpcy51bmRvRWxSZWYoZWwsIHJlZiwgcGh4RXZlbnQpKVxuICAgIH1cbiAgfVxuXG4gIHVuZG9FbFJlZihlbCwgcmVmLCBwaHhFdmVudCl7XG4gICAgbGV0IGVsUmVmID0gbmV3IEVsZW1lbnRSZWYoZWwpXG5cbiAgICBlbFJlZi5tYXliZVVuZG8ocmVmLCBwaHhFdmVudCwgY2xvbmVkVHJlZSA9PiB7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHBlcmZvcm0gYSBmdWxsIHBhdGNoIG9uIHVubG9ja2VkIGVsZW1lbnRzXG4gICAgICAvLyB0byBwZXJmb3JtIGFsbCB0aGUgbmVjZXNzYXJ5IGxvZ2ljIChsaWtlIGNhbGxpbmcgdXBkYXRlZCBmb3IgaG9va3MsIGV0Yy4pXG4gICAgICBsZXQgcGF0Y2ggPSBuZXcgRE9NUGF0Y2godGhpcywgZWwsIHRoaXMuaWQsIGNsb25lZFRyZWUsIFtdLCBudWxsLCB7dW5kb1JlZjogcmVmfSlcbiAgICAgIGNvbnN0IHBoeENoaWxkcmVuQWRkZWQgPSB0aGlzLnBlcmZvcm1QYXRjaChwYXRjaCwgdHJ1ZSlcbiAgICAgIERPTS5hbGwoZWwsIGBbJHtQSFhfUkVGX1NSQ309XCIke3RoaXMucmVmU3JjKCl9XCJdYCwgY2hpbGQgPT4gdGhpcy51bmRvRWxSZWYoY2hpbGQsIHJlZiwgcGh4RXZlbnQpKVxuICAgICAgaWYocGh4Q2hpbGRyZW5BZGRlZCl7IHRoaXMuam9pbk5ld0NoaWxkcmVuKCkgfVxuICAgIH0pXG4gIH1cblxuICByZWZTcmMoKXsgcmV0dXJuIHRoaXMuZWwuaWQgfVxuXG4gIHB1dFJlZihlbGVtZW50cywgcGh4RXZlbnQsIGV2ZW50VHlwZSwgb3B0cyA9IHt9KXtcbiAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYrK1xuICAgIGxldCBkaXNhYmxlV2l0aCA9IHRoaXMuYmluZGluZyhQSFhfRElTQUJMRV9XSVRIKVxuICAgIGlmKG9wdHMubG9hZGluZyl7XG4gICAgICBsZXQgbG9hZGluZ0VscyA9IERPTS5hbGwoZG9jdW1lbnQsIG9wdHMubG9hZGluZykubWFwKGVsID0+IHtcbiAgICAgICAgcmV0dXJuIHtlbCwgbG9jazogdHJ1ZSwgbG9hZGluZzogdHJ1ZX1cbiAgICAgIH0pXG4gICAgICBlbGVtZW50cyA9IGVsZW1lbnRzLmNvbmNhdChsb2FkaW5nRWxzKVxuICAgIH1cblxuICAgIGZvcihsZXQge2VsLCBsb2NrLCBsb2FkaW5nfSBvZiBlbGVtZW50cyl7XG4gICAgICBpZighbG9jayAmJiAhbG9hZGluZyl7IHRocm93IG5ldyBFcnJvcihcInB1dFJlZiByZXF1aXJlcyBsb2NrIG9yIGxvYWRpbmdcIikgfVxuICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfU1JDLCB0aGlzLnJlZlNyYygpKVxuICAgICAgaWYobG9hZGluZyl7IGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGX0xPQURJTkcsIG5ld1JlZikgfVxuICAgICAgaWYobG9jayl7IGVsLnNldEF0dHJpYnV0ZShQSFhfUkVGX0xPQ0ssIG5ld1JlZikgfVxuXG4gICAgICBpZighbG9hZGluZyB8fCAob3B0cy5zdWJtaXR0ZXIgJiYgIShlbCA9PT0gb3B0cy5zdWJtaXR0ZXIgfHwgZWwgPT09IG9wdHMuZm9ybSkpKXsgY29udGludWUgfVxuXG4gICAgICBsZXQgbG9ja0NvbXBsZXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGBwaHg6dW5kby1sb2NrOiR7bmV3UmVmfWAsICgpID0+IHJlc29sdmUoZGV0YWlsKSwge29uY2U6IHRydWV9KVxuICAgICAgfSlcblxuICAgICAgbGV0IGxvYWRpbmdDb21wbGV0ZVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihgcGh4OnVuZG8tbG9hZGluZzoke25ld1JlZn1gLCAoKSA9PiByZXNvbHZlKGRldGFpbCksIHtvbmNlOiB0cnVlfSlcbiAgICAgIH0pXG5cbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoYHBoeC0ke2V2ZW50VHlwZX0tbG9hZGluZ2ApXG4gICAgICBsZXQgZGlzYWJsZVRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoZGlzYWJsZVdpdGgpXG4gICAgICBpZihkaXNhYmxlVGV4dCAhPT0gbnVsbCl7XG4gICAgICAgIGlmKCFlbC5nZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVfV0lUSF9SRVNUT1JFKSl7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKFBIWF9ESVNBQkxFX1dJVEhfUkVTVE9SRSwgZWwuaW5uZXJUZXh0KVxuICAgICAgICB9XG4gICAgICAgIGlmKGRpc2FibGVUZXh0ICE9PSBcIlwiKXsgZWwuaW5uZXJUZXh0ID0gZGlzYWJsZVRleHQgfVxuICAgICAgICAvLyBQSFhfRElTQUJMRUQgY291bGQgaGF2ZSBhbHJlYWR5IGJlZW4gc2V0IGluIGRpc2FibGVGb3JtXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQsIGVsLmdldEF0dHJpYnV0ZShQSFhfRElTQUJMRUQpIHx8IGVsLmRpc2FibGVkKVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKVxuICAgICAgfVxuXG4gICAgICBsZXQgZGV0YWlsID0ge1xuICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgICByZWY6IG5ld1JlZixcbiAgICAgICAgaXNMb2FkaW5nOiBsb2FkaW5nLFxuICAgICAgICBpc0xvY2tlZDogbG9jayxcbiAgICAgICAgbG9ja0VsZW1lbnRzOiBlbGVtZW50cy5maWx0ZXIoKHtsb2NrfSkgPT4gbG9jaykubWFwKCh7ZWx9KSA9PiBlbCksXG4gICAgICAgIGxvYWRpbmdFbGVtZW50czogZWxlbWVudHMuZmlsdGVyKCh7bG9hZGluZ30pID0+IGxvYWRpbmcpLm1hcCgoe2VsfSkgPT4gZWwpLFxuICAgICAgICB1bmxvY2s6IChlbHMpID0+IHtcbiAgICAgICAgICBlbHMgPSBBcnJheS5pc0FycmF5KGVscykgPyBlbHMgOiBbZWxzXVxuICAgICAgICAgIHRoaXMudW5kb1JlZnMobmV3UmVmLCBwaHhFdmVudCwgZWxzKVxuICAgICAgICB9LFxuICAgICAgICBsb2NrQ29tcGxldGU6IGxvY2tDb21wbGV0ZVByb21pc2UsXG4gICAgICAgIGxvYWRpbmdDb21wbGV0ZTogbG9hZGluZ0NvbXBsZXRlUHJvbWlzZSxcbiAgICAgICAgbG9jazogKGxvY2tFbCkgPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGlmKHRoaXMuaXNBY2tlZChuZXdSZWYpKXsgcmV0dXJuIHJlc29sdmUoZGV0YWlsKSB9XG4gICAgICAgICAgICBsb2NrRWwuc2V0QXR0cmlidXRlKFBIWF9SRUZfTE9DSywgbmV3UmVmKVxuICAgICAgICAgICAgbG9ja0VsLnNldEF0dHJpYnV0ZShQSFhfUkVGX1NSQywgdGhpcy5yZWZTcmMoKSlcbiAgICAgICAgICAgIGxvY2tFbC5hZGRFdmVudExpc3RlbmVyKGBwaHg6bG9jay1zdG9wOiR7bmV3UmVmfWAsICgpID0+IHJlc29sdmUoZGV0YWlsKSwge29uY2U6IHRydWV9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwicGh4OnB1c2hcIiwge1xuICAgICAgICBkZXRhaWw6IGRldGFpbCxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogZmFsc2VcbiAgICAgIH0pKVxuICAgICAgaWYocGh4RXZlbnQpe1xuICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChgcGh4OnB1c2g6JHtwaHhFdmVudH1gLCB7XG4gICAgICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBmYWxzZVxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtuZXdSZWYsIGVsZW1lbnRzLm1hcCgoe2VsfSkgPT4gZWwpLCBvcHRzXVxuICB9XG5cbiAgaXNBY2tlZChyZWYpeyByZXR1cm4gdGhpcy5sYXN0QWNrUmVmICE9PSBudWxsICYmIHRoaXMubGFzdEFja1JlZiA+PSByZWYgfVxuXG4gIGNvbXBvbmVudElEKGVsKXtcbiAgICBsZXQgY2lkID0gZWwuZ2V0QXR0cmlidXRlICYmIGVsLmdldEF0dHJpYnV0ZShQSFhfQ09NUE9ORU5UKVxuICAgIHJldHVybiBjaWQgPyBwYXJzZUludChjaWQpIDogbnVsbFxuICB9XG5cbiAgdGFyZ2V0Q29tcG9uZW50SUQodGFyZ2V0LCB0YXJnZXRDdHgsIG9wdHMgPSB7fSl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7IHJldHVybiB0YXJnZXRDdHggfVxuXG4gICAgbGV0IGNpZE9yU2VsZWN0b3IgPSBvcHRzLnRhcmdldCB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhcInRhcmdldFwiKSlcbiAgICBpZihpc0NpZChjaWRPclNlbGVjdG9yKSl7XG4gICAgICByZXR1cm4gcGFyc2VJbnQoY2lkT3JTZWxlY3RvcilcbiAgICB9IGVsc2UgaWYodGFyZ2V0Q3R4ICYmIChjaWRPclNlbGVjdG9yICE9PSBudWxsIHx8IG9wdHMudGFyZ2V0KSl7XG4gICAgICByZXR1cm4gdGhpcy5jbG9zZXN0Q29tcG9uZW50SUQodGFyZ2V0Q3R4KVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpe1xuICAgIGlmKGlzQ2lkKHRhcmdldEN0eCkpe1xuICAgICAgcmV0dXJuIHRhcmdldEN0eFxuICAgIH0gZWxzZSBpZih0YXJnZXRDdHgpe1xuICAgICAgcmV0dXJuIG1heWJlKHRhcmdldEN0eC5jbG9zZXN0KGBbJHtQSFhfQ09NUE9ORU5UfV1gKSwgZWwgPT4gdGhpcy5vd25zRWxlbWVudChlbCkgJiYgdGhpcy5jb21wb25lbnRJRChlbCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcHVzaEhvb2tFdmVudChlbCwgdGFyZ2V0Q3R4LCBldmVudCwgcGF5bG9hZCwgb25SZXBseSl7XG4gICAgaWYoIXRoaXMuaXNDb25uZWN0ZWQoKSl7XG4gICAgICB0aGlzLmxvZyhcImhvb2tcIiwgKCkgPT4gW1widW5hYmxlIHRvIHB1c2ggaG9vayBldmVudC4gTGl2ZVZpZXcgbm90IGNvbm5lY3RlZFwiLCBldmVudCwgcGF5bG9hZF0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgbGV0IFtyZWYsIGVscywgb3B0c10gPSB0aGlzLnB1dFJlZihbe2VsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiB0cnVlfV0sIGV2ZW50LCBcImhvb2tcIilcbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkoKCkgPT4gW3JlZiwgZWxzLCBvcHRzXSwgXCJldmVudFwiLCB7XG4gICAgICB0eXBlOiBcImhvb2tcIixcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIHZhbHVlOiBwYXlsb2FkLFxuICAgICAgY2lkOiB0aGlzLmNsb3Nlc3RDb21wb25lbnRJRCh0YXJnZXRDdHgpXG4gICAgfSkudGhlbigoe3Jlc3A6IF9yZXNwLCByZXBseTogaG9va1JlcGx5fSkgPT4gb25SZXBseShob29rUmVwbHksIHJlZikpXG5cbiAgICByZXR1cm4gcmVmXG4gIH1cblxuICBleHRyYWN0TWV0YShlbCwgbWV0YSwgdmFsdWUpe1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmJpbmRpbmcoXCJ2YWx1ZS1cIilcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgZWwuYXR0cmlidXRlcy5sZW5ndGg7IGkrKyl7XG4gICAgICBpZighbWV0YSl7IG1ldGEgPSB7fSB9XG4gICAgICBsZXQgbmFtZSA9IGVsLmF0dHJpYnV0ZXNbaV0ubmFtZVxuICAgICAgaWYobmFtZS5zdGFydHNXaXRoKHByZWZpeCkpeyBtZXRhW25hbWUucmVwbGFjZShwcmVmaXgsIFwiXCIpXSA9IGVsLmdldEF0dHJpYnV0ZShuYW1lKSB9XG4gICAgfVxuICAgIGlmKGVsLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgIShlbCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCkpe1xuICAgICAgaWYoIW1ldGEpeyBtZXRhID0ge30gfVxuICAgICAgbWV0YS52YWx1ZSA9IGVsLnZhbHVlXG5cbiAgICAgIGlmKGVsLnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiBDSEVDS0FCTEVfSU5QVVRTLmluZGV4T2YoZWwudHlwZSkgPj0gMCAmJiAhZWwuY2hlY2tlZCl7XG4gICAgICAgIGRlbGV0ZSBtZXRhLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHZhbHVlKXtcbiAgICAgIGlmKCFtZXRhKXsgbWV0YSA9IHt9IH1cbiAgICAgIGZvcihsZXQga2V5IGluIHZhbHVlKXsgbWV0YVtrZXldID0gdmFsdWVba2V5XSB9XG4gICAgfVxuICAgIHJldHVybiBtZXRhXG4gIH1cblxuICBwdXNoRXZlbnQodHlwZSwgZWwsIHRhcmdldEN0eCwgcGh4RXZlbnQsIG1ldGEsIG9wdHMgPSB7fSwgb25SZXBseSl7XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KCgpID0+IHRoaXMucHV0UmVmKFt7ZWwsIGxvYWRpbmc6IHRydWUsIGxvY2s6IHRydWV9XSwgcGh4RXZlbnQsIHR5cGUsIG9wdHMpLCBcImV2ZW50XCIsIHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICB2YWx1ZTogdGhpcy5leHRyYWN0TWV0YShlbCwgbWV0YSwgb3B0cy52YWx1ZSksXG4gICAgICBjaWQ6IHRoaXMudGFyZ2V0Q29tcG9uZW50SUQoZWwsIHRhcmdldEN0eCwgb3B0cylcbiAgICB9KS50aGVuKCh7cmVwbHl9KSA9PiBvblJlcGx5ICYmIG9uUmVwbHkocmVwbHkpKVxuICB9XG5cbiAgcHVzaEZpbGVQcm9ncmVzcyhmaWxlRWwsIGVudHJ5UmVmLCBwcm9ncmVzcywgb25SZXBseSA9IGZ1bmN0aW9uICgpeyB9KXtcbiAgICB0aGlzLmxpdmVTb2NrZXQud2l0aGluT3duZXJzKGZpbGVFbC5mb3JtLCAodmlldywgdGFyZ2V0Q3R4KSA9PiB7XG4gICAgICB2aWV3LnB1c2hXaXRoUmVwbHkobnVsbCwgXCJwcm9ncmVzc1wiLCB7XG4gICAgICAgIGV2ZW50OiBmaWxlRWwuZ2V0QXR0cmlidXRlKHZpZXcuYmluZGluZyhQSFhfUFJPR1JFU1MpKSxcbiAgICAgICAgcmVmOiBmaWxlRWwuZ2V0QXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSxcbiAgICAgICAgZW50cnlfcmVmOiBlbnRyeVJlZixcbiAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzLFxuICAgICAgICBjaWQ6IHZpZXcudGFyZ2V0Q29tcG9uZW50SUQoZmlsZUVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH0pLnRoZW4oKHtyZXNwfSkgPT4gb25SZXBseShyZXNwKSlcbiAgICB9KVxuICB9XG5cbiAgcHVzaElucHV0KGlucHV0RWwsIHRhcmdldEN0eCwgZm9yY2VDaWQsIHBoeEV2ZW50LCBvcHRzLCBjYWxsYmFjayl7XG4gICAgaWYoIWlucHV0RWwuZm9ybSl7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmb3JtIGV2ZW50cyByZXF1aXJlIHRoZSBpbnB1dCB0byBiZSBpbnNpZGUgYSBmb3JtXCIpXG4gICAgfVxuXG4gICAgbGV0IHVwbG9hZHNcbiAgICBsZXQgY2lkID0gaXNDaWQoZm9yY2VDaWQpID8gZm9yY2VDaWQgOiB0aGlzLnRhcmdldENvbXBvbmVudElEKGlucHV0RWwuZm9ybSwgdGFyZ2V0Q3R4LCBvcHRzKVxuICAgIGxldCByZWZHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5wdXRSZWYoW1xuICAgICAgICB7ZWw6IGlucHV0RWwsIGxvYWRpbmc6IHRydWUsIGxvY2s6IHRydWV9LFxuICAgICAgICB7ZWw6IGlucHV0RWwuZm9ybSwgbG9hZGluZzogdHJ1ZSwgbG9jazogdHJ1ZX1cbiAgICAgIF0sIHBoeEV2ZW50LCBcImNoYW5nZVwiLCBvcHRzKVxuICAgIH1cbiAgICBsZXQgZm9ybURhdGFcbiAgICBsZXQgbWV0YSA9IHRoaXMuZXh0cmFjdE1ldGEoaW5wdXRFbC5mb3JtLCB7fSwgb3B0cy52YWx1ZSlcbiAgICBsZXQgc2VyaWFsaXplT3B0cyA9IHt9XG4gICAgaWYoaW5wdXRFbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KXsgc2VyaWFsaXplT3B0cy5zdWJtaXR0ZXIgPSBpbnB1dEVsIH1cbiAgICBpZihpbnB1dEVsLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpKXtcbiAgICAgIGZvcm1EYXRhID0gc2VyaWFsaXplRm9ybShpbnB1dEVsLmZvcm0sIHNlcmlhbGl6ZU9wdHMsIFtpbnB1dEVsLm5hbWVdKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oaW5wdXRFbC5mb3JtLCBzZXJpYWxpemVPcHRzKVxuICAgIH1cbiAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBpbnB1dEVsLmZpbGVzICYmIGlucHV0RWwuZmlsZXMubGVuZ3RoID4gMCl7XG4gICAgICBMaXZlVXBsb2FkZXIudHJhY2tGaWxlcyhpbnB1dEVsLCBBcnJheS5mcm9tKGlucHV0RWwuZmlsZXMpKVxuICAgIH1cbiAgICB1cGxvYWRzID0gTGl2ZVVwbG9hZGVyLnNlcmlhbGl6ZVVwbG9hZHMoaW5wdXRFbClcblxuICAgIGxldCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwiZm9ybVwiLFxuICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgbWV0YToge190YXJnZXQ6IG9wdHMuX3RhcmdldCwgLi4ubWV0YX0sXG4gICAgICB1cGxvYWRzOiB1cGxvYWRzLFxuICAgICAgY2lkOiBjaWRcbiAgICB9XG4gICAgdGhpcy5wdXNoV2l0aFJlcGx5KHJlZkdlbmVyYXRvciwgXCJldmVudFwiLCBldmVudCkudGhlbigoe3Jlc3B9KSA9PiB7XG4gICAgICBpZihET00uaXNVcGxvYWRJbnB1dChpbnB1dEVsKSAmJiBET00uaXNBdXRvVXBsb2FkKGlucHV0RWwpKXtcbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgY291bGQgYmUgaW5zaWRlIGEgbG9ja2VkIHBhcmVudCBmb3Igb3RoZXIgdW5yZWxhdGVkIGNoYW5nZXM7XG4gICAgICAgIC8vIHdlIGNhbiBvbmx5IHN0YXJ0IHVwbG9hZHMgd2hlbiB0aGUgdHJlZSBpcyB1bmxvY2tlZCBhbmQgdGhlXG4gICAgICAgIC8vIG5lY2Vzc2FyeSBkYXRhIGF0dHJpYnV0ZXMgYXJlIHNldCBpbiB0aGUgcmVhbCBET01cbiAgICAgICAgRWxlbWVudFJlZi5vblVubG9jayhpbnB1dEVsLCAoKSA9PiB7XG4gICAgICAgICAgaWYoTGl2ZVVwbG9hZGVyLmZpbGVzQXdhaXRpbmdQcmVmbGlnaHQoaW5wdXRFbCkubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICBsZXQgW3JlZiwgX2Vsc10gPSByZWZHZW5lcmF0b3IoKVxuICAgICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYsIHBoeEV2ZW50LCBbaW5wdXRFbC5mb3JtXSlcbiAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoaW5wdXRFbC5mb3JtLCBwaHhFdmVudCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgKF91cGxvYWRzKSA9PiB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHJlc3ApXG4gICAgICAgICAgICAgIHRoaXMudHJpZ2dlckF3YWl0aW5nU3VibWl0KGlucHV0RWwuZm9ybSwgcGh4RXZlbnQpXG4gICAgICAgICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwaHhFdmVudClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVzcClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgdHJpZ2dlckF3YWl0aW5nU3VibWl0KGZvcm1FbCwgcGh4RXZlbnQpe1xuICAgIGxldCBhd2FpdGluZ1N1Ym1pdCA9IHRoaXMuZ2V0U2NoZWR1bGVkU3VibWl0KGZvcm1FbClcbiAgICBpZihhd2FpdGluZ1N1Ym1pdCl7XG4gICAgICBsZXQgW19lbCwgX3JlZiwgX29wdHMsIGNhbGxiYWNrXSA9IGF3YWl0aW5nU3VibWl0XG4gICAgICB0aGlzLmNhbmNlbFN1Ym1pdChmb3JtRWwsIHBoeEV2ZW50KVxuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIGdldFNjaGVkdWxlZFN1Ym1pdChmb3JtRWwpe1xuICAgIHJldHVybiB0aGlzLmZvcm1TdWJtaXRzLmZpbmQoKFtlbCwgX3JlZiwgX29wdHMsIF9jYWxsYmFja10pID0+IGVsLmlzU2FtZU5vZGUoZm9ybUVsKSlcbiAgfVxuXG4gIHNjaGVkdWxlU3VibWl0KGZvcm1FbCwgcmVmLCBvcHRzLCBjYWxsYmFjayl7XG4gICAgaWYodGhpcy5nZXRTY2hlZHVsZWRTdWJtaXQoZm9ybUVsKSl7IHJldHVybiB0cnVlIH1cbiAgICB0aGlzLmZvcm1TdWJtaXRzLnB1c2goW2Zvcm1FbCwgcmVmLCBvcHRzLCBjYWxsYmFja10pXG4gIH1cblxuICBjYW5jZWxTdWJtaXQoZm9ybUVsLCBwaHhFdmVudCl7XG4gICAgdGhpcy5mb3JtU3VibWl0cyA9IHRoaXMuZm9ybVN1Ym1pdHMuZmlsdGVyKChbZWwsIHJlZiwgX29wdHMsIF9jYWxsYmFja10pID0+IHtcbiAgICAgIGlmKGVsLmlzU2FtZU5vZGUoZm9ybUVsKSl7XG4gICAgICAgIHRoaXMudW5kb1JlZnMocmVmLCBwaHhFdmVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkaXNhYmxlRm9ybShmb3JtRWwsIHBoeEV2ZW50LCBvcHRzID0ge30pe1xuICAgIGxldCBmaWx0ZXJJZ25vcmVkID0gZWwgPT4ge1xuICAgICAgbGV0IHVzZXJJZ25vcmVkID0gY2xvc2VzdFBoeEJpbmRpbmcoZWwsIGAke3RoaXMuYmluZGluZyhQSFhfVVBEQVRFKX09aWdub3JlYCwgZWwuZm9ybSlcbiAgICAgIHJldHVybiAhKHVzZXJJZ25vcmVkIHx8IGNsb3Nlc3RQaHhCaW5kaW5nKGVsLCBcImRhdGEtcGh4LXVwZGF0ZT1pZ25vcmVcIiwgZWwuZm9ybSkpXG4gICAgfVxuICAgIGxldCBmaWx0ZXJEaXNhYmxlcyA9IGVsID0+IHtcbiAgICAgIHJldHVybiBlbC5oYXNBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9ESVNBQkxFX1dJVEgpKVxuICAgIH1cbiAgICBsZXQgZmlsdGVyQnV0dG9uID0gZWwgPT4gZWwudGFnTmFtZSA9PSBcIkJVVFRPTlwiXG5cbiAgICBsZXQgZmlsdGVySW5wdXQgPSBlbCA9PiBbXCJJTlBVVFwiLCBcIlRFWFRBUkVBXCIsIFwiU0VMRUNUXCJdLmluY2x1ZGVzKGVsLnRhZ05hbWUpXG5cbiAgICBsZXQgZm9ybUVsZW1lbnRzID0gQXJyYXkuZnJvbShmb3JtRWwuZWxlbWVudHMpXG4gICAgbGV0IGRpc2FibGVzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJEaXNhYmxlcylcbiAgICBsZXQgYnV0dG9ucyA9IGZvcm1FbGVtZW50cy5maWx0ZXIoZmlsdGVyQnV0dG9uKS5maWx0ZXIoZmlsdGVySWdub3JlZClcbiAgICBsZXQgaW5wdXRzID0gZm9ybUVsZW1lbnRzLmZpbHRlcihmaWx0ZXJJbnB1dCkuZmlsdGVyKGZpbHRlcklnbm9yZWQpXG5cbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBidXR0b24uZGlzYWJsZWQpXG4gICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlXG4gICAgfSlcbiAgICBpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiB7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX1JFQURPTkxZLCBpbnB1dC5yZWFkT25seSlcbiAgICAgIGlucHV0LnJlYWRPbmx5ID0gdHJ1ZVxuICAgICAgaWYoaW5wdXQuZmlsZXMpe1xuICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoUEhYX0RJU0FCTEVELCBpbnB1dC5kaXNhYmxlZClcbiAgICAgICAgaW5wdXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB9XG4gICAgfSlcbiAgICBsZXQgZm9ybUVscyA9IGRpc2FibGVzLmNvbmNhdChidXR0b25zKS5jb25jYXQoaW5wdXRzKS5tYXAoZWwgPT4ge1xuICAgICAgcmV0dXJuIHtlbCwgbG9hZGluZzogdHJ1ZSwgbG9jazogdHJ1ZX1cbiAgICB9KVxuXG4gICAgLy8gd2UgcmV2ZXJzZSB0aGUgb3JkZXIgc28gZm9ybSBjaGlsZHJlbiBhcmUgYWxyZWFkeSBsb2NrZWQgYnkgdGhlIHRpbWVcbiAgICAvLyB0aGUgZm9ybSBpcyBsb2NrZWRcbiAgICBsZXQgZWxzID0gW3tlbDogZm9ybUVsLCBsb2FkaW5nOiB0cnVlLCBsb2NrOiBmYWxzZX1dLmNvbmNhdChmb3JtRWxzKS5yZXZlcnNlKClcbiAgICByZXR1cm4gdGhpcy5wdXRSZWYoZWxzLCBwaHhFdmVudCwgXCJzdWJtaXRcIiwgb3B0cylcbiAgfVxuXG4gIHB1c2hGb3JtU3VibWl0KGZvcm1FbCwgdGFyZ2V0Q3R4LCBwaHhFdmVudCwgc3VibWl0dGVyLCBvcHRzLCBvblJlcGx5KXtcbiAgICBsZXQgcmVmR2VuZXJhdG9yID0gKCkgPT4gdGhpcy5kaXNhYmxlRm9ybShmb3JtRWwsIHBoeEV2ZW50LCB7XG4gICAgICAuLi5vcHRzLFxuICAgICAgZm9ybTogZm9ybUVsLFxuICAgICAgc3VibWl0dGVyOiBzdWJtaXR0ZXJcbiAgICB9KVxuICAgIGxldCBjaWQgPSB0aGlzLnRhcmdldENvbXBvbmVudElEKGZvcm1FbCwgdGFyZ2V0Q3R4KVxuICAgIGlmKExpdmVVcGxvYWRlci5oYXNVcGxvYWRzSW5Qcm9ncmVzcyhmb3JtRWwpKXtcbiAgICAgIGxldCBbcmVmLCBfZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHVzaCA9ICgpID0+IHRoaXMucHVzaEZvcm1TdWJtaXQoZm9ybUVsLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBzdWJtaXR0ZXIsIG9wdHMsIG9uUmVwbHkpXG4gICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVN1Ym1pdChmb3JtRWwsIHJlZiwgb3B0cywgcHVzaClcbiAgICB9IGVsc2UgaWYoTGl2ZVVwbG9hZGVyLmlucHV0c0F3YWl0aW5nUHJlZmxpZ2h0KGZvcm1FbCkubGVuZ3RoID4gMCl7XG4gICAgICBsZXQgW3JlZiwgZWxzXSA9IHJlZkdlbmVyYXRvcigpXG4gICAgICBsZXQgcHJveHlSZWZHZW4gPSAoKSA9PiBbcmVmLCBlbHMsIG9wdHNdXG4gICAgICB0aGlzLnVwbG9hZEZpbGVzKGZvcm1FbCwgcGh4RXZlbnQsIHRhcmdldEN0eCwgcmVmLCBjaWQsIChfdXBsb2FkcykgPT4ge1xuICAgICAgICAvLyBpZiB3ZSBzdGlsbCBoYXZpbmcgcGVuZGluZyBwcmVmbGlnaHRzIGl0IG1lYW5zIHdlIGhhdmUgaW52YWxpZCBlbnRyaWVzXG4gICAgICAgIC8vIGFuZCB0aGUgcGh4LXN1Ym1pdCBjYW5ub3QgYmUgY29tcGxldGVkXG4gICAgICAgIGlmKExpdmVVcGxvYWRlci5pbnB1dHNBd2FpdGluZ1ByZWZsaWdodChmb3JtRWwpLmxlbmd0aCA+IDApe1xuICAgICAgICAgIHJldHVybiB0aGlzLnVuZG9SZWZzKHJlZiwgcGh4RXZlbnQpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGEgPSB0aGlzLmV4dHJhY3RNZXRhKGZvcm1FbCwge30sIG9wdHMudmFsdWUpXG4gICAgICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsLCB7c3VibWl0dGVyfSlcbiAgICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KHByb3h5UmVmR2VuLCBcImV2ZW50XCIsIHtcbiAgICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgICBldmVudDogcGh4RXZlbnQsXG4gICAgICAgICAgdmFsdWU6IGZvcm1EYXRhLFxuICAgICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgICAgY2lkOiBjaWRcbiAgICAgICAgfSkudGhlbigoe3Jlc3B9KSA9PiBvblJlcGx5KHJlc3ApKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYoIShmb3JtRWwuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSAmJiBmb3JtRWwuY2xhc3NMaXN0LmNvbnRhaW5zKFwicGh4LXN1Ym1pdC1sb2FkaW5nXCIpKSl7XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZXh0cmFjdE1ldGEoZm9ybUVsLCB7fSwgb3B0cy52YWx1ZSlcbiAgICAgIGxldCBmb3JtRGF0YSA9IHNlcmlhbGl6ZUZvcm0oZm9ybUVsLCB7c3VibWl0dGVyfSlcbiAgICAgIHRoaXMucHVzaFdpdGhSZXBseShyZWZHZW5lcmF0b3IsIFwiZXZlbnRcIiwge1xuICAgICAgICB0eXBlOiBcImZvcm1cIixcbiAgICAgICAgZXZlbnQ6IHBoeEV2ZW50LFxuICAgICAgICB2YWx1ZTogZm9ybURhdGEsXG4gICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgIGNpZDogY2lkXG4gICAgICB9KS50aGVuKCh7cmVzcH0pID0+IG9uUmVwbHkocmVzcCkpXG4gICAgfVxuICB9XG5cbiAgdXBsb2FkRmlsZXMoZm9ybUVsLCBwaHhFdmVudCwgdGFyZ2V0Q3R4LCByZWYsIGNpZCwgb25Db21wbGV0ZSl7XG4gICAgbGV0IGpvaW5Db3VudEF0VXBsb2FkID0gdGhpcy5qb2luQ291bnRcbiAgICBsZXQgaW5wdXRFbHMgPSBMaXZlVXBsb2FkZXIuYWN0aXZlRmlsZUlucHV0cyhmb3JtRWwpXG4gICAgbGV0IG51bUZpbGVJbnB1dHNJblByb2dyZXNzID0gaW5wdXRFbHMubGVuZ3RoXG5cbiAgICAvLyBnZXQgZWFjaCBmaWxlIGlucHV0XG4gICAgaW5wdXRFbHMuZm9yRWFjaChpbnB1dEVsID0+IHtcbiAgICAgIGxldCB1cGxvYWRlciA9IG5ldyBMaXZlVXBsb2FkZXIoaW5wdXRFbCwgdGhpcywgKCkgPT4ge1xuICAgICAgICBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcy0tXG4gICAgICAgIGlmKG51bUZpbGVJbnB1dHNJblByb2dyZXNzID09PSAwKXsgb25Db21wbGV0ZSgpIH1cbiAgICAgIH0pXG5cbiAgICAgIGxldCBlbnRyaWVzID0gdXBsb2FkZXIuZW50cmllcygpLm1hcChlbnRyeSA9PiBlbnRyeS50b1ByZWZsaWdodFBheWxvYWQoKSlcblxuICAgICAgaWYoZW50cmllcy5sZW5ndGggPT09IDApe1xuICAgICAgICBudW1GaWxlSW5wdXRzSW5Qcm9ncmVzcy0tXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgcGF5bG9hZCA9IHtcbiAgICAgICAgcmVmOiBpbnB1dEVsLmdldEF0dHJpYnV0ZShQSFhfVVBMT0FEX1JFRiksXG4gICAgICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgICAgIGNpZDogdGhpcy50YXJnZXRDb21wb25lbnRJRChpbnB1dEVsLmZvcm0sIHRhcmdldEN0eClcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW1wic2VuZGluZyBwcmVmbGlnaHQgcmVxdWVzdFwiLCBwYXlsb2FkXSlcblxuICAgICAgdGhpcy5wdXNoV2l0aFJlcGx5KG51bGwsIFwiYWxsb3dfdXBsb2FkXCIsIHBheWxvYWQpLnRoZW4oKHtyZXNwfSkgPT4ge1xuICAgICAgICB0aGlzLmxvZyhcInVwbG9hZFwiLCAoKSA9PiBbXCJnb3QgcHJlZmxpZ2h0IHJlc3BvbnNlXCIsIHJlc3BdKVxuICAgICAgICAvLyB0aGUgcHJlZmxpZ2h0IHdpbGwgcmVqZWN0IGVudHJpZXMgYmV5b25kIHRoZSBtYXggZW50cmllc1xuICAgICAgICAvLyBzbyB3ZSBlcnJvciBhbmQgY2FuY2VsIGVudHJpZXMgb24gdGhlIGNsaWVudCB0aGF0IGFyZSBtaXNzaW5nIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgIHVwbG9hZGVyLmVudHJpZXMoKS5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICBpZihyZXNwLmVudHJpZXMgJiYgIXJlc3AuZW50cmllc1tlbnRyeS5yZWZdKXtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRmFpbGVkRW50cnlQcmVmbGlnaHQoZW50cnkucmVmLCBcImZhaWxlZCBwcmVmbGlnaHRcIiwgdXBsb2FkZXIpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAvLyBmb3IgYXV0byB1cGxvYWRzLCB3ZSBtYXkgaGF2ZSBhbiBlbXB0eSBlbnRyaWVzIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAvLyBmb3IgZm9ybSBzdWJtaXRzIHRoYXQgY29udGFpbiBpbnZhbGlkIGVudHJpZXNcbiAgICAgICAgaWYocmVzcC5lcnJvciB8fCBPYmplY3Qua2V5cyhyZXNwLmVudHJpZXMpLmxlbmd0aCA9PT0gMCl7XG4gICAgICAgICAgdGhpcy51bmRvUmVmcyhyZWYsIHBoeEV2ZW50KVxuICAgICAgICAgIGxldCBlcnJvcnMgPSByZXNwLmVycm9yIHx8IFtdXG4gICAgICAgICAgZXJyb3JzLm1hcCgoW2VudHJ5X3JlZiwgcmVhc29uXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVGYWlsZWRFbnRyeVByZWZsaWdodChlbnRyeV9yZWYsIHJlYXNvbiwgdXBsb2FkZXIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgb25FcnJvciA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLm9uRXJyb3IoKCkgPT4ge1xuICAgICAgICAgICAgICBpZih0aGlzLmpvaW5Db3VudCA9PT0gam9pbkNvdW50QXRVcGxvYWQpeyBjYWxsYmFjaygpIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwbG9hZGVyLmluaXRBZGFwdGVyVXBsb2FkKHJlc3AsIG9uRXJyb3IsIHRoaXMubGl2ZVNvY2tldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlRmFpbGVkRW50cnlQcmVmbGlnaHQodXBsb2FkUmVmLCByZWFzb24sIHVwbG9hZGVyKXtcbiAgICBpZih1cGxvYWRlci5pc0F1dG9VcGxvYWQoKSl7XG4gICAgICAvLyB1cGxvYWRSZWYgbWF5IGJlIHRvcCBsZXZlbCB1cGxvYWQgY29uZmlnIHJlZiBvciBlbnRyeSByZWZcbiAgICAgIGxldCBlbnRyeSA9IHVwbG9hZGVyLmVudHJpZXMoKS5maW5kKGVudHJ5ID0+IGVudHJ5LnJlZiA9PT0gdXBsb2FkUmVmLnRvU3RyaW5nKCkpXG4gICAgICBpZihlbnRyeSl7IGVudHJ5LmNhbmNlbCgpIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBsb2FkZXIuZW50cmllcygpLm1hcChlbnRyeSA9PiBlbnRyeS5jYW5jZWwoKSlcbiAgICB9XG4gICAgdGhpcy5sb2coXCJ1cGxvYWRcIiwgKCkgPT4gW2BlcnJvciBmb3IgZW50cnkgJHt1cGxvYWRSZWZ9YCwgcmVhc29uXSlcbiAgfVxuXG4gIGRpc3BhdGNoVXBsb2Fkcyh0YXJnZXRDdHgsIG5hbWUsIGZpbGVzT3JCbG9icyl7XG4gICAgbGV0IHRhcmdldEVsZW1lbnQgPSB0aGlzLnRhcmdldEN0eEVsZW1lbnQodGFyZ2V0Q3R4KSB8fCB0aGlzLmVsXG4gICAgbGV0IGlucHV0cyA9IERPTS5maW5kVXBsb2FkSW5wdXRzKHRhcmdldEVsZW1lbnQpLmZpbHRlcihlbCA9PiBlbC5uYW1lID09PSBuYW1lKVxuICAgIGlmKGlucHV0cy5sZW5ndGggPT09IDApeyBsb2dFcnJvcihgbm8gbGl2ZSBmaWxlIGlucHV0cyBmb3VuZCBtYXRjaGluZyB0aGUgbmFtZSBcIiR7bmFtZX1cImApIH1cbiAgICBlbHNlIGlmKGlucHV0cy5sZW5ndGggPiAxKXsgbG9nRXJyb3IoYGR1cGxpY2F0ZSBsaXZlIGZpbGUgaW5wdXRzIGZvdW5kIG1hdGNoaW5nIHRoZSBuYW1lIFwiJHtuYW1lfVwiYCkgfVxuICAgIGVsc2UgeyBET00uZGlzcGF0Y2hFdmVudChpbnB1dHNbMF0sIFBIWF9UUkFDS19VUExPQURTLCB7ZGV0YWlsOiB7ZmlsZXM6IGZpbGVzT3JCbG9ic319KSB9XG4gIH1cblxuICB0YXJnZXRDdHhFbGVtZW50KHRhcmdldEN0eCl7XG4gICAgaWYoaXNDaWQodGFyZ2V0Q3R4KSl7XG4gICAgICBsZXQgW3RhcmdldF0gPSBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIHRhcmdldEN0eClcbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9IGVsc2UgaWYodGFyZ2V0Q3R4KXtcbiAgICAgIHJldHVybiB0YXJnZXRDdHhcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICBwdXNoRm9ybVJlY292ZXJ5KG9sZEZvcm0sIG5ld0Zvcm0sIHRlbXBsYXRlRG9tLCBjYWxsYmFjayl7XG4gICAgLy8gd2UgYXJlIG9ubHkgcmVjb3ZlcmluZyBmb3JtcyBpbnNpZGUgdGhlIGN1cnJlbnQgdmlldywgdGhlcmVmb3JlIGl0IGlzIHNhZmUgdG9cbiAgICAvLyBza2lwIHdpdGhpbk93bmVycyBoZXJlIGFuZCBhbHdheXMgdXNlIHRoaXMgd2hlbiByZWZlcnJpbmcgdG8gdGhlIHZpZXdcbiAgICBjb25zdCBwaHhDaGFuZ2UgPSB0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIilcbiAgICBjb25zdCBwaHhUYXJnZXQgPSBuZXdGb3JtLmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJ0YXJnZXRcIikpIHx8IG5ld0Zvcm1cbiAgICBjb25zdCBwaHhFdmVudCA9IG5ld0Zvcm0uZ2V0QXR0cmlidXRlKHRoaXMuYmluZGluZyhQSFhfQVVUT19SRUNPVkVSKSkgfHwgbmV3Rm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2hhbmdlXCIpKVxuICAgIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20ob2xkRm9ybS5lbGVtZW50cykuZmlsdGVyKGVsID0+IERPTS5pc0Zvcm1JbnB1dChlbCkgJiYgZWwubmFtZSAmJiAhZWwuaGFzQXR0cmlidXRlKHBoeENoYW5nZSkpXG4gICAgaWYoaW5wdXRzLmxlbmd0aCA9PT0gMCl7IHJldHVybiB9XG5cbiAgICAvLyB3ZSBtdXN0IGNsZWFyIHRyYWNrZWQgdXBsb2FkcyBiZWZvcmUgcmVjb3ZlcnkgYXMgdGhleSBubyBsb25nZXIgaGF2ZSB2YWxpZCByZWZzXG4gICAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4gaW5wdXQuaGFzQXR0cmlidXRlKFBIWF9VUExPQURfUkVGKSAmJiBMaXZlVXBsb2FkZXIuY2xlYXJGaWxlcyhpbnB1dCkpXG4gICAgLy8gcHVzaElucHV0IGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIHNvdXJjZSBlbGVtZW50IHRoYXQgaW5pdGlhdGVkIHRoZSBjaGFuZ2U7XG4gICAgLy8gYmVjYXVzZSB0aGlzIGlzIG5vdCB0aGUgY2FzZSB3aGVuIHdlIHJlY292ZXIgZm9ybXMsIHdlIHByb3ZpZGUgdGhlIGZpcnN0IGlucHV0IHdlIGZpbmRcbiAgICBsZXQgaW5wdXQgPSBpbnB1dHMuZmluZChlbCA9PiBlbC50eXBlICE9PSBcImhpZGRlblwiKSB8fCBpbnB1dHNbMF1cblxuICAgIC8vIGluIHRoZSBjYXNlIHRoYXQgdGhlcmUgYXJlIG11bHRpcGxlIHRhcmdldHMsIHdlIGNvdW50IHRoZSBudW1iZXIgb2YgcGVuZGluZyByZWNvdmVyeSBldmVudHNcbiAgICAvLyBhbmQgb25seSBjYWxsIHRoZSBjYWxsYmFjayBvbmNlIGFsbCBldmVudHMgaGF2ZSBiZWVuIHByb2Nlc3NlZFxuICAgIGxldCBwZW5kaW5nID0gMFxuICAgIC8vIHdpdGhpblRhcmdldHMocGh4VGFyZ2V0LCBjYWxsYmFjaywgZG9tLCB2aWV3RWwpXG4gICAgdGhpcy53aXRoaW5UYXJnZXRzKHBoeFRhcmdldCwgKHRhcmdldFZpZXcsIHRhcmdldEN0eCkgPT4ge1xuICAgICAgY29uc3QgY2lkID0gdGhpcy50YXJnZXRDb21wb25lbnRJRChuZXdGb3JtLCB0YXJnZXRDdHgpXG4gICAgICBwZW5kaW5nKytcbiAgICAgIGxldCBlID0gbmV3IEN1c3RvbUV2ZW50KFwicGh4OmZvcm0tcmVjb3ZlcnlcIiwge2RldGFpbDoge3NvdXJjZUVsZW1lbnQ6IG9sZEZvcm19fSlcbiAgICAgIEpTLmV4ZWMoZSwgXCJjaGFuZ2VcIiwgcGh4RXZlbnQsIHRoaXMsIGlucHV0LCBbXCJwdXNoXCIsIHtcbiAgICAgICAgX3RhcmdldDogaW5wdXQubmFtZSxcbiAgICAgICAgdGFyZ2V0VmlldyxcbiAgICAgICAgdGFyZ2V0Q3R4LFxuICAgICAgICBuZXdDaWQ6IGNpZCxcbiAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICBwZW5kaW5nLS1cbiAgICAgICAgICBpZihwZW5kaW5nID09PSAwKXsgY2FsbGJhY2soKSB9XG4gICAgICAgIH1cbiAgICAgIH1dKVxuICAgIH0sIHRlbXBsYXRlRG9tLCB0ZW1wbGF0ZURvbSlcbiAgfVxuXG4gIHB1c2hMaW5rUGF0Y2goZSwgaHJlZiwgdGFyZ2V0RWwsIGNhbGxiYWNrKXtcbiAgICBsZXQgbGlua1JlZiA9IHRoaXMubGl2ZVNvY2tldC5zZXRQZW5kaW5nTGluayhocmVmKVxuICAgIC8vIG9ubHkgYWRkIGxvYWRpbmcgc3RhdGVzIGlmIGV2ZW50IGlzIHRydXN0ZWQgKGl0IHdhcyB0cmlnZ2VyZWQgYnkgdXNlciwgc3VjaCBhcyBjbGljaykgYW5kXG4gICAgLy8gaXQncyBub3QgYSBmb3J3YXJkL2JhY2sgbmF2aWdhdGlvbiBmcm9tIHBvcHN0YXRlXG4gICAgbGV0IGxvYWRpbmcgPSBlLmlzVHJ1c3RlZCAmJiBlLnR5cGUgIT09IFwicG9wc3RhdGVcIlxuICAgIGxldCByZWZHZW4gPSB0YXJnZXRFbCA/ICgpID0+IHRoaXMucHV0UmVmKFt7ZWw6IHRhcmdldEVsLCBsb2FkaW5nOiBsb2FkaW5nLCBsb2NrOiB0cnVlfV0sIG51bGwsIFwiY2xpY2tcIikgOiBudWxsXG4gICAgbGV0IGZhbGxiYWNrID0gKCkgPT4gdGhpcy5saXZlU29ja2V0LnJlZGlyZWN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgIGxldCB1cmwgPSBocmVmLnN0YXJ0c1dpdGgoXCIvXCIpID8gYCR7bG9jYXRpb24ucHJvdG9jb2x9Ly8ke2xvY2F0aW9uLmhvc3R9JHtocmVmfWAgOiBocmVmXG5cbiAgICB0aGlzLnB1c2hXaXRoUmVwbHkocmVmR2VuLCBcImxpdmVfcGF0Y2hcIiwge3VybH0pLnRoZW4oXG4gICAgICAoe3Jlc3B9KSA9PiB7XG4gICAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBpZihyZXNwLmxpbmtfcmVkaXJlY3Qpe1xuICAgICAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcGxhY2VNYWluKGhyZWYsIG51bGwsIGNhbGxiYWNrLCBsaW5rUmVmKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZih0aGlzLmxpdmVTb2NrZXQuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICAgICAgICB0aGlzLmhyZWYgPSBocmVmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFwcGx5UGVuZGluZ1VwZGF0ZXMoKVxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobGlua1JlZilcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgKHtlcnJvcjogX2Vycm9yLCB0aW1lb3V0OiBfdGltZW91dH0pID0+IGZhbGxiYWNrKClcbiAgICApXG4gIH1cblxuICBnZXRGb3Jtc0ZvclJlY292ZXJ5KCl7XG4gICAgaWYodGhpcy5qb2luQ291bnQgPT09IDApeyByZXR1cm4ge30gfVxuXG4gICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuXG4gICAgcmV0dXJuIERPTS5hbGwodGhpcy5lbCwgYGZvcm1bJHtwaHhDaGFuZ2V9XWApXG4gICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5pZClcbiAgICAgIC5maWx0ZXIoZm9ybSA9PiBmb3JtLmVsZW1lbnRzLmxlbmd0aCA+IDApXG4gICAgICAuZmlsdGVyKGZvcm0gPT4gZm9ybS5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9BVVRPX1JFQ09WRVIpKSAhPT0gXCJpZ25vcmVcIilcbiAgICAgIC5tYXAoZm9ybSA9PiBmb3JtLmNsb25lTm9kZSh0cnVlKSlcbiAgICAgIC5yZWR1Y2UoKGFjYywgZm9ybSkgPT4ge1xuICAgICAgICBhY2NbZm9ybS5pZF0gPSBmb3JtXG4gICAgICAgIHJldHVybiBhY2NcbiAgICAgIH0sIHt9KVxuICB9XG5cbiAgbWF5YmVQdXNoQ29tcG9uZW50c0Rlc3Ryb3llZChkZXN0cm95ZWRDSURzKXtcbiAgICBsZXQgd2lsbERlc3Ryb3lDSURzID0gZGVzdHJveWVkQ0lEcy5maWx0ZXIoY2lkID0+IHtcbiAgICAgIHJldHVybiBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIGNpZCkubGVuZ3RoID09PSAwXG4gICAgfSlcblxuICAgIGlmKHdpbGxEZXN0cm95Q0lEcy5sZW5ndGggPiAwKXtcbiAgICAgIC8vIHdlIG11c3QgcmVzZXQgdGhlIHJlbmRlciBjaGFuZ2UgdHJhY2tpbmcgZm9yIGNpZHMgdGhhdFxuICAgICAgLy8gY291bGQgYmUgYWRkZWQgYmFjayBmcm9tIHRoZSBzZXJ2ZXIgc28gd2UgZG9uJ3Qgc2tpcCB0aGVtXG4gICAgICB3aWxsRGVzdHJveUNJRHMuZm9yRWFjaChjaWQgPT4gdGhpcy5yZW5kZXJlZC5yZXNldFJlbmRlcihjaWQpKVxuXG4gICAgICB0aGlzLnB1c2hXaXRoUmVwbHkobnVsbCwgXCJjaWRzX3dpbGxfZGVzdHJveVwiLCB7Y2lkczogd2lsbERlc3Ryb3lDSURzfSkudGhlbigoKSA9PiB7XG4gICAgICAgIC8vIHdlIG11c3Qgd2FpdCBmb3IgcGVuZGluZyB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZSBiZWZvcmUgZGV0ZXJtaW5pbmdcbiAgICAgICAgLy8gaWYgdGhlIGNpZHMgd2VyZSBhZGRlZCBiYWNrIHRvIHRoZSBET00gaW4gdGhlIG1lYW50aW1lICgjMzEzOSlcbiAgICAgICAgdGhpcy5saXZlU29ja2V0LnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIC8vIFNlZSBpZiBhbnkgb2YgdGhlIGNpZHMgd2Ugd2FudGVkIHRvIGRlc3Ryb3kgd2VyZSBhZGRlZCBiYWNrLFxuICAgICAgICAgIC8vIGlmIHRoZXkgd2VyZSBhZGRlZCBiYWNrLCB3ZSBkb24ndCBhY3R1YWxseSBkZXN0cm95IHRoZW0uXG4gICAgICAgICAgbGV0IGNvbXBsZXRlbHlEZXN0cm95Q0lEcyA9IHdpbGxEZXN0cm95Q0lEcy5maWx0ZXIoY2lkID0+IHtcbiAgICAgICAgICAgIHJldHVybiBET00uZmluZENvbXBvbmVudE5vZGVMaXN0KHRoaXMuZWwsIGNpZCkubGVuZ3RoID09PSAwXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmKGNvbXBsZXRlbHlEZXN0cm95Q0lEcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIHRoaXMucHVzaFdpdGhSZXBseShudWxsLCBcImNpZHNfZGVzdHJveWVkXCIsIHtjaWRzOiBjb21wbGV0ZWx5RGVzdHJveUNJRHN9KS50aGVuKCh7cmVzcH0pID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlZC5wcnVuZUNJRHMocmVzcC5jaWRzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIG93bnNFbGVtZW50KGVsKXtcbiAgICBsZXQgcGFyZW50Vmlld0VsID0gZWwuY2xvc2VzdChQSFhfVklFV19TRUxFQ1RPUilcbiAgICByZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFBIWF9QQVJFTlRfSUQpID09PSB0aGlzLmlkIHx8XG4gICAgICAocGFyZW50Vmlld0VsICYmIHBhcmVudFZpZXdFbC5pZCA9PT0gdGhpcy5pZCkgfHxcbiAgICAgICghcGFyZW50Vmlld0VsICYmIHRoaXMuaXNEZWFkKVxuICB9XG5cbiAgc3VibWl0Rm9ybShmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBzdWJtaXR0ZXIsIG9wdHMgPSB7fSl7XG4gICAgRE9NLnB1dFByaXZhdGUoZm9ybSwgUEhYX0hBU19TVUJNSVRURUQsIHRydWUpXG4gICAgY29uc3QgaW5wdXRzID0gQXJyYXkuZnJvbShmb3JtLmVsZW1lbnRzKVxuICAgIGlucHV0cy5mb3JFYWNoKGlucHV0ID0+IERPTS5wdXRQcml2YXRlKGlucHV0LCBQSFhfSEFTX1NVQk1JVFRFRCwgdHJ1ZSkpXG4gICAgdGhpcy5saXZlU29ja2V0LmJsdXJBY3RpdmVFbGVtZW50KHRoaXMpXG4gICAgdGhpcy5wdXNoRm9ybVN1Ym1pdChmb3JtLCB0YXJnZXRDdHgsIHBoeEV2ZW50LCBzdWJtaXR0ZXIsIG9wdHMsICgpID0+IHtcbiAgICAgIHRoaXMubGl2ZVNvY2tldC5yZXN0b3JlUHJldmlvdXNseUFjdGl2ZUZvY3VzKClcbiAgICB9KVxuICB9XG5cbiAgYmluZGluZyhraW5kKXsgcmV0dXJuIHRoaXMubGl2ZVNvY2tldC5iaW5kaW5nKGtpbmQpIH1cbn1cbiIsICIvKiogSW5pdGlhbGl6ZXMgdGhlIExpdmVTb2NrZXRcbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFBvaW50IC0gVGhlIHN0cmluZyBXZWJTb2NrZXQgZW5kcG9pbnQsIGllLCBgXCJ3c3M6Ly9leGFtcGxlLmNvbS9saXZlXCJgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcIi9saXZlXCJgIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICogQHBhcmFtIHtQaG9lbml4LlNvY2tldH0gc29ja2V0IC0gdGhlIHJlcXVpcmVkIFBob2VuaXggU29ja2V0IGNsYXNzIGltcG9ydGVkIGZyb20gXCJwaG9lbml4XCIuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuICogICAgIGltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcbiAqICAgICBsZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7Li4ufSlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gT3B0aW9uYWwgY29uZmlndXJhdGlvbi4gT3V0c2lkZSBvZiBrZXlzIGxpc3RlZCBiZWxvdywgYWxsXG4gKiBjb25maWd1cmF0aW9uIGlzIHBhc3NlZCBkaXJlY3RseSB0byB0aGUgUGhvZW5peCBTb2NrZXQgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuZGVmYXVsdHNdIC0gVGhlIG9wdGlvbmFsIGRlZmF1bHRzIHRvIHVzZSBmb3IgdmFyaW91cyBiaW5kaW5ncyxcbiAqIHN1Y2ggYXMgYHBoeC1kZWJvdW5jZWAuIFN1cHBvcnRzIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqXG4gKiAgIC0gZGVib3VuY2UgLSB0aGUgbWlsbGlzZWNvbmQgcGh4LWRlYm91bmNlIHRpbWUuIERlZmF1bHRzIDMwMFxuICogICAtIHRocm90dGxlIC0gdGhlIG1pbGxpc2Vjb25kIHBoeC10aHJvdHRsZSB0aW1lLiBEZWZhdWx0cyAzMDBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0cy5wYXJhbXNdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBwYXNzaW5nIGNvbm5lY3QgcGFyYW1zLlxuICogVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIExpdmVWaWV3LiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgKGVsKSA9PiB7dmlldzogZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS1teS12aWV3LW5hbWVcIiwgdG9rZW46IHdpbmRvdy5teVRva2VufVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iaW5kaW5nUHJlZml4XSAtIFRoZSBvcHRpb25hbCBwcmVmaXggdG8gdXNlIGZvciBhbGwgcGh4IERPTSBhbm5vdGF0aW9ucy5cbiAqIERlZmF1bHRzIHRvIFwicGh4LVwiLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLmhvb2tzXSAtIFRoZSBvcHRpb25hbCBvYmplY3QgZm9yIHJlZmVyZW5jaW5nIExpdmVWaWV3IGhvb2sgY2FsbGJhY2tzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzLnVwbG9hZGVyc10gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IGZvciByZWZlcmVuY2luZyBMaXZlVmlldyB1cGxvYWRlciBjYWxsYmFja3MuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLmxvYWRlclRpbWVvdXRdIC0gVGhlIG9wdGlvbmFsIGRlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBhcHBseVxuICogbG9hZGluZyBzdGF0ZXMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLmRpc2Nvbm5lY3RlZFRpbWVvdXRdIC0gVGhlIGRlbGF5IGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZVxuICogZXhlY3V0aW5nIHBoeC1kaXNjb25uZWN0ZWQgY29tbWFuZHMuIERlZmF1bHRzIHRvIDUwMC5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMubWF4UmVsb2Fkc10gLSBUaGUgbWF4aW11bSByZWxvYWRzIGJlZm9yZSBlbnRlcmluZyBmYWlsc2FmZSBtb2RlLlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0cy5yZWxvYWRKaXR0ZXJNaW5dIC0gVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIG5vcm1hbCByZWxvYWQgYXR0ZW1wdHMuXG4gKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRzLnJlbG9hZEppdHRlck1heF0gLSBUaGUgbWF4aW11bSB0aW1lIGJldHdlZW4gbm9ybWFsIHJlbG9hZCBhdHRlbXB0cy5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdHMuZmFpbHNhZmVKaXR0ZXJdIC0gVGhlIHRpbWUgYmV0d2VlbiByZWxvYWQgYXR0ZW1wdHMgaW4gZmFpbHNhZmUgbW9kZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRzLnZpZXdMb2dnZXJdIC0gVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGxvZyBkZWJ1ZyBpbmZvcm1hdGlvbi4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgICh2aWV3LCBraW5kLCBtc2csIG9iaikgPT4gY29uc29sZS5sb2coYCR7dmlldy5pZH0gJHtraW5kfTogJHttc2d9IC0gYCwgb2JqKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5tZXRhZGF0YV0gLSBUaGUgb3B0aW9uYWwgb2JqZWN0IG1hcHBpbmcgZXZlbnQgbmFtZXMgdG8gZnVuY3Rpb25zIGZvclxuICogcG9wdWxhdGluZyBldmVudCBtZXRhZGF0YS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIG1ldGFkYXRhOiB7XG4gKiAgICAgICBjbGljazogKGUsIGVsKSA9PiB7XG4gKiAgICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICogICAgICAgICAgIG1ldGFLZXk6IGUubWV0YUtleSxcbiAqICAgICAgICAgICBkZXRhaWw6IGUuZGV0YWlsIHx8IDEsXG4gKiAgICAgICAgIH1cbiAqICAgICAgIH0sXG4gKiAgICAgICBrZXlkb3duOiAoZSwgZWwpID0+IHtcbiAqICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICBrZXk6IGUua2V5LFxuICogICAgICAgICAgIGN0cmxLZXk6IGUuY3RybEtleSxcbiAqICAgICAgICAgICBtZXRhS2V5OiBlLm1ldGFLZXksXG4gKiAgICAgICAgICAgc2hpZnRLZXk6IGUuc2hpZnRLZXlcbiAqICAgICAgICAgfVxuICogICAgICAgfVxuICogICAgIH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5zZXNzaW9uU3RvcmFnZV0gLSBBbiBvcHRpb25hbCBTdG9yYWdlIGNvbXBhdGlibGUgb2JqZWN0XG4gKiBVc2VmdWwgd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgc2Vzc2lvblN0b3JhZ2VgLiAgRm9yIGV4YW1wbGUsIFRoaXMgY291bGRcbiAqIGhhcHBlbiBpZiBhIHNpdGUgbG9hZHMgYSBjcm9zcy1kb21haW4gTGl2ZVZpZXcgaW4gYW4gaWZyYW1lLiAgRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgICAgY2xhc3MgSW5NZW1vcnlTdG9yYWdlIHtcbiAqICAgICAgIGNvbnN0cnVjdG9yKCkgeyB0aGlzLnN0b3JhZ2UgPSB7fSB9XG4gKiAgICAgICBnZXRJdGVtKGtleU5hbWUpIHsgcmV0dXJuIHRoaXMuc3RvcmFnZVtrZXlOYW1lXSB8fCBudWxsIH1cbiAqICAgICAgIHJlbW92ZUl0ZW0oa2V5TmFtZSkgeyBkZWxldGUgdGhpcy5zdG9yYWdlW2tleU5hbWVdIH1cbiAqICAgICAgIHNldEl0ZW0oa2V5TmFtZSwga2V5VmFsdWUpIHsgdGhpcy5zdG9yYWdlW2tleU5hbWVdID0ga2V5VmFsdWUgfVxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMubG9jYWxTdG9yYWdlXSAtIEFuIG9wdGlvbmFsIFN0b3JhZ2UgY29tcGF0aWJsZSBvYmplY3RcbiAqIFVzZWZ1bCBmb3Igd2hlbiBMaXZlVmlldyB3b24ndCBoYXZlIGFjY2VzcyB0byBgbG9jYWxTdG9yYWdlYC5cbiAqIFNlZSBgb3B0cy5zZXNzaW9uU3RvcmFnZWAgZm9yIGV4YW1wbGVzLlxuKi9cblxuaW1wb3J0IHtcbiAgQklORElOR19QUkVGSVgsXG4gIENPTlNFQ1VUSVZFX1JFTE9BRFMsXG4gIERFRkFVTFRTLFxuICBGQUlMU0FGRV9KSVRURVIsXG4gIExPQURFUl9USU1FT1VULFxuICBESVNDT05ORUNURURfVElNRU9VVCxcbiAgTUFYX1JFTE9BRFMsXG4gIFBIWF9ERUJPVU5DRSxcbiAgUEhYX0RST1BfVEFSR0VULFxuICBQSFhfSEFTX0ZPQ1VTRUQsXG4gIFBIWF9LRVksXG4gIFBIWF9MSU5LX1NUQVRFLFxuICBQSFhfTElWRV9MSU5LLFxuICBQSFhfTFZfREVCVUcsXG4gIFBIWF9MVl9MQVRFTkNZX1NJTSxcbiAgUEhYX0xWX1BST0ZJTEUsXG4gIFBIWF9MVl9ISVNUT1JZX1BPU0lUSU9OLFxuICBQSFhfTUFJTixcbiAgUEhYX1BBUkVOVF9JRCxcbiAgUEhYX1ZJRVdfU0VMRUNUT1IsXG4gIFBIWF9ST09UX0lELFxuICBQSFhfVEhST1RUTEUsXG4gIFBIWF9UUkFDS19VUExPQURTLFxuICBQSFhfU0VTU0lPTixcbiAgUkVMT0FEX0pJVFRFUl9NSU4sXG4gIFJFTE9BRF9KSVRURVJfTUFYLFxuICBQSFhfUkVGX1NSQyxcbiAgUEhYX1JFTE9BRF9TVEFUVVNcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcblxuaW1wb3J0IHtcbiAgY2xvbmUsXG4gIGNsb3Nlc3RQaHhCaW5kaW5nLFxuICBjbG9zdXJlLFxuICBkZWJ1ZyxcbiAgbWF5YmVcbn0gZnJvbSBcIi4vdXRpbHNcIlxuXG5pbXBvcnQgQnJvd3NlciBmcm9tIFwiLi9icm93c2VyXCJcbmltcG9ydCBET00gZnJvbSBcIi4vZG9tXCJcbmltcG9ydCBIb29rcyBmcm9tIFwiLi9ob29rc1wiXG5pbXBvcnQgTGl2ZVVwbG9hZGVyIGZyb20gXCIuL2xpdmVfdXBsb2FkZXJcIlxuaW1wb3J0IFZpZXcgZnJvbSBcIi4vdmlld1wiXG5pbXBvcnQgSlMgZnJvbSBcIi4vanNcIlxuXG5leHBvcnQgbGV0IGlzVXNlZElucHV0ID0gKGVsKSA9PiBET00uaXNVc2VkSW5wdXQoZWwpXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpdmVTb2NrZXQge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHBoeFNvY2tldCwgb3B0cyA9IHt9KXtcbiAgICB0aGlzLnVubG9hZGVkID0gZmFsc2VcbiAgICBpZighcGh4U29ja2V0IHx8IHBoeFNvY2tldC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk9iamVjdFwiKXtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXG4gICAgICBhIHBob2VuaXggU29ja2V0IG11c3QgYmUgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGl2ZVNvY2tldCBjb25zdHJ1Y3Rvci4gRm9yIGV4YW1wbGU6XG5cbiAgICAgICAgICBpbXBvcnQge1NvY2tldH0gZnJvbSBcInBob2VuaXhcIlxuICAgICAgICAgIGltcG9ydCB7TGl2ZVNvY2tldH0gZnJvbSBcInBob2VuaXhfbGl2ZV92aWV3XCJcbiAgICAgICAgICBsZXQgbGl2ZVNvY2tldCA9IG5ldyBMaXZlU29ja2V0KFwiL2xpdmVcIiwgU29ja2V0LCB7Li4ufSlcbiAgICAgIGApXG4gICAgfVxuICAgIHRoaXMuc29ja2V0ID0gbmV3IHBoeFNvY2tldCh1cmwsIG9wdHMpXG4gICAgdGhpcy5iaW5kaW5nUHJlZml4ID0gb3B0cy5iaW5kaW5nUHJlZml4IHx8IEJJTkRJTkdfUFJFRklYXG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIHRoaXMucGFyYW1zID0gY2xvc3VyZShvcHRzLnBhcmFtcyB8fCB7fSlcbiAgICB0aGlzLnZpZXdMb2dnZXIgPSBvcHRzLnZpZXdMb2dnZXJcbiAgICB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzID0gb3B0cy5tZXRhZGF0YSB8fCB7fVxuICAgIHRoaXMuZGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKGNsb25lKERFRkFVTFRTKSwgb3B0cy5kZWZhdWx0cyB8fCB7fSlcbiAgICB0aGlzLmFjdGl2ZUVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5wcmV2QWN0aXZlID0gbnVsbFxuICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZVxuICAgIHRoaXMubWFpbiA9IG51bGxcbiAgICB0aGlzLm91dGdvaW5nTWFpbkVsID0gbnVsbFxuICAgIHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBudWxsXG4gICAgdGhpcy5saW5rUmVmID0gMVxuICAgIHRoaXMucm9vdHMgPSB7fVxuICAgIHRoaXMuaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGxcbiAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGNsb25lKHdpbmRvdy5sb2NhdGlvbilcbiAgICB0aGlzLmhvb2tzID0gb3B0cy5ob29rcyB8fCB7fVxuICAgIHRoaXMudXBsb2FkZXJzID0gb3B0cy51cGxvYWRlcnMgfHwge31cbiAgICB0aGlzLmxvYWRlclRpbWVvdXQgPSBvcHRzLmxvYWRlclRpbWVvdXQgfHwgTE9BREVSX1RJTUVPVVRcbiAgICB0aGlzLmRpc2Nvbm5lY3RlZFRpbWVvdXQgPSBvcHRzLmRpc2Nvbm5lY3RlZFRpbWVvdXQgfHwgRElTQ09OTkVDVEVEX1RJTUVPVVRcbiAgICB0aGlzLnJlbG9hZFdpdGhKaXR0ZXJUaW1lciA9IG51bGxcbiAgICB0aGlzLm1heFJlbG9hZHMgPSBvcHRzLm1heFJlbG9hZHMgfHwgTUFYX1JFTE9BRFNcbiAgICB0aGlzLnJlbG9hZEppdHRlck1pbiA9IG9wdHMucmVsb2FkSml0dGVyTWluIHx8IFJFTE9BRF9KSVRURVJfTUlOXG4gICAgdGhpcy5yZWxvYWRKaXR0ZXJNYXggPSBvcHRzLnJlbG9hZEppdHRlck1heCB8fCBSRUxPQURfSklUVEVSX01BWFxuICAgIHRoaXMuZmFpbHNhZmVKaXR0ZXIgPSBvcHRzLmZhaWxzYWZlSml0dGVyIHx8IEZBSUxTQUZFX0pJVFRFUlxuICAgIHRoaXMubG9jYWxTdG9yYWdlID0gb3B0cy5sb2NhbFN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZVxuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2UgPSBvcHRzLnNlc3Npb25TdG9yYWdlIHx8IHdpbmRvdy5zZXNzaW9uU3RvcmFnZVxuICAgIHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyA9IGZhbHNlXG4gICAgdGhpcy5ib3VuZEV2ZW50TmFtZXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLnNlcnZlckNsb3NlUmVmID0gbnVsbFxuICAgIHRoaXMuZG9tQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBqc1F1ZXJ5U2VsZWN0b3JBbGw6IG51bGwsXG4gICAgICBvblBhdGNoU3RhcnQ6IGNsb3N1cmUoKSxcbiAgICAgIG9uUGF0Y2hFbmQ6IGNsb3N1cmUoKSxcbiAgICAgIG9uTm9kZUFkZGVkOiBjbG9zdXJlKCksXG4gICAgICBvbkJlZm9yZUVsVXBkYXRlZDogY2xvc3VyZSgpfSxcbiAgICBvcHRzLmRvbSB8fCB7fSlcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFRyYW5zaXRpb25TZXQoKVxuICAgIHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbiA9IHBhcnNlSW50KHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfSElTVE9SWV9QT1NJVElPTikpIHx8IDBcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9lID0+IHtcbiAgICAgIHRoaXMudW5sb2FkZWQgPSB0cnVlXG4gICAgfSlcbiAgICB0aGlzLnNvY2tldC5vbk9wZW4oKCkgPT4ge1xuICAgICAgaWYodGhpcy5pc1VubG9hZGVkKCkpe1xuICAgICAgICAvLyByZWxvYWQgcGFnZSBpZiBiZWluZyByZXN0b3JlZCBmcm9tIGJhY2svZm9yd2FyZCBjYWNoZSBhbmQgYnJvd3NlciBkb2VzIG5vdCBlbWl0IFwicGFnZXNob3dcIlxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gcHVibGljXG5cbiAgdmVyc2lvbigpeyByZXR1cm4gTFZfVlNOIH1cblxuICBpc1Byb2ZpbGVFbmFibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX1BST0ZJTEUpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0VuYWJsZWQoKXsgcmV0dXJuIHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfREVCVUcpID09PSBcInRydWVcIiB9XG5cbiAgaXNEZWJ1Z0Rpc2FibGVkKCl7IHJldHVybiB0aGlzLnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oUEhYX0xWX0RFQlVHKSA9PT0gXCJmYWxzZVwiIH1cblxuICBlbmFibGVEZWJ1ZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX0RFQlVHLCBcInRydWVcIikgfVxuXG4gIGVuYWJsZVByb2ZpbGluZygpeyB0aGlzLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oUEhYX0xWX1BST0ZJTEUsIFwidHJ1ZVwiKSB9XG5cbiAgZGlzYWJsZURlYnVnKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfREVCVUcsIFwiZmFsc2VcIikgfVxuXG4gIGRpc2FibGVQcm9maWxpbmcoKXsgdGhpcy5zZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFBIWF9MVl9QUk9GSUxFKSB9XG5cbiAgZW5hYmxlTGF0ZW5jeVNpbSh1cHBlckJvdW5kTXMpe1xuICAgIHRoaXMuZW5hYmxlRGVidWcoKVxuICAgIGNvbnNvbGUubG9nKFwibGF0ZW5jeSBzaW11bGF0b3IgZW5hYmxlZCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoaXMgYnJvd3NlciBzZXNzaW9uLiBDYWxsIGRpc2FibGVMYXRlbmN5U2ltKCkgdG8gZGlzYWJsZVwiKVxuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0sIHVwcGVyQm91bmRNcylcbiAgfVxuXG4gIGRpc2FibGVMYXRlbmN5U2ltKCl7IHRoaXMuc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShQSFhfTFZfTEFURU5DWV9TSU0pIH1cblxuICBnZXRMYXRlbmN5U2ltKCl7XG4gICAgbGV0IHN0ciA9IHRoaXMuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShQSFhfTFZfTEFURU5DWV9TSU0pXG4gICAgcmV0dXJuIHN0ciA/IHBhcnNlSW50KHN0cikgOiBudWxsXG4gIH1cblxuICBnZXRTb2NrZXQoKXsgcmV0dXJuIHRoaXMuc29ja2V0IH1cblxuICBjb25uZWN0KCl7XG4gICAgLy8gZW5hYmxlIGRlYnVnIGJ5IGRlZmF1bHQgaWYgb24gbG9jYWxob3N0IGFuZCBub3QgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgIGlmKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA9PT0gXCJsb2NhbGhvc3RcIiAmJiAhdGhpcy5pc0RlYnVnRGlzYWJsZWQoKSl7IHRoaXMuZW5hYmxlRGVidWcoKSB9XG4gICAgbGV0IGRvQ29ubmVjdCA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVzZXRSZWxvYWRTdGF0dXMoKVxuICAgICAgaWYodGhpcy5qb2luUm9vdFZpZXdzKCkpe1xuICAgICAgICB0aGlzLmJpbmRUb3BMZXZlbEV2ZW50cygpXG4gICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgICAgfSBlbHNlIGlmKHRoaXMubWFpbil7XG4gICAgICAgIHRoaXMuc29ja2V0LmNvbm5lY3QoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iaW5kVG9wTGV2ZWxFdmVudHMoe2RlYWQ6IHRydWV9KVxuICAgICAgfVxuICAgICAgdGhpcy5qb2luRGVhZFZpZXcoKVxuICAgIH1cbiAgICBpZihbXCJjb21wbGV0ZVwiLCBcImxvYWRlZFwiLCBcImludGVyYWN0aXZlXCJdLmluZGV4T2YoZG9jdW1lbnQucmVhZHlTdGF0ZSkgPj0gMCl7XG4gICAgICBkb0Nvbm5lY3QoKVxuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiBkb0Nvbm5lY3QoKSlcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0KGNhbGxiYWNrKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgLy8gcmVtb3ZlIHRoZSBzb2NrZXQgY2xvc2UgbGlzdGVuZXIgdG8gYXZvaWQgdHJ5aW5nIHRvIGhhbmRsZVxuICAgIC8vIGEgc2VydmVyIGNsb3NlIGV2ZW50IHdoZW4gaXQgaXMgYWN0dWFsbHkgY2F1c2VkIGJ5IHVzIGRpc2Nvbm5lY3RpbmdcbiAgICBpZih0aGlzLnNlcnZlckNsb3NlUmVmKXtcbiAgICAgIHRoaXMuc29ja2V0Lm9mZih0aGlzLnNlcnZlckNsb3NlUmVmKVxuICAgICAgdGhpcy5zZXJ2ZXJDbG9zZVJlZiA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5zb2NrZXQuZGlzY29ubmVjdChjYWxsYmFjaylcbiAgfVxuXG4gIHJlcGxhY2VUcmFuc3BvcnQodHJhbnNwb3J0KXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5zb2NrZXQucmVwbGFjZVRyYW5zcG9ydCh0cmFuc3BvcnQpXG4gICAgdGhpcy5jb25uZWN0KClcbiAgfVxuXG4gIGV4ZWNKUyhlbCwgZW5jb2RlZEpTLCBldmVudFR5cGUgPSBudWxsKXtcbiAgICBsZXQgZSA9IG5ldyBDdXN0b21FdmVudChcInBoeDpleGVjXCIsIHtkZXRhaWw6IHtzb3VyY2VFbGVtZW50OiBlbH19KVxuICAgIHRoaXMub3duZXIoZWwsIHZpZXcgPT4gSlMuZXhlYyhlLCBldmVudFR5cGUsIGVuY29kZWRKUywgdmlldywgZWwpKVxuICB9XG5cbiAgLy8gcHJpdmF0ZVxuXG4gIGV4ZWNKU0hvb2tQdXNoKGVsLCBwaHhFdmVudCwgZGF0YSwgY2FsbGJhY2spe1xuICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCB2aWV3ID0+IHtcbiAgICAgIGxldCBlID0gbmV3IEN1c3RvbUV2ZW50KFwicGh4OmV4ZWNcIiwge2RldGFpbDoge3NvdXJjZUVsZW1lbnQ6IGVsfX0pXG4gICAgICBKUy5leGVjKGUsIFwiaG9va1wiLCBwaHhFdmVudCwgdmlldywgZWwsIFtcInB1c2hcIiwge2RhdGEsIGNhbGxiYWNrfV0pXG4gICAgfSlcbiAgfVxuXG4gIHVubG9hZCgpe1xuICAgIGlmKHRoaXMudW5sb2FkZWQpeyByZXR1cm4gfVxuICAgIGlmKHRoaXMubWFpbiAmJiB0aGlzLmlzQ29ubmVjdGVkKCkpeyB0aGlzLmxvZyh0aGlzLm1haW4sIFwic29ja2V0XCIsICgpID0+IFtcImRpc2Nvbm5lY3QgZm9yIHBhZ2UgbmF2XCJdKSB9XG4gICAgdGhpcy51bmxvYWRlZCA9IHRydWVcbiAgICB0aGlzLmRlc3Ryb3lBbGxWaWV3cygpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgfVxuXG4gIHRyaWdnZXJET00oa2luZCwgYXJncyl7IHRoaXMuZG9tQ2FsbGJhY2tzW2tpbmRdKC4uLmFyZ3MpIH1cblxuICB0aW1lKG5hbWUsIGZ1bmMpe1xuICAgIGlmKCF0aGlzLmlzUHJvZmlsZUVuYWJsZWQoKSB8fCAhY29uc29sZS50aW1lKXsgcmV0dXJuIGZ1bmMoKSB9XG4gICAgY29uc29sZS50aW1lKG5hbWUpXG4gICAgbGV0IHJlc3VsdCA9IGZ1bmMoKVxuICAgIGNvbnNvbGUudGltZUVuZChuYW1lKVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGxvZyh2aWV3LCBraW5kLCBtc2dDYWxsYmFjayl7XG4gICAgaWYodGhpcy52aWV3TG9nZ2VyKXtcbiAgICAgIGxldCBbbXNnLCBvYmpdID0gbXNnQ2FsbGJhY2soKVxuICAgICAgdGhpcy52aWV3TG9nZ2VyKHZpZXcsIGtpbmQsIG1zZywgb2JqKVxuICAgIH0gZWxzZSBpZih0aGlzLmlzRGVidWdFbmFibGVkKCkpe1xuICAgICAgbGV0IFttc2csIG9ial0gPSBtc2dDYWxsYmFjaygpXG4gICAgICBkZWJ1Zyh2aWV3LCBraW5kLCBtc2csIG9iailcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0RE9NVXBkYXRlKGNhbGxiYWNrKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zLmFmdGVyKGNhbGxiYWNrKVxuICB9XG5cbiAgdHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUgPSBmdW5jdGlvbigpe30pe1xuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkVHJhbnNpdGlvbih0aW1lLCBvblN0YXJ0LCBvbkRvbmUpXG4gIH1cblxuICBvbkNoYW5uZWwoY2hhbm5lbCwgZXZlbnQsIGNiKXtcbiAgICBjaGFubmVsLm9uKGV2ZW50LCBkYXRhID0+IHtcbiAgICAgIGxldCBsYXRlbmN5ID0gdGhpcy5nZXRMYXRlbmN5U2ltKClcbiAgICAgIGlmKCFsYXRlbmN5KXtcbiAgICAgICAgY2IoZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY2IoZGF0YSksIGxhdGVuY3kpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJlbG9hZFdpdGhKaXR0ZXIodmlldywgbG9nKXtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5yZWxvYWRXaXRoSml0dGVyVGltZXIpXG4gICAgdGhpcy5kaXNjb25uZWN0KClcbiAgICBsZXQgbWluTXMgPSB0aGlzLnJlbG9hZEppdHRlck1pblxuICAgIGxldCBtYXhNcyA9IHRoaXMucmVsb2FkSml0dGVyTWF4XG4gICAgbGV0IGFmdGVyTXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4TXMgLSBtaW5NcyArIDEpKSArIG1pbk1zXG4gICAgbGV0IHRyaWVzID0gQnJvd3Nlci51cGRhdGVMb2NhbCh0aGlzLmxvY2FsU3RvcmFnZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCBDT05TRUNVVElWRV9SRUxPQURTLCAwLCBjb3VudCA9PiBjb3VudCArIDEpXG4gICAgaWYodHJpZXMgPj0gdGhpcy5tYXhSZWxvYWRzKXtcbiAgICAgIGFmdGVyTXMgPSB0aGlzLmZhaWxzYWZlSml0dGVyXG4gICAgfVxuICAgIHRoaXMucmVsb2FkV2l0aEppdHRlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBpZiB2aWV3IGhhcyByZWNvdmVyZWQsIHN1Y2ggYXMgdHJhbnNwb3J0IHJlcGxhY2VkLCB0aGVuIGNhbmNlbFxuICAgICAgaWYodmlldy5pc0Rlc3Ryb3llZCgpIHx8IHZpZXcuaXNDb25uZWN0ZWQoKSl7IHJldHVybiB9XG4gICAgICB2aWV3LmRlc3Ryb3koKVxuICAgICAgbG9nID8gbG9nKCkgOiB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW2BlbmNvdW50ZXJlZCAke3RyaWVzfSBjb25zZWN1dGl2ZSByZWxvYWRzYF0pXG4gICAgICBpZih0cmllcyA+PSB0aGlzLm1heFJlbG9hZHMpe1xuICAgICAgICB0aGlzLmxvZyh2aWV3LCBcImpvaW5cIiwgKCkgPT4gW2BleGNlZWRlZCAke3RoaXMubWF4UmVsb2Fkc30gY29uc2VjdXRpdmUgcmVsb2Fkcy4gRW50ZXJpbmcgZmFpbHNhZmUgbW9kZWBdKVxuICAgICAgfVxuICAgICAgaWYodGhpcy5oYXNQZW5kaW5nTGluaygpKXtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gdGhpcy5wZW5kaW5nTGlua1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICB9XG4gICAgfSwgYWZ0ZXJNcylcbiAgfVxuXG4gIGdldEhvb2tDYWxsYmFja3MobmFtZSl7XG4gICAgcmV0dXJuIG5hbWUgJiYgbmFtZS5zdGFydHNXaXRoKFwiUGhvZW5peC5cIikgPyBIb29rc1tuYW1lLnNwbGl0KFwiLlwiKVsxXV0gOiB0aGlzLmhvb2tzW25hbWVdXG4gIH1cblxuICBpc1VubG9hZGVkKCl7IHJldHVybiB0aGlzLnVubG9hZGVkIH1cblxuICBpc0Nvbm5lY3RlZCgpeyByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSB9XG5cbiAgZ2V0QmluZGluZ1ByZWZpeCgpeyByZXR1cm4gdGhpcy5iaW5kaW5nUHJlZml4IH1cblxuICBiaW5kaW5nKGtpbmQpeyByZXR1cm4gYCR7dGhpcy5nZXRCaW5kaW5nUHJlZml4KCl9JHtraW5kfWAgfVxuXG4gIGNoYW5uZWwodG9waWMsIHBhcmFtcyl7IHJldHVybiB0aGlzLnNvY2tldC5jaGFubmVsKHRvcGljLCBwYXJhbXMpIH1cblxuICBqb2luRGVhZFZpZXcoKXtcbiAgICBsZXQgYm9keSA9IGRvY3VtZW50LmJvZHlcbiAgICBpZihib2R5ICYmICF0aGlzLmlzUGh4Vmlldyhib2R5KSAmJiAhdGhpcy5pc1BoeFZpZXcoZG9jdW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpKXtcbiAgICAgIGxldCB2aWV3ID0gdGhpcy5uZXdSb290Vmlldyhib2R5KVxuICAgICAgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKVxuICAgICAgdmlldy5qb2luRGVhZCgpXG4gICAgICBpZighdGhpcy5tYWluKXsgdGhpcy5tYWluID0gdmlldyB9XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdmlldy5leGVjTmV3TW91bnRlZCgpXG4gICAgICAgIC8vIHJlc3RvcmUgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gbmF2aWdhdGluZyBmcm9tIGFuIGV4dGVybmFsIC8gbm9uLWxpdmUgcGFnZVxuICAgICAgICB0aGlzLm1heWJlU2Nyb2xsKGhpc3Rvcnkuc3RhdGU/LnNjcm9sbClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgam9pblJvb3RWaWV3cygpe1xuICAgIGxldCByb290c0ZvdW5kID0gZmFsc2VcbiAgICBET00uYWxsKGRvY3VtZW50LCBgJHtQSFhfVklFV19TRUxFQ1RPUn06bm90KFske1BIWF9QQVJFTlRfSUR9XSlgLCByb290RWwgPT4ge1xuICAgICAgaWYoIXRoaXMuZ2V0Um9vdEJ5SWQocm9vdEVsLmlkKSl7XG4gICAgICAgIGxldCB2aWV3ID0gdGhpcy5uZXdSb290Vmlldyhyb290RWwpXG4gICAgICAgIC8vIHN0aWNraWVzIGNhbm5vdCBiZSBtb3VudGVkIGF0IHRoZSByb3V0ZXIgYW5kIHRoZXJlZm9yZSBzaG91bGQgbm90XG4gICAgICAgIC8vIGdldCBhIGhyZWYgc2V0IG9uIHRoZW1cbiAgICAgICAgaWYoIURPTS5pc1BoeFN0aWNreShyb290RWwpKXsgdmlldy5zZXRIcmVmKHRoaXMuZ2V0SHJlZigpKSB9XG4gICAgICAgIHZpZXcuam9pbigpXG4gICAgICAgIGlmKHJvb3RFbC5oYXNBdHRyaWJ1dGUoUEhYX01BSU4pKXsgdGhpcy5tYWluID0gdmlldyB9XG4gICAgICB9XG4gICAgICByb290c0ZvdW5kID0gdHJ1ZVxuICAgIH0pXG4gICAgcmV0dXJuIHJvb3RzRm91bmRcbiAgfVxuXG4gIHJlZGlyZWN0KHRvLCBmbGFzaCwgcmVsb2FkVG9rZW4pe1xuICAgIGlmKHJlbG9hZFRva2VuKXsgQnJvd3Nlci5zZXRDb29raWUoUEhYX1JFTE9BRF9TVEFUVVMsIHJlbG9hZFRva2VuLCA2MCkgfVxuICAgIHRoaXMudW5sb2FkKClcbiAgICBCcm93c2VyLnJlZGlyZWN0KHRvLCBmbGFzaClcbiAgfVxuXG4gIHJlcGxhY2VNYWluKGhyZWYsIGZsYXNoLCBjYWxsYmFjayA9IG51bGwsIGxpbmtSZWYgPSB0aGlzLnNldFBlbmRpbmdMaW5rKGhyZWYpKXtcbiAgICBjb25zdCBsaXZlUmVmZXJlciA9IHRoaXMuY3VycmVudExvY2F0aW9uLmhyZWZcbiAgICB0aGlzLm91dGdvaW5nTWFpbkVsID0gdGhpcy5vdXRnb2luZ01haW5FbCB8fCB0aGlzLm1haW4uZWxcblxuICAgIGNvbnN0IHN0aWNraWVzID0gRE9NLmZpbmRQaHhTdGlja3koZG9jdW1lbnQpIHx8IFtdXG4gICAgY29uc3QgcmVtb3ZlRWxzID0gRE9NLmFsbCh0aGlzLm91dGdvaW5nTWFpbkVsLCBgWyR7dGhpcy5iaW5kaW5nKFwicmVtb3ZlXCIpfV1gKVxuICAgICAgLmZpbHRlcihlbCA9PiAhRE9NLmlzQ2hpbGRPZkFueShlbCwgc3RpY2tpZXMpKVxuXG4gICAgY29uc3QgbmV3TWFpbkVsID0gRE9NLmNsb25lTm9kZSh0aGlzLm91dGdvaW5nTWFpbkVsLCBcIlwiKVxuICAgIHRoaXMubWFpbi5zaG93TG9hZGVyKHRoaXMubG9hZGVyVGltZW91dClcbiAgICB0aGlzLm1haW4uZGVzdHJveSgpXG5cbiAgICB0aGlzLm1haW4gPSB0aGlzLm5ld1Jvb3RWaWV3KG5ld01haW5FbCwgZmxhc2gsIGxpdmVSZWZlcmVyKVxuICAgIHRoaXMubWFpbi5zZXRSZWRpcmVjdChocmVmKVxuICAgIHRoaXMudHJhbnNpdGlvblJlbW92ZXMocmVtb3ZlRWxzKVxuICAgIHRoaXMubWFpbi5qb2luKChqb2luQ291bnQsIG9uRG9uZSkgPT4ge1xuICAgICAgaWYoam9pbkNvdW50ID09PSAxICYmIHRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpe1xuICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgIC8vIHJlbW92ZSBwaHgtcmVtb3ZlIGVscyByaWdodCBiZWZvcmUgd2UgcmVwbGFjZSB0aGUgbWFpbiBlbGVtZW50XG4gICAgICAgICAgcmVtb3ZlRWxzLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpXG4gICAgICAgICAgc3RpY2tpZXMuZm9yRWFjaChlbCA9PiBuZXdNYWluRWwuYXBwZW5kQ2hpbGQoZWwpKVxuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwucmVwbGFjZVdpdGgobmV3TWFpbkVsKVxuICAgICAgICAgIHRoaXMub3V0Z29pbmdNYWluRWwgPSBudWxsXG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobGlua1JlZilcbiAgICAgICAgICBvbkRvbmUoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICB0cmFuc2l0aW9uUmVtb3ZlcyhlbGVtZW50cywgY2FsbGJhY2spe1xuICAgIGxldCByZW1vdmVBdHRyID0gdGhpcy5iaW5kaW5nKFwicmVtb3ZlXCIpXG4gICAgbGV0IHNpbGVuY2VFdmVudHMgPSAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgfVxuICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgLy8gcHJldmVudCBhbGwgbGlzdGVuZXJzIHdlIGNhcmUgYWJvdXQgZnJvbSBidWJibGluZyB0byB3aW5kb3dcbiAgICAgIC8vIHNpbmNlIHdlIGFyZSByZW1vdmluZyB0aGUgZWxlbWVudFxuICAgICAgZm9yKGxldCBldmVudCBvZiB0aGlzLmJvdW5kRXZlbnROYW1lcyl7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHNpbGVuY2VFdmVudHMsIHRydWUpXG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWNKUyhlbCwgZWwuZ2V0QXR0cmlidXRlKHJlbW92ZUF0dHIpLCBcInJlbW92ZVwiKVxuICAgIH0pXG4gICAgLy8gcmVtb3ZlIHRoZSBzaWxlbmNlZCBsaXN0ZW5lcnMgd2hlbiB0cmFuc2l0aW9ucyBhcmUgZG9uZSBpbmNhc2UgdGhlIGVsZW1lbnQgaXMgcmUtdXNlZFxuICAgIC8vIGFuZCBjYWxsIGNhbGxlcidzIGNhbGxiYWNrIGFzIHNvb24gYXMgd2UgYXJlIGRvbmUgd2l0aCB0cmFuc2l0aW9uc1xuICAgIHRoaXMucmVxdWVzdERPTVVwZGF0ZSgoKSA9PiB7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgZm9yKGxldCBldmVudCBvZiB0aGlzLmJvdW5kRXZlbnROYW1lcyl7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgc2lsZW5jZUV2ZW50cywgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKClcbiAgICB9KVxuICB9XG5cbiAgaXNQaHhWaWV3KGVsKXsgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSAmJiBlbC5nZXRBdHRyaWJ1dGUoUEhYX1NFU1NJT04pICE9PSBudWxsIH1cblxuICBuZXdSb290VmlldyhlbCwgZmxhc2gsIGxpdmVSZWZlcmVyKXtcbiAgICBsZXQgdmlldyA9IG5ldyBWaWV3KGVsLCB0aGlzLCBudWxsLCBmbGFzaCwgbGl2ZVJlZmVyZXIpXG4gICAgdGhpcy5yb290c1t2aWV3LmlkXSA9IHZpZXdcbiAgICByZXR1cm4gdmlld1xuICB9XG5cbiAgb3duZXIoY2hpbGRFbCwgY2FsbGJhY2spe1xuICAgIGxldCB2aWV3ID0gbWF5YmUoY2hpbGRFbC5jbG9zZXN0KFBIWF9WSUVXX1NFTEVDVE9SKSwgZWwgPT4gdGhpcy5nZXRWaWV3QnlFbChlbCkpIHx8IHRoaXMubWFpblxuICAgIHJldHVybiB2aWV3ICYmIGNhbGxiYWNrID8gY2FsbGJhY2sodmlldykgOiB2aWV3XG4gIH1cblxuICB3aXRoaW5Pd25lcnMoY2hpbGRFbCwgY2FsbGJhY2spe1xuICAgIHRoaXMub3duZXIoY2hpbGRFbCwgdmlldyA9PiBjYWxsYmFjayh2aWV3LCBjaGlsZEVsKSlcbiAgfVxuXG4gIGdldFZpZXdCeUVsKGVsKXtcbiAgICBsZXQgcm9vdElkID0gZWwuZ2V0QXR0cmlidXRlKFBIWF9ST09UX0lEKVxuICAgIHJldHVybiBtYXliZSh0aGlzLmdldFJvb3RCeUlkKHJvb3RJZCksIHJvb3QgPT4gcm9vdC5nZXREZXNjZW5kZW50QnlFbChlbCkpXG4gIH1cblxuICBnZXRSb290QnlJZChpZCl7IHJldHVybiB0aGlzLnJvb3RzW2lkXSB9XG5cbiAgZGVzdHJveUFsbFZpZXdzKCl7XG4gICAgZm9yKGxldCBpZCBpbiB0aGlzLnJvb3RzKXtcbiAgICAgIHRoaXMucm9vdHNbaWRdLmRlc3Ryb3koKVxuICAgICAgZGVsZXRlIHRoaXMucm9vdHNbaWRdXG4gICAgfVxuICAgIHRoaXMubWFpbiA9IG51bGxcbiAgfVxuXG4gIGRlc3Ryb3lWaWV3QnlFbChlbCl7XG4gICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3RCeUlkKGVsLmdldEF0dHJpYnV0ZShQSFhfUk9PVF9JRCkpXG4gICAgaWYocm9vdCAmJiByb290LmlkID09PSBlbC5pZCl7XG4gICAgICByb290LmRlc3Ryb3koKVxuICAgICAgZGVsZXRlIHRoaXMucm9vdHNbcm9vdC5pZF1cbiAgICB9IGVsc2UgaWYocm9vdCl7XG4gICAgICByb290LmRlc3Ryb3lEZXNjZW5kZW50KGVsLmlkKVxuICAgIH1cbiAgfVxuXG4gIGdldEFjdGl2ZUVsZW1lbnQoKXtcbiAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICB9XG5cbiAgZHJvcEFjdGl2ZUVsZW1lbnQodmlldyl7XG4gICAgaWYodGhpcy5wcmV2QWN0aXZlICYmIHZpZXcub3duc0VsZW1lbnQodGhpcy5wcmV2QWN0aXZlKSl7XG4gICAgICB0aGlzLnByZXZBY3RpdmUgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgcmVzdG9yZVByZXZpb3VzbHlBY3RpdmVGb2N1cygpe1xuICAgIGlmKHRoaXMucHJldkFjdGl2ZSAmJiB0aGlzLnByZXZBY3RpdmUgIT09IGRvY3VtZW50LmJvZHkpe1xuICAgICAgdGhpcy5wcmV2QWN0aXZlLmZvY3VzKClcbiAgICB9XG4gIH1cblxuICBibHVyQWN0aXZlRWxlbWVudCgpe1xuICAgIHRoaXMucHJldkFjdGl2ZSA9IHRoaXMuZ2V0QWN0aXZlRWxlbWVudCgpXG4gICAgaWYodGhpcy5wcmV2QWN0aXZlICE9PSBkb2N1bWVudC5ib2R5KXsgdGhpcy5wcmV2QWN0aXZlLmJsdXIoKSB9XG4gIH1cblxuICBiaW5kVG9wTGV2ZWxFdmVudHMoe2RlYWR9ID0ge30pe1xuICAgIGlmKHRoaXMuYm91bmRUb3BMZXZlbEV2ZW50cyl7IHJldHVybiB9XG5cbiAgICB0aGlzLmJvdW5kVG9wTGV2ZWxFdmVudHMgPSB0cnVlXG4gICAgLy8gZW50ZXIgZmFpbHNhZmUgcmVsb2FkIGlmIHNlcnZlciBoYXMgZ29uZSBhd2F5IGludGVudGlvbmFsbHksIHN1Y2ggYXMgXCJkaXNjb25uZWN0XCIgYnJvYWRjYXN0XG4gICAgdGhpcy5zZXJ2ZXJDbG9zZVJlZiA9IHRoaXMuc29ja2V0Lm9uQ2xvc2UoZXZlbnQgPT4ge1xuICAgICAgLy8gZmFpbHNhZmUgcmVsb2FkIGlmIG5vcm1hbCBjbG9zdXJlIGFuZCB3ZSBzdGlsbCBoYXZlIGEgbWFpbiBMVlxuICAgICAgaWYoZXZlbnQgJiYgZXZlbnQuY29kZSA9PT0gMTAwMCAmJiB0aGlzLm1haW4peyByZXR1cm4gdGhpcy5yZWxvYWRXaXRoSml0dGVyKHRoaXMubWFpbikgfVxuICAgIH0pXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCl7IH0pIC8vIGVuc3VyZSBhbGwgY2xpY2sgZXZlbnRzIGJ1YmJsZSBmb3IgbW9iaWxlIFNhZmFyaVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIiwgZSA9PiB7XG4gICAgICBpZihlLnBlcnNpc3RlZCl7IC8vIHJlbG9hZCBwYWdlIGlmIGJlaW5nIHJlc3RvcmVkIGZyb20gYmFjay9mb3J3YXJkIGNhY2hlXG4gICAgICAgIHRoaXMuZ2V0U29ja2V0KCkuZGlzY29ubmVjdCgpXG4gICAgICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogd2luZG93LmxvY2F0aW9uLmhyZWYsIGtpbmQ6IFwicmVkaXJlY3RcIn0pXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgfVxuICAgIH0sIHRydWUpXG4gICAgaWYoIWRlYWQpeyB0aGlzLmJpbmROYXYoKSB9XG4gICAgdGhpcy5iaW5kQ2xpY2tzKClcbiAgICBpZighZGVhZCl7IHRoaXMuYmluZEZvcm1zKCkgfVxuICAgIHRoaXMuYmluZCh7a2V5dXA6IFwia2V5dXBcIiwga2V5ZG93bjogXCJrZXlkb3duXCJ9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBfcGh4VGFyZ2V0KSA9PiB7XG4gICAgICBsZXQgbWF0Y2hLZXkgPSB0YXJnZXRFbC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9LRVkpKVxuICAgICAgbGV0IHByZXNzZWRLZXkgPSBlLmtleSAmJiBlLmtleS50b0xvd2VyQ2FzZSgpIC8vIGNocm9tZSBjbGlja2VkIGF1dG9jb21wbGV0ZXMgc2VuZCBhIGtleWRvd24gd2l0aG91dCBrZXlcbiAgICAgIGlmKG1hdGNoS2V5ICYmIG1hdGNoS2V5LnRvTG93ZXJDYXNlKCkgIT09IHByZXNzZWRLZXkpeyByZXR1cm4gfVxuXG4gICAgICBsZXQgZGF0YSA9IHtrZXk6IGUua2V5LCAuLi50aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbCl9XG4gICAgICBKUy5leGVjKGUsIHR5cGUsIHBoeEV2ZW50LCB2aWV3LCB0YXJnZXRFbCwgW1wicHVzaFwiLCB7ZGF0YX1dKVxuICAgIH0pXG4gICAgdGhpcy5iaW5kKHtibHVyOiBcImZvY3Vzb3V0XCIsIGZvY3VzOiBcImZvY3VzaW5cIn0sIChlLCB0eXBlLCB2aWV3LCB0YXJnZXRFbCwgcGh4RXZlbnQsIHBoeFRhcmdldCkgPT4ge1xuICAgICAgaWYoIXBoeFRhcmdldCl7XG4gICAgICAgIGxldCBkYXRhID0ge2tleTogZS5rZXksIC4uLnRoaXMuZXZlbnRNZXRhKHR5cGUsIGUsIHRhcmdldEVsKX1cbiAgICAgICAgSlMuZXhlYyhlLCB0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuYmluZCh7Ymx1cjogXCJibHVyXCIsIGZvY3VzOiBcImZvY3VzXCJ9LCAoZSwgdHlwZSwgdmlldywgdGFyZ2V0RWwsIHBoeEV2ZW50LCBwaHhUYXJnZXQpID0+IHtcbiAgICAgIC8vIGJsdXIgYW5kIGZvY3VzIGFyZSB0cmlnZ2VyZWQgb24gZG9jdW1lbnQgYW5kIHdpbmRvdy4gRGlzY2FyZCBvbmUgdG8gYXZvaWQgZHVwc1xuICAgICAgaWYocGh4VGFyZ2V0ID09PSBcIndpbmRvd1wiKXtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmV2ZW50TWV0YSh0eXBlLCBlLCB0YXJnZXRFbClcbiAgICAgICAgSlMuZXhlYyhlLCB0eXBlLCBwaHhFdmVudCwgdmlldywgdGFyZ2V0RWwsIFtcInB1c2hcIiwge2RhdGF9XSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMub24oXCJkcmFnb3ZlclwiLCBlID0+IGUucHJldmVudERlZmF1bHQoKSlcbiAgICB0aGlzLm9uKFwiZHJvcFwiLCBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgbGV0IGRyb3BUYXJnZXRJZCA9IG1heWJlKGNsb3Nlc3RQaHhCaW5kaW5nKGUudGFyZ2V0LCB0aGlzLmJpbmRpbmcoUEhYX0RST1BfVEFSR0VUKSksIHRydWVUYXJnZXQgPT4ge1xuICAgICAgICByZXR1cm4gdHJ1ZVRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFBIWF9EUk9QX1RBUkdFVCkpXG4gICAgICB9KVxuICAgICAgbGV0IGRyb3BUYXJnZXQgPSBkcm9wVGFyZ2V0SWQgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZHJvcFRhcmdldElkKVxuICAgICAgbGV0IGZpbGVzID0gQXJyYXkuZnJvbShlLmRhdGFUcmFuc2Zlci5maWxlcyB8fCBbXSlcbiAgICAgIGlmKCFkcm9wVGFyZ2V0IHx8IGRyb3BUYXJnZXQuZGlzYWJsZWQgfHwgZmlsZXMubGVuZ3RoID09PSAwIHx8ICEoZHJvcFRhcmdldC5maWxlcyBpbnN0YW5jZW9mIEZpbGVMaXN0KSl7IHJldHVybiB9XG5cbiAgICAgIExpdmVVcGxvYWRlci50cmFja0ZpbGVzKGRyb3BUYXJnZXQsIGZpbGVzLCBlLmRhdGFUcmFuc2ZlcilcbiAgICAgIGRyb3BUYXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiLCB7YnViYmxlczogdHJ1ZX0pKVxuICAgIH0pXG4gICAgdGhpcy5vbihQSFhfVFJBQ0tfVVBMT0FEUywgZSA9PiB7XG4gICAgICBsZXQgdXBsb2FkVGFyZ2V0ID0gZS50YXJnZXRcbiAgICAgIGlmKCFET00uaXNVcGxvYWRJbnB1dCh1cGxvYWRUYXJnZXQpKXsgcmV0dXJuIH1cbiAgICAgIGxldCBmaWxlcyA9IEFycmF5LmZyb20oZS5kZXRhaWwuZmlsZXMgfHwgW10pLmZpbHRlcihmID0+IGYgaW5zdGFuY2VvZiBGaWxlIHx8IGYgaW5zdGFuY2VvZiBCbG9iKVxuICAgICAgTGl2ZVVwbG9hZGVyLnRyYWNrRmlsZXModXBsb2FkVGFyZ2V0LCBmaWxlcylcbiAgICAgIHVwbG9hZFRhcmdldC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlfSkpXG4gICAgfSlcbiAgfVxuXG4gIGV2ZW50TWV0YShldmVudE5hbWUsIGUsIHRhcmdldEVsKXtcbiAgICBsZXQgY2FsbGJhY2sgPSB0aGlzLm1ldGFkYXRhQ2FsbGJhY2tzW2V2ZW50TmFtZV1cbiAgICByZXR1cm4gY2FsbGJhY2sgPyBjYWxsYmFjayhlLCB0YXJnZXRFbCkgOiB7fVxuICB9XG5cbiAgc2V0UGVuZGluZ0xpbmsoaHJlZil7XG4gICAgdGhpcy5saW5rUmVmKytcbiAgICB0aGlzLnBlbmRpbmdMaW5rID0gaHJlZlxuICAgIHRoaXMucmVzZXRSZWxvYWRTdGF0dXMoKVxuICAgIHJldHVybiB0aGlzLmxpbmtSZWZcbiAgfVxuXG4gIC8vIGFueXRpbWUgd2UgYXJlIG5hdmlnYXRpbmcgb3IgY29ubmVjdGluZywgZHJvcCByZWxvYWQgY29va2llIGluIGNhc2VcbiAgLy8gd2UgaXNzdWUgdGhlIGNvb2tpZSBidXQgdGhlIG5leHQgcmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYW5kIHRoZSBzZXJ2ZXIgbmV2ZXIgZHJvcHBlZCBpdFxuICByZXNldFJlbG9hZFN0YXR1cygpeyBCcm93c2VyLmRlbGV0ZUNvb2tpZShQSFhfUkVMT0FEX1NUQVRVUykgfVxuXG4gIGNvbW1pdFBlbmRpbmdMaW5rKGxpbmtSZWYpe1xuICAgIGlmKHRoaXMubGlua1JlZiAhPT0gbGlua1JlZil7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ocmVmID0gdGhpcy5wZW5kaW5nTGlua1xuICAgICAgdGhpcy5wZW5kaW5nTGluayA9IG51bGxcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgZ2V0SHJlZigpeyByZXR1cm4gdGhpcy5ocmVmIH1cblxuICBoYXNQZW5kaW5nTGluaygpeyByZXR1cm4gISF0aGlzLnBlbmRpbmdMaW5rIH1cblxuICBiaW5kKGV2ZW50cywgY2FsbGJhY2spe1xuICAgIGZvcihsZXQgZXZlbnQgaW4gZXZlbnRzKXtcbiAgICAgIGxldCBicm93c2VyRXZlbnROYW1lID0gZXZlbnRzW2V2ZW50XVxuXG4gICAgICB0aGlzLm9uKGJyb3dzZXJFdmVudE5hbWUsIGUgPT4ge1xuICAgICAgICBsZXQgYmluZGluZyA9IHRoaXMuYmluZGluZyhldmVudClcbiAgICAgICAgbGV0IHdpbmRvd0JpbmRpbmcgPSB0aGlzLmJpbmRpbmcoYHdpbmRvdy0ke2V2ZW50fWApXG4gICAgICAgIGxldCB0YXJnZXRQaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoYmluZGluZylcbiAgICAgICAgaWYodGFyZ2V0UGh4RXZlbnQpe1xuICAgICAgICAgIHRoaXMuZGVib3VuY2UoZS50YXJnZXQsIGUsIGJyb3dzZXJFdmVudE5hbWUsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGUudGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICAgICAgY2FsbGJhY2soZSwgZXZlbnQsIHZpZXcsIGUudGFyZ2V0LCB0YXJnZXRQaHhFdmVudCwgbnVsbClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET00uYWxsKGRvY3VtZW50LCBgWyR7d2luZG93QmluZGluZ31dYCwgZWwgPT4ge1xuICAgICAgICAgICAgbGV0IHBoeEV2ZW50ID0gZWwuZ2V0QXR0cmlidXRlKHdpbmRvd0JpbmRpbmcpXG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlKGVsLCBlLCBicm93c2VyRXZlbnROYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCB2aWV3ID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlLCBldmVudCwgdmlldywgZWwsIHBoeEV2ZW50LCBcIndpbmRvd1wiKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGJpbmRDbGlja3MoKXtcbiAgICB0aGlzLm9uKFwibW91c2Vkb3duXCIsIGUgPT4gdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IGUudGFyZ2V0KVxuICAgIHRoaXMuYmluZENsaWNrKFwiY2xpY2tcIiwgXCJjbGlja1wiKVxuICB9XG5cbiAgYmluZENsaWNrKGV2ZW50TmFtZSwgYmluZGluZ05hbWUpe1xuICAgIGxldCBjbGljayA9IHRoaXMuYmluZGluZyhiaW5kaW5nTmFtZSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGUgPT4ge1xuICAgICAgbGV0IHRhcmdldCA9IG51bGxcbiAgICAgIC8vIGEgc3ludGhldGljIGNsaWNrIGV2ZW50IChkZXRhaWwgMCkgd2lsbCBub3QgaGF2ZSBjYXVzZWQgYSBtb3VzZWRvd24gZXZlbnQsXG4gICAgICAvLyB0aGVyZWZvcmUgdGhlIGNsaWNrU3RhcnRlZEF0VGFyZ2V0IGlzIHN0YWxlXG4gICAgICBpZihlLmRldGFpbCA9PT0gMCkgdGhpcy5jbGlja1N0YXJ0ZWRBdFRhcmdldCA9IGUudGFyZ2V0XG4gICAgICBsZXQgY2xpY2tTdGFydGVkQXRUYXJnZXQgPSB0aGlzLmNsaWNrU3RhcnRlZEF0VGFyZ2V0IHx8IGUudGFyZ2V0XG4gICAgICAvLyB3aGVuIHNlYXJjaGluZyB0aGUgdGFyZ2V0IGZvciB0aGUgY2xpY2sgZXZlbnQsIHdlIGFsd2F5cyB3YW50IHRvXG4gICAgICAvLyB1c2UgdGhlIGFjdHVhbCBldmVudCB0YXJnZXQsIHNlZSAjMzM3MlxuICAgICAgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIGNsaWNrKVxuICAgICAgdGhpcy5kaXNwYXRjaENsaWNrQXdheShlLCBjbGlja1N0YXJ0ZWRBdFRhcmdldClcbiAgICAgIHRoaXMuY2xpY2tTdGFydGVkQXRUYXJnZXQgPSBudWxsXG4gICAgICBsZXQgcGh4RXZlbnQgPSB0YXJnZXQgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShjbGljaylcbiAgICAgIGlmKCFwaHhFdmVudCl7XG4gICAgICAgIGlmKERPTS5pc05ld1BhZ2VDbGljayhlLCB3aW5kb3cubG9jYXRpb24pKXsgdGhpcy51bmxvYWQoKSB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZih0YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIpeyBlLnByZXZlbnREZWZhdWx0KCkgfVxuXG4gICAgICAvLyBub29wIGlmIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIGF3YWl0aW5nIGFuIGFjayBmb3IgdGhpcyBlbCBhbHJlYWR5XG4gICAgICBpZih0YXJnZXQuaGFzQXR0cmlidXRlKFBIWF9SRUZfU1JDKSl7IHJldHVybiB9XG5cbiAgICAgIHRoaXMuZGVib3VuY2UodGFyZ2V0LCBlLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnModGFyZ2V0LCB2aWV3ID0+IHtcbiAgICAgICAgICBKUy5leGVjKGUsIFwiY2xpY2tcIiwgcGh4RXZlbnQsIHZpZXcsIHRhcmdldCwgW1wicHVzaFwiLCB7ZGF0YTogdGhpcy5ldmVudE1ldGEoXCJjbGlja1wiLCBlLCB0YXJnZXQpfV0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICB9XG5cbiAgZGlzcGF0Y2hDbGlja0F3YXkoZSwgY2xpY2tTdGFydGVkQXQpe1xuICAgIGxldCBwaHhDbGlja0F3YXkgPSB0aGlzLmJpbmRpbmcoXCJjbGljay1hd2F5XCIpXG4gICAgRE9NLmFsbChkb2N1bWVudCwgYFske3BoeENsaWNrQXdheX1dYCwgZWwgPT4ge1xuICAgICAgaWYoIShlbC5pc1NhbWVOb2RlKGNsaWNrU3RhcnRlZEF0KSB8fCBlbC5jb250YWlucyhjbGlja1N0YXJ0ZWRBdCkpKXtcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZWwsIHZpZXcgPT4ge1xuICAgICAgICAgIGxldCBwaHhFdmVudCA9IGVsLmdldEF0dHJpYnV0ZShwaHhDbGlja0F3YXkpXG4gICAgICAgICAgaWYoSlMuaXNWaXNpYmxlKGVsKSAmJiBKUy5pc0luVmlld3BvcnQoZWwpKXtcbiAgICAgICAgICAgIEpTLmV4ZWMoZSwgXCJjbGlja1wiLCBwaHhFdmVudCwgdmlldywgZWwsIFtcInB1c2hcIiwge2RhdGE6IHRoaXMuZXZlbnRNZXRhKFwiY2xpY2tcIiwgZSwgZS50YXJnZXQpfV0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBiaW5kTmF2KCl7XG4gICAgaWYoIUJyb3dzZXIuY2FuUHVzaFN0YXRlKCkpeyByZXR1cm4gfVxuICAgIGlmKGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24peyBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIiB9XG4gICAgbGV0IHNjcm9sbFRpbWVyID0gbnVsbFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIF9lID0+IHtcbiAgICAgIGNsZWFyVGltZW91dChzY3JvbGxUaW1lcilcbiAgICAgIHNjcm9sbFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIEJyb3dzZXIudXBkYXRlQ3VycmVudFN0YXRlKHN0YXRlID0+IE9iamVjdC5hc3NpZ24oc3RhdGUsIHtzY3JvbGw6IHdpbmRvdy5zY3JvbGxZfSkpXG4gICAgICB9LCAxMDApXG4gICAgfSlcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmKCF0aGlzLnJlZ2lzdGVyTmV3TG9jYXRpb24od2luZG93LmxvY2F0aW9uKSl7IHJldHVybiB9XG4gICAgICBsZXQge3R5cGUsIGJhY2tUeXBlLCBpZCwgc2Nyb2xsLCBwb3NpdGlvbn0gPSBldmVudC5zdGF0ZSB8fCB7fVxuICAgICAgbGV0IGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuXG4gICAgICAvLyBDb21wYXJlIHBvc2l0aW9ucyB0byBkZXRlcm1pbmUgZGlyZWN0aW9uXG4gICAgICBsZXQgaXNGb3J3YXJkID0gcG9zaXRpb24gPiB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb25cblxuICAgICAgdHlwZSA9IGlzRm9yd2FyZCA/IHR5cGUgOiAoYmFja1R5cGUgfHwgdHlwZSlcblxuICAgICAgLy8gVXBkYXRlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgIHRoaXMuY3VycmVudEhpc3RvcnlQb3NpdGlvbiA9IHBvc2l0aW9uIHx8IDBcbiAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfSElTVE9SWV9QT1NJVElPTiwgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uLnRvU3RyaW5nKCkpXG5cbiAgICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6bmF2aWdhdGVcIiwge2RldGFpbDoge2hyZWYsIHBhdGNoOiB0eXBlID09PSBcInBhdGNoXCIsIHBvcDogdHJ1ZSwgZGlyZWN0aW9uOiBpc0ZvcndhcmQgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIn19KVxuICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7IHRoaXMubWF5YmVTY3JvbGwoc2Nyb2xsKSB9XG4gICAgICAgIGlmKHRoaXMubWFpbi5pc0Nvbm5lY3RlZCgpICYmICh0eXBlID09PSBcInBhdGNoXCIgJiYgaWQgPT09IHRoaXMubWFpbi5pZCkpe1xuICAgICAgICAgIHRoaXMubWFpbi5wdXNoTGlua1BhdGNoKGV2ZW50LCBocmVmLCBudWxsLCBjYWxsYmFjaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlcGxhY2VNYWluKGhyZWYsIG51bGwsIGNhbGxiYWNrKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sIGZhbHNlKVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gY2xvc2VzdFBoeEJpbmRpbmcoZS50YXJnZXQsIFBIWF9MSVZFX0xJTkspXG4gICAgICBsZXQgdHlwZSA9IHRhcmdldCAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKFBIWF9MSVZFX0xJTkspXG4gICAgICBpZighdHlwZSB8fCAhdGhpcy5pc0Nvbm5lY3RlZCgpIHx8ICF0aGlzLm1haW4gfHwgRE9NLndhbnRzTmV3VGFiKGUpKXsgcmV0dXJuIH1cblxuICAgICAgLy8gV2hlbiB3cmFwcGluZyBhbiBTVkcgZWxlbWVudCBpbiBhbiBhbmNob3IgdGFnLCB0aGUgaHJlZiBjYW4gYmUgYW4gU1ZHQW5pbWF0ZWRTdHJpbmdcbiAgICAgIGxldCBocmVmID0gdGFyZ2V0LmhyZWYgaW5zdGFuY2VvZiBTVkdBbmltYXRlZFN0cmluZyA/IHRhcmdldC5ocmVmLmJhc2VWYWwgOiB0YXJnZXQuaHJlZlxuXG4gICAgICBsZXQgbGlua1N0YXRlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShQSFhfTElOS19TVEFURSlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSAvLyBkbyBub3QgYnViYmxlIGNsaWNrIHRvIHJlZ3VsYXIgcGh4LWNsaWNrIGJpbmRpbmdzXG4gICAgICBpZih0aGlzLnBlbmRpbmdMaW5rID09PSBocmVmKXsgcmV0dXJuIH1cblxuICAgICAgdGhpcy5yZXF1ZXN0RE9NVXBkYXRlKCgpID0+IHtcbiAgICAgICAgaWYodHlwZSA9PT0gXCJwYXRjaFwiKXtcbiAgICAgICAgICB0aGlzLnB1c2hIaXN0b3J5UGF0Y2goZSwgaHJlZiwgbGlua1N0YXRlLCB0YXJnZXQpXG4gICAgICAgIH0gZWxzZSBpZih0eXBlID09PSBcInJlZGlyZWN0XCIpe1xuICAgICAgICAgIHRoaXMuaGlzdG9yeVJlZGlyZWN0KGUsIGhyZWYsIGxpbmtTdGF0ZSwgbnVsbCwgdGFyZ2V0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHtQSFhfTElWRV9MSU5LfSB0byBiZSBcInBhdGNoXCIgb3IgXCJyZWRpcmVjdFwiLCBnb3Q6ICR7dHlwZX1gKVxuICAgICAgICB9XG4gICAgICAgIGxldCBwaHhDbGljayA9IHRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwiY2xpY2tcIikpXG4gICAgICAgIGlmKHBoeENsaWNrKXtcbiAgICAgICAgICB0aGlzLnJlcXVlc3RET01VcGRhdGUoKCkgPT4gdGhpcy5leGVjSlModGFyZ2V0LCBwaHhDbGljaywgXCJjbGlja1wiKSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LCBmYWxzZSlcbiAgfVxuXG4gIG1heWJlU2Nyb2xsKHNjcm9sbCl7XG4gICAgaWYodHlwZW9mKHNjcm9sbCkgPT09IFwibnVtYmVyXCIpe1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHNjcm9sbClcbiAgICAgIH0pIC8vIHRoZSBib2R5IG5lZWRzIHRvIHJlbmRlciBiZWZvcmUgd2Ugc2Nyb2xsLlxuICAgIH1cbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQgPSB7fSl7XG4gICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBgcGh4OiR7ZXZlbnR9YCwge2RldGFpbDogcGF5bG9hZH0pXG4gIH1cblxuICBkaXNwYXRjaEV2ZW50cyhldmVudHMpe1xuICAgIGV2ZW50cy5mb3JFYWNoKChbZXZlbnQsIHBheWxvYWRdKSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHBheWxvYWQpKVxuICB9XG5cbiAgd2l0aFBhZ2VMb2FkaW5nKGluZm8sIGNhbGxiYWNrKXtcbiAgICBET00uZGlzcGF0Y2hFdmVudCh3aW5kb3csIFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCB7ZGV0YWlsOiBpbmZvfSlcbiAgICBsZXQgZG9uZSA9ICgpID0+IERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwge2RldGFpbDogaW5mb30pXG4gICAgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soZG9uZSkgOiBkb25lXG4gIH1cblxuICBwdXNoSGlzdG9yeVBhdGNoKGUsIGhyZWYsIGxpbmtTdGF0ZSwgdGFyZ2V0RWwpe1xuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbi5pc01haW4oKSl7IHJldHVybiBCcm93c2VyLnJlZGlyZWN0KGhyZWYpIH1cblxuICAgIHRoaXMud2l0aFBhZ2VMb2FkaW5nKHt0bzogaHJlZiwga2luZDogXCJwYXRjaFwifSwgZG9uZSA9PiB7XG4gICAgICB0aGlzLm1haW4ucHVzaExpbmtQYXRjaChlLCBocmVmLCB0YXJnZXRFbCwgbGlua1JlZiA9PiB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVBhdGNoKGhyZWYsIGxpbmtTdGF0ZSwgbGlua1JlZilcbiAgICAgICAgZG9uZSgpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBoaXN0b3J5UGF0Y2goaHJlZiwgbGlua1N0YXRlLCBsaW5rUmVmID0gdGhpcy5zZXRQZW5kaW5nTGluayhocmVmKSl7XG4gICAgaWYoIXRoaXMuY29tbWl0UGVuZGluZ0xpbmsobGlua1JlZikpeyByZXR1cm4gfVxuXG4gICAgLy8gSW5jcmVtZW50IHBvc2l0aW9uIGZvciBuZXcgc3RhdGVcbiAgICB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24rK1xuICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfSElTVE9SWV9QT1NJVElPTiwgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uLnRvU3RyaW5nKCkpXG5cbiAgICAvLyBzdG9yZSB0aGUgdHlwZSBmb3IgYmFjayBuYXZpZ2F0aW9uXG4gICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoKHN0YXRlKSA9PiAoey4uLnN0YXRlLCBiYWNrVHlwZTogXCJwYXRjaFwifSkpXG5cbiAgICBCcm93c2VyLnB1c2hTdGF0ZShsaW5rU3RhdGUsIHtcbiAgICAgIHR5cGU6IFwicGF0Y2hcIixcbiAgICAgIGlkOiB0aGlzLm1haW4uaWQsXG4gICAgICBwb3NpdGlvbjogdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uXG4gICAgfSwgaHJlZilcblxuICAgIERPTS5kaXNwYXRjaEV2ZW50KHdpbmRvdywgXCJwaHg6bmF2aWdhdGVcIiwge2RldGFpbDoge3BhdGNoOiB0cnVlLCBocmVmLCBwb3A6IGZhbHNlLCBkaXJlY3Rpb246IFwiZm9yd2FyZFwifX0pXG4gICAgdGhpcy5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbilcbiAgfVxuXG4gIGhpc3RvcnlSZWRpcmVjdChlLCBocmVmLCBsaW5rU3RhdGUsIGZsYXNoLCB0YXJnZXRFbCl7XG4gICAgY29uc3QgY2xpY2tMb2FkaW5nID0gdGFyZ2V0RWwgJiYgZS5pc1RydXN0ZWQgJiYgZS50eXBlICE9PSBcInBvcHN0YXRlXCJcbiAgICBpZihjbGlja0xvYWRpbmcpeyB0YXJnZXRFbC5jbGFzc0xpc3QuYWRkKFwicGh4LWNsaWNrLWxvYWRpbmdcIikgfVxuICAgIGlmKCF0aGlzLmlzQ29ubmVjdGVkKCkgfHwgIXRoaXMubWFpbi5pc01haW4oKSl7IHJldHVybiBCcm93c2VyLnJlZGlyZWN0KGhyZWYsIGZsYXNoKSB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIGZ1bGwgaHJlZiBpZiBvbmx5IHBhdGggcHJlZml4XG4gICAgaWYoL15cXC8kfF5cXC9bXlxcL10rLiokLy50ZXN0KGhyZWYpKXtcbiAgICAgIGxldCB7cHJvdG9jb2wsIGhvc3R9ID0gd2luZG93LmxvY2F0aW9uXG4gICAgICBocmVmID0gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9JHtocmVmfWBcbiAgICB9XG4gICAgbGV0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZXG4gICAgdGhpcy53aXRoUGFnZUxvYWRpbmcoe3RvOiBocmVmLCBraW5kOiBcInJlZGlyZWN0XCJ9LCBkb25lID0+IHtcbiAgICAgIHRoaXMucmVwbGFjZU1haW4oaHJlZiwgZmxhc2gsIChsaW5rUmVmKSA9PiB7XG4gICAgICAgIGlmKGxpbmtSZWYgPT09IHRoaXMubGlua1JlZil7XG4gICAgICAgICAgLy8gSW5jcmVtZW50IHBvc2l0aW9uIGZvciBuZXcgc3RhdGVcbiAgICAgICAgICB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb24rK1xuICAgICAgICAgIHRoaXMuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShQSFhfTFZfSElTVE9SWV9QT1NJVElPTiwgdGhpcy5jdXJyZW50SGlzdG9yeVBvc2l0aW9uLnRvU3RyaW5nKCkpXG5cbiAgICAgICAgICAvLyBzdG9yZSB0aGUgdHlwZSBmb3IgYmFjayBuYXZpZ2F0aW9uXG4gICAgICAgICAgQnJvd3Nlci51cGRhdGVDdXJyZW50U3RhdGUoKHN0YXRlKSA9PiAoey4uLnN0YXRlLCBiYWNrVHlwZTogXCJyZWRpcmVjdFwifSkpXG5cbiAgICAgICAgICBCcm93c2VyLnB1c2hTdGF0ZShsaW5rU3RhdGUsIHtcbiAgICAgICAgICAgIHR5cGU6IFwicmVkaXJlY3RcIixcbiAgICAgICAgICAgIGlkOiB0aGlzLm1haW4uaWQsXG4gICAgICAgICAgICBzY3JvbGw6IHNjcm9sbCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmN1cnJlbnRIaXN0b3J5UG9zaXRpb25cbiAgICAgICAgICB9LCBocmVmKVxuXG4gICAgICAgICAgRE9NLmRpc3BhdGNoRXZlbnQod2luZG93LCBcInBoeDpuYXZpZ2F0ZVwiLCB7ZGV0YWlsOiB7aHJlZiwgcGF0Y2g6IGZhbHNlLCBwb3A6IGZhbHNlLCBkaXJlY3Rpb246IFwiZm9yd2FyZFwifX0pXG4gICAgICAgICAgdGhpcy5yZWdpc3Rlck5ld0xvY2F0aW9uKHdpbmRvdy5sb2NhdGlvbilcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBsaWNpdGx5IHVuZG8gY2xpY2stbG9hZGluZyBjbGFzc1xuICAgICAgICAvLyAoaW4gY2FzZSBpdCBvcmlnaW5hdGVkIGluIGEgc3RpY2t5IGxpdmUgdmlldywgb3RoZXJ3aXNlIGl0IHdvdWxkIGJlIHJlbW92ZWQgYW55d2F5KVxuICAgICAgICBpZihjbGlja0xvYWRpbmcpeyB0YXJnZXRFbC5jbGFzc0xpc3QucmVtb3ZlKFwicGh4LWNsaWNrLWxvYWRpbmdcIikgfVxuICAgICAgICBkb25lKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHJlZ2lzdGVyTmV3TG9jYXRpb24obmV3TG9jYXRpb24pe1xuICAgIGxldCB7cGF0aG5hbWUsIHNlYXJjaH0gPSB0aGlzLmN1cnJlbnRMb2NhdGlvblxuICAgIGlmKHBhdGhuYW1lICsgc2VhcmNoID09PSBuZXdMb2NhdGlvbi5wYXRobmFtZSArIG5ld0xvY2F0aW9uLnNlYXJjaCl7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBjbG9uZShuZXdMb2NhdGlvbilcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgYmluZEZvcm1zKCl7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwXG4gICAgbGV0IGV4dGVybmFsRm9ybVN1Ym1pdHRlZCA9IGZhbHNlXG5cbiAgICAvLyBkaXNhYmxlIGZvcm1zIG9uIHN1Ym1pdCB0aGF0IHRyYWNrIHBoeC1jaGFuZ2UgYnV0IHBlcmZvcm0gZXh0ZXJuYWwgc3VibWl0XG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhTdWJtaXQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUodGhpcy5iaW5kaW5nKFwic3VibWl0XCIpKVxuICAgICAgbGV0IHBoeENoYW5nZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJjaGFuZ2VcIikpXG4gICAgICBpZighZXh0ZXJuYWxGb3JtU3VibWl0dGVkICYmIHBoeENoYW5nZSAmJiAhcGh4U3VibWl0KXtcbiAgICAgICAgZXh0ZXJuYWxGb3JtU3VibWl0dGVkID0gdHJ1ZVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZS50YXJnZXQsIHZpZXcgPT4ge1xuICAgICAgICAgIHZpZXcuZGlzYWJsZUZvcm0oZS50YXJnZXQpXG4gICAgICAgICAgLy8gc2FmYXJpIG5lZWRzIG5leHQgdGlja1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYoRE9NLmlzVW5sb2FkYWJsZUZvcm1TdWJtaXQoZSkpeyB0aGlzLnVubG9hZCgpIH1cbiAgICAgICAgICAgIGUudGFyZ2V0LnN1Ym1pdCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5vbihcInN1Ym1pdFwiLCBlID0+IHtcbiAgICAgIGxldCBwaHhFdmVudCA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZSh0aGlzLmJpbmRpbmcoXCJzdWJtaXRcIikpXG4gICAgICBpZighcGh4RXZlbnQpe1xuICAgICAgICBpZihET00uaXNVbmxvYWRhYmxlRm9ybVN1Ym1pdChlKSl7IHRoaXMudW5sb2FkKCkgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS50YXJnZXQuZGlzYWJsZWQgPSB0cnVlXG4gICAgICB0aGlzLndpdGhpbk93bmVycyhlLnRhcmdldCwgdmlldyA9PiB7XG4gICAgICAgIEpTLmV4ZWMoZSwgXCJzdWJtaXRcIiwgcGh4RXZlbnQsIHZpZXcsIGUudGFyZ2V0LCBbXCJwdXNoXCIsIHtzdWJtaXR0ZXI6IGUuc3VibWl0dGVyfV0pXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBmb3IobGV0IHR5cGUgb2YgW1wiY2hhbmdlXCIsIFwiaW5wdXRcIl0pe1xuICAgICAgdGhpcy5vbih0eXBlLCBlID0+IHtcbiAgICAgICAgaWYoZSBpbnN0YW5jZW9mIEN1c3RvbUV2ZW50ICYmIGUudGFyZ2V0LmZvcm0gPT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgLy8gdGhyb3cgb24gaW52YWxpZCBKUy5kaXNwYXRjaCB0YXJnZXQgYW5kIG5vb3AgaWYgQ3VzdG9tRXZlbnQgdHJpZ2dlcmVkIG91dHNpZGUgSlMuZGlzcGF0Y2hcbiAgICAgICAgICBpZihlLmRldGFpbCAmJiBlLmRldGFpbC5kaXNwYXRjaGVyKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzcGF0Y2hpbmcgYSBjdXN0b20gJHt0eXBlfSBldmVudCBpcyBvbmx5IHN1cHBvcnRlZCBvbiBpbnB1dCBlbGVtZW50cyBpbnNpZGUgYSBmb3JtYClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBoeENoYW5nZSA9IHRoaXMuYmluZGluZyhcImNoYW5nZVwiKVxuICAgICAgICBsZXQgaW5wdXQgPSBlLnRhcmdldFxuICAgICAgICAvLyBkbyBub3QgZmlyZSBwaHgtY2hhbmdlIGlmIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIGEgY29tcG9zaXRpb24gc2Vzc2lvblxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9pc0NvbXBvc2luZ1xuICAgICAgICAvLyBTYWZhcmkgaGFzIGlzc3VlcyBpZiB0aGUgaW5wdXQgaXMgdXBkYXRlZCB3aGlsZSBjb21wb3NpbmdcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXhfbGl2ZV92aWV3L2lzc3Vlcy8zMzIyXG4gICAgICAgIGlmKGUuaXNDb21wb3Npbmcpe1xuICAgICAgICAgIGNvbnN0IGtleSA9IGBjb21wb3NpdGlvbi1saXN0ZW5lci0ke3R5cGV9YFxuICAgICAgICAgIGlmKCFET00ucHJpdmF0ZShpbnB1dCwga2V5KSl7XG4gICAgICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwga2V5LCB0cnVlKVxuICAgICAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbXBvc2l0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgLy8gdHJpZ2dlciBhIG5ldyBpbnB1dC9jaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgICAgaW5wdXQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQodHlwZSwge2J1YmJsZXM6IHRydWV9KSlcbiAgICAgICAgICAgICAgRE9NLmRlbGV0ZVByaXZhdGUoaW5wdXQsIGtleSlcbiAgICAgICAgICAgIH0sIHtvbmNlOiB0cnVlfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlucHV0RXZlbnQgPSBpbnB1dC5nZXRBdHRyaWJ1dGUocGh4Q2hhbmdlKVxuICAgICAgICBsZXQgZm9ybUV2ZW50ID0gaW5wdXQuZm9ybSAmJiBpbnB1dC5mb3JtLmdldEF0dHJpYnV0ZShwaHhDaGFuZ2UpXG4gICAgICAgIGxldCBwaHhFdmVudCA9IGlucHV0RXZlbnQgfHwgZm9ybUV2ZW50XG4gICAgICAgIGlmKCFwaHhFdmVudCl7IHJldHVybiB9XG4gICAgICAgIGlmKGlucHV0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5wdXQudmFsaWRpdHkgJiYgaW5wdXQudmFsaWRpdHkuYmFkSW5wdXQpeyByZXR1cm4gfVxuXG4gICAgICAgIGxldCBkaXNwYXRjaGVyID0gaW5wdXRFdmVudCA/IGlucHV0IDogaW5wdXQuZm9ybVxuICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zXG4gICAgICAgIGl0ZXJhdGlvbnMrK1xuICAgICAgICBsZXQge2F0OiBhdCwgdHlwZTogbGFzdFR5cGV9ID0gRE9NLnByaXZhdGUoaW5wdXQsIFwicHJldi1pdGVyYXRpb25cIikgfHwge31cbiAgICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIGFsd2F5cyBmaXJlIGF0IGxlYXN0IG9uZSBcImlucHV0XCIgZXZlbnQgYmVmb3JlIGV2ZXJ5IFwiY2hhbmdlXCJcbiAgICAgICAgLy8gSWdub3JlIFwiY2hhbmdlXCIgZXZlbnRzLCB1bmxlc3MgdGhlcmUgd2FzIG5vIHByaW9yIFwiaW5wdXRcIiBldmVudC5cbiAgICAgICAgLy8gVGhpcyBjb3VsZCBoYXBwZW4gaWYgdXNlciBjb2RlIHRyaWdnZXJzIGEgXCJjaGFuZ2VcIiBldmVudCwgb3IgaWYgdGhlIGJyb3dzZXIgaXMgbm9uLWNvbmZvcm1pbmcuXG4gICAgICAgIGlmKGF0ID09PSBjdXJyZW50SXRlcmF0aW9ucyAtIDEgJiYgdHlwZSA9PT0gXCJjaGFuZ2VcIiAmJiBsYXN0VHlwZSA9PT0gXCJpbnB1dFwiKXsgcmV0dXJuIH1cblxuICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgXCJwcmV2LWl0ZXJhdGlvblwiLCB7YXQ6IGN1cnJlbnRJdGVyYXRpb25zLCB0eXBlOiB0eXBlfSlcblxuICAgICAgICB0aGlzLmRlYm91bmNlKGlucHV0LCBlLCB0eXBlLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy53aXRoaW5Pd25lcnMoZGlzcGF0Y2hlciwgdmlldyA9PiB7XG4gICAgICAgICAgICBET00ucHV0UHJpdmF0ZShpbnB1dCwgUEhYX0hBU19GT0NVU0VELCB0cnVlKVxuICAgICAgICAgICAgSlMuZXhlYyhlLCBcImNoYW5nZVwiLCBwaHhFdmVudCwgdmlldywgaW5wdXQsIFtcInB1c2hcIiwge190YXJnZXQ6IGUudGFyZ2V0Lm5hbWUsIGRpc3BhdGNoZXI6IGRpc3BhdGNoZXJ9XSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gICAgdGhpcy5vbihcInJlc2V0XCIsIChlKSA9PiB7XG4gICAgICBsZXQgZm9ybSA9IGUudGFyZ2V0XG4gICAgICBET00ucmVzZXRGb3JtKGZvcm0pXG4gICAgICBsZXQgaW5wdXQgPSBBcnJheS5mcm9tKGZvcm0uZWxlbWVudHMpLmZpbmQoZWwgPT4gZWwudHlwZSA9PT0gXCJyZXNldFwiKVxuICAgICAgaWYoaW5wdXQpe1xuICAgICAgICAvLyB3YWl0IHVudGlsIG5leHQgdGljayB0byBnZXQgdXBkYXRlZCBpbnB1dCB2YWx1ZVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiBmYWxzZX0pKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkZWJvdW5jZShlbCwgZXZlbnQsIGV2ZW50VHlwZSwgY2FsbGJhY2spe1xuICAgIGlmKGV2ZW50VHlwZSA9PT0gXCJibHVyXCIgfHwgZXZlbnRUeXBlID09PSBcImZvY3Vzb3V0XCIpeyByZXR1cm4gY2FsbGJhY2soKSB9XG5cbiAgICBsZXQgcGh4RGVib3VuY2UgPSB0aGlzLmJpbmRpbmcoUEhYX0RFQk9VTkNFKVxuICAgIGxldCBwaHhUaHJvdHRsZSA9IHRoaXMuYmluZGluZyhQSFhfVEhST1RUTEUpXG4gICAgbGV0IGRlZmF1bHREZWJvdW5jZSA9IHRoaXMuZGVmYXVsdHMuZGVib3VuY2UudG9TdHJpbmcoKVxuICAgIGxldCBkZWZhdWx0VGhyb3R0bGUgPSB0aGlzLmRlZmF1bHRzLnRocm90dGxlLnRvU3RyaW5nKClcblxuICAgIHRoaXMud2l0aGluT3duZXJzKGVsLCB2aWV3ID0+IHtcbiAgICAgIGxldCBhc3luY0ZpbHRlciA9ICgpID0+ICF2aWV3LmlzRGVzdHJveWVkKCkgJiYgZG9jdW1lbnQuYm9keS5jb250YWlucyhlbClcbiAgICAgIERPTS5kZWJvdW5jZShlbCwgZXZlbnQsIHBoeERlYm91bmNlLCBkZWZhdWx0RGVib3VuY2UsIHBoeFRocm90dGxlLCBkZWZhdWx0VGhyb3R0bGUsIGFzeW5jRmlsdGVyLCAoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIHNpbGVuY2VFdmVudHMoY2FsbGJhY2spe1xuICAgIHRoaXMuc2lsZW5jZWQgPSB0cnVlXG4gICAgY2FsbGJhY2soKVxuICAgIHRoaXMuc2lsZW5jZWQgPSBmYWxzZVxuICB9XG5cbiAgb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICB0aGlzLmJvdW5kRXZlbnROYW1lcy5hZGQoZXZlbnQpXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGUgPT4ge1xuICAgICAgaWYoIXRoaXMuc2lsZW5jZWQpeyBjYWxsYmFjayhlKSB9XG4gICAgfSlcbiAgfVxuXG4gIGpzUXVlcnlTZWxlY3RvckFsbChzb3VyY2VFbCwgcXVlcnksIGRlZmF1bHRRdWVyeSl7XG4gICAgbGV0IGFsbCA9IHRoaXMuZG9tQ2FsbGJhY2tzLmpzUXVlcnlTZWxlY3RvckFsbFxuICAgIHJldHVybiBhbGwgPyBhbGwoc291cmNlRWwsIHF1ZXJ5LCBkZWZhdWx0UXVlcnkpIDogZGVmYXVsdFF1ZXJ5KClcbiAgfVxufVxuXG5jbGFzcyBUcmFuc2l0aW9uU2V0IHtcbiAgY29uc3RydWN0b3IoKXtcbiAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFNldCgpXG4gICAgdGhpcy5wZW5kaW5nT3BzID0gW11cbiAgfVxuXG4gIHJlc2V0KCl7XG4gICAgdGhpcy50cmFuc2l0aW9ucy5mb3JFYWNoKHRpbWVyID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuZGVsZXRlKHRpbWVyKVxuICAgIH0pXG4gICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKVxuICB9XG5cbiAgYWZ0ZXIoY2FsbGJhY2spe1xuICAgIGlmKHRoaXMuc2l6ZSgpID09PSAwKXtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoUGVuZGluZ09wKGNhbGxiYWNrKVxuICAgIH1cbiAgfVxuXG4gIGFkZFRyYW5zaXRpb24odGltZSwgb25TdGFydCwgb25Eb25lKXtcbiAgICBvblN0YXJ0KClcbiAgICBsZXQgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNpdGlvbnMuZGVsZXRlKHRpbWVyKVxuICAgICAgb25Eb25lKClcbiAgICAgIHRoaXMuZmx1c2hQZW5kaW5nT3BzKClcbiAgICB9LCB0aW1lKVxuICAgIHRoaXMudHJhbnNpdGlvbnMuYWRkKHRpbWVyKVxuICB9XG5cbiAgcHVzaFBlbmRpbmdPcChvcCl7IHRoaXMucGVuZGluZ09wcy5wdXNoKG9wKSB9XG5cbiAgc2l6ZSgpeyByZXR1cm4gdGhpcy50cmFuc2l0aW9ucy5zaXplIH1cblxuICBmbHVzaFBlbmRpbmdPcHMoKXtcbiAgICBpZih0aGlzLnNpemUoKSA+IDApeyByZXR1cm4gfVxuICAgIGxldCBvcCA9IHRoaXMucGVuZGluZ09wcy5zaGlmdCgpXG4gICAgaWYob3Ape1xuICAgICAgb3AoKVxuICAgICAgdGhpcy5mbHVzaFBlbmRpbmdPcHMoKVxuICAgIH1cbiAgfVxufVxuIiwgIi8qXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuUGhvZW5peCBMaXZlVmlldyBKYXZhU2NyaXB0IENsaWVudFxuPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuU2VlIHRoZSBoZXhkb2NzIGF0IGBodHRwczovL2hleGRvY3MucG0vcGhvZW5peF9saXZlX3ZpZXdgIGZvciBkb2N1bWVudGF0aW9uLlxuXG4qL1xuXG5pbXBvcnQgTGl2ZVNvY2tldCwge2lzVXNlZElucHV0fSBmcm9tIFwiLi9saXZlX3NvY2tldFwiXG5pbXBvcnQgRE9NIGZyb20gXCIuL2RvbVwiXG5pbXBvcnQgVmlld0hvb2sgZnJvbSBcIi4vdmlld19ob29rXCJcbmltcG9ydCBWaWV3IGZyb20gXCIuL3ZpZXdcIlxuXG4vKiogQ3JlYXRlcyBhIFZpZXdIb29rIGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCBhbmQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIC0gVGhlIGVsZW1lbnQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGhvb2suXG4gKiBAcGFyYW0ge09iamVjdH0gW2NhbGxiYWNrc10gLSBUaGUgbGlzdCBvZiBob29rIGNhbGxiYWNrcywgc3VjaCBhcyBtb3VudGVkLFxuICogICB1cGRhdGVkLCBkZXN0cm95ZWQsIGV0Yy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICogICBjb25uZWN0ZWRDYWxsYmFjaygpe1xuICogICAgIGxldCBvbkxpdmVWaWV3TW91bnRlZCA9ICgpID0+IHRoaXMuaG9vay5wdXNoRXZlbnQoLi4uKSlcbiAqICAgICB0aGlzLmhvb2sgPSBjcmVhdGVIb29rKHRoaXMsIHttb3VudGVkOiBvbkxpdmVWaWV3TW91bnRlZH0pXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAqTm90ZSo6IGBjcmVhdGVIb29rYCBtdXN0IGJlIGNhbGxlZCBmcm9tIHRoZSBgY29ubmVjdGVkQ2FsbGJhY2tgIGxpZmVjeWNsZVxuICogd2hpY2ggaXMgdHJpZ2dlcmVkIGFmdGVyIHRoZSBlbGVtZW50IGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBET00uIElmIHlvdSB0cnlcbiAqIHRvIGNhbGwgYGNyZWF0ZUhvb2tgIGZyb20gdGhlIGNvbnN0cnVjdG9yLCBhbiBlcnJvciB3aWxsIGJlIGxvZ2dlZC5cbiAqXG4gKiBAcmV0dXJucyB7Vmlld0hvb2t9IFJldHVybnMgdGhlIFZpZXdIb29rIGluc3RhbmNlIGZvciB0aGUgY3VzdG9tIGVsZW1lbnQuXG4gKi9cbmxldCBjcmVhdGVIb29rID0gKGVsLCBjYWxsYmFja3MgPSB7fSkgPT4ge1xuICBsZXQgZXhpc3RpbmdIb29rID0gRE9NLmdldEN1c3RvbUVsSG9vayhlbClcbiAgaWYoZXhpc3RpbmdIb29rKXsgcmV0dXJuIGV4aXN0aW5nSG9vayB9XG5cbiAgbGV0IGhvb2sgPSBuZXcgVmlld0hvb2soVmlldy5jbG9zZXN0VmlldyhlbCksIGVsLCBjYWxsYmFja3MpXG4gIERPTS5wdXRDdXN0b21FbEhvb2soZWwsIGhvb2spXG4gIHJldHVybiBob29rXG59XG5cbmV4cG9ydCB7XG4gIExpdmVTb2NrZXQsXG4gIGlzVXNlZElucHV0LFxuICBjcmVhdGVIb29rXG59XG4iLCAiaW1wb3J0IFwicGhvZW5peF9odG1sXCI7XG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwicGhvZW5peFwiO1xuaW1wb3J0IHsgTGl2ZVNvY2tldCB9IGZyb20gXCJwaG9lbml4X2xpdmVfdmlld1wiO1xuaW1wb3J0IHRvcGJhciBmcm9tIFwiLi4vdmVuZG9yL3RvcGJhclwiO1xuXG5sZXQgY3NyZlRva2VuID0gZG9jdW1lbnRcbiAgLnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9J2NzcmYtdG9rZW4nXVwiKVxuICAuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKTtcblxuLy8gRGVmaW5lIExpdmVWaWV3IEhvb2tzXG5cbmxldCBIb29rcyA9IHt9O1xuXG5pbXBvcnQgQ2hhcnQgZnJvbSBcImNoYXJ0LmpzL2F1dG9cIjtcblxuSG9va3MuTG9jYXRpb25NYXAgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgbGF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9kdWN0LW9yZGVyLWxhdGl0dWRlXCIpLmlubmVyVGV4dDtcbiAgICBjb25zdCBsbmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2R1Y3Qtb3JkZXItbG9uZ2l0dWRlXCIpLmlubmVyVGV4dDtcblxuICAgIGZ1bmN0aW9uIGluaXRNYXAoKSB7XG4gICAgICBjb25zdCBtYXAgPSBuZXcgZ29vZ2xlLm1hcHMuTWFwKFxuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInByb2R1Y3Qtb3JkZXItbWFwXCIpLFxuICAgICAgICB7XG4gICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICBsYXQ6IHBhcnNlRmxvYXQobGF0KSxcbiAgICAgICAgICAgIGxuZzogcGFyc2VGbG9hdChsbmcpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgem9vbTogOCxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGxhdDogcGFyc2VGbG9hdChsYXQpLFxuICAgICAgICAgIGxuZzogcGFyc2VGbG9hdChsbmcpLFxuICAgICAgICB9LFxuICAgICAgICBtYXAsXG4gICAgICAgIHRpdGxlOiBcIkhlbGxvIFdvcmxkIVwiLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRNYXAoKTtcbiAgfSxcblxuICB1cGRhdGVkKCkge1xuICAgIGNvbnN0IGxhdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvZHVjdC1vcmRlci1sYXRpdHVkZVwiKS5pbm5lclRleHQ7XG4gICAgY29uc3QgbG5nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9kdWN0LW9yZGVyLWxvbmdpdHVkZVwiKS5pbm5lclRleHQ7XG5cbiAgICBmdW5jdGlvbiBpbml0TWFwKCkge1xuICAgICAgY29uc3QgbWFwID0gbmV3IGdvb2dsZS5tYXBzLk1hcChcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9kdWN0LW9yZGVyLW1hcFwiKSxcbiAgICAgICAge1xuICAgICAgICAgIGNlbnRlcjoge1xuICAgICAgICAgICAgbGF0OiBwYXJzZUZsb2F0KGxhdCksXG4gICAgICAgICAgICBsbmc6IHBhcnNlRmxvYXQobG5nKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHpvb206IDgsXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBsYXQ6IHBhcnNlRmxvYXQobGF0KSxcbiAgICAgICAgICBsbmc6IHBhcnNlRmxvYXQobG5nKSxcbiAgICAgICAgfSxcbiAgICAgICAgbWFwLFxuICAgICAgICB0aXRsZTogXCJIZWxsbyBXb3JsZCFcIixcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0TWFwKCk7XG4gIH0sXG59O1xuXG5cbkhvb2tzLlByb2R1Y3RMb2NhdGlvbiA9IHtcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvZHVjdF9vcmRlcl9sb2NhdGlvblwiKTtcblxuICAgIGNvbnN0IGRlbGl2ZXJ5X2xhdGl0dWRlX3Byb2R1Y3Rfb3JkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgIFwiZGVsaXZlcnlfbGF0aXR1ZGVfcHJvZHVjdF9vcmRlclwiXG4gICAgKTtcbiAgICBjb25zdCBkZWxpdmVyeV9sb25naXR1ZGVfcHJvZHVjdF9vcmRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgXCJkZWxpdmVyeV9sb25naXR1ZGVfcHJvZHVjdF9vcmRlclwiXG4gICAgKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBmaWVsZHM6IFtcImFkZHJlc3NfY29tcG9uZW50c1wiLCBcImdlb21ldHJ5XCIsIFwiaWNvblwiLCBcIm5hbWVcIl0sXG4gICAgICBjb21wb25lbnRSZXN0cmljdGlvbnM6IHsgY291bnRyeTogXCJrZVwiIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGF1dG9jb21wbGV0ZTEgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZShpbnB1dCwgb3B0aW9ucyk7XG5cbiAgICBhdXRvY29tcGxldGUxLmFkZExpc3RlbmVyKFwicGxhY2VfY2hhbmdlZFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBwbGFjZTEgPSBhdXRvY29tcGxldGUxLmdldFBsYWNlKCk7XG5cbiAgICAgIGRlbGl2ZXJ5X2xhdGl0dWRlX3Byb2R1Y3Rfb3JkZXIudmFsdWUgPSBwbGFjZTEuZ2VvbWV0cnkubG9jYXRpb24ubGF0KCk7XG4gICAgICBkZWxpdmVyeV9sb25naXR1ZGVfcHJvZHVjdF9vcmRlci52YWx1ZSA9IHBsYWNlMS5nZW9tZXRyeS5sb2NhdGlvbi5sbmcoKTtcbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGVkKCkge1xuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9kdWN0X29yZGVyX2xvY2F0aW9uXCIpO1xuXG4gICAgY29uc3QgZGVsaXZlcnlfbGF0aXR1ZGVfcHJvZHVjdF9vcmRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgXCJkZWxpdmVyeV9sYXRpdHVkZV9wcm9kdWN0X29yZGVyXCJcbiAgICApO1xuICAgIGNvbnN0IGRlbGl2ZXJ5X2xvbmdpdHVkZV9wcm9kdWN0X29yZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICBcImRlbGl2ZXJ5X2xvbmdpdHVkZV9wcm9kdWN0X29yZGVyXCJcbiAgICApO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGZpZWxkczogW1wiYWRkcmVzc19jb21wb25lbnRzXCIsIFwiZ2VvbWV0cnlcIiwgXCJpY29uXCIsIFwibmFtZVwiXSxcbiAgICAgIGNvbXBvbmVudFJlc3RyaWN0aW9uczogeyBjb3VudHJ5OiBcImtlXCIgfSxcbiAgICB9O1xuXG4gICAgY29uc3QgYXV0b2NvbXBsZXRlMSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuQXV0b2NvbXBsZXRlKGlucHV0LCBvcHRpb25zKTtcblxuICAgIGF1dG9jb21wbGV0ZTEuYWRkTGlzdGVuZXIoXCJwbGFjZV9jaGFuZ2VkXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHBsYWNlMSA9IGF1dG9jb21wbGV0ZTEuZ2V0UGxhY2UoKTtcblxuICAgICAgZGVsaXZlcnlfbGF0aXR1ZGVfcHJvZHVjdF9vcmRlci52YWx1ZSA9IHBsYWNlMS5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKTtcbiAgICAgIGRlbGl2ZXJ5X2xvbmdpdHVkZV9wcm9kdWN0X29yZGVyLnZhbHVlID0gcGxhY2UxLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpO1xuICAgIH0pO1xuICB9LFxufTtcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICB1cGRhdGVDYXJ0VmFsdWUoKTtcbn0pO1xuXG5jb25zdCB1cGRhdGVDYXJ0VmFsdWUgPSAoKSA9PiB7XG4gIG9yZGVyX2l0ZW1zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcIm9yZGVyX2l0ZW1zXCIpO1xuXG4gIGlmIChvcmRlcl9pdGVtcykge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FydC1uYXZiYXItdmFsdWVcIikuaW5uZXJIVE1MID1cbiAgICAgIEpTT04ucGFyc2Uob3JkZXJfaXRlbXMpLmxlbmd0aDtcblxuICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FydC1uYXZiYXItc2lkZWJhci12YWx1ZVwiKS5pbm5lckhUTUwgPVxuICAgIC8vICAgSlNPTi5wYXJzZShvcmRlcl9pdGVtcykubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2FydC1uYXZiYXItdmFsdWVcIikuaW5uZXJIVE1MID0gMDtcbiAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNhcnQtbmF2YmFyLXNpZGViYXItdmFsdWVcIikuaW5uZXJIVE1MID0gMDtcbiAgfVxufTtcblxuSG9va3MuUmVzdG9yZUNhcnQgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgb3JkZXJfaXRlbXMgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwib3JkZXJfaXRlbXNcIik7XG4gICAgdGhpcy5wdXNoRXZlbnQoXCJSZXN0b3JlQ2FydFwiLCB7IG9yZGVyX2l0ZW1zOiBvcmRlcl9pdGVtcyB9KTtcbiAgICB1cGRhdGVDYXJ0VmFsdWUoKTtcbiAgfSxcbn07XG5Ib29rcy5VcGRhdGVDYXJ0ID0ge1xuICBtb3VudGVkKCkge1xuICAgIHRoaXMuaGFuZGxlRXZlbnQoXCJVcGRhdGVDYXJ0XCIsICh7IG9yZGVyX2l0ZW1zIH0pID0+IHtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJvcmRlcl9pdGVtc1wiLCBvcmRlcl9pdGVtcyk7XG4gICAgICB1cGRhdGVDYXJ0VmFsdWUoKTtcbiAgICB9KTtcbiAgfSxcbn07XG5cbkhvb2tzLmRlbGV0ZUNhcnRJdGVtID0ge1xuICBtb3VudGVkKCkge1xuICAgIHRoaXMuaGFuZGxlRXZlbnQoXCJkZWxldGVDYXJ0SXRlbVwiLCAoeyBvcmRlcl9pdGVtcyB9KSA9PiB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwib3JkZXJfaXRlbXNcIiwgb3JkZXJfaXRlbXMpO1xuICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgdXBkYXRlQ2FydFZhbHVlKCk7XG4gICAgfSk7XG4gIH0sXG59O1xuXG5Ib29rcy5jbGVhckNhcnQgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5oYW5kbGVFdmVudChcImNsZWFyQ2FydFwiLCAoKSA9PiB7XG4gICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKFwib3JkZXJfaXRlbXNcIik7XG4gICAgfSk7XG4gIH0sXG59O1xuXG5Ib29rcy5Td2lwZXJIb29rID0ge1xuICBtb3VudGVkKCkge1xuICAgIC8vIEluaXRpYWxpemUgU3dpcGVyIHdoZW4gdGhlIGVsZW1lbnQgaXMgbW91bnRlZCBpbiB0aGUgRE9NXG4gICAgdGhpcy5zd2lwZXIgPSBuZXcgU3dpcGVyKHRoaXMuZWwsIHtcbiAgICAgIC8vIEVuYWJsZSBob3Jpem9udGFsIGRpcmVjdGlvbiAobW9yZSBjb21tb24gZm9yIGltYWdlIHNsaWRlcnMpXG4gICAgICBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLFxuXG4gICAgICAvLyBFbmFibGUgbG9vcFxuICAgICAgbG9vcDogdHJ1ZSxcblxuICAgICAgLy8gRW5hYmxlIGF1dG8gcGxheVxuICAgICAgYXV0b3BsYXk6IHtcbiAgICAgICAgZGVsYXk6IDMwMDAsIC8vIDMgc2Vjb25kcyBiZXR3ZWVuIHNsaWRlc1xuICAgICAgICBkaXNhYmxlT25JbnRlcmFjdGlvbjogZmFsc2UsIC8vIENvbnRpbnVlIGF1dG9wbGF5IGFmdGVyIHVzZXIgaW50ZXJhY3Rpb25cbiAgICAgIH0sXG5cbiAgICAgIC8vIEFkZCBwYWdpbmF0aW9uXG4gICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgIGVsOiBcIi5zd2lwZXItcGFnaW5hdGlvblwiLFxuICAgICAgICBjbGlja2FibGU6IHRydWUsXG4gICAgICB9LFxuXG4gICAgICAvLyBBZGQgZWZmZWN0c1xuICAgICAgZWZmZWN0OiBcInNsaWRlXCIsIC8vIFlvdSBjYW4gdHJ5ICdmYWRlJywgJ2N1YmUnLCAnY292ZXJmbG93JywgZXRjLlxuXG4gICAgICAvLyBPcHRpb25hbDogYWRkIHJlc3BvbnNpdmUgYnJlYWtwb2ludHNcbiAgICAgIGJyZWFrcG9pbnRzOiB7XG4gICAgICAgIDY0MDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICAgIH0sXG4gICAgICAgIDc2ODoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICAgIH0sXG4gICAgICAgIDEwMjQ6IHtcbiAgICAgICAgICBzbGlkZXNQZXJWaWV3OiAxLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSxcblxuICB1cGRhdGVkKCkge1xuICAgIC8vIFdoZW4gdGhlIGNvbnRlbnQgaXMgdXBkYXRlZCAobGlrZSB3aGVuIG5ldyBpbWFnZXMgYXJlIGFkZGVkKVxuICAgIC8vIERlc3Ryb3kgYW5kIHJlaW5pdGlhbGl6ZSB0aGUgc3dpcGVyXG4gICAgaWYgKHRoaXMuc3dpcGVyKSB7XG4gICAgICB0aGlzLnN3aXBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgLy8gUmUtaW5pdGlhbGl6ZSB3aXRoIGEgc2xpZ2h0IGRlbGF5IHRvIGVuc3VyZSBET00gaXMgdXBkYXRlZFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5zd2lwZXIgPSBuZXcgU3dpcGVyKHRoaXMuZWwsIHtcbiAgICAgICAgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgbG9vcDogdHJ1ZSxcbiAgICAgICAgYXV0b3BsYXk6IHtcbiAgICAgICAgICBkZWxheTogMzAwMCxcbiAgICAgICAgICBkaXNhYmxlT25JbnRlcmFjdGlvbjogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgICBlbDogXCIuc3dpcGVyLXBhZ2luYXRpb25cIixcbiAgICAgICAgICBjbGlja2FibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGVmZmVjdDogXCJzbGlkZVwiLFxuICAgICAgfSk7XG4gICAgfSwgMTAwKTtcbiAgfSxcblxuICBkZXN0cm95ZWQoKSB7XG4gICAgLy8gQ2xlYW4gdXAgd2hlbiB0aGUgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIERPTVxuICAgIGlmICh0aGlzLnN3aXBlcikge1xuICAgICAgdGhpcy5zd2lwZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5zd2lwZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIC8vIEZvciBvbGRlciBQaG9lbml4IHZlcnNpb25zIHRoYXQgdXNlIGJlZm9yZURlc3Ryb3kgaW5zdGVhZCBvZiBkZXN0cm95ZWRcbiAgICBpZiAodGhpcy5zd2lwZXIpIHtcbiAgICAgIHRoaXMuc3dpcGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuc3dpcGVyID0gbnVsbDtcbiAgICB9XG4gIH0sXG59O1xuXG5Ib29rcy5FYWNoUHJvZHVjdFN3aXBlckhvb2sgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBTd2lwZXIgd2hlbiB0aGUgZWxlbWVudCBpcyBtb3VudGVkIGluIHRoZSBET01cbiAgICB0aGlzLnN3aXBlciA9IG5ldyBTd2lwZXIodGhpcy5lbCwge1xuICAgICAgLy8gRW5hYmxlIGhvcml6b250YWwgZGlyZWN0aW9uIChtb3JlIGNvbW1vbiBmb3IgaW1hZ2Ugc2xpZGVycylcbiAgICAgIGRpcmVjdGlvbjogXCJob3Jpem9udGFsXCIsXG5cbiAgICAgIC8vIEVuYWJsZSBsb29wXG4gICAgICBsb29wOiB0cnVlLFxuXG4gICAgICAvLyBFbmFibGUgYXV0byBwbGF5XG4gICAgICBhdXRvcGxheToge1xuICAgICAgICBkZWxheTogMzAwMCwgLy8gMyBzZWNvbmRzIGJldHdlZW4gc2xpZGVzXG4gICAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiBmYWxzZSwgLy8gQ29udGludWUgYXV0b3BsYXkgYWZ0ZXIgdXNlciBpbnRlcmFjdGlvblxuICAgICAgfSxcblxuICAgICAgLy8gQWRkIHBhZ2luYXRpb25cbiAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgZWw6IFwiLnN3aXBlci1wYWdpbmF0aW9uXCIsXG4gICAgICAgIGNsaWNrYWJsZTogdHJ1ZSxcbiAgICAgIH0sXG5cbiAgICAgIC8vIEFkZCBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICAgIG5hdmlnYXRpb246IHtcbiAgICAgICAgbmV4dEVsOiBcIi5zd2lwZXItYnV0dG9uLW5leHRcIixcbiAgICAgICAgcHJldkVsOiBcIi5zd2lwZXItYnV0dG9uLXByZXZcIixcbiAgICAgIH0sXG5cbiAgICAgIC8vIEFkZCBlZmZlY3RzXG4gICAgICBlZmZlY3Q6IFwic2xpZGVcIiwgLy8gWW91IGNhbiB0cnkgJ2ZhZGUnLCAnY3ViZScsICdjb3ZlcmZsb3cnLCBldGMuXG5cbiAgICAgIC8vIE9wdGlvbmFsOiBhZGQgcmVzcG9uc2l2ZSBicmVha3BvaW50c1xuICAgICAgYnJlYWtwb2ludHM6IHtcbiAgICAgICAgNjQwOiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcbiAgICAgICAgfSxcbiAgICAgICAgNzY4OiB7XG4gICAgICAgICAgc2xpZGVzUGVyVmlldzogMSxcbiAgICAgICAgfSxcbiAgICAgICAgMTAyNDoge1xuICAgICAgICAgIHNsaWRlc1BlclZpZXc6IDEsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZWQoKSB7XG4gICAgLy8gV2hlbiB0aGUgY29udGVudCBpcyB1cGRhdGVkIChsaWtlIHdoZW4gbmV3IGltYWdlcyBhcmUgYWRkZWQpXG4gICAgLy8gRGVzdHJveSBhbmQgcmVpbml0aWFsaXplIHRoZSBzd2lwZXJcbiAgICBpZiAodGhpcy5zd2lwZXIpIHtcbiAgICAgIHRoaXMuc3dpcGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyBSZS1pbml0aWFsaXplIHdpdGggYSBzbGlnaHQgZGVsYXkgdG8gZW5zdXJlIERPTSBpcyB1cGRhdGVkXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnN3aXBlciA9IG5ldyBTd2lwZXIodGhpcy5lbCwge1xuICAgICAgICBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBsb29wOiB0cnVlLFxuICAgICAgICBhdXRvcGxheToge1xuICAgICAgICAgIGRlbGF5OiAzMDAwLFxuICAgICAgICAgIGRpc2FibGVPbkludGVyYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgcGFnaW5hdGlvbjoge1xuICAgICAgICAgIGVsOiBcIi5zd2lwZXItcGFnaW5hdGlvblwiLFxuICAgICAgICAgIGNsaWNrYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZWZmZWN0OiBcInNsaWRlXCIsXG4gICAgICB9KTtcbiAgICB9LCAxMDApO1xuICB9LFxuXG4gIGRlc3Ryb3llZCgpIHtcbiAgICAvLyBDbGVhbiB1cCB3aGVuIHRoZSBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4gICAgaWYgKHRoaXMuc3dpcGVyKSB7XG4gICAgICB0aGlzLnN3aXBlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLnN3aXBlciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgLy8gRm9yIG9sZGVyIFBob2VuaXggdmVyc2lvbnMgdGhhdCB1c2UgYmVmb3JlRGVzdHJveSBpbnN0ZWFkIG9mIGRlc3Ryb3llZFxuICAgIGlmICh0aGlzLnN3aXBlcikge1xuICAgICAgdGhpcy5zd2lwZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5zd2lwZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcbn07XG5cbmxldCBsaXZlU29ja2V0ID0gbmV3IExpdmVTb2NrZXQoXCIvbGl2ZVwiLCBTb2NrZXQsIHtcbiAgbG9uZ1BvbGxGYWxsYmFja01zOiAyNTAwLFxuICBwYXJhbXM6IHsgX2NzcmZfdG9rZW46IGNzcmZUb2tlbiB9LFxuICBob29rczogSG9va3MsXG59KTtcblxuLy8gU2hvdyBwcm9ncmVzcyBiYXIgb24gbGl2ZSBuYXZpZ2F0aW9uIGFuZCBmb3JtIHN1Ym1pdHNcbnRvcGJhci5jb25maWcoeyBiYXJDb2xvcnM6IHsgMDogXCIjMjlkXCIgfSwgc2hhZG93Q29sb3I6IFwicmdiYSgwLCAwLCAwLCAuMylcIiB9KTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicGh4OnBhZ2UtbG9hZGluZy1zdGFydFwiLCAoX2luZm8pID0+IHRvcGJhci5zaG93KDMwMCkpO1xud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwaHg6cGFnZS1sb2FkaW5nLXN0b3BcIiwgKF9pbmZvKSA9PiB0b3BiYXIuaGlkZSgpKTtcblxuLy8gQ29ubmVjdCBpZiB0aGVyZSBhcmUgYW55IExpdmVWaWV3cyBvbiB0aGUgcGFnZVxubGl2ZVNvY2tldC5jb25uZWN0KCk7XG5cbi8vIEV4cG9zZSBsaXZlU29ja2V0IG9uIHdpbmRvdyBmb3IgZGVidWdnaW5nXG53aW5kb3cubGl2ZVNvY2tldCA9IGxpdmVTb2NrZXQ7XG4vLyBkcm9wZG93blxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICBjb25zdCB0b2dnbGVCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRvZ2dsZS1yZXZpZXdzXCIpO1xuICBjb25zdCByZXZpZXdTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZXZpZXdzLXNlY3Rpb25cIik7XG4gIGNvbnN0IGRyb3Bkb3duSWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHJvcGRvd24taWNvblwiKTtcbiAgY29uc3QgdG9nZ2xlQWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWRcbiAgKFwidG9nZ2xlLXJldmlldy1mb3JtXCIpO1xuICBjb25zdCByZXZpZXdGb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmb3JtLXJldmlld1wiKTtcbiAgLy8gY29uc3QgdG9nZ2xlRHJvcERvd249IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHJvcGRvd25cIilcbiAgLy8gY29uc3QgZHJvcGRvd25TZWN0aW9uPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRyb3Atc2VjdGlvblwiKVxuXG4gIC8vIHRvZ2dsZURyb3BEb3duLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuICAvLyAgIHJldmlld1NlY3Rpb24uY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiKVxuXG4gIC8vICAgZHJvcGRvd25JY29uLnN0eWxlLnRyYW5zZm9ybSA9IHJldmlld1NlY3Rpb24uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpXG4gIC8vICAgPyBcInJvdGF0ZSgwZGVnKVwiXG4gIC8vICAgOiBcInJvdGF0ZSgxODBkZWcpXCI7XG4gIC8vIH0pXG4gIC8vIGRyb3Bkb3duU2VjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIixmdW5jdGlvbigpe1xuICAvLyAgIHJldmlld0Zvcm0uY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiKVxuICAvLyB9KVxuXG4gIHRvZ2dsZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgIC8vIFRvZ2dsZSB2aXNpYmlsaXR5XG4gICAgcmV2aWV3U2VjdGlvbi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIpO1xuXG4gICAgLy8gUm90YXRlIGljb25cbiAgICBkcm9wZG93bkljb24uc3R5bGUudHJhbnNmb3JtID0gcmV2aWV3U2VjdGlvbi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIilcbiAgICAgID8gXCJyb3RhdGUoMGRlZylcIlxuICAgICAgOiBcInJvdGF0ZSgxODBkZWcpXCI7XG4gIH0pO1xuXG4gIHRvZ2dsZUFjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldmlld0Zvcm0uY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiKTtcbiAgfSk7XG59KTtcblxuSG9va3MuT3JkZXJTdW1tYXJ5Q2hhcnQgPSB7XG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc29sZS5sb2coXCJPcmRlclN1bW1hcnlDaGFydCBtb3VudGVkXCIpO1xuICAgIHRoaXMucmVuZGVyQ2hhcnQoKTtcbiAgfSxcblxuICB1cGRhdGVkKCkge1xuICAgIGNvbnNvbGUubG9nKFwiT3JkZXJTdW1tYXJ5Q2hhcnQgdXBkYXRlZFwiKTtcbiAgICB0aGlzLnJlbmRlckNoYXJ0KCk7XG4gIH0sXG5cbiAgcmVuZGVyQ2hhcnQoKSB7XG4gICAgY29uc29sZS5sb2coXCJyZW5kZXJDaGFydCBjYWxsZWRcIik7XG4gICAgaWYgKHRoaXMuY2hhcnQpIHtcbiAgICAgIHRoaXMuY2hhcnQuZGVzdHJveSgpO1xuICAgIH1cblxuICAgXG5cbiAgICBjb25zdCBjdHggPSB0aGlzLmVsLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjb25zdCBjaGFydERhdGEgPSBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5jaGFydERhdGEpO1xuICAgIGNvbnN0IGNoYXJ0TGFiZWxzID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQuY2hhcnRMYWJlbHMpO1xuXG4gICAgY29uc29sZS5sb2coXCJDaGFydCBEYXRhOlwiLCBjaGFydERhdGEpOyBcbiAgICBjb25zb2xlLmxvZyhcIkNoYXJ0IExhYmVsczpcIiwgY2hhcnRMYWJlbHMpOyBcblxuICAgIHRoaXMuY2hhcnQgPSBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgICB0eXBlOiBcImxpbmVcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWxzOiBjaGFydExhYmVscyxcbiAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgbGFiZWw6IFwiT3JkZXJzXCIsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYmEoMTE5LCA1MSwgMjU1LCAwLjIpXCIsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiYSgxMTksIDUxLCAyNTUsIDEpXCIsXG4gICAgICAgICAgZmlsbDogdHJ1ZSxcbiAgICAgICAgICBkYXRhOiBjaGFydERhdGEsXG4gICAgICAgICAgdGVuc2lvbjogMC40LFxuICAgICAgICB9XSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgICBsZWdlbmQ6IHsgZGlzcGxheTogZmFsc2UgfSxcbiAgICAgICAgICB0b29sdGlwOiB7IGVuYWJsZWQ6IHRydWUgfVxuICAgICAgICB9LFxuICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICB4OiB7XG4gICAgICAgICAgICB0aXRsZTogeyBkaXNwbGF5OiB0cnVlLCB0ZXh0OiB0aGlzLmVsLmRhdGFzZXQueEF4aXNUaXRsZSB9LFxuICAgICAgICAgICAgZ3JpZDogeyBjb2xvcjogXCIjMzc0MTUxXCIsIGxpbmVXaWR0aDogMC4xIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgIHRpdGxlOiB7IGRpc3BsYXk6IHRydWUsIHRleHQ6IFwiTnVtYmVyIG9mIE9yZGVyc1wiIH0sXG4gICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgICAgICAgIGdyaWQ6IHsgY29sb3I6IFwiIzM3NDE1MVwiLCBsaW5lV2lkdGg6IDAuMSB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cblxuSG9va3MuUmV2ZW51ZUNoYXJ0ID0ge1xuICBtb3VudGVkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuZWwuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb25zdCBhdmVyYWdlU2FsZXMgPSBwYXJzZUZsb2F0KHRoaXMuZWwuZGF0YXNldC5hdmVyYWdlU2FsZXMpO1xuICAgIGNvbnN0IGF2ZXJhZ2VSZXZlbnVlID0gcGFyc2VGbG9hdCh0aGlzLmVsLmRhdGFzZXQuYXZlcmFnZVJldmVudWUpO1xuICAgIGNvbnN0IGRheXMgPSBKU09OLnBhcnNlKHRoaXMuZWwuZGF0YXNldC5kYXlzKTtcbiAgICBjb25zdCBzYWxlcyA9IEpTT04ucGFyc2UodGhpcy5lbC5kYXRhc2V0LnNhbGVzKTtcbiAgICBjb25zdCByZXZlbnVlID0gSlNPTi5wYXJzZSh0aGlzLmVsLmRhdGFzZXQucmV2ZW51ZSk7XG5cbiAgICBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgICB0eXBlOiAnYmFyJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbGFiZWxzOiBkYXlzLCAvLyBVc2UgdGhlIGRheSBudW1iZXJzIGhlcmVcbiAgICAgICAgZGF0YXNldHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBsYWJlbDogJ0RhaWx5IFNhbGVzJyxcbiAgICAgICAgICAgIGRhdGE6IHNhbGVzLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjA3KScsXG4gICAgICAgICAgICBiYXJUaGlja25lc3M6IDgsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGxhYmVsOiAnRGFpbHkgUmV2ZW51ZScsXG4gICAgICAgICAgICBkYXRhOiByZXZlbnVlLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgxMTgsIDIzOCwgMTQsIDAuMyknLFxuICAgICAgICAgICAgYmFyVGhpY2tuZXNzOiA4LFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA0XG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHNjYWxlczoge1xuICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgdGV4dDogJ0Ftb3VudCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeDoge1xuICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICAgIHRleHQ6ICdEYXknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGxldCBsYWJlbCA9IGNvbnRleHQuZGF0YXNldC5sYWJlbCB8fCAnJztcblxuICAgICAgICAgICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgICAgICAgICAgbGFiZWwgKz0gJzogJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQucGFyc2VkLnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGxhYmVsICs9IG5ldyBJbnRsLk51bWJlckZvcm1hdCgnZW4tVVMnLCB7IHN0eWxlOiAnY3VycmVuY3knLCBjdXJyZW5jeTogJ0tFUycgfSkuZm9ybWF0KGNvbnRleHQucGFyc2VkLnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxufTtcblxuIiwgIi8qIVxuICogQGt1cmtsZS9jb2xvciB2MC4zLjRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9rdXJrbGUvY29sb3IjcmVhZG1lXG4gKiAoYykgMjAyNCBKdWtrYSBLdXJrZWxhXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gcm91bmQodikge1xuICByZXR1cm4gdiArIDAuNSB8IDA7XG59XG5jb25zdCBsaW0gPSAodiwgbCwgaCkgPT4gTWF0aC5tYXgoTWF0aC5taW4odiwgaCksIGwpO1xuZnVuY3Rpb24gcDJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMi41NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMnAodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSwgMCwgMTAwKTtcbn1cbmZ1bmN0aW9uIG4yYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMm4odikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XG59XG5mdW5jdGlvbiBuMnAodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAxMDApLCAwLCAxMDApO1xufVxuXG5jb25zdCBtYXAkMSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1fTtcbmNvbnN0IGhleCA9IFsuLi4nMDEyMzQ1Njc4OUFCQ0RFRiddO1xuY29uc3QgaDEgPSBiID0+IGhleFtiICYgMHhGXTtcbmNvbnN0IGgyID0gYiA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gYiA9PiAoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpO1xuY29uc3QgaXNTaG9ydCA9IHYgPT4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogMjU1ICYgbWFwJDFbc3RyWzFdXSAqIDE3LFxuICAgICAgICBnOiAyNTUgJiBtYXAkMVtzdHJbMl1dICogMTcsXG4gICAgICAgIGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcbiAgICAgICAgYTogbGVuID09PSA1ID8gbWFwJDFbc3RyWzRdXSAqIDE3IDogMjU1XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiBtYXAkMVtzdHJbMV1dIDw8IDQgfCBtYXAkMVtzdHJbMl1dLFxuICAgICAgICBnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxuICAgICAgICBiOiBtYXAkMVtzdHJbNV1dIDw8IDQgfCBtYXAkMVtzdHJbNl1dLFxuICAgICAgICBhOiBsZW4gPT09IDkgPyAobWFwJDFbc3RyWzddXSA8PCA0IHwgbWFwJDFbc3RyWzhdXSkgOiAyNTVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBhbHBoYSA9IChhLCBmKSA9PiBhIDwgMjU1ID8gZihhKSA6ICcnO1xuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcbiAgdmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcbiAgcmV0dXJuIHZcbiAgICA/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArIGFscGhhKHYuYSwgZilcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxuY29uc3QgSFVFX1JFID0gL14oaHNsYT98aHdifGhzdilcXChcXHMqKFstKy5lXFxkXSspKD86ZGVnKT9bXFxzLF0rKFstKy5lXFxkXSspJVtcXHMsXSsoWy0rLmVcXGRdKyklKD86W1xccyxdKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIGhzbDJyZ2JuKGgsIHMsIGwpIHtcbiAgY29uc3QgYSA9IHMgKiBNYXRoLm1pbihsLCAxIC0gbCk7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDMwKSAlIDEyKSA9PiBsIC0gYSAqIE1hdGgubWF4KE1hdGgubWluKGsgLSAzLCA5IC0gaywgMSksIC0xKTtcbiAgcmV0dXJuIFtmKDApLCBmKDgpLCBmKDQpXTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2JuKGgsIHMsIHYpIHtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gNjApICUgNikgPT4gdiAtIHYgKiBzICogTWF0aC5tYXgoTWF0aC5taW4oaywgNCAtIGssIDEpLCAwKTtcbiAgcmV0dXJuIFtmKDUpLCBmKDMpLCBmKDEpXTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2JuKGgsIHcsIGIpIHtcbiAgY29uc3QgcmdiID0gaHNsMnJnYm4oaCwgMSwgMC41KTtcbiAgbGV0IGk7XG4gIGlmICh3ICsgYiA+IDEpIHtcbiAgICBpID0gMSAvICh3ICsgYik7XG4gICAgdyAqPSBpO1xuICAgIGIgKj0gaTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcmdiW2ldICo9IDEgLSB3IC0gYjtcbiAgICByZ2JbaV0gKz0gdztcbiAgfVxuICByZXR1cm4gcmdiO1xufVxuZnVuY3Rpb24gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KSB7XG4gIGlmIChyID09PSBtYXgpIHtcbiAgICByZXR1cm4gKChnIC0gYikgLyBkKSArIChnIDwgYiA/IDYgOiAwKTtcbiAgfVxuICBpZiAoZyA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIChiIC0gcikgLyBkICsgMjtcbiAgfVxuICByZXR1cm4gKHIgLSBnKSAvIGQgKyA0O1xufVxuZnVuY3Rpb24gcmdiMmhzbCh2KSB7XG4gIGNvbnN0IHJhbmdlID0gMjU1O1xuICBjb25zdCByID0gdi5yIC8gcmFuZ2U7XG4gIGNvbnN0IGcgPSB2LmcgLyByYW5nZTtcbiAgY29uc3QgYiA9IHYuYiAvIHJhbmdlO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGxldCBoLCBzLCBkO1xuICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICBoID0gaHVlVmFsdWUociwgZywgYiwgZCwgbWF4KTtcbiAgICBoID0gaCAqIDYwICsgMC41O1xuICB9XG4gIHJldHVybiBbaCB8IDAsIHMgfHwgMCwgbF07XG59XG5mdW5jdGlvbiBjYWxsbihmLCBhLCBiLCBjKSB7XG4gIHJldHVybiAoXG4gICAgQXJyYXkuaXNBcnJheShhKVxuICAgICAgPyBmKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgICA6IGYoYSwgYiwgYylcbiAgKS5tYXAobjJiKTtcbn1cbmZ1bmN0aW9uIGhzbDJyZ2IoaCwgcywgbCkge1xuICByZXR1cm4gY2FsbG4oaHNsMnJnYm4sIGgsIHMsIGwpO1xufVxuZnVuY3Rpb24gaHdiMnJnYihoLCB3LCBiKSB7XG4gIHJldHVybiBjYWxsbihod2IycmdibiwgaCwgdywgYik7XG59XG5mdW5jdGlvbiBoc3YycmdiKGgsIHMsIHYpIHtcbiAgcmV0dXJuIGNhbGxuKGhzdjJyZ2JuLCBoLCBzLCB2KTtcbn1cbmZ1bmN0aW9uIGh1ZShoKSB7XG4gIHJldHVybiAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG59XG5mdW5jdGlvbiBodWVQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IEhVRV9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgdjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzVdICE9PSB2KSB7XG4gICAgYSA9IG1bNl0gPyBwMmIoK21bNV0pIDogbjJiKCttWzVdKTtcbiAgfVxuICBjb25zdCBoID0gaHVlKCttWzJdKTtcbiAgY29uc3QgcDEgPSArbVszXSAvIDEwMDtcbiAgY29uc3QgcDIgPSArbVs0XSAvIDEwMDtcbiAgaWYgKG1bMV0gPT09ICdod2InKSB7XG4gICAgdiA9IGh3YjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIGlmIChtWzFdID09PSAnaHN2Jykge1xuICAgIHYgPSBoc3YycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSB7XG4gICAgdiA9IGhzbDJyZ2IoaCwgcDEsIHAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHI6IHZbMF0sXG4gICAgZzogdlsxXSxcbiAgICBiOiB2WzJdLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh2LCBkZWcpIHtcbiAgdmFyIGggPSByZ2IyaHNsKHYpO1xuICBoWzBdID0gaHVlKGhbMF0gKyBkZWcpO1xuICBoID0gaHNsMnJnYihoKTtcbiAgdi5yID0gaFswXTtcbiAgdi5nID0gaFsxXTtcbiAgdi5iID0gaFsyXTtcbn1cbmZ1bmN0aW9uIGhzbFN0cmluZyh2KSB7XG4gIGlmICghdikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gcmdiMmhzbCh2KTtcbiAgY29uc3QgaCA9IGFbMF07XG4gIGNvbnN0IHMgPSBuMnAoYVsxXSk7XG4gIGNvbnN0IGwgPSBuMnAoYVsyXSk7XG4gIHJldHVybiB2LmEgPCAyNTVcbiAgICA/IGBoc2xhKCR7aH0sICR7c30lLCAke2x9JSwgJHtiMm4odi5hKX0pYFxuICAgIDogYGhzbCgke2h9LCAke3N9JSwgJHtsfSUpYDtcbn1cblxuY29uc3QgbWFwID0ge1xuXHR4OiAnZGFyaycsXG5cdFo6ICdsaWdodCcsXG5cdFk6ICdyZScsXG5cdFg6ICdibHUnLFxuXHRXOiAnZ3InLFxuXHRWOiAnbWVkaXVtJyxcblx0VTogJ3NsYXRlJyxcblx0QTogJ2VlJyxcblx0VDogJ29sJyxcblx0UzogJ29yJyxcblx0QjogJ3JhJyxcblx0QzogJ2xhdGVnJyxcblx0RDogJ2lnaHRzJyxcblx0UjogJ2luJyxcblx0UTogJ3R1cnF1b2lzJyxcblx0RTogJ2hpJyxcblx0UDogJ3JvJyxcblx0TzogJ2FsJyxcblx0TjogJ2xlJyxcblx0TTogJ2RlJyxcblx0TDogJ3llbGxvJyxcblx0RjogJ2VuJyxcblx0SzogJ2NoJyxcblx0RzogJ2Fya3MnLFxuXHRIOiAnZWEnLFxuXHRJOiAnaWdodGcnLFxuXHRKOiAnd2gnXG59O1xuY29uc3QgbmFtZXMkMSA9IHtcblx0T2ljZVhlOiAnZjBmOGZmJyxcblx0YW50aXF1ZXdFdGU6ICdmYWViZDcnLFxuXHRhcXVhOiAnZmZmZicsXG5cdGFxdWFtYXJSZTogJzdmZmZkNCcsXG5cdGF6dVk6ICdmMGZmZmYnLFxuXHRiZWlnZTogJ2Y1ZjVkYycsXG5cdGJpc3F1ZTogJ2ZmZTRjNCcsXG5cdGJsYWNrOiAnMCcsXG5cdGJsYW5LZWRPbW9uZDogJ2ZmZWJjZCcsXG5cdFhlOiAnZmYnLFxuXHRYZXZpVGV0OiAnOGEyYmUyJyxcblx0YlB3bjogJ2E1MmEyYScsXG5cdGJ1cmx5d29vZDogJ2RlYjg4NycsXG5cdGNhTXRYZTogJzVmOWVhMCcsXG5cdEthcnRZdXNlOiAnN2ZmZjAwJyxcblx0S29jVGF0ZTogJ2QyNjkxZScsXG5cdGNTTzogJ2ZmN2Y1MCcsXG5cdGNTbmZsb3dlclhlOiAnNjQ5NWVkJyxcblx0Y1Nuc2lsazogJ2ZmZjhkYycsXG5cdGNyaW1zb246ICdkYzE0M2MnLFxuXHRjeWFuOiAnZmZmZicsXG5cdHhYZTogJzhiJyxcblx0eGN5YW46ICc4YjhiJyxcblx0eGdUTW5QZDogJ2I4ODYwYicsXG5cdHhXYXk6ICdhOWE5YTknLFxuXHR4Z1lGOiAnNjQwMCcsXG5cdHhnWXk6ICdhOWE5YTknLFxuXHR4a2hha2k6ICdiZGI3NmInLFxuXHR4bWFnRnRhOiAnOGIwMDhiJyxcblx0eFRpdmVnWUY6ICc1NTZiMmYnLFxuXHR4U2FuZ2U6ICdmZjhjMDAnLFxuXHR4U2NFZDogJzk5MzJjYycsXG5cdHhZZDogJzhiMDAwMCcsXG5cdHhzT21vbjogJ2U5OTY3YScsXG5cdHhzSGdZRjogJzhmYmM4ZicsXG5cdHhVWGU6ICc0ODNkOGInLFxuXHR4VVdheTogJzJmNGY0ZicsXG5cdHhVZ1l5OiAnMmY0ZjRmJyxcblx0eFFlOiAnY2VkMScsXG5cdHh2aVRldDogJzk0MDBkMycsXG5cdGRBcHBSazogJ2ZmMTQ5MycsXG5cdGRBcHNreVhlOiAnYmZmZicsXG5cdGRpbVdheTogJzY5Njk2OScsXG5cdGRpbWdZeTogJzY5Njk2OScsXG5cdGRvZGdlclhlOiAnMWU5MGZmJyxcblx0ZmlZYnJpY2s6ICdiMjIyMjInLFxuXHRmbFNPd0V0ZTogJ2ZmZmFmMCcsXG5cdGZvWXN0V0FuOiAnMjI4YjIyJyxcblx0ZnVLc2lhOiAnZmYwMGZmJyxcblx0Z2FSc2JTbzogJ2RjZGNkYycsXG5cdGdob3N0d0V0ZTogJ2Y4ZjhmZicsXG5cdGdUZDogJ2ZmZDcwMCcsXG5cdGdUTW5QZDogJ2RhYTUyMCcsXG5cdFdheTogJzgwODA4MCcsXG5cdGdZRjogJzgwMDAnLFxuXHRnWUZMdzogJ2FkZmYyZicsXG5cdGdZeTogJzgwODA4MCcsXG5cdGhvbmV5TXc6ICdmMGZmZjAnLFxuXHRob3RwUms6ICdmZjY5YjQnLFxuXHRSZGlhbllkOiAnY2Q1YzVjJyxcblx0UmRpZ286ICc0YjAwODInLFxuXHRpdlN5OiAnZmZmZmYwJyxcblx0a2hha2k6ICdmMGU2OGMnLFxuXHRsYXZGTXI6ICdlNmU2ZmEnLFxuXHRsYXZGTXJYc2g6ICdmZmYwZjUnLFxuXHRsYXduZ1lGOiAnN2NmYzAwJyxcblx0Tm1vbmNFZmZvbjogJ2ZmZmFjZCcsXG5cdFpYZTogJ2FkZDhlNicsXG5cdFpjU086ICdmMDgwODAnLFxuXHRaY3lhbjogJ2UwZmZmZicsXG5cdFpnVE1uUGRMdzogJ2ZhZmFkMicsXG5cdFpXYXk6ICdkM2QzZDMnLFxuXHRaZ1lGOiAnOTBlZTkwJyxcblx0WmdZeTogJ2QzZDNkMycsXG5cdFpwUms6ICdmZmI2YzEnLFxuXHRac09tb246ICdmZmEwN2EnLFxuXHRac0hnWUY6ICcyMGIyYWEnLFxuXHRac2t5WGU6ICc4N2NlZmEnLFxuXHRaVVdheTogJzc3ODg5OScsXG5cdFpVZ1l5OiAnNzc4ODk5Jyxcblx0WnN0QWxYZTogJ2IwYzRkZScsXG5cdFpMdzogJ2ZmZmZlMCcsXG5cdGxpbWU6ICdmZjAwJyxcblx0bGltZWdZRjogJzMyY2QzMicsXG5cdGxSRjogJ2ZhZjBlNicsXG5cdG1hZ0Z0YTogJ2ZmMDBmZicsXG5cdG1hUG9uOiAnODAwMDAwJyxcblx0VmFxdWFtYXJSZTogJzY2Y2RhYScsXG5cdFZYZTogJ2NkJyxcblx0VlNjRWQ6ICdiYTU1ZDMnLFxuXHRWcHVycE46ICc5MzcwZGInLFxuXHRWc0hnWUY6ICczY2IzNzEnLFxuXHRWVVhlOiAnN2I2OGVlJyxcblx0VnNwclJnZ1lGOiAnZmE5YScsXG5cdFZRZTogJzQ4ZDFjYycsXG5cdFZ2aVRldFlkOiAnYzcxNTg1Jyxcblx0bWlkbmlnaHRYZTogJzE5MTk3MCcsXG5cdG1SdGNZYW06ICdmNWZmZmEnLFxuXHRtaXN0eVBzZTogJ2ZmZTRlMScsXG5cdG1vY2Nhc1I6ICdmZmU0YjUnLFxuXHRuYXZham93RXRlOiAnZmZkZWFkJyxcblx0bmF2eTogJzgwJyxcblx0VGRsYWNlOiAnZmRmNWU2Jyxcblx0VGl2ZTogJzgwODAwMCcsXG5cdFRpdmVkQmI6ICc2YjhlMjMnLFxuXHRTYW5nZTogJ2ZmYTUwMCcsXG5cdFNhbmdlWWQ6ICdmZjQ1MDAnLFxuXHRTY0VkOiAnZGE3MGQ2Jyxcblx0cE9lZ1RNblBkOiAnZWVlOGFhJyxcblx0cE9lZ1lGOiAnOThmYjk4Jyxcblx0cE9lUWU6ICdhZmVlZWUnLFxuXHRwT2V2aVRldFlkOiAnZGI3MDkzJyxcblx0cGFwYXlhd0VwOiAnZmZlZmQ1Jyxcblx0cEhLcHVmZjogJ2ZmZGFiOScsXG5cdHBlcnU6ICdjZDg1M2YnLFxuXHRwUms6ICdmZmMwY2InLFxuXHRwbHVtOiAnZGRhMGRkJyxcblx0cG93TXJYZTogJ2IwZTBlNicsXG5cdHB1cnBOOiAnODAwMDgwJyxcblx0WWJlY2NhcHVycE46ICc2NjMzOTknLFxuXHRZZDogJ2ZmMDAwMCcsXG5cdFBzeWJyb3duOiAnYmM4ZjhmJyxcblx0UHlPWGU6ICc0MTY5ZTEnLFxuXHRzYWRkTmJQd246ICc4YjQ1MTMnLFxuXHRzT21vbjogJ2ZhODA3MicsXG5cdHNhbmR5YlB3bjogJ2Y0YTQ2MCcsXG5cdHNIZ1lGOiAnMmU4YjU3Jyxcblx0c0hzaGVsbDogJ2ZmZjVlZScsXG5cdHNpRm5hOiAnYTA1MjJkJyxcblx0c2lsdmVyOiAnYzBjMGMwJyxcblx0c2t5WGU6ICc4N2NlZWInLFxuXHRVWGU6ICc2YTVhY2QnLFxuXHRVV2F5OiAnNzA4MDkwJyxcblx0VWdZeTogJzcwODA5MCcsXG5cdHNub3c6ICdmZmZhZmEnLFxuXHRzcHJSZ2dZRjogJ2ZmN2YnLFxuXHRzdEFsWGU6ICc0NjgyYjQnLFxuXHR0YW46ICdkMmI0OGMnLFxuXHR0ZU86ICc4MDgwJyxcblx0dEVzdE46ICdkOGJmZDgnLFxuXHR0b21hdG86ICdmZjYzNDcnLFxuXHRRZTogJzQwZTBkMCcsXG5cdHZpVGV0OiAnZWU4MmVlJyxcblx0Skh0OiAnZjVkZWIzJyxcblx0d0V0ZTogJ2ZmZmZmZicsXG5cdHdFdGVzbW9rZTogJ2Y1ZjVmNScsXG5cdEx3OiAnZmZmZjAwJyxcblx0THdnWUY6ICc5YWNkMzInXG59O1xuZnVuY3Rpb24gdW5wYWNrKCkge1xuICBjb25zdCB1bnBhY2tlZCA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmFtZXMkMSk7XG4gIGNvbnN0IHRrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgbGV0IGksIGosIGssIG9rLCBuaztcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBvayA9IG5rID0ga2V5c1tpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgdGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGsgPSB0a2V5c1tqXTtcbiAgICAgIG5rID0gbmsucmVwbGFjZShrLCBtYXBba10pO1xuICAgIH1cbiAgICBrID0gcGFyc2VJbnQobmFtZXMkMVtva10sIDE2KTtcbiAgICB1bnBhY2tlZFtua10gPSBbayA+PiAxNiAmIDB4RkYsIGsgPj4gOCAmIDB4RkYsIGsgJiAweEZGXTtcbiAgfVxuICByZXR1cm4gdW5wYWNrZWQ7XG59XG5cbmxldCBuYW1lcztcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcbiAgaWYgKCFuYW1lcykge1xuICAgIG5hbWVzID0gdW5wYWNrKCk7XG4gICAgbmFtZXMudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XG4gIH1cbiAgY29uc3QgYSA9IG5hbWVzW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGEgJiYge1xuICAgIHI6IGFbMF0sXG4gICAgZzogYVsxXSxcbiAgICBiOiBhWzJdLFxuICAgIGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuICB9O1xufVxuXG5jb25zdCBSR0JfUkUgPSAvXnJnYmE/XFwoXFxzKihbLSsuXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT8oPzpbXFxzLC9dKyhbLSsuZVxcZF0rKSglKT8pP1xccypcXCkkLztcbmZ1bmN0aW9uIHJnYlBhcnNlKHN0cikge1xuICBjb25zdCBtID0gUkdCX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCByLCBnLCBiO1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bN10gIT09IHIpIHtcbiAgICBjb25zdCB2ID0gK21bN107XG4gICAgYSA9IG1bOF0gPyBwMmIodikgOiBsaW0odiAqIDI1NSwgMCwgMjU1KTtcbiAgfVxuICByID0gK21bMV07XG4gIGcgPSArbVszXTtcbiAgYiA9ICttWzVdO1xuICByID0gMjU1ICYgKG1bMl0gPyBwMmIocikgOiBsaW0ociwgMCwgMjU1KSk7XG4gIGcgPSAyNTUgJiAobVs0XSA/IHAyYihnKSA6IGxpbShnLCAwLCAyNTUpKTtcbiAgYiA9IDI1NSAmIChtWzZdID8gcDJiKGIpIDogbGltKGIsIDAsIDI1NSkpO1xuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHJnYlN0cmluZyh2KSB7XG4gIHJldHVybiB2ICYmIChcbiAgICB2LmEgPCAyNTVcbiAgICAgID8gYHJnYmEoJHt2LnJ9LCAke3YuZ30sICR7di5ifSwgJHtiMm4odi5hKX0pYFxuICAgICAgOiBgcmdiKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0pYFxuICApO1xufVxuXG5jb25zdCB0byA9IHYgPT4gdiA8PSAwLjAwMzEzMDggPyB2ICogMTIuOTIgOiBNYXRoLnBvdyh2LCAxLjAgLyAyLjQpICogMS4wNTUgLSAwLjA1NTtcbmNvbnN0IGZyb20gPSB2ID0+IHYgPD0gMC4wNDA0NSA/IHYgLyAxMi45MiA6IE1hdGgucG93KCh2ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShyZ2IxLCByZ2IyLCB0KSB7XG4gIGNvbnN0IHIgPSBmcm9tKGIybihyZ2IxLnIpKTtcbiAgY29uc3QgZyA9IGZyb20oYjJuKHJnYjEuZykpO1xuICBjb25zdCBiID0gZnJvbShiMm4ocmdiMS5iKSk7XG4gIHJldHVybiB7XG4gICAgcjogbjJiKHRvKHIgKyB0ICogKGZyb20oYjJuKHJnYjIucikpIC0gcikpKSxcbiAgICBnOiBuMmIodG8oZyArIHQgKiAoZnJvbShiMm4ocmdiMi5nKSkgLSBnKSkpLFxuICAgIGI6IG4yYih0byhiICsgdCAqIChmcm9tKGIybihyZ2IyLmIpKSAtIGIpKSksXG4gICAgYTogcmdiMS5hICsgdCAqIChyZ2IyLmEgLSByZ2IxLmEpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuICBpZiAodikge1xuICAgIGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuICAgIHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuICAgIHRtcCA9IGhzbDJyZ2IodG1wKTtcbiAgICB2LnIgPSB0bXBbMF07XG4gICAgdi5nID0gdG1wWzFdO1xuICAgIHYuYiA9IHRtcFsyXTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcbiAgcmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG4gIHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuICAgICAgdiA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdi5hID0gbjJiKGlucHV0WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuICAgIHYuYSA9IG4yYih2LmEpO1xuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuICAgIHJldHVybiByZ2JQYXJzZShzdHIpO1xuICB9XG4gIHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gICAgbGV0IHY7XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2ID0gZnJvbU9iamVjdChpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdiA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aGlzLl9yZ2IgPSB2O1xuICAgIHRoaXMuX3ZhbGlkID0gISF2O1xuICB9XG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gIH1cbiAgZ2V0IHJnYigpIHtcbiAgICB2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG4gICAgaWYgKHYpIHtcbiAgICAgIHYuYSA9IGIybih2LmEpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBzZXQgcmdiKG9iaikge1xuICAgIHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcbiAgfVxuICByZ2JTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhzbFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBtaXgoY29sb3IsIHdlaWdodCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgY29uc3QgYzEgPSB0aGlzLnJnYjtcbiAgICAgIGNvbnN0IGMyID0gY29sb3IucmdiO1xuICAgICAgbGV0IHcyO1xuICAgICAgY29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3ID0gMiAqIHAgLSAxO1xuICAgICAgY29uc3QgYSA9IGMxLmEgLSBjMi5hO1xuICAgICAgY29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG4gICAgICB3MiA9IDEgLSB3MTtcbiAgICAgIGMxLnIgPSAweEZGICYgdzEgKiBjMS5yICsgdzIgKiBjMi5yICsgMC41O1xuICAgICAgYzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XG4gICAgICBjMS5iID0gMHhGRiAmIHcxICogYzEuYiArIHcyICogYzIuYiArIDAuNTtcbiAgICAgIGMxLmEgPSBwICogYzEuYSArICgxIC0gcCkgKiBjMi5hO1xuICAgICAgdGhpcy5yZ2IgPSBjMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW50ZXJwb2xhdGUoY29sb3IsIHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuX3JnYiA9IGludGVycG9sYXRlKHRoaXMuX3JnYiwgY29sb3IuX3JnYiwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuICB9XG4gIGFscGhhKGEpIHtcbiAgICB0aGlzLl9yZ2IuYSA9IG4yYihhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcmVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgLSByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncmV5c2NhbGUoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcbiAgICByZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb3BhcXVlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxICsgcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG4gICAgdi5yID0gMjU1IC0gdi5yO1xuICAgIHYuZyA9IDI1NSAtIHYuZztcbiAgICB2LmIgPSAyNTUgLSB2LmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlnaHRlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkYXJrZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShkZWcpIHtcbiAgICByb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4X2VzbShpbnB1dCkge1xuICByZXR1cm4gbmV3IENvbG9yKGlucHV0KTtcbn1cblxuZXhwb3J0IHsgQ29sb3IsIGIybiwgYjJwLCBpbmRleF9lc20gYXMgZGVmYXVsdCwgaGV4UGFyc2UsIGhleFN0cmluZywgaHNsMnJnYiwgaHNsU3RyaW5nLCBoc3YycmdiLCBodWVQYXJzZSwgaHdiMnJnYiwgbGltLCBuMmIsIG4ycCwgbmFtZVBhcnNlLCBwMmIsIHJnYjJoc2wsIHJnYlBhcnNlLCByZ2JTdHJpbmcsIHJvdGF0ZSwgcm91bmQgfTtcbiIsICIvKipcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuaGVscGVyc1xuICovXG5cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtBY3RpdmVEYXRhUG9pbnQsIENoYXJ0RXZlbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuLyoqXG4gKiBBbiBlbXB0eSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgZm9yIG9wdGlvbmFsIGNhbGxiYWNrLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHtcbiAgLyogbm9vcCAqL1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB1bmlxdWUgaWQsIHNlcXVlbnRpYWxseSBnZW5lcmF0ZWQgZnJvbSBhIGdsb2JhbCB2YXJpYWJsZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVpZCA9ICgoKSA9PiB7XG4gIGxldCBpZCA9IDA7XG4gIHJldHVybiAoKSA9PiBpZCsrO1xufSkoKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBuZWl0aGVyIG51bGwgbm9yIHVuZGVmaW5lZCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudWxsIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkgKGluY2x1ZGluZyB0eXBlZCBhcnJheXMpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheTxUID0gdW5rbm93bj4odmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBUW10ge1xuICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodHlwZS5zbGljZSgwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc2xpY2UoLTYpID09PSAnQXJyYXldJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgKGV4Y2x1ZGluZyBudWxsKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgQW55T2JqZWN0IHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGEgZmluaXRlIG51bWJlciwgZWxzZSByZXR1cm5zIGZhbHNlXG4gKiBAcGFyYW0gdmFsdWUgIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyRmluaXRlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgbnVtYmVyIHtcbiAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgrdmFsdWUpO1xufVxuZXhwb3J0IHtcbiAgaXNOdW1iZXJGaW5pdGUgYXMgaXNGaW5pdGUsXG59O1xuXG4vKipcbiAqIFJldHVybnMgYHZhbHVlYCBpZiBmaW5pdGUsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgbm90IGZpbml0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZTogdW5rbm93biwgZGVmYXVsdFZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHZhbHVlYCBpZiBkZWZpbmVkLCBlbHNlIHJldHVybnMgYGRlZmF1bHRWYWx1ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGRlZmluZWQuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBgdmFsdWVgIGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbHVlT3JEZWZhdWx0PFQ+KHZhbHVlOiBUIHwgdW5kZWZpbmVkLCBkZWZhdWx0VmFsdWU6IFQpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0VmFsdWUgOiB2YWx1ZTtcbn1cblxuZXhwb3J0IGNvbnN0IHRvUGVyY2VudGFnZSA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgIDogK3ZhbHVlIC8gZGltZW5zaW9uO1xuXG5leHBvcnQgY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWU6IG51bWJlciB8IHN0cmluZywgZGltZW5zaW9uOiBudW1iZXIpID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDAgKiBkaW1lbnNpb25cbiAgICA6ICt2YWx1ZTtcblxuLyoqXG4gKiBDYWxscyBgZm5gIHdpdGggdGhlIGdpdmVuIGBhcmdzYCBpbiB0aGUgc2NvcGUgZGVmaW5lZCBieSBgdGhpc0FyZ2AgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggYGZuYCBzaG91bGQgYmUgY2FsbGVkLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxsYmFjazxUIGV4dGVuZHMgKHRoaXM6IFRBLCAuLi5yZXN0QXJnczogdW5rbm93bltdKSA9PiBSLCBUQSwgUj4oXG4gIGZuOiBUIHwgdW5kZWZpbmVkLFxuICBhcmdzOiB1bmtub3duW10sXG4gIHRoaXNBcmc/OiBUQVxuKTogUiB8IHVuZGVmaW5lZCB7XG4gIGlmIChmbiAmJiB0eXBlb2YgZm4uY2FsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vdGUoU0IpIGZvciBwZXJmb3JtYW5jZSBzYWtlLCB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4gbG9vcGFibGUgdHlwZVxuICogaXMgdW5rbm93biBvciBpbiBub25lIGludGVuc2l2ZSBjb2RlIChub3QgY2FsbGVkIG9mdGVuIGFuZCBzbWFsbCBsb29wYWJsZSkuIEVsc2VcbiAqIGl0J3MgcHJlZmVyYWJsZSB0byB1c2UgYSByZWd1bGFyIGZvcigpIGxvb3AgYW5kIHNhdmUgZXh0cmEgZnVuY3Rpb24gY2FsbHMuXG4gKiBAcGFyYW0gbG9vcGFibGUgLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGJlIGl0ZXJhdGVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaXRlbS5cbiAqIEBwYXJhbSBbdGhpc0FyZ10gLSBUaGUgdmFsdWUgb2YgYHRoaXNgIHByb3ZpZGVkIGZvciB0aGUgY2FsbCB0byBgZm5gLlxuICogQHBhcmFtIFtyZXZlcnNlXSAtIElmIHRydWUsIGl0ZXJhdGVzIGJhY2t3YXJkIG9uIHRoZSBsb29wYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogUmVjb3JkPHN0cmluZywgVD4sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IHN0cmluZykgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQsIFRBPihcbiAgbG9vcGFibGU6IFRbXSxcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogbnVtYmVyKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdIHwgUmVjb3JkPHN0cmluZywgVD4sXG4gIGZuOiAodGhpczogVEEsIHY6IFQsIGk6IGFueSkgPT4gdm9pZCxcbiAgdGhpc0FyZz86IFRBLFxuICByZXZlcnNlPzogYm9vbGVhblxuKSB7XG4gIGxldCBpOiBudW1iZXIsIGxlbjogbnVtYmVyLCBrZXlzOiBzdHJpbmdbXTtcbiAgaWYgKGlzQXJyYXkobG9vcGFibGUpKSB7XG4gICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChsb29wYWJsZSkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBgYTBgIGFuZCBgYTFgIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQsIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSBhMCAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcGFyYW0gYTEgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwOiBBY3RpdmVEYXRhUG9pbnRbXSwgYTE6IEFjdGl2ZURhdGFQb2ludFtdKSB7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdjA6IEFjdGl2ZURhdGFQb2ludCwgdjE6IEFjdGl2ZURhdGFQb2ludDtcblxuICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2MCA9IGEwW2ldO1xuICAgIHYxID0gYTFbaV07XG5cbiAgICBpZiAodjAuZGF0YXNldEluZGV4ICE9PSB2MS5kYXRhc2V0SW5kZXggfHwgdjAuaW5kZXggIT09IHYxLmluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmU8VD4oc291cmNlOiBUKTogVCB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcChjbG9uZSkgYXMgdW5rbm93biBhcyBUO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgayA9IDA7XG5cbiAgICBmb3IgKDsgayA8IGtsZW47ICsraykge1xuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUoc291cmNlW2tleXNba11dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgcmV0dXJuIHNvdXJjZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXk6IHN0cmluZykge1xuICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBtZXJnZXIgd2hlbiBDaGFydC5oZWxwZXJzLm1lcmdlIGlzIGNhbGxlZCB3aXRob3V0IG1lcmdlciBvcHRpb24uXG4gKiBOb3RlKFNCKTogYWxzbyB1c2VkIGJ5IG1lcmdlQ29uZmlnIGFuZCBtZXJnZVNjYWxlQ29uZmlnIGFzIGZhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZXJnZXIoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCwgb3B0aW9uczogQW55T2JqZWN0KSB7XG4gIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG5cbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIG1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXJnZU9wdGlvbnMge1xuICBtZXJnZXI/OiAoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCwgb3B0aW9ucz86IEFueU9iamVjdCkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgd2l0aCB0aGUgZ2l2ZW4gYG9wdGlvbnNgLlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEBwYXJhbSBbb3B0aW9uc10gLSBNZXJnaW5nIG9wdGlvbnM6XG4gKiBAcGFyYW0gW29wdGlvbnMubWVyZ2VyXSAtIFRoZSBtZXJnZSBtZXRob2QgKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG4gKiBAcmV0dXJucyBUaGUgYHRhcmdldGAgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBTMSwgUzI+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMiwgUzMsIFM0PihcbiAgdGFyZ2V0OiBULFxuICBzb3VyY2U6IFtTMSwgUzIsIFMzLCBTNF0sXG4gIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnNcbik6IFQgJiBTMSAmIFMyICYgUzMgJiBTNDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogQW55T2JqZWN0IHtcbiAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuICBjb25zdCBpbGVuID0gc291cmNlcy5sZW5ndGg7XG5cbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldCBhcyBBbnlPYmplY3Q7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWVyZ2VyID0gb3B0aW9ucy5tZXJnZXIgfHwgX21lcmdlcjtcbiAgbGV0IGN1cnJlbnQ6IEFueU9iamVjdDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBzb3VyY2VzW2ldO1xuICAgIGlmICghaXNPYmplY3QoY3VycmVudCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdXJyZW50KTtcbiAgICBmb3IgKGxldCBrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICBtZXJnZXIoa2V5c1trXSwgdGFyZ2V0LCBjdXJyZW50LCBvcHRpb25zIGFzIEFueU9iamVjdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBkZWVwIGNvcGllcyBgc291cmNlYCBwcm9wZXJ0aWVzIGludG8gYHRhcmdldGAgKm9ubHkqIGlmIG5vdCBkZWZpbmVkIGluIHRhcmdldC5cbiAqIElNUE9SVEFOVDogYHRhcmdldGAgaXMgbm90IGNsb25lZCBhbmQgd2lsbCBiZSB1cGRhdGVkIHdpdGggYHNvdXJjZWAgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCBpbiB3aGljaCBhbGwgc291cmNlcyBhcmUgbWVyZ2VkIGludG8uXG4gKiBAcGFyYW0gc291cmNlIC0gT2JqZWN0KHMpIHRvIG1lcmdlIGludG8gYHRhcmdldGAuXG4gKiBAcmV0dXJucyBUaGUgYHRhcmdldGAgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10pOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBTMSk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxXSk6IFQgJiBTMTtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMSwgUzIsIFMzPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzNdKTogVCAmIFMxICYgUzIgJiBTMztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzMsIFM0Pih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSk6IFQgJiBTMSAmIFMyICYgUzMgJiBTNDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSk6IEFueU9iamVjdCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgcmV0dXJuIG1lcmdlPFQ+KHRhcmdldCwgc291cmNlLCB7bWVyZ2VyOiBfbWVyZ2VySWZ9KTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgc291cmNlW2tleV0gaW4gdGFyZ2V0W2tleV0gb25seSBpZiB0YXJnZXRba2V5XSBpcyB1bmRlZmluZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcklmKGtleTogc3RyaW5nLCB0YXJnZXQ6IEFueU9iamVjdCwgc291cmNlOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICBtZXJnZUlmKHR2YWwsIHN2YWwpO1xuICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVwcmVjYXRlZChzY29wZTogc3RyaW5nLCB2YWx1ZTogdW5rbm93biwgcHJldmlvdXM6IHN0cmluZywgY3VycmVudDogc3RyaW5nKSB7XG4gIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKHNjb3BlICsgJzogXCInICsgcHJldmlvdXMgK1xuICAgICAgJ1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCInICsgY3VycmVudCArICdcIiBpbnN0ZWFkJyk7XG4gIH1cbn1cblxuLy8gcmVzb2x2ZU9iamVjdEtleSByZXNvbHZlciBjYWNoZVxuY29uc3Qga2V5UmVzb2x2ZXJzID0ge1xuICAvLyBDaGFydC5oZWxwZXJzLmNvcmUgcmVzb2x2ZU9iamVjdEtleSBzaG91bGQgcmVzb2x2ZSBlbXB0eSBrZXkgdG8gcm9vdCBvYmplY3RcbiAgJyc6IHYgPT4gdixcbiAgLy8gZGVmYXVsdCByZXNvbHZlcnNcbiAgeDogbyA9PiBvLngsXG4gIHk6IG8gPT4gby55XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3BsaXRLZXkoa2V5OiBzdHJpbmcpIHtcbiAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgY29uc3Qga2V5czogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHRtcCA9ICcnO1xuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICB0bXAgKz0gcGFydDtcbiAgICBpZiAodG1wLmVuZHNXaXRoKCdcXFxcJykpIHtcbiAgICAgIHRtcCA9IHRtcC5zbGljZSgwLCAtMSkgKyAnLic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMucHVzaCh0bXApO1xuICAgICAgdG1wID0gJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfZ2V0S2V5UmVzb2x2ZXIoa2V5OiBzdHJpbmcpIHtcbiAgY29uc3Qga2V5cyA9IF9zcGxpdEtleShrZXkpO1xuICByZXR1cm4gb2JqID0+IHtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgaWYgKGsgPT09ICcnKSB7XG4gICAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OlxuICAgICAgICAvLyBDaGFydC5oZWxwZXJzLmNvcmUgcmVzb2x2ZU9iamVjdEtleSBzaG91bGQgYnJlYWsgYXQgZW1wdHkga2V5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqICYmIG9ialtrXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPYmplY3RLZXkob2JqOiBBbnlPYmplY3QsIGtleTogc3RyaW5nKTogYW55IHtcbiAgY29uc3QgcmVzb2x2ZXIgPSBrZXlSZXNvbHZlcnNba2V5XSB8fCAoa2V5UmVzb2x2ZXJzW2tleV0gPSBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSk7XG4gIHJldHVybiByZXNvbHZlcihvYmopO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHI6IHN0cmluZykge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuXG5cbmV4cG9ydCBjb25zdCBkZWZpbmVkID0gKHZhbHVlOiB1bmtub3duKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuXG5leHBvcnQgY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55ID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMxMTI4ODU1L2NvbXBhcmluZy1lY21hNi1zZXRzLWZvci1lcXVhbGl0eSMzMTEyOTM4NFxuZXhwb3J0IGNvbnN0IHNldHNFcXVhbCA9IDxUPihhOiBTZXQ8VD4sIGI6IFNldDxUPikgPT4ge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGUgLSBUaGUgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNDbGlja0V2ZW50KGU6IENoYXJ0RXZlbnQpIHtcbiAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudSc7XG59XG4iLCAiaW1wb3J0IHR5cGUge1BvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHtpc0Zpbml0ZSBhcyBpc0Zpbml0ZU51bWJlcn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEBhbGlhcyBDaGFydC5oZWxwZXJzLm1hdGhcbiAqIEBuYW1lc3BhY2VcbiAqL1xuXG5leHBvcnQgY29uc3QgUEkgPSBNYXRoLlBJO1xuZXhwb3J0IGNvbnN0IFRBVSA9IDIgKiBQSTtcbmV4cG9ydCBjb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuZXhwb3J0IGNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuZXhwb3J0IGNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5leHBvcnQgY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmV4cG9ydCBjb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuZXhwb3J0IGNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuXG5leHBvcnQgY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuZXhwb3J0IGNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5cbmV4cG9ydCBmdW5jdGlvbiBhbG1vc3RFcXVhbHMoeDogbnVtYmVyLCB5OiBudW1iZXIsIGVwc2lsb246IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5hYnMoeCAtIHkpIDwgZXBzaWxvbjtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgbmljZSBudW1iZXIgYWxnb3JpdGhtIHVzZWQgaW4gZGV0ZXJtaW5pbmcgd2hlcmUgYXhpcyBsYWJlbHMgd2lsbCBnb1xuICovXG5leHBvcnQgZnVuY3Rpb24gbmljZU51bShyYW5nZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZhY3RvcnMgc29ydGVkIGZyb20gMSB0byBzcXJ0KHZhbHVlKVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWU6IG51bWJlcikge1xuICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7IC8vIGlmIHZhbHVlIGlzIGEgc3F1YXJlIG51bWJlclxuICAgIHJlc3VsdC5wdXNoKHNxcnQpO1xuICB9XG5cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGF0IGF0dGVtcHRpbmcgdG8gY29lcmNlIG4gdG8gc3RyaW5nIG9yIG51bWJlciB3b24ndCB0aHJvdyBhIFR5cGVFcnJvci5cbiAqL1xuZnVuY3Rpb24gaXNOb25QcmltaXRpdmUobjogdW5rbm93bikge1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdzeW1ib2wnIHx8ICh0eXBlb2YgbiA9PT0gJ29iamVjdCcgJiYgbiAhPT0gbnVsbCAmJiAhKFN5bWJvbC50b1ByaW1pdGl2ZSBpbiBuIHx8ICd0b1N0cmluZycgaW4gbiB8fCAndmFsdWVPZicgaW4gbikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIobjogdW5rbm93bik6IG4gaXMgbnVtYmVyIHtcbiAgcmV0dXJuICFpc05vblByaW1pdGl2ZShuKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChuIGFzIHN0cmluZykpICYmIGlzRmluaXRlKG4gYXMgbnVtYmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdFdob2xlKHg6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShcbiAgYXJyYXk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAgdGFyZ2V0OiB7IG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciB9LFxuICBwcm9wZXJ0eTogc3RyaW5nXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogbnVtYmVyO1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGFyZ2V0Lm1pbiA9IE1hdGgubWluKHRhcmdldC5taW4sIHZhbHVlKTtcbiAgICAgIHRhcmdldC5tYXggPSBNYXRoLm1heCh0YXJnZXQubWF4LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlczogbnVtYmVyKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zOiBudW1iZXIpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICogaS5lLiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgb2YgdGhlIHZhbHVlIG9mIHRoaXMgTnVtYmVyLlxuICogQHBhcmFtIHggLSBBIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeDogbnVtYmVyKSB7XG4gIGlmICghaXNGaW5pdGVOdW1iZXIoeCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGUgPSAxO1xuICBsZXQgcCA9IDA7XG4gIHdoaWxlIChNYXRoLnJvdW5kKHggKiBlKSAvIGUgIT09IHgpIHtcbiAgICBlICo9IDEwO1xuICAgIHArKztcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuLy8gR2V0cyB0aGUgYW5nbGUgZnJvbSB2ZXJ0aWNhbCB1cHJpZ2h0IHRvIHRoZSBwb2ludCBhYm91dCBhIGNlbnRyZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChcbiAgY2VudHJlUG9pbnQ6IFBvaW50LFxuICBhbmdsZVBvaW50OiBQb2ludFxuKSB7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVhDZW50ZXIgPSBhbmdsZVBvaW50LnggLSBjZW50cmVQb2ludC54O1xuICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgY29uc3QgcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyID0gTWF0aC5zcXJ0KGRpc3RhbmNlRnJvbVhDZW50ZXIgKiBkaXN0YW5jZUZyb21YQ2VudGVyICsgZGlzdGFuY2VGcm9tWUNlbnRlciAqIGRpc3RhbmNlRnJvbVlDZW50ZXIpO1xuXG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG5cbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7IC8vIG1ha2Ugc3VyZSB0aGUgcmV0dXJuZWQgYW5nbGUgaXMgaW4gdGhlIHJhbmdlIG9mICgtUEkvMiwgM1BJLzJdXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuZ2xlLFxuICAgIGRpc3RhbmNlOiByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXJcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlblBvaW50cyhwdDE6IFBvaW50LCBwdDI6IFBvaW50KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5cbi8qKlxuICogU2hvcnRlc3QgZGlzdGFuY2UgYmV0d2VlbiBhbmdsZXMsIGluIGVpdGhlciBkaXJlY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlRGlmZihhOiBudW1iZXIsIGI6IG51bWJlcikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplIGFuZ2xlIHRvIGJlIGJldHdlZW4gMCBhbmQgMipQSVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlPzogYm9vbGVhbikge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cblxuLyoqXG4gKiBMaW1pdCBgdmFsdWVgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbGltaXRWYWx1ZSh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlOiBudW1iZXIpIHtcbiAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbHVlLCAtMzI3NjgsIDMyNzY3KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICogQHBhcmFtIFtlcHNpbG9uXVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0JldHdlZW4odmFsdWU6IG51bWJlciwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGVwc2lsb24gPSAxZS02KSB7XG4gIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuIiwgImltcG9ydCB7X2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSB2YWx1ZSAtIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSBjbXBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwKFxuICB0YWJsZTogbnVtYmVyW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cDxUPihcbiAgdGFibGU6IFRbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wOiAodmFsdWU6IG51bWJlcikgPT4gYm9vbGVhblxuKToge2xvOiBudW1iZXIsIGhpOiBudW1iZXJ9O1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiB1bmtub3duW10sXG4gIHZhbHVlOiBudW1iZXIsXG4gIGNtcD86ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pIHtcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IG1pZDogbnVtYmVyO1xuXG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIG1pZCA9IChsbyArIGhpKSA+PiAxO1xuICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgbG8gPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpID0gbWlkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7bG8sIGhpfTtcbn1cblxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGxhc3QgLSBsb29rdXAgbGFzdCBpbmRleFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9sb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXIsXG4gIGxhc3Q/OiBib29sZWFuXG4pID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBsYXN0XG4gICAgPyBpbmRleCA9PiB7XG4gICAgICBjb25zdCB0aSA9IHRhYmxlW2luZGV4XVtrZXldO1xuICAgICAgcmV0dXJuIHRpIDwgdmFsdWUgfHwgdGkgPT09IHZhbHVlICYmIHRhYmxlW2luZGV4ICsgMV1ba2V5XSA9PT0gdmFsdWU7XG4gICAgfVxuICAgIDogaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPCB2YWx1ZSk7XG5cbi8qKlxuICogUmV2ZXJzZSBiaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9ybG9va3VwQnlLZXkgPSAoXG4gIHRhYmxlOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+W10sXG4gIGtleTogc3RyaW5nLFxuICB2YWx1ZTogbnVtYmVyXG4pID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA+PSB2YWx1ZSk7XG5cbi8qKlxuICogUmV0dXJuIHN1YnNldCBvZiBgdmFsdWVzYCBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YCBpbmNsdXNpdmUuXG4gKiBWYWx1ZXMgYXJlIGFzc3VtZWQgdG8gYmUgaW4gc29ydGVkIG9yZGVyLlxuICogQHBhcmFtIHZhbHVlcyAtIHNvcnRlZCBhcnJheSBvZiB2YWx1ZXNcbiAqIEBwYXJhbSBtaW4gLSBtaW4gdmFsdWVcbiAqIEBwYXJhbSBtYXggLSBtYXggdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlczogbnVtYmVyW10sIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gdmFsdWVzLmxlbmd0aDtcblxuICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgdmFsdWVzW3N0YXJ0XSA8IG1pbikge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHZhbHVlc1tlbmQgLSAxXSA+IG1heCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cblxuY29uc3QgYXJyYXlFdmVudHMgPSBbJ3B1c2gnLCAncG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsICd1bnNoaWZ0J10gYXMgY29uc3Q7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJyYXlMaXN0ZW5lcjxUPiB7XG4gIF9vbkRhdGFQdXNoPyguLi5pdGVtOiBUW10pOiB2b2lkO1xuICBfb25EYXRhUG9wPygpOiB2b2lkO1xuICBfb25EYXRhU2hpZnQ/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTcGxpY2U/KGluZGV4OiBudW1iZXIsIGRlbGV0ZUNvdW50OiBudW1iZXIsIC4uLml0ZW1zOiBUW10pOiB2b2lkO1xuICBfb25EYXRhVW5zaGlmdD8oLi4uaXRlbTogVFtdKTogdm9pZDtcbn1cblxuLyoqXG4gKiBIb29rcyB0aGUgYXJyYXkgbWV0aG9kcyB0aGF0IGFkZCBvciByZW1vdmUgdmFsdWVzICgncHVzaCcsIHBvcCcsICdzaGlmdCcsICdzcGxpY2UnLFxuICogJ3Vuc2hpZnQnKSBhbmQgbm90aWZ5IHRoZSBsaXN0ZW5lciBBRlRFUiB0aGUgYXJyYXkgaGFzIGJlZW4gYWx0ZXJlZC4gTGlzdGVuZXJzIGFyZVxuICogY2FsbGVkIG9uIHRoZSAnX29uRGF0YSonIGNhbGxiYWNrcyAoZS5nLiBfb25EYXRhUHVzaCwgZXRjLikgd2l0aCBzYW1lIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzPFQ+KGFycmF5OiBUW10sIGxpc3RlbmVyOiBBcnJheUxpc3RlbmVyPFQ+KTogdm9pZDtcbmV4cG9ydCBmdW5jdGlvbiBsaXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdXG4gICAgfVxuICB9KTtcblxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWUoLi4uYXJncykge1xuICAgICAgICBjb25zdCByZXMgPSBiYXNlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChvYmplY3QpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmplY3RbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZ2l2ZW4gYXJyYXkgZXZlbnQgbGlzdGVuZXIgYW5kIGNsZWFudXAgZXh0cmEgYXR0YWNoZWQgcHJvcGVydGllcyAoc3VjaCBhc1xuICogdGhlIF9jaGFydGpzIHN0dWIgYW5kIG92ZXJyaWRkZW4gbWV0aG9kcykgaWYgYXJyYXkgZG9lc24ndCBoYXZlIGFueSBtb3JlIGxpc3RlbmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGNvbnN0IHN0dWIgPSBhcnJheS5fY2hhcnRqcztcbiAgaWYgKCFzdHViKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cblxuICBpZiAobGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgYXJyYXlba2V5XTtcbiAgfSk7XG5cbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpdGVtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gX2FycmF5VW5pcXVlPFQ+KGl0ZW1zOiBUW10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxUPihpdGVtcyk7XG5cbiAgaWYgKHNldC5zaXplID09PSBpdGVtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydE1ldGEsIFBvaW50RWxlbWVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5pbXBvcnQge19saW1pdFZhbHVlfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19sb29rdXBCeUtleX0gZnJvbSAnLi9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmb250U3RyaW5nKHBpeGVsU2l6ZTogbnVtYmVyLCBmb250U3R5bGU6IHN0cmluZywgZm9udEZhbWlseTogc3RyaW5nKSB7XG4gIHJldHVybiBmb250U3R5bGUgKyAnICcgKyBwaXhlbFNpemUgKyAncHggJyArIGZvbnRGYW1pbHk7XG59XG5cbi8qKlxuKiBSZXF1ZXN0IGFuaW1hdGlvbiBwb2x5ZmlsbFxuKi9cbmV4cG9ydCBjb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG59KCkpO1xuXG4vKipcbiAqIFRocm90dGxlcyBjYWxsaW5nIGBmbmAgb25jZSBwZXIgYW5pbWF0aW9uIGZyYW1lXG4gKiBMYXRlc3QgYXJndW1lbnRzIGFyZSB1c2VkIG9uIHRoZSBhY3R1YWwgY2FsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGVkPFRBcmdzIGV4dGVuZHMgQXJyYXk8YW55Pj4oXG4gIGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsXG4gIHRoaXNBcmc6IGFueSxcbikge1xuICBsZXQgYXJnc1RvVXNlID0gW10gYXMgVEFyZ3M7XG4gIGxldCB0aWNraW5nID0gZmFsc2U7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IFRBcmdzKSB7XG4gICAgLy8gU2F2ZSB0aGUgYXJncyBmb3IgdXNlIGxhdGVyXG4gICAgYXJnc1RvVXNlID0gYXJncztcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3NUb1VzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRGVib3VuY2VzIGNhbGxpbmcgYGZuYCBmb3IgYGRlbGF5YCBtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihmbjogKC4uLmFyZ3M6IFRBcmdzKSA9PiB2b2lkLCBkZWxheTogbnVtYmVyKSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgJ3N0YXJ0JyB0byAnbGVmdCcsICdlbmQnIHRvICdyaWdodCcgYW5kIG90aGVycyB0byAnY2VudGVyJ1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicpID0+IGFsaWduID09PSAnc3RhcnQnID8gJ2xlZnQnIDogYWxpZ24gPT09ICdlbmQnID8gJ3JpZ2h0JyA6ICdjZW50ZXInO1xuXG4vKipcbiAqIFJldHVybnMgYHN0YXJ0YCwgYGVuZGAgb3IgYChzdGFydCArIGVuZCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGNlbnRlcmBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbjogJ3N0YXJ0JyB8ICdlbmQnIHwgJ2NlbnRlcicsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5cbi8qKlxuICogUmV0dXJucyBgbGVmdGAsIGByaWdodGAgb3IgYChsZWZ0ICsgcmlnaHQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBsZWZ0YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF90ZXh0WCA9IChhbGlnbjogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInLCBsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIHJ0bDogYm9vbGVhbikgPT4ge1xuICBjb25zdCBjaGVjayA9IHJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuXG4vKipcbiAqIFJldHVybiBzdGFydCBhbmQgY291bnQgb2YgdmlzaWJsZSBwb2ludHMuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sIHBvaW50czogUG9pbnRFbGVtZW50W10sIGFuaW1hdGlvbnNEaXNhYmxlZDogYm9vbGVhbikge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuXG4gIGlmIChtZXRhLl9zb3J0ZWQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9wYXJzZWR9ID0gbWV0YTtcbiAgICBjb25zdCBzcGFuR2FwcyA9IG1ldGEuZGF0YXNldCA/IG1ldGEuZGF0YXNldC5vcHRpb25zID8gbWV0YS5kYXRhc2V0Lm9wdGlvbnMuc3BhbkdhcHMgOiBudWxsIDogbnVsbDtcbiAgICBjb25zdCBheGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG5cbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBNYXRoLm1pbihcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIHR5cGUgX3BhcnNlZFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgYXhpcywgbWluKS5sbyxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gcG9pbnRDb3VudCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1pbikpLmxvKTtcbiAgICAgIGlmIChzcGFuR2Fwcykge1xuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZExvID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UoMCwgc3RhcnQgKyAxKVxuICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAuZmluZEluZGV4KFxuICAgICAgICAgICAgcG9pbnQgPT4gIWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSkpO1xuICAgICAgICBzdGFydCAtPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZExvKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgICB9XG4gICAgaWYgKG1heERlZmluZWQpIHtcbiAgICAgIGxldCBlbmQgPSBNYXRoLm1heChcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIHR5cGUgX3BhcnNlZFxuICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCwgdHJ1ZSkuaGkgKyAxLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyAwIDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWF4KSwgdHJ1ZSkuaGkgKyAxKTtcbiAgICAgIGlmIChzcGFuR2Fwcykge1xuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZEhpID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UoZW5kIC0gMSlcbiAgICAgICAgICAuZmluZEluZGV4KFxuICAgICAgICAgICAgcG9pbnQgPT4gIWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSkpO1xuICAgICAgICBlbmQgKz0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRIaSk7XG4gICAgICB9XG4gICAgICBjb3VudCA9IF9saW1pdFZhbHVlKGVuZCwgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNjYWxlIHJhbmdlcyBoYXZlIGNoYW5nZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YS5cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcblxuICBPYmplY3QuYXNzaWduKF9zY2FsZVJhbmdlcywgbmV3UmFuZ2VzKTtcbiAgcmV0dXJuIGNoYW5nZWQ7XG59XG4iLCAiaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbmNvbnN0IGF0RWRnZSA9ICh0OiBudW1iZXIpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodDogbnVtYmVyLCBzOiBudW1iZXIsIHA6IG51bWJlcikgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuXG4vKipcbiAqIEVhc2luZyBmdW5jdGlvbnMgYWRhcHRlZCBmcm9tIFJvYmVydCBQZW5uZXIncyBlYXNpbmcgZXF1YXRpb25zLlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzLmVhc2luZy5lZmZlY3RzXG4gKiBAc2VlIGh0dHA6Ly93d3cucm9iZXJ0cGVubmVyLmNvbS9lYXNpbmcvXG4gKi9cbmNvbnN0IGVmZmVjdHMgPSB7XG4gIGxpbmVhcjogKHQ6IG51bWJlcikgPT4gdCxcblxuICBlYXNlSW5RdWFkOiAodDogbnVtYmVyKSA9PiB0ICogdCxcblxuICBlYXNlT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gLXQgKiAodCAtIDIpLFxuXG4gIGVhc2VJbk91dFF1YWQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuXG4gIGVhc2VJbkN1YmljOiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dEN1YmljOiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRDdWJpYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblF1YXJ0OiAodDogbnVtYmVyKSA9PiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFydDogKHQ6IG51bWJlcikgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuXG4gIGVhc2VJbk91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG5cbiAgZWFzZUluUXVpbnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuXG4gIGVhc2VPdXRRdWludDogKHQ6IG51bWJlcikgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcblxuICBlYXNlSW5PdXRRdWludDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcblxuICBlYXNlSW5TaW5lOiAodDogbnVtYmVyKSA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcblxuICBlYXNlT3V0U2luZTogKHQ6IG51bWJlcikgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuXG4gIGVhc2VJbk91dFNpbmU6ICh0OiBudW1iZXIpID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuXG4gIGVhc2VJbkV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuXG4gIGVhc2VPdXRFeHBvOiAodDogbnVtYmVyKSA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcblxuICBlYXNlSW5PdXRFeHBvOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG5cbiAgZWFzZUluQ2lyYzogKHQ6IG51bWJlcikgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuXG4gIGVhc2VPdXRDaXJjOiAodDogbnVtYmVyKSA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG5cbiAgZWFzZUluT3V0Q2lyYzogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG5cbiAgZWFzZUluRWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlT3V0RWxhc3RpYzogKHQ6IG51bWJlcikgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG5cbiAgZWFzZUluT3V0RWxhc3RpYyh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuXG4gIGVhc2VJbkJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH0sXG5cbiAgZWFzZU91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcblxuICBlYXNlSW5PdXRCYWNrKHQ6IG51bWJlcikge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuXG4gIGVhc2VJbkJvdW5jZTogKHQ6IG51bWJlcikgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG5cbiAgZWFzZU91dEJvdW5jZSh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBtID0gNy41NjI1O1xuICAgIGNvbnN0IGQgPSAyLjc1O1xuICAgIGlmICh0IDwgKDEgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICB9XG4gICAgaWYgKHQgPCAoMiAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgxLjUgLyBkKSkgKiB0ICsgMC43NTtcbiAgICB9XG4gICAgaWYgKHQgPCAoMi41IC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDIuMjUgLyBkKSkgKiB0ICsgMC45Mzc1O1xuICAgIH1cbiAgICByZXR1cm4gbSAqICh0IC09ICgyLjYyNSAvIGQpKSAqIHQgKyAwLjk4NDM3NTtcbiAgfSxcblxuICBlYXNlSW5PdXRCb3VuY2U6ICh0OiBudW1iZXIpID0+ICh0IDwgMC41KVxuICAgID8gZWZmZWN0cy5lYXNlSW5Cb3VuY2UodCAqIDIpICogMC41XG4gICAgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIEVhc2luZ0Z1bmN0aW9uID0ga2V5b2YgdHlwZW9mIGVmZmVjdHNcblxuZXhwb3J0IGRlZmF1bHQgZWZmZWN0cztcbiIsICJpbXBvcnQge0NvbG9yfSBmcm9tICdAa3Vya2xlL2NvbG9yJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBDYW52YXNQYXR0ZXJuIHwgQ2FudmFzR3JhZGllbnQge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBDYW52YXNQYXR0ZXJuXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlOiBDYW52YXNQYXR0ZXJuKTogQ2FudmFzUGF0dGVybjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcihcbiAgdmFsdWU6XG4gIHwgc3RyaW5nXG4gIHwgeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyOyBhOiBudW1iZXIgfVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXVxuICB8IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdXG4pOiBDb2xvcjtcbmV4cG9ydCBmdW5jdGlvbiBjb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBDb2xvcih2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlOiBDYW52YXNHcmFkaWVudCk6IENhbnZhc0dyYWRpZW50O1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBnZXRIb3ZlckNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IG5ldyBDb2xvcih2YWx1ZSkuc2F0dXJhdGUoMC41KS5kYXJrZW4oMC4xKS5oZXhTdHJpbmcoKTtcbn1cbiIsICJjb25zdCBudW1iZXJzID0gWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJywgJ3RlbnNpb24nXTtcbmNvbnN0IGNvbG9ycyA9IFsnY29sb3InLCAnYm9yZGVyQ29sb3InLCAnYmFja2dyb3VuZENvbG9yJ107XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgICBkZWxheTogdW5kZWZpbmVkLFxuICAgIGR1cmF0aW9uOiAxMDAwLFxuICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgZm46IHVuZGVmaW5lZCxcbiAgICBmcm9tOiB1bmRlZmluZWQsXG4gICAgbG9vcDogdW5kZWZpbmVkLFxuICAgIHRvOiB1bmRlZmluZWQsXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICAgIF9mYWxsYmFjazogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogbnVtYmVyc1xuICAgIH0sXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb25zJywge1xuICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gICAgYWN0aXZlOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVzaXplOiB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3c6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGR1cmF0aW9uOiAwIC8vIHNob3cgaW1tZWRpYXRlbHlcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZGU6IHtcbiAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgdG86ICd0cmFuc3BhcmVudCdcbiAgICAgICAgfSxcbiAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgIGZuOiB2ID0+IHYgfCAwIC8vIGZvciBrZWVwaW5nIHRoZSBkYXRhc2V0IHZpc2libGUgYWxsIHRoZSB3YXkgdGhyb3VnaCB0aGUgYW5pbWF0aW9uXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsICJleHBvcnQgZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfVxuICB9KTtcbn1cbiIsICJcbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBJbnRsLk51bWJlckZvcm1hdD4oKTtcblxuZnVuY3Rpb24gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bTogbnVtYmVyLCBsb2NhbGU6IHN0cmluZywgb3B0aW9ucz86IEludGwuTnVtYmVyRm9ybWF0T3B0aW9ucykge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KG51bSk7XG59XG4iLCAiaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHtsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIGZvcm1hdHRlcnMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiB0aWNrc1xuICogQG5hbWVzcGFjZSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzXG4gKi9cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIHZhbHVlIGxhYmVsc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMudmFsdWVzXG4gICAqIEBwYXJhbSB2YWx1ZSB0aGUgdmFsdWUgdG8gZGlzcGxheVxuICAgKiBAcmV0dXJuIHtzdHJpbmd8c3RyaW5nW119IHRoZSBsYWJlbCB0byBkaXNwbGF5XG4gICAqL1xuICB2YWx1ZXModmFsdWUpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyAvKiogQHR5cGUge3N0cmluZ1tdfSAqLyAodmFsdWUpIDogJycgKyB2YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBudW1lcmljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAqIEBwYXJhbSB0aWNrVmFsdWUge251bWJlcn0gdGhlIHZhbHVlIHRvIGJlIGZvcm1hdHRlZFxuICAgKiBAcGFyYW0gaW5kZXgge251bWJlcn0gdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyIGluIHRoZSB0aWNrcyBhcnJheVxuICAgKiBAcGFyYW0gdGlja3Mge29iamVjdFtdfSB0aGUgbGlzdCBvZiB0aWNrcyBiZWluZyBjb252ZXJ0ZWRcbiAgICogQHJldHVybiB7c3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXJcbiAgICovXG4gIG51bWVyaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnOyAvLyBuZXZlciBzaG93IGRlY2ltYWwgcGxhY2VzIGZvciAwXG4gICAgfVxuXG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlOyAvLyBUaGlzIGlzIHVzZWQgd2hlbiB0aGVyZSBhcmUgbGVzcyB0aGFuIDIgdGlja3MgYXMgdGhlIHRpY2sgaW50ZXJ2YWwuXG5cbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgLy8gYWxsIHRpY2tzIGFyZSBzbWFsbCBvciB0aGVyZSBodWdlIG51bWJlcnM7IHVzZSBzY2llbnRpZmljIG5vdGF0aW9uXG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cblxuICAgICAgZGVsdGEgPSBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG5cbiAgICAvLyBXaGVuIGRhdGFzZXRzIGhhdmUgdmFsdWVzIGFwcHJvYWNoaW5nIE51bWJlci5NQVhfVkFMVUUsIHRoZSB0aWNrIGNhbGN1bGF0aW9ucyBtaWdodCByZXN1bHQgaW5cbiAgICAvLyBpbmZpbml0eSBhbmQgZXZlbnR1YWxseSBOYU4uIFBhc3NpbmcgTmFOIGZvciBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgb3IgbWF4aW11bUZyYWN0aW9uRGlnaXRzXG4gICAgLy8gd2lsbCBtYWtlIHRoZSBudW1iZXIgZm9ybWF0dGVyIHRocm93LiBTbyBpbnN0ZWFkIHdlIGNoZWNrIGZvciBpc05hTiBhbmQgdXNlIGEgZmFsbGJhY2sgdmFsdWUuXG4gICAgLy9cbiAgICAvLyB0b0ZpeGVkIGhhcyBhIG1heCBvZiAyMCBkZWNpbWFsIHBsYWNlc1xuICAgIGNvbnN0IG51bURlY2ltYWwgPSBpc05hTihsb2dEZWx0YSkgPyAxIDogTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7bm90YXRpb24sIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsfTtcbiAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogRm9ybWF0dGVyIGZvciBsb2dhcml0aG1pYyB0aWNrc1xuICAgKiBAbWV0aG9kIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrc1tpbmRleF0uc2lnbmlmaWNhbmQgfHwgKHRpY2tWYWx1ZSAvIChNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSkpKTtcbiAgICBpZiAoWzEsIDIsIDMsIDUsIDEwLCAxNV0uaW5jbHVkZXMocmVtYWluKSB8fCBpbmRleCA+IDAuOCAqIHRpY2tzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMubnVtZXJpYy5jYWxsKHRoaXMsIHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbn07XG5cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcykge1xuICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IGRpZ2l0cyB0byBzaG93XG4gIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBmaXJzdCB0d28gdGlja3MgbWlnaHQgYmUgc21hbGxlciB0aGFuIG5vcm1hbCBzcGFjaW5nXG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcblxuICAvLyBJZiB3ZSBoYXZlIGEgbnVtYmVyIGxpa2UgMi41IGFzIHRoZSBkZWx0YSwgZmlndXJlIG91dCBob3cgbWFueSBkZWNpbWFsIHBsYWNlcyB3ZSBuZWVkXG4gIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgIC8vIG5vdCBhbiBpbnRlZ2VyXG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG4vKipcbiAqIE5hbWVzcGFjZSB0byBob2xkIHN0YXRpYyB0aWNrIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtmb3JtYXR0ZXJzfTtcbiIsICJpbXBvcnQgVGlja3MgZnJvbSAnLi9jb3JlLnRpY2tzLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2NhbGVEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgb2Zmc2V0OiBmYWxzZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICBiZWdpbkF0WmVybzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICd0aWNrcycsXG5cbiAgICBjbGlwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb24gZ3JhY2UgYWRkZWQgdG8gbWF4IGFuZCByZWR1Y2VkIGZyb20gbWluIGRhdGEgdmFsdWUuXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICovXG4gICAgZ3JhY2U6IDAsXG5cbiAgICAvLyBncmlkIGxpbmUgc2V0dGluZ3NcbiAgICBncmlkOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgZHJhd09uQ2hhcnRBcmVhOiB0cnVlLFxuICAgICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgICAgdGlja0xlbmd0aDogOCxcbiAgICAgIHRpY2tXaWR0aDogKF9jdHgsIG9wdGlvbnMpID0+IG9wdGlvbnMubGluZVdpZHRoLFxuICAgICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgfSxcblxuICAgIGJvcmRlcjoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGRhc2g6IFtdLFxuICAgICAgZGFzaE9mZnNldDogMC4wLFxuICAgICAgd2lkdGg6IDFcbiAgICB9LFxuXG4gICAgLy8gc2NhbGUgdGl0bGVcbiAgICB0aXRsZToge1xuICAgICAgLy8gZGlzcGxheSBwcm9wZXJ0eVxuICAgICAgZGlzcGxheTogZmFsc2UsXG5cbiAgICAgIC8vIGFjdHVhbCBsYWJlbFxuICAgICAgdGV4dDogJycsXG5cbiAgICAgIC8vIHRvcC9ib3R0b20gcGFkZGluZ1xuICAgICAgcGFkZGluZzoge1xuICAgICAgICB0b3A6IDQsXG4gICAgICAgIGJvdHRvbTogNFxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgcGFkZGluZzogMyxcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgLy8gV2UgcGFzcyB0aHJvdWdoIGFycmF5cyB0byBiZSByZW5kZXJlZCBhcyBtdWx0aWxpbmUgbGFiZWxzLCB3ZSBjb252ZXJ0IE90aGVycyB0byBzdHJpbmdzIGhlcmUuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy52YWx1ZXMsXG4gICAgICBtaW5vcjoge30sXG4gICAgICBtYWpvcjoge30sXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICBjcm9zc0FsaWduOiAnbmVhcicsXG5cbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiBmYWxzZSxcbiAgICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICB9XG4gIH0pO1xuXG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aWNrcycsICdjb2xvcicsICcnLCAnY29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ib3JkZXInLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gIGRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUnLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICAgIF9mYWxsYmFjazogJ3NjYWxlJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG4gIH0pO1xufVxuIiwgImltcG9ydCB7Z2V0SG92ZXJDb2xvcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbG9yLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthcHBseUFuaW1hdGlvbnNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseUxheW91dHNEZWZhdWx0c30gZnJvbSAnLi9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHthcHBseVNjYWxlRGVmYXVsdHN9IGZyb20gJy4vY29yZS5zY2FsZS5kZWZhdWx0cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0IGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTY29wZShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsICcnKSwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdHMge1xuICBjb25zdHJ1Y3RvcihfZGVzY3JpcHRvcnMsIF9hcHBsaWVycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcblxuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgICB0aGlzLmFwcGx5KF9hcHBsaWVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIHNldChzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVcblx0ICovXG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSh0aGlzLCBzY29wZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBzY29wZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlc11cblx0ICovXG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIG92ZXJyaWRlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cblxuICAvKipcblx0ICogUm91dGVzIHRoZSBuYW1lZCBkZWZhdWx0cyB0byBmYWxsYmFjayB0byBhbm90aGVyIHNjb3BlL25hbWUuXG5cdCAqIFRoaXMgcm91dGluZyBpcyB1c2VmdWwgd2hlbiB0aG9zZSB0YXJnZXQgdmFsdWVzLCBsaWtlIGRlZmF1bHRzLmNvbG9yLCBhcmUgY2hhbmdlZCBydW50aW1lLlxuXHQgKiBJZiB0aGUgdmFsdWVzIHdvdWxkIGJlIGNvcGllZCwgdGhlIHJ1bnRpbWUgY2hhbmdlIHdvdWxkIG5vdCB0YWtlIGVmZmVjdC4gQnkgcm91dGluZywgdGhlXG5cdCAqIGZhbGxiYWNrIGlzIGV2YWx1YXRlZCBhdCBlYWNoIGFjY2Vzcywgc28gaXRzIGFsd2F5cyB1cCB0byBkYXRlLlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKlxuXHQgKiBcdGRlZmF1bHRzLnJvdXRlKCdlbGVtZW50cy5hcmMnLCAnYmFja2dyb3VuZENvbG9yJywgJycsICdjb2xvcicpXG5cdCAqICAgLSByZWFkcyB0aGUgYmFja2dyb3VuZENvbG9yIGZyb20gZGVmYXVsdHMuY29sb3Igd2hlbiB1bmRlZmluZWQgbG9jYWxseVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGUgU2NvcGUgdGhpcyByb3V0ZSBhcHBsaWVzIHRvLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBQcm9wZXJ0eSBuYW1lIHRoYXQgc2hvdWxkIGJlIHJvdXRlZCB0byBkaWZmZXJlbnQgbmFtZXNwYWNlIHdoZW4gbm90IGRlZmluZWQgaGVyZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldFNjb3BlIFRoZSBuYW1lc3BhY2Ugd2hlcmUgdGhvc2UgcHJvcGVydGllcyBzaG91bGQgYmUgcm91dGVkIHRvLlxuXHQgKiBFbXB0eSBzdHJpbmcgKCcnKSBpcyB0aGUgcm9vdCBvZiBkZWZhdWx0cy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldE5hbWUgVGhlIHRhcmdldCBuYW1lIGluIHRoZSB0YXJnZXQgc2NvcGUgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqL1xuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzY29wZU9iamVjdCwge1xuICAgICAgLy8gQSBwcml2YXRlIHByb3BlcnR5IGlzIGRlZmluZWQgdG8gaG9sZCB0aGUgYWN0dWFsIHZhbHVlLCB3aGVuIHRoaXMgcHJvcGVydHkgaXMgc2V0IGluIGl0cyBzY29wZSAoc2V0IGluIHRoZSBzZXR0ZXIpXG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICAvLyBUaGUgYWN0dWFsIHByb3BlcnR5IGlzIGRlZmluZWQgYXMgZ2V0dGVyL3NldHRlciBzbyB3ZSBjYW4gZG8gdGhlIHJvdXRpbmcgd2hlbiB2YWx1ZSBpcyBub3QgbG9jYWxseSBzZXQuXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5KGFwcGxpZXJzKSB7XG4gICAgYXBwbGllcnMuZm9yRWFjaCgoYXBwbHkpID0+IGFwcGx5KHRoaXMpKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0sIFthcHBseUFuaW1hdGlvbnNEZWZhdWx0cywgYXBwbHlMYXlvdXRzRGVmYXVsdHMsIGFwcGx5U2NhbGVEZWZhdWx0c10pO1xuIiwgImltcG9ydCB0eXBlIHtcbiAgQ2hhcnQsXG4gIFBvaW50LFxuICBGb250U3BlYyxcbiAgQ2FudmFzRm9udFNwZWMsXG4gIFBvaW50U3R5bGUsXG4gIFJlbmRlclRleHRPcHRzLFxuICBCYWNrZHJvcE9wdGlvbnNcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBUUkJMLFxuICBTcGxpbmVQb2ludCxcbiAgUm91bmRlZFJlY3QsXG4gIFRSQkxDb3JuZXJzXG59IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7UEksIFRBVSwgSEFMRl9QSSwgUVVBUlRFUl9QSSwgVFdPX1RISVJEU19QSSwgUkFEX1BFUl9ERUd9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gZm9udCBvYmplY3QgaW50byBhIENTUyBmb250IHN0cmluZy5cbiAqIEBwYXJhbSBmb250IC0gQSBmb250IG9iamVjdC5cbiAqIEByZXR1cm4gVGhlIENTUyBmb250IHN0cmluZy4gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQ6IEZvbnRTcGVjKSB7XG4gIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9tZWFzdXJlVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gIGdjOiBzdHJpbmdbXSxcbiAgbG9uZ2VzdDogbnVtYmVyLFxuICBzdHJpbmc6IHN0cmluZ1xuKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxudHlwZSBUaGluZyA9IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGxcbnR5cGUgVGhpbmdzID0gKFRoaW5nIHwgVGhpbmdbXSlbXVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gX2xvbmdlc3RUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZm9udDogc3RyaW5nLFxuICBhcnJheU9mVGhpbmdzOiBUaGluZ3MsXG4gIGNhY2hlPzoge2RhdGE/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBnYXJiYWdlQ29sbGVjdD86IHN0cmluZ1tdLCBmb250Pzogc3RyaW5nfVxuKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG5cbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGk6IG51bWJlciwgajogbnVtYmVyLCBqbGVuOiBudW1iZXIsIHRoaW5nOiBUaGluZyB8IFRoaW5nW10sIG5lc3RlZFRoaW5nOiBUaGluZyB8IFRoaW5nW107XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyBpKyspIHtcbiAgICB0aGluZyA9IGFycmF5T2ZUaGluZ3NbaV07XG5cbiAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheSh0aGluZykpIHtcbiAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgdGhpbmcpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgIC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSB0aGluZy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuICogQHBhcmFtIGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuICogQHBhcmFtIHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0OiBDaGFydCwgcGl4ZWw6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cblxuLyoqXG4gKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXM/OiBIVE1MQ2FudmFzRWxlbWVudCwgY3R4PzogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XG4gIGlmICghY3R4ICYmICFjYW52YXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgY3R4LnNhdmUoKTtcbiAgLy8gY2FudmFzLndpZHRoIGFuZCBjYW52YXMuaGVpZ2h0IGRvIG5vdCBjb25zaWRlciB0aGUgY2FudmFzIHRyYW5zZm9ybSxcbiAgLy8gd2hpbGUgY2xlYXJSZWN0IGRvZXNcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEcmF3UG9pbnRPcHRpb25zIHtcbiAgcG9pbnRTdHlsZTogUG9pbnRTdHlsZTtcbiAgcm90YXRpb24/OiBudW1iZXI7XG4gIHJhZGl1czogbnVtYmVyO1xuICBib3JkZXJXaWR0aDogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd1BvaW50KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgb3B0aW9uczogRHJhd1BvaW50T3B0aW9ucyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXJcbikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIG51bGwpO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdQb2ludExlZ2VuZChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIG9wdGlvbnM6IERyYXdQb2ludE9wdGlvbnMsXG4gIHg6IG51bWJlcixcbiAgeTogbnVtYmVyLFxuICB3OiBudW1iZXJcbikge1xuICBsZXQgdHlwZTogc3RyaW5nLCB4T2Zmc2V0OiBudW1iZXIsIHlPZmZzZXQ6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBjb3JuZXJSYWRpdXM6IG51bWJlciwgd2lkdGg6IG51bWJlciwgeE9mZnNldFc6IG51bWJlciwgeU9mZnNldFc6IG51bWJlcjtcbiAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnBvaW50U3R5bGU7XG4gIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gIGxldCByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcblxuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgLy8gRGVmYXVsdCBpbmNsdWRlcyBjaXJjbGVcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHcpIHtcbiAgICAgICAgY3R4LmVsbGlwc2UoeCwgeSwgdyAvIDIsIHJhZGl1cywgMCwgMCwgVEFVKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndHJpYW5nbGUnOlxuICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiByYWRpdXM7XG4gICAgICBjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIC8vIE5PVEU6IHRoZSByb3VuZGVkIHJlY3QgaW1wbGVtZW50YXRpb24gY2hhbmdlZCB0byB1c2UgYGFyY2AgaW5zdGVhZCBvZlxuICAgIC8vIGBxdWFkcmF0aWNDdXJ2ZVRvYCBzaW5jZSBpdCBnZW5lcmF0ZXMgYmV0dGVyIHJlc3VsdHMgd2hlbiByZWN0IGlzXG4gICAgLy8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuICAgIC8vIGNsb3NlciBwcm9wb3J0aW9uIHRvIHRoZSBwcmV2aW91cyBpbXBsIGFuZCBpdCBpcyBpbnNjcmliZWQgaW4gdGhlXG4gICAgLy8gY2lyY2xlIHdpdGggYHJhZGl1c2AuIEZvciBtb3JlIGRldGFpbHMsIHNlZSB0aGUgZm9sbG93aW5nIFBSczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81ODU4XG4gICAgICBjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcbiAgICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqICh3ID8gdyAvIDIgLSBjb3JuZXJSYWRpdXMgOiBzaXplKTtcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgY3R4LmFyYyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMoeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgICAgY3R4LmFyYyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmVjdCc6XG4gICAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICAgIHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG4gICAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogc2l6ZTtcbiAgICAgICAgY3R4LnJlY3QoeCAtIHdpZHRoLCB5IC0gc2l6ZSwgMiAqIHdpZHRoLCAyICogc2l6ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgJ3JlY3RSb3QnOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY3Jvc3NSb3QnOlxuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N0YXInOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsaW5lJzpcbiAgICAgIHhPZmZzZXQgPSB3ID8gdyAvIDIgOiBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkYXNoJzpcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyksIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZmFsc2U6XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGN0eC5maWxsKCk7XG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBwb2ludCAtIFRoZSBwb2ludCB0byB0ZXN0XG4gKiBAcGFyYW0gYXJlYSAtIFRoZSByZWN0YW5nbGVcbiAqIEBwYXJhbSBtYXJnaW4gLSBhbGxvd2VkIG1hcmdpblxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc1BvaW50SW5BcmVhKFxuICBwb2ludDogUG9pbnQsXG4gIGFyZWE6IFRSQkwsXG4gIG1hcmdpbj86IG51bWJlclxuKSB7XG4gIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7IC8vIG1hcmdpbiAtIGRlZmF1bHQgaXMgdG8gbWF0Y2ggcm91bmRlZCBkZWNpbWFsc1xuXG4gIHJldHVybiAhYXJlYSB8fCAocG9pbnQgJiYgcG9pbnQueCA+IGFyZWEubGVmdCAtIG1hcmdpbiAmJiBwb2ludC54IDwgYXJlYS5yaWdodCArIG1hcmdpbiAmJlxuXHRcdHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW4pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpcEFyZWEoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IFRSQkwpIHtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuY2xpcEFyZWEoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3N0ZXBwZWRMaW5lVG8oXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBwcmV2aW91czogUG9pbnQsXG4gIHRhcmdldDogUG9pbnQsXG4gIGZsaXA/OiBib29sZWFuLFxuICBtb2RlPzogc3RyaW5nXG4pIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdtaWRkbGUnKSB7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCBwcmV2aW91cy55KTtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCB0YXJnZXQueSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FmdGVyJyAhPT0gISFmbGlwKSB7XG4gICAgY3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHByZXZpb3VzOiBTcGxpbmVQb2ludCxcbiAgdGFyZ2V0OiBTcGxpbmVQb2ludCxcbiAgZmxpcD86IGJvb2xlYW5cbikge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBjdHguYmV6aWVyQ3VydmVUbyhcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeCA6IHByZXZpb3VzLmNwMngsXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeCA6IHRhcmdldC5jcDF4LFxuICAgIGZsaXAgPyB0YXJnZXQuY3AyeSA6IHRhcmdldC5jcDF5LFxuICAgIHRhcmdldC54LFxuICAgIHRhcmdldC55KTtcbn1cblxuZnVuY3Rpb24gc2V0UmVuZGVyT3B0cyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3B0czogUmVuZGVyVGV4dE9wdHMpIHtcbiAgaWYgKG9wdHMudHJhbnNsYXRpb24pIHtcbiAgICBjdHgudHJhbnNsYXRlKG9wdHMudHJhbnNsYXRpb25bMF0sIG9wdHMudHJhbnNsYXRpb25bMV0pO1xuICB9XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMucm90YXRpb24pKSB7XG4gICAgY3R4LnJvdGF0ZShvcHRzLnJvdGF0aW9uKTtcbiAgfVxuXG4gIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gIH1cblxuICBpZiAob3B0cy50ZXh0QWxpZ24pIHtcbiAgICBjdHgudGV4dEFsaWduID0gb3B0cy50ZXh0QWxpZ247XG4gIH1cblxuICBpZiAob3B0cy50ZXh0QmFzZWxpbmUpIHtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0cy50ZXh0QmFzZWxpbmU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVjb3JhdGVUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGxpbmU6IHN0cmluZyxcbiAgb3B0czogUmVuZGVyVGV4dE9wdHNcbikge1xuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgLyoqXG4gICAgICogTm93IHRoYXQgSUUxMSBzdXBwb3J0IGhhcyBiZWVuIGRyb3BwZWQsIHdlIGNhbiB1c2UgbW9yZVxuICAgICAqIG9mIHRoZSBUZXh0TWV0cmljcyBvYmplY3QuIFRoZSBhY3R1YWwgYm91bmRpbmcgYm94ZXNcbiAgICAgKiBhcmUgdW5mbGFnZ2VkIGluIENocm9tZSwgRmlyZWZveCwgRWRnZSwgYW5kIFNhZmFyaSBzbyB0aGV5XG4gICAgICogY2FuIGJlIHNhZmVseSB1c2VkLlxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dE1ldHJpY3MjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gICAgICovXG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcbiAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICBjdHgubW92ZVRvKGxlZnQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHgubGluZVRvKHJpZ2h0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdCYWNrZHJvcChjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3B0czogQmFja2Ryb3BPcHRpb25zKSB7XG4gIGNvbnN0IG9sZENvbG9yID0gY3R4LmZpbGxTdHlsZTtcblxuICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvciBhcyBzdHJpbmc7XG4gIGN0eC5maWxsUmVjdChvcHRzLmxlZnQsIG9wdHMudG9wLCBvcHRzLndpZHRoLCBvcHRzLmhlaWdodCk7XG4gIGN0eC5maWxsU3R5bGUgPSBvbGRDb2xvcjtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGV4dCBvbnRvIHRoZSBjYW52YXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICB0ZXh0OiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGZvbnQ6IENhbnZhc0ZvbnRTcGVjLFxuICBvcHRzOiBSZW5kZXJUZXh0T3B0cyA9IHt9XG4pIHtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KHRleHQpID8gdGV4dCA6IFt0ZXh0XTtcbiAgY29uc3Qgc3Ryb2tlID0gb3B0cy5zdHJva2VXaWR0aCA+IDAgJiYgb3B0cy5zdHJva2VDb2xvciAhPT0gJyc7XG4gIGxldCBpOiBudW1iZXIsIGxpbmU6IHN0cmluZztcblxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuICBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cyk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgaWYgKG9wdHMuYmFja2Ryb3ApIHtcbiAgICAgIGRyYXdCYWNrZHJvcChjdHgsIG9wdHMuYmFja2Ryb3ApO1xuICAgIH1cblxuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGlmIChvcHRzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnN0cm9rZVdpZHRoKSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpO1xuXG4gICAgeSArPSBOdW1iZXIoZm9udC5saW5lSGVpZ2h0KTtcbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbi8qKlxuICogQWRkIGEgcGF0aCBvZiBhIHJlY3RhbmdsZSB3aXRoIHJvdW5kZWQgY29ybmVycyB0byB0aGUgY3VycmVudCBzdWItcGF0aFxuICogQHBhcmFtIGN0eCAtIENvbnRleHRcbiAqIEBwYXJhbSByZWN0IC0gQm91bmRpbmcgcmVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcmVjdDogUm91bmRlZFJlY3QgJiB7IHJhZGl1czogVFJCTENvcm5lcnMgfVxuKSB7XG4gIGNvbnN0IHt4LCB5LCB3LCBoLCByYWRpdXN9ID0gcmVjdDtcblxuICAvLyB0b3AgbGVmdCBhcmNcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIDEuNSAqIFBJLCBQSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIHRvcCBsZWZ0IHRvIGJvdHRvbSBsZWZ0XG4gIGN0eC5saW5lVG8oeCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCk7XG5cbiAgLy8gYm90dG9tIGxlZnQgYXJjXG4gIGN0eC5hcmMoeCArIHJhZGl1cy5ib3R0b21MZWZ0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0LCByYWRpdXMuYm90dG9tTGVmdCwgUEksIEhBTEZfUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSBib3R0b20gbGVmdCB0byBib3R0b20gcmlnaHRcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuXG4gIC8vIGJvdHRvbSByaWdodCBhcmNcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGggLSByYWRpdXMuYm90dG9tUmlnaHQsIHJhZGl1cy5ib3R0b21SaWdodCwgSEFMRl9QSSwgMCwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIGJvdHRvbSByaWdodCB0byB0b3AgcmlnaHRcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG5cbiAgLy8gdG9wIHJpZ2h0IGFyY1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gdG9wIHJpZ2h0IHRvIHRvcCBsZWZ0XG4gIGN0eC5saW5lVG8oeCArIHJhZGl1cy50b3BMZWZ0LCB5KTtcbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3QsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnRTdHJpbmd9IGZyb20gJy4vaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0QXJlYSwgRm9udFNwZWMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7VFJCTCwgVFJCTENvcm5lcnN9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC87XG5jb25zdCBGT05UX1NUWUxFID0gL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC87XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMub3B0aW9uc1xuICogQG5hbWVzcGFjZVxuICovXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBsaW5lIGhlaWdodCBgdmFsdWVgIGluIHBpeGVscyBmb3IgYSBzcGVjaWZpYyBmb250IGBzaXplYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBsaW5lSGVpZ2h0IHRvIHBhcnNlIChlZy4gMS42LCAnMTRweCcsICc3NSUnLCAnMS42ZW0nKS5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIGZvbnQgc2l6ZSAoaW4gcGl4ZWxzKSB1c2VkIHRvIHJlc29sdmUgcmVsYXRpdmUgYHZhbHVlYC5cbiAqIEByZXR1cm5zIFRoZSBlZmZlY3RpdmUgbGluZSBoZWlnaHQgaW4gcGl4ZWxzIChzaXplICogMS4yIGlmIHZhbHVlIGlzIGludmFsaWQpLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvbGluZS1oZWlnaHRcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIHNpemU6IG51bWJlcik6IG51bWJlciB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuXG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG5cbiAgc3dpdGNoIChtYXRjaGVzWzNdKSB7XG4gICAgY2FzZSAncHgnOlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGNhc2UgJyUnOlxuICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cblxuY29uc3QgbnVtYmVyT3JaZXJvID0gKHY6IHVua25vd24pID0+ICt2IHx8IDA7XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcGFyYW0gcHJvcHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SywgbnVtYmVyPiwgcHJvcHM6IEtbXSk6IFJlY29yZDxLLCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzPEsgZXh0ZW5kcyBzdHJpbmcsIFQgZXh0ZW5kcyBzdHJpbmc+KHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8SyAmIFQsIG51bWJlcj4sIHByb3BzOiBSZWNvcmQ8VCwgSz4pOiBSZWNvcmQ8VCwgbnVtYmVyPjtcbmV4cG9ydCBmdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZTogbnVtYmVyIHwgUmVjb3JkPHN0cmluZywgbnVtYmVyPiwgcHJvcHM6IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nPikge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBrZXlzKSB7XG4gICAgcmV0W3Byb3BdID0gbnVtYmVyT3JaZXJvKHJlYWQocHJvcCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkwodmFsdWU6IG51bWJlciB8IFRSQkwgfCBQb2ludCkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBjb3JuZXJzIG9iamVjdCAoc2ltaWxhciB3aXRoIGNzcyBib3JkZXItcmFkaXVzKS5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvcm5lciBjb21wb25lbnRzLFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogQHJldHVybnMgVGhlIFRSQkwgY29ybmVyIHZhbHVlcyAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxuICogQHNpbmNlIDMuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlOiBudW1iZXIgfCBUUkJMQ29ybmVycykge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgcGFkZGluZyBvYmplY3Qgd2l0aCBwcmUtY29tcHV0ZWQgd2lkdGgvaGVpZ2h0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQpXG4gKiBAc2luY2UgMi43LjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUGFkZGluZyh2YWx1ZT86IG51bWJlciB8IFRSQkwpOiBDaGFydEFyZWEge1xuICBjb25zdCBvYmogPSB0b1RSQkwodmFsdWUpIGFzIENoYXJ0QXJlYTtcblxuICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgb2JqLmhlaWdodCA9IG9iai50b3AgKyBvYmouYm90dG9tO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSBmYWxsYmFjayAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZmFsbGJhY2sgZm9udCBvcHRpb25zLlxuICogQHJldHVybiBUaGUgZm9udCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnQob3B0aW9uczogUGFydGlhbDxGb250U3BlYz4sIGZhbGxiYWNrPzogUGFydGlhbDxGb250U3BlYz4pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udCBhcyBGb250U3BlYztcblxuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG5cbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHNpemUgPSBwYXJzZUludChzaXplLCAxMCk7XG4gIH1cbiAgbGV0IHN0eWxlID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zdHlsZSwgZmFsbGJhY2suc3R5bGUpO1xuICBpZiAoc3R5bGUgJiYgISgnJyArIHN0eWxlKS5tYXRjaChGT05UX1NUWUxFKSkge1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCBmb250IHN0eWxlIHNwZWNpZmllZDogXCInICsgc3R5bGUgKyAnXCInKTtcbiAgICBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB7XG4gICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICBsaW5lSGVpZ2h0OiB0b0xpbmVIZWlnaHQodmFsdWVPckRlZmF1bHQob3B0aW9ucy5saW5lSGVpZ2h0LCBmYWxsYmFjay5saW5lSGVpZ2h0KSwgc2l6ZSksXG4gICAgc2l6ZSxcbiAgICBzdHlsZSxcbiAgICB3ZWlnaHQ6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMud2VpZ2h0LCBmYWxsYmFjay53ZWlnaHQpLFxuICAgIHN0cmluZzogJydcbiAgfTtcblxuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5cbi8qKlxuICogRXZhbHVhdGVzIHRoZSBnaXZlbiBgaW5wdXRzYCBzZXF1ZW50aWFsbHkgYW5kIHJldHVybnMgdGhlIGZpcnN0IGRlZmluZWQgdmFsdWUuXG4gKiBAcGFyYW0gaW5wdXRzIC0gQW4gYXJyYXkgb2YgdmFsdWVzLCBmYWxsaW5nIGJhY2sgdG8gdGhlIGxhc3QgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGEgZnVuY3Rpb24sIHRoZSB2YWx1ZVxuICogaXMgY2FsbGVkIHdpdGggYGNvbnRleHRgIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGUgcmVzdWx0IGJlY29tZXMgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmRleCAtIElmIGRlZmluZWQgYW5kIHRoZSBjdXJyZW50IHZhbHVlIGlzIGFuIGFycmF5LCB0aGUgdmFsdWVcbiAqIGF0IGBpbmRleGAgYmVjb21lIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5mbyAtIG9iamVjdCB0byByZXR1cm4gaW5mb3JtYXRpb24gYWJvdXQgcmVzb2x1dGlvbiBpblxuICogQHBhcmFtIGluZm8uY2FjaGVhYmxlIC0gV2lsbCBiZSBzZXQgdG8gYGZhbHNlYCBpZiBvcHRpb24gaXMgbm90IGNhY2hlYWJsZS5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZShpbnB1dHM6IEFycmF5PHVua25vd24+LCBjb250ZXh0Pzogb2JqZWN0LCBpbmRleD86IG51bWJlciwgaW5mbz86IHsgY2FjaGVhYmxlOiBib29sZWFuIH0pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgdmFsdWU6IHVua25vd247XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBtaW5tYXhcbiAqIEBwYXJhbSBncmFjZVxuICogQHBhcmFtIGJlZ2luQXRaZXJvXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heDogeyBtaW46IG51bWJlcjsgbWF4OiBudW1iZXI7IH0sIGdyYWNlOiBudW1iZXIgfCBzdHJpbmcsIGJlZ2luQXRaZXJvOiBib29sZWFuKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZTogbnVtYmVyLCBhZGQ6IG51bWJlcikgPT4gYmVnaW5BdFplcm8gJiYgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUgKyBhZGQ7XG4gIHJldHVybiB7XG4gICAgbWluOiBrZWVwWmVybyhtaW4sIC1NYXRoLmFicyhjaGFuZ2UpKSxcbiAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNvbnRleHQgaW5oZXJpdGluZyBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gcGFyZW50Q29udGV4dFxuICogQHBhcmFtIGNvbnRleHRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0PFQgZXh0ZW5kcyBvYmplY3Q+KHBhcmVudENvbnRleHQ6IG51bGwsIGNvbnRleHQ6IFQpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdCwgUCBleHRlbmRzIFQ+KHBhcmVudENvbnRleHQ6IFAsIGNvbnRleHQ6IFQpOiBQICYgVDtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQ6IG9iamVjdCwgY29udGV4dDogb2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocGFyZW50Q29udGV4dCksIGNvbnRleHQpO1xufVxuIiwgIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0TWV0YX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge1xuICBSZXNvbHZlck9iamVjdEtleSxcbiAgUmVzb2x2ZXJDYWNoZSxcbiAgUmVzb2x2ZXJQcm94eSxcbiAgRGVzY3JpcHRvckRlZmF1bHRzLFxuICBEZXNjcmlwdG9yLFxuICBDb250ZXh0Q2FjaGUsXG4gIENvbnRleHRQcm94eVxufSBmcm9tICcuL2hlbHBlcnMuY29uZmlnLnR5cGVzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIHJlc29sdmVPYmplY3RLZXksIF9jYXBpdGFsaXplfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCAqIGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm94eSBmb3IgcmVzb2x2aW5nIHJhdyB2YWx1ZXMgZm9yIG9wdGlvbnMuXG4gKiBAcGFyYW0gc2NvcGVzIC0gVGhlIG9wdGlvbiBzY29wZXMgdG8gbG9vayBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyXG4gKiBAcGFyYW0gcHJlZml4ZXMgLSBUaGUgcHJlZml4ZXMgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlci5cbiAqIEBwYXJhbSByb290U2NvcGVzIC0gVGhlIHJvb3Qgb3B0aW9uIHNjb3Blc1xuICogQHBhcmFtIGZhbGxiYWNrIC0gUGFyZW50IHNjb3BlcyBmYWxsYmFja1xuICogQHBhcmFtIGdldFRhcmdldCAtIGNhbGxiYWNrIGZvciBnZXR0aW5nIHRoZSB0YXJnZXQgZm9yIGNoYW5nZWQgdmFsdWVzXG4gKiBAcmV0dXJucyBQcm94eVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcjxcbiAgVCBleHRlbmRzIEFueU9iamVjdFtdID0gQW55T2JqZWN0W10sXG4gIFIgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IFRcbj4oXG4gIHNjb3BlczogVCxcbiAgcHJlZml4ZXMgPSBbJyddLFxuICByb290U2NvcGVzPzogUixcbiAgZmFsbGJhY2s/OiBSZXNvbHZlck9iamVjdEtleSxcbiAgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdXG4pIHtcbiAgY29uc3QgZmluYWxSb290U2NvcGVzID0gcm9vdFNjb3BlcyB8fCBzY29wZXM7XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgfVxuICBjb25zdCBjYWNoZTogUmVzb2x2ZXJDYWNoZTxULCBSPiA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ09iamVjdCcsXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgX3Jvb3RTY29wZXM6IGZpbmFsUm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlOiBBbnlPYmplY3QpID0+IF9jcmVhdGVSZXNvbHZlcihbc2NvcGUsIC4uLnNjb3Blc10sIHByZWZpeGVzLCBmaW5hbFJvb3RTY29wZXMsIGZhbGxiYWNrKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gdG9wIGxldmVsIHNjb3BlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGVzWzBdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICovXG4gICAgaGFzKHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KS5pbmNsdWRlcyhwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyBhbmQgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scy5cbiAgICAgKi9cbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3Igc2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0KHRhcmdldCwgcHJvcDogc3RyaW5nLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gdG9wIGxldmVsIHNjb3BlICsgY2FjaGVcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSBhcyBSZXNvbHZlclByb3h5PFQsIFI+O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gUHJveHkgZm9yIHJlc29sdmluZyBvcHRpb24gdmFsdWVzIHdpdGggY29udGV4dC5cbiAqIEBwYXJhbSBwcm94eSAtIFRoZSBQcm94eSByZXR1cm5lZCBieSBgX2NyZWF0ZVJlc29sdmVyYFxuICogQHBhcmFtIGNvbnRleHQgLSBDb250ZXh0IG9iamVjdCBmb3Igc2NyaXB0YWJsZS9pbmRleGFibGUgb3B0aW9uc1xuICogQHBhcmFtIHN1YlByb3h5IC0gVGhlIHByb3h5IHByb3ZpZGVkIGZvciBzY3JpcHRhYmxlIG9wdGlvbnNcbiAqIEBwYXJhbSBkZXNjcmlwdG9yRGVmYXVsdHMgLSBEZWZhdWx0cyBmb3IgZGVzY3JpcHRvcnNcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXR0YWNoQ29udGV4dDxcbiAgVCBleHRlbmRzIEFueU9iamVjdFtdID0gQW55T2JqZWN0W10sXG4gIFIgZXh0ZW5kcyBBbnlPYmplY3RbXSA9IFRcbj4oXG4gIHByb3h5OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBjb250ZXh0OiBBbnlPYmplY3QsXG4gIHN1YlByb3h5PzogUmVzb2x2ZXJQcm94eTxULCBSPixcbiAgZGVzY3JpcHRvckRlZmF1bHRzPzogRGVzY3JpcHRvckRlZmF1bHRzXG4pIHtcbiAgY29uc3QgY2FjaGU6IENvbnRleHRDYWNoZTxULCBSPiA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eDogQW55T2JqZWN0KSA9PiBfYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBvdmVycmlkZTogKHNjb3BlOiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICBkZWxldGUgcHJveHlbcHJvcF07IC8vIHJlbW92ZSBmcm9tIHByb3h5XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHJlY2VpdmVyKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgICogQWxzbyB1c2VkIGJ5IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXG4gICAgICAgID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge2VudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqL1xuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHByb3h5XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSBhcyBDb250ZXh0UHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXNjcmlwdG9ycyhcbiAgcHJveHk6IFJlc29sdmVyQ2FjaGUsXG4gIGRlZmF1bHRzOiBEZXNjcmlwdG9yRGVmYXVsdHMgPSB7c2NyaXB0YWJsZTogdHJ1ZSwgaW5kZXhhYmxlOiB0cnVlfVxuKTogRGVzY3JpcHRvciB7XG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBfYWxsS2V5cyxcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgaXNTY3JpcHRhYmxlOiBpc0Z1bmN0aW9uKF9zY3JpcHRhYmxlKSA/IF9zY3JpcHRhYmxlIDogKCkgPT4gX3NjcmlwdGFibGUsXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxuICB9O1xufVxuXG5jb25zdCByZWFkS2V5ID0gKHByZWZpeDogc3RyaW5nLCBuYW1lOiBzdHJpbmcpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbmNvbnN0IG5lZWRzU3ViUmVzb2x2ZXIgPSAocHJvcDogc3RyaW5nLCB2YWx1ZTogdW5rbm93bikgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5cbmZ1bmN0aW9uIF9jYWNoZWQoXG4gIHRhcmdldDogQW55T2JqZWN0LFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlc29sdmU6ICgpID0+IHVua25vd25cbikge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkgfHwgcHJvcCA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgLy8gY2FjaGUgdGhlIHJlc29sdmVkIHZhbHVlXG4gIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQoXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHJlY2VpdmVyOiBBbnlPYmplY3Rcbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdOyAvLyByZXNvbHZlIGZyb20gcHJveHlcblxuICAvLyByZXNvbHZlIHdpdGggY29udGV4dFxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIC8vIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGNyZWF0ZSBhIHN1YiByZXNvbHZlciBmb3IgaXRcbiAgICB2YWx1ZSA9IF9hdHRhY2hDb250ZXh0KHZhbHVlLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKFxuICBwcm9wOiBzdHJpbmcsXG4gIGdldFZhbHVlOiAoY3R4OiBBbnlPYmplY3QsIHN1YjogQW55T2JqZWN0KSA9PiB1bmtub3duLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShfY29udGV4dCwgX3N1YlByb3h5IHx8IHJlY2VpdmVyKTtcbiAgX3N0YWNrLmRlbGV0ZShwcm9wKTtcbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gV2hlbiBzY3JpcHRhYmxlIG9wdGlvbiByZXR1cm5zIGFuIG9iamVjdCwgY3JlYXRlIGEgcmVzb2x2ZXIgb24gdGhhdC5cbiAgICB2YWx1ZSA9IGNyZWF0ZVN1YlJlc29sdmVyKF9wcm94eS5fc2NvcGVzLCBfcHJveHksIHByb3AsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkoXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25bXSxcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIGlzSW5kZXhhYmxlOiAoa2V5OiBzdHJpbmcpID0+IGJvb2xlYW5cbikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcblxuICBpZiAodHlwZW9mIF9jb250ZXh0LmluZGV4ICE9PSAndW5kZWZpbmVkJyAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHJldHVybiB2YWx1ZVtfY29udGV4dC5pbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWVbMF0pKSB7XG4gICAgLy8gQXJyYXkgb2Ygb2JqZWN0cywgcmV0dXJuIGFycmF5IG9yIHJlc29sdmVyc1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVGYWxsYmFjayhcbiAgZmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5IHwgKChwcm9wOiBSZXNvbHZlck9iamVjdEtleSwgdmFsdWU6IHVua25vd24pID0+IFJlc29sdmVyT2JqZWN0S2V5KSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oZmFsbGJhY2spID8gZmFsbGJhY2socHJvcCwgdmFsdWUpIDogZmFsbGJhY2s7XG59XG5cbmNvbnN0IGdldFNjb3BlID0gKGtleTogUmVzb2x2ZXJPYmplY3RLZXksIHBhcmVudDogQW55T2JqZWN0KSA9PiBrZXkgPT09IHRydWUgPyBwYXJlbnRcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBhZGRTY29wZXMoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHBhcmVudEZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRTY29wZXMpIHtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgcmVhY2ggdGhlIGRlc2NyaXB0b3IgdGhhdCBkZWZpbmVzIGEgbmV3IF9mYWxsYmFjaywgcmV0dXJuIHRoYXQuXG4gICAgICAgIC8vIFRoZSBmYWxsYmFjayB3aWxsIHJlc3VtZSB0byB0aGF0IG5ldyBzY29wZS5cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IGZhbHNlICYmIHR5cGVvZiBwYXJlbnRGYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5ICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gYGZhbHNlYCByZXN1bHRzIHRvIGBmYWxzZWAsIHdoZW4gZmFsbGluZyBiYWNrIHRvIGRpZmZlcmVudCBrZXkuXG4gICAgICAvLyBGb3IgZXhhbXBsZSBgaW50ZXJhY3Rpb25gIGZyb20gYGhvdmVyYCBvciBgcGx1Z2lucy50b29sdGlwYCBhbmQgYGFuaW1hdGlvbmAgZnJvbSBgYW5pbWF0aW9uc2BcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YlJlc29sdmVyKFxuICBwYXJlbnRTY29wZXM6IEFueU9iamVjdFtdLFxuICByZXNvbHZlcjogUmVzb2x2ZXJDYWNoZSxcbiAgcHJvcDogUmVzb2x2ZXJPYmplY3RLZXksXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8QW55T2JqZWN0PigpO1xuICBzZXQuYWRkKHZhbHVlKTtcbiAgbGV0IGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIHByb3AsIGZhbGxiYWNrIHx8IHByb3AsIHZhbHVlKTtcbiAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBmYWxsYmFjayAhPT0gcHJvcCkge1xuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbJyddLCByb290U2NvcGVzLCBmYWxsYmFjayxcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AgYXMgc3RyaW5nLCB2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KFxuICBzZXQ6IFNldDxBbnlPYmplY3Q+LFxuICBhbGxTY29wZXM6IEFueU9iamVjdFtdLFxuICBrZXk6IFJlc29sdmVyT2JqZWN0S2V5LFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGl0ZW06IHVua25vd25cbikge1xuICB3aGlsZSAoa2V5KSB7XG4gICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG5mdW5jdGlvbiBzdWJHZXRUYXJnZXQoXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBzdHJpbmcsXG4gIHZhbHVlOiB1bmtub3duXG4pIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgLy8gRm9yIGFycmF5IG9mIG9iamVjdHMsIHRoZSBvYmplY3QgaXMgdXNlZCB0byBzdG9yZSB1cGRhdGVkIHZhbHVlc1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0IHx8IHt9O1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhcbiAgcHJvcDogc3RyaW5nLFxuICBwcmVmaXhlczogc3RyaW5nW10sXG4gIHNjb3BlczogQW55T2JqZWN0W10sXG4gIHByb3h5OiBSZXNvbHZlclByb3h5XG4pIHtcbiAgbGV0IHZhbHVlOiB1bmtub3duO1xuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Jlc29sdmUoa2V5OiBzdHJpbmcsIHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldDogUmVzb2x2ZXJDYWNoZSkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXM6IEFueU9iamVjdFtdKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjb3BlKS5maWx0ZXIoayA9PiAhay5zdGFydHNXaXRoKCdfJykpKSB7XG4gICAgICBzZXQuYWRkKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUoXG4gIG1ldGE6IENoYXJ0TWV0YTwnbGluZScgfCAnc2NhdHRlcic+LFxuICBkYXRhOiBBbnlPYmplY3RbXSxcbiAgc3RhcnQ6IG51bWJlcixcbiAgY291bnQ6IG51bWJlclxuKSB7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge2tleSA9ICdyJ30gPSB0aGlzLl9wYXJzaW5nO1xuICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXk8e3I6IHVua25vd259Pihjb3VudCk7XG4gIGxldCBpOiBudW1iZXIsIGlsZW46IG51bWJlciwgaW5kZXg6IG51bWJlciwgaXRlbTogQW55T2JqZWN0O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICBwYXJzZWRbaV0gPSB7XG4gICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICB9O1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCAiaW1wb3J0IHthbG1vc3RFcXVhbHMsIGRpc3RhbmNlQmV0d2VlblBvaW50cywgc2lnbn0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYX0gZnJvbSAnLi9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRBcmVhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7U3BsaW5lUG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5cbmNvbnN0IEVQU0lMT04gPSBOdW1iZXIuRVBTSUxPTiB8fCAxZS0xNDtcblxudHlwZSBPcHRpb25hbFNwbGluZVBvaW50ID0gU3BsaW5lUG9pbnQgfCBmYWxzZVxuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBpOiBudW1iZXIpOiBPcHRpb25hbFNwbGluZVBvaW50ID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzOiAneCcgfCAneScpID0+IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmUoXG4gIGZpcnN0UG9pbnQ6IFNwbGluZVBvaW50LFxuICBtaWRkbGVQb2ludDogU3BsaW5lUG9pbnQsXG4gIGFmdGVyUG9pbnQ6IFNwbGluZVBvaW50LFxuICB0OiBudW1iZXJcbik6IHtcbiAgICBwcmV2aW91czogU3BsaW5lUG9pbnRcbiAgICBuZXh0OiBTcGxpbmVQb2ludFxuICB9IHtcbiAgLy8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG4gIC8vIGh0dHA6Ly9zY2FsZWRpbm5vdmF0aW9uLmNvbS9hbmFseXRpY3Mvc3BsaW5lcy9hYm91dFNwbGluZXMuaHRtbFxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBhbHNvIHJlc3BlY3QgXCJza2lwcGVkXCIgcG9pbnRzXG5cbiAgY29uc3QgcHJldmlvdXMgPSBmaXJzdFBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGZpcnN0UG9pbnQ7XG4gIGNvbnN0IGN1cnJlbnQgPSBtaWRkbGVQb2ludDtcbiAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgY29uc3QgZDAxID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGN1cnJlbnQsIHByZXZpb3VzKTtcbiAgY29uc3QgZDEyID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKG5leHQsIGN1cnJlbnQpO1xuXG4gIGxldCBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcbiAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuXG4gIC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcbiAgczAxID0gaXNOYU4oczAxKSA/IDAgOiBzMDE7XG4gIHMxMiA9IGlzTmFOKHMxMikgPyAwIDogczEyO1xuXG4gIGNvbnN0IGZhID0gdCAqIHMwMTsgLy8gc2NhbGluZyBmYWN0b3IgZm9yIHRyaWFuZ2xlIFRhXG4gIGNvbnN0IGZiID0gdCAqIHMxMjtcblxuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiB7XG4gICAgICB4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEFkanVzdCB0YW5nZW50cyB0byBlbnN1cmUgbW9ub3RvbmljIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBkZWx0YUs6IG51bWJlcltdLCBtSzogbnVtYmVyW10pIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgYWxwaGFLOiBudW1iZXIsIGJldGFLOiBudW1iZXIsIHRhdUs6IG51bWJlciwgc3F1YXJlZE1hZ25pdHVkZTogbnVtYmVyLCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICBiZXRhSyA9IG1LW2kgKyAxXSAvIGRlbHRhS1tpXTtcbiAgICBzcXVhcmVkTWFnbml0dWRlID0gTWF0aC5wb3coYWxwaGFLLCAyKSArIE1hdGgucG93KGJldGFLLCAyKTtcbiAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICBtS1tpXSA9IGFscGhhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgbUtbaSArIDFdID0gYmV0YUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHM6IFNwbGluZVBvaW50W10sIG1LOiBudW1iZXJbXSwgaW5kZXhBeGlzOiAneCcgfCAneScgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YTogbnVtYmVyLCBwb2ludEJlZm9yZTogT3B0aW9uYWxTcGxpbmVQb2ludCwgcG9pbnRDdXJyZW50OiBPcHRpb25hbFNwbGluZVBvaW50O1xuICBsZXQgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgMCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcbiAqIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcbiAqIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgZGVsdGFLOiBudW1iZXJbXSA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKTtcblxuICAvLyBDYWxjdWxhdGUgc2xvcGVzIChkZWx0YUspIGFuZCBpbml0aWFsaXplIHRhbmdlbnRzIChtSylcbiAgbGV0IGksIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGNvbnN0IHNsb3BlRGVsdGEgPSBwb2ludEFmdGVyW2luZGV4QXhpc10gLSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcblxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgICAgOiAoc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pKSA/IDBcbiAgICAgICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cblxuICBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspO1xuXG4gIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMpO1xufVxuXG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQ6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cblxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50czogU3BsaW5lUG9pbnRbXSwgYXJlYTogQ2hhcnRBcmVhKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICBsZXQgaW5BcmVhTmV4dCA9IF9pc1BvaW50SW5BcmVhKHBvaW50c1swXSwgYXJlYSk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICBpbkFyZWEgPSBpbkFyZWFOZXh0O1xuICAgIGluQXJlYU5leHQgPSBpIDwgaWxlbiAtIDEgJiYgX2lzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXSwgYXJlYSk7XG4gICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgICBpZiAoaW5BcmVhTmV4dCkge1xuICAgICAgcG9pbnQuY3AyeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AyeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhcbiAgcG9pbnRzOiBTcGxpbmVQb2ludFtdLFxuICBvcHRpb25zLFxuICBhcmVhOiBDaGFydEFyZWEsXG4gIGxvb3A6IGJvb2xlYW4sXG4gIGluZGV4QXhpczogJ3gnIHwgJ3knXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBwb2ludDogU3BsaW5lUG9pbnQsIGNvbnRyb2xQb2ludHM6IFJldHVyblR5cGU8dHlwZW9mIHNwbGluZUN1cnZlPjtcblxuICAvLyBPbmx5IGNvbnNpZGVyIHBvaW50cyB0aGF0IGFyZSBkcmF3biBpbiBjYXNlIHRoZSBzcGFuR2FwcyBvcHRpb24gaXMgdXNlZFxuICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgIHBvaW50cyA9IHBvaW50cy5maWx0ZXIoKHB0KSA9PiAhcHQuc2tpcCk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMuY2FwQmV6aWVyUG9pbnRzKSB7XG4gICAgY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBTY2FsZX0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuaW1wb3J0IHR5cGUgUHJpdmF0ZUNoYXJ0IGZyb20gJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMuanMnO1xuaW1wb3J0IHtJTkZJTklUWX0gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlOiBIVE1MQ2FudmFzRWxlbWVudCk6IEhUTUxDYW52YXNFbGVtZW50IHtcbiAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgcGFyZW50ID0gKHBhcmVudCBhcyBTaGFkb3dSb290KS5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQgYXMgSFRNTENhbnZhc0VsZW1lbnQ7XG59XG5cbi8qKlxuICogY29udmVydCBtYXgtd2lkdGgvbWF4LWhlaWdodCB2YWx1ZXMgdGhhdCBtYXkgYmUgcGVyY2VudGFnZXMgaW50byBhIG51bWJlclxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWU6IHN0cmluZyB8IG51bWJlciwgbm9kZTogSFRNTEVsZW1lbnQsIHBhcmVudFByb3BlcnR5OiBzdHJpbmcpIHtcbiAgbGV0IHZhbHVlSW5QaXhlbHM6IG51bWJlcjtcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG5cbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAvLyBwZXJjZW50YWdlICogc2l6ZSBpbiBkaW1lbnNpb25cbiAgICAgIHZhbHVlSW5QaXhlbHMgPSAodmFsdWVJblBpeGVscyAvIDEwMCkgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuXG5jb25zdCBnZXRDb21wdXRlZFN0eWxlID0gKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9PlxuICBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlKGVsOiBIVE1MRWxlbWVudCwgcHJvcGVydHk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cblxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXM6IENTU1N0eWxlRGVjbGFyYXRpb24sIHN0eWxlOiBzdHJpbmcsIHN1ZmZpeD86IHN0cmluZyk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9IGFzIENoYXJ0QXJlYTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmNvbnN0IHVzZU9mZnNldFBvcyA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgdGFyZ2V0OiBIVE1MRWxlbWVudCB8IEV2ZW50VGFyZ2V0KSA9PlxuICAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5zaGFkb3dSb290KTtcblxuLyoqXG4gKiBAcGFyYW0gZVxuICogQHBhcmFtIGNhbnZhc1xuICogQHJldHVybnMgQ2FudmFzIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKFxuICBlOiBFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50XG4pOiB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICBib3g6IGJvb2xlYW47XG4gIH0ge1xuICBjb25zdCB0b3VjaGVzID0gKGUgYXMgVG91Y2hFdmVudCkudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZSkgYXMgTW91c2VFdmVudDtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlIGFzIE1vdXNlRXZlbnQ7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5cbi8qKlxuICogR2V0cyBhbiBldmVudCdzIHgsIHkgY29vcmRpbmF0ZXMsIHJlbGF0aXZlIHRvIHRoZSBjaGFydCBhcmVhXG4gKiBAcGFyYW0gZXZlbnRcbiAqIEBwYXJhbSBjaGFydFxuICogQHJldHVybnMgeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihcbiAgZXZlbnQ6IEV2ZW50IHwgQ2hhcnRFdmVudCB8IFRvdWNoRXZlbnQgfCBNb3VzZUV2ZW50LFxuICBjaGFydDogQ2hhcnQgfCBQcml2YXRlQ2hhcnRcbik6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XG4gIGlmICgnbmF0aXZlJyBpbiBldmVudCkge1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuXG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG5cbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNoYXJ0O1xuICBpZiAoYm9yZGVyQm94KSB7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgucm91bmQoKHggLSB4T2Zmc2V0KSAvIHdpZHRoICogY2FudmFzLndpZHRoIC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pLFxuICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFBhcnRpYWw8U2NhbGU+IHtcbiAgbGV0IG1heFdpZHRoOiBudW1iZXIsIG1heEhlaWdodDogbnVtYmVyO1xuXG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gdGhpcyBpcyB0aGUgYm9yZGVyIGJveCBvZiB0aGUgY29udGFpbmVyXG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5cbmNvbnN0IHJvdW5kMSA9ICh2OiBudW1iZXIpID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1heGltdW1TaXplKFxuICBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICBiYldpZHRoPzogbnVtYmVyLFxuICBiYkhlaWdodD86IG51bWJlcixcbiAgYXNwZWN0UmF0aW8/OiBudW1iZXJcbik6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG5cbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyB3aWR0aCAvIGFzcGVjdFJhdGlvIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80NjU5XG4gICAgLy8gSWYgdGhlIGNhbnZhcyBoYXMgd2lkdGgsIGJ1dCBubyBoZWlnaHQsIGRlZmF1bHQgdG8gYXNwZWN0UmF0aW8gb2YgMiAoY2FudmFzIGRlZmF1bHQpXG4gICAgaGVpZ2h0ID0gcm91bmQxKHdpZHRoIC8gMik7XG4gIH1cblxuICBjb25zdCBtYWludGFpbkhlaWdodCA9IGJiV2lkdGggIT09IHVuZGVmaW5lZCB8fCBiYkhlaWdodCAhPT0gdW5kZWZpbmVkO1xuXG4gIGlmIChtYWludGFpbkhlaWdodCAmJiBhc3BlY3RSYXRpbyAmJiBjb250YWluZXJTaXplLmhlaWdodCAmJiBoZWlnaHQgPiBjb250YWluZXJTaXplLmhlaWdodCkge1xuICAgIGhlaWdodCA9IGNvbnRhaW5lclNpemUuaGVpZ2h0O1xuICAgIHdpZHRoID0gcm91bmQxKE1hdGguZmxvb3IoaGVpZ2h0ICogYXNwZWN0UmF0aW8pKTtcbiAgfVxuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbi8qKlxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcGFyYW0gZm9yY2VSYXRpb1xuICogQHBhcmFtIGZvcmNlU3R5bGVcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNhbnZhcyBjb250ZXh0IHNpemUgb3IgdHJhbnNmb3JtYXRpb24gaGFzIGNoYW5nZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRpbmFTY2FsZShcbiAgY2hhcnQ6IENoYXJ0IHwgUHJpdmF0ZUNoYXJ0LFxuICBmb3JjZVJhdGlvOiBudW1iZXIsXG4gIGZvcmNlU3R5bGU/OiBib29sZWFuXG4pOiBib29sZWFuIHwgdm9pZCB7XG4gIGNvbnN0IHBpeGVsUmF0aW8gPSBmb3JjZVJhdGlvIHx8IDE7XG4gIGNvbnN0IGRldmljZUhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0ICogcGl4ZWxSYXRpbyk7XG4gIGNvbnN0IGRldmljZVdpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCAqIHBpeGVsUmF0aW8pO1xuXG4gIChjaGFydCBhcyBQcml2YXRlQ2hhcnQpLmhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0KTtcbiAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkud2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoKTtcblxuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG5cbiAgLy8gSWYgbm8gc3R5bGUgaGFzIGJlZW4gc2V0IG9uIHRoZSBjYW52YXMsIHRoZSByZW5kZXIgc2l6ZSBpcyB1c2VkIGFzIGRpc3BsYXkgc2l6ZSxcbiAgLy8gbWFraW5nIHRoZSBjaGFydCB2aXN1YWxseSBiaWdnZXIsIHNvIGxldCdzIGVuZm9yY2UgaXQgdG8gdGhlIFwiY29ycmVjdFwiIHZhbHVlcy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuXG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRGV0ZWN0cyBzdXBwb3J0IGZvciBvcHRpb25zIG9iamVjdCBhcmd1bWVudCBpbiBhZGRFdmVudExpc3RlbmVyLlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSAoZnVuY3Rpb24oKSB7XG4gIGxldCBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBwYXNzaXZlKCkgeyAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgYXR0ZW1wdHMgdG8gYWNjZXNzIHRoZSBwYXNzaXZlIHByb3BlcnR5LlxuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gYXMgRXZlbnRMaXN0ZW5lck9wdGlvbnM7XG5cbiAgICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5cbi8qKlxuICogVGhlIFwidXNlZFwiIHNpemUgaXMgdGhlIGZpbmFsIHZhbHVlIG9mIGEgZGltZW5zaW9uIHByb3BlcnR5IGFmdGVyIGFsbCBjYWxjdWxhdGlvbnMgaGF2ZVxuICogYmVlbiBwZXJmb3JtZWQuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGNvbXB1dGVkIHN0eWxlIG9mIGBlbGVtZW50YCBidXQgcmV0dXJucyB1bmRlZmluZWRcbiAqIGlmIHRoZSBjb21wdXRlZCBzdHlsZSBpcyBub3QgZXhwcmVzc2VkIGluIHBpeGVscy4gVGhhdCBjYW4gaGFwcGVuIGluIHNvbWUgY2FzZXMgd2hlcmVcbiAqIGBlbGVtZW50YCBoYXMgYSBzaXplIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgYW5kIHRoaXMgbGFzdCBvbmUgaXMgbm90IHlldCBkaXNwbGF5ZWQsXG4gKiBmb3IgZXhhbXBsZSBiZWNhdXNlIG9mIGBkaXNwbGF5OiBub25lYCBvbiBhIHBhcmVudCBub2RlLlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdXNlZF92YWx1ZVxuICogQHJldHVybnMgU2l6ZSBpbiBwaXhlbHMgb3IgdW5kZWZpbmVkIGlmIHVua25vd24uXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShcbiAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gIHByb3BlcnR5OiAnd2lkdGgnIHwgJ2hlaWdodCdcbik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHZhbHVlID0gZ2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHkpO1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gIHJldHVybiBtYXRjaGVzID8gK21hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG59XG4iLCAiaW1wb3J0IHR5cGUge1BvaW50LCBTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxOiBQb2ludCwgcDI6IFBvaW50LCB0OiBudW1iZXIsIG1vZGU/KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RlcHBlZEludGVycG9sYXRpb24oXG4gIHAxOiBQb2ludCxcbiAgcDI6IFBvaW50LFxuICB0OiBudW1iZXIsIG1vZGU6ICdtaWRkbGUnIHwgJ2FmdGVyJyB8IHVua25vd25cbikge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgICAgOiBtb2RlID09PSAnYWZ0ZXInID8gdCA8IDEgPyBwMS55IDogcDIueVxuICAgICAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JlemllckludGVycG9sYXRpb24ocDE6IFNwbGluZVBvaW50LCBwMjogU3BsaW5lUG9pbnQsIHQ6IG51bWJlciwgbW9kZT8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgY3AxID0ge3g6IHAxLmNwMngsIHk6IHAxLmNwMnl9O1xuICBjb25zdCBjcDIgPSB7eDogcDIuY3AxeCwgeTogcDIuY3AxeX07XG4gIGNvbnN0IGEgPSBfcG9pbnRJbkxpbmUocDEsIGNwMSwgdCk7XG4gIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xuICBjb25zdCBjID0gX3BvaW50SW5MaW5lKGNwMiwgcDIsIHQpO1xuICBjb25zdCBkID0gX3BvaW50SW5MaW5lKGEsIGIsIHQpO1xuICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xuICByZXR1cm4gX3BvaW50SW5MaW5lKGQsIGUsIHQpO1xufVxuIiwgImV4cG9ydCBpbnRlcmZhY2UgUlRMQWRhcHRlciB7XG4gIHgoeDogbnVtYmVyKTogbnVtYmVyO1xuICBzZXRXaWR0aCh3OiBudW1iZXIpOiB2b2lkO1xuICB0ZXh0QWxpZ24oYWxpZ246ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0Jyk6ICdjZW50ZXInIHwgJ2xlZnQnIHwgJ3JpZ2h0JztcbiAgeFBsdXMoeDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogbnVtYmVyO1xuICBsZWZ0Rm9yTHRyKHg6IG51bWJlciwgaXRlbVdpZHRoOiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYOiBudW1iZXIsIHdpZHRoOiBudW1iZXIpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcblxuY29uc3QgZ2V0TGVmdFRvUmlnaHRBZGFwdGVyID0gZnVuY3Rpb24oKTogUlRMQWRhcHRlciB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bDogYm9vbGVhbiwgcmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcikge1xuICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgZGlyZWN0aW9uOiAnbHRyJyB8ICdydGwnKSB7XG4gIGxldCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgb3JpZ2luYWw6IFtzdHJpbmcsIHN0cmluZ107XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG5cbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgb3JpZ2luYWw/OiBbc3RyaW5nLCBzdHJpbmddKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIChjdHggYXMgeyBwcmV2VGV4dERpcmVjdGlvbj86IFtzdHJpbmcsIHN0cmluZ10gfSkucHJldlRleHREaXJlY3Rpb247XG4gICAgY3R4LmNhbnZhcy5zdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgb3JpZ2luYWxbMF0sIG9yaWdpbmFsWzFdKTtcbiAgfVxufVxuIiwgImltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgX2FuZ2xlRGlmZiwgX2lzQmV0d2VlbiwgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHR9IGZyb20gJy4vaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7aXNQYXR0ZXJuT3JHcmFkaWVudH0gZnJvbSAnLi9oZWxwZXJzLmNvbG9yLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqIEB0eXBlZGVmIHt7c3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIGxvb3A6IGJvb2xlYW4sIHN0eWxlPzogYW55fX0gU2VnbWVudFxuICovXG5cbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXG4gICAgICBjb21wYXJlOiBfYW5nbGVEaWZmLFxuICAgICAgbm9ybWFsaXplOiBfbm9ybWFsaXplQW5nbGUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJldHdlZW46IF9pc0JldHdlZW4sXG4gICAgY29tcGFyZTogKGEsIGIpID0+IGEgLSBiLFxuICAgIG5vcm1hbGl6ZTogeCA9PiB4XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCB7YmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtzdGFydCwgZW5kLCBsb29wfSA9IHNlZ21lbnQ7XG4gIGxldCBpLCBpbGVuO1xuXG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICBlbmQgKz0gY291bnQ7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZTogc2VnbWVudC5zdHlsZX07XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc3ViLXNlZ21lbnQocykgb2YgYSBsaW5lIHNlZ21lbnQgdGhhdCBmYWxsIGluIHRoZSBnaXZlbiBib3VuZHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5zdGFydCAtIHN0YXJ0IGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuZW5kIC0gZW5kIGluZGV4IG9mIHRoZSBzZWdtZW50LCByZWZlcnJpbmcgdGhlIHBvaW50cyBhcnJheVxuICogQHBhcmFtIHtib29sZWFufSBzZWdtZW50Lmxvb3AgLSBpbmRpY2F0ZXMgdGhhdCB0aGUgc2VnbWVudCBpcyBhIGxvb3BcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudC5zdHlsZV0gLSBzZWdtZW50IHN0eWxlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzIHRoYXQgdGhpcyBzZWdtZW50IHJlZmVycyB0b1xuICogQHBhcmFtIHtvYmplY3R9IFtib3VuZHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRzLnByb3BlcnR5IC0gdGhlIHByb3BlcnR5IG9mIGEgYFBvaW50RWxlbWVudGAgd2UgYXJlIGJvdW5kaW5nLiBgeGAsIGB5YCBvciBgYW5nbGVgLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5zdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5lbmQgLSBlbmQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICoqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xuICB9XG5cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gIGxldCBzdWJTdGFydCA9IG51bGw7XG4gIGxldCB2YWx1ZSwgcG9pbnQsIHByZXZWYWx1ZTtcblxuICBjb25zdCBzdGFydElzQmVmb3JlID0gKCkgPT4gYmV0d2VlbihzdGFydEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKSAmJiBjb21wYXJlKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSkgIT09IDA7XG4gIGNvbnN0IGVuZElzQmVmb3JlID0gKCkgPT4gY29tcGFyZShlbmRCb3VuZCwgdmFsdWUpID09PSAwIHx8IGJldHdlZW4oZW5kQm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpO1xuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XG4gIGNvbnN0IHNob3VsZFN0b3AgPSAoKSA9PiAhaW5zaWRlIHx8IGVuZElzQmVmb3JlKCk7XG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG5cbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaW5zaWRlID0gYmV0d2Vlbih2YWx1ZSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpO1xuXG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICB9XG5cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGlmIChzdWJTdGFydCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2VnbWVudHMgb2YgdGhlIGxpbmUgdGhhdCBhcmUgaW5zaWRlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtib3VuZHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYm91bmRzLnByb3BlcnR5IC0gdGhlIHByb3BlcnR5IHdlIGFyZSBib3VuZGluZyB3aXRoLiBgeGAsIGB5YCBvciBgYW5nbGVgLlxuICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kcy5zdGFydCAtIHN0YXJ0IHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgYHByb3BlcnR5YFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9ib3VuZFNlZ21lbnRzKGxpbmUsIGJvdW5kcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdWIgPSBfYm91bmRTZWdtZW50KHNlZ21lbnRzW2ldLCBsaW5lLnBvaW50cywgYm91bmRzKTtcbiAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGaW5kIHN0YXJ0IGFuZCBlbmQgaW5kZXggb2YgYSBsaW5lLlxuICovXG5mdW5jdGlvbiBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGNvdW50IC0gMTtcblxuICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICAvLyBsb29wIGFuZCBub3Qgc3Bhbm5pbmcgZ2FwcywgZmlyc3QgZmluZCBhIGdhcCB0byBzdGFydCBmcm9tXG4gICAgd2hpbGUgKHN0YXJ0IDwgY291bnQgJiYgIXBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgICAgc3RhcnQrKztcbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIGZpcnN0IG5vbiBza2lwcGVkIHBvaW50IChhZnRlciB0aGUgZmlyc3QgZ2FwIHBvc3NpYmx5KVxuICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICBzdGFydCsrO1xuICB9XG5cbiAgLy8gaWYgd2UgbG9vcGVkIHRvIGNvdW50LCBzdGFydCBuZWVkcyB0byBiZSAwXG4gIHN0YXJ0ICU9IGNvdW50O1xuXG4gIGlmIChsb29wKSB7XG4gICAgLy8gbG9vcCB3aWxsIGdvIHBhc3QgY291bnQsIGlmIHN0YXJ0ID4gMFxuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuXG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuXG4gIC8vIGVuZCBjb3VsZCBiZSBtb3JlIHRoYW4gY291bnQsIG5vcm1hbGl6ZVxuICBlbmQgJT0gY291bnQ7XG5cbiAgcmV0dXJuIHtzdGFydCwgZW5kfTtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHNvbGlkIHNlZ21lbnRzIGZyb20gUG9pbnRzLCB3aGVuIHNwYW5HYXBzID09PSBmYWxzZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzIC0gdGhlIHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggLSBtYXggaW5kZXggKGNhbiBnbyBwYXN0IGNvdW50IG9uIGEgbG9vcClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcCAtIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoaXMgd291bGQgYmUgYSBsb29wIGlmIG5vIGdhcHMgYXJlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBsb29wKSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBsYXN0ID0gc3RhcnQ7XG4gIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0XTtcbiAgbGV0IGVuZDtcblxuICBmb3IgKGVuZCA9IHN0YXJ0ICsgMTsgZW5kIDw9IG1heDsgKytlbmQpIHtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xuICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogKGVuZCAtIDEpICUgY291bnQsIGxvb3B9KTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG5cbiAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogbGFzdCAlIGNvdW50LCBsb29wfSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNvbnRpbnVvdXMgc2VnbWVudHMgdGhhdCBkZWZpbmUgdGhlIHdob2xlIGxpbmVcbiAqIFRoZXJlIGNhbiBiZSBza2lwcGVkIHBvaW50cyB3aXRoaW4gYSBzZWdtZW50LCBpZiBzcGFuR2FwcyBpcyB0cnVlLlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGlmICghY291bnQpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICBjb25zdCB7c3RhcnQsIGVuZH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuXG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IG1heCA9IGVuZCA8IHN0YXJ0ID8gZW5kICsgY291bnQgOiBlbmQ7XG4gIGNvbnN0IGNvbXBsZXRlTG9vcCA9ICEhbGluZS5fZnVsbExvb3AgJiYgc3RhcnQgPT09IDAgJiYgZW5kID09PSBjb3VudCAtIDE7XG4gIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNvbGlkU2VnbWVudHMocG9pbnRzLCBzdGFydCwgbWF4LCBjb21wbGV0ZUxvb3ApLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgcmV0dXJuIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtTZWdtZW50W119IHNlZ21lbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc2VnbWVudE9wdGlvbnNdXG4gKiBAcmV0dXJuIHtTZWdtZW50W119XG4gKi9cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuXG4gIGZ1bmN0aW9uIGFkZFN0eWxlKHMsIGUsIGwsIHN0KSB7XG4gICAgY29uc3QgZGlyID0gc3BhbkdhcHMgPyAtMSA6IDE7XG4gICAgaWYgKHMgPT09IGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU3R5bGUgY2FuIG5vdCBzdGFydC9lbmQgb24gYSBza2lwcGVkIHBvaW50LCBhZGp1c3QgaW5kaWNlcyBhY2NvcmRpbmdseVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG5cbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc3RhcnQgPSBzcGFuR2FwcyA/IHN0YXJ0IDogc2VnbWVudC5zdGFydDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydCAlIGNvdW50XTtcbiAgICBsZXQgc3R5bGU7XG4gICAgZm9yIChpID0gc3RhcnQgKyAxOyBpIDw9IHNlZ21lbnQuZW5kOyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gcG9pbnRzW2kgJSBjb3VudF07XG4gICAgICBzdHlsZSA9IHJlYWRTdHlsZShzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0KGNyZWF0ZUNvbnRleHQoY2hhcnRDb250ZXh0LCB7XG4gICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgcDA6IHByZXYsXG4gICAgICAgIHAxOiBwdCxcbiAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgcDFEYXRhSW5kZXg6IGkgJSBjb3VudCxcbiAgICAgICAgZGF0YXNldEluZGV4XG4gICAgICB9KSkpO1xuICAgICAgaWYgKHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSkge1xuICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHByZXYgPSBwdDtcbiAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCBpIC0gMSkge1xuICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICBpZiAoIXByZXZTdHlsZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBjYWNoZSA9IFtdO1xuICBjb25zdCByZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghY2FjaGUuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICBjYWNoZS5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmluZGV4T2YodmFsdWUpO1xuICB9O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3R5bGUsIHJlcGxhY2VyKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlLCByZXBsYWNlcik7XG59XG4iLCAiaW1wb3J0IHtyZXF1ZXN0QW5pbUZyYW1lfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmFuaW1hdGlvbi5qcycpLmRlZmF1bHQgfSBBbmltYXRpb25cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLl9jaGFydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcbiAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuXG4gICAgY2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oe1xuICAgICAgY2hhcnQsXG4gICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgbnVtU3RlcHMsXG4gICAgICBjdXJyZW50U3RlcDogTWF0aC5taW4oZGF0ZSAtIGFuaW1zLnN0YXJ0LCBudW1TdGVwcylcbiAgICB9KSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZShkYXRlID0gRGF0ZS5ub3coKSkge1xuICAgIGxldCByZW1haW5pbmcgPSAwO1xuXG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCkgPT4ge1xuICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICBsZXQgaXRlbTtcblxuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgaWYgKGl0ZW0uX3RvdGFsID4gYW5pbXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIGJlZW4gdXBkYXRlZCBhbmQgaXRzIGR1cmF0aW9uIHByb2xvbmdlZCxcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0b3RhbCBkdXJhdGlvbiBvZiBjdXJyZW50IGFuaW1hdGlvbnMgcnVuIChmb3IgcHJvZ3Jlc3MgZXZlbnQpXG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBpdGVtIGJ5IHJlcGxhY2luZyBpdCB3aXRoIGxhc3QgaXRlbSBhbmQgcmVtb3ZpbmcgdGhlIGxhc3RcbiAgICAgICAgICAvLyBBIGxvdCBmYXN0ZXIgdGhhbiBzcGxpY2UuXG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZHJhdykge1xuICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdwcm9ncmVzcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9sYXN0RGF0ZSA9IGRhdGU7XG5cbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QW5pbXMoY2hhcnQpIHtcbiAgICBjb25zdCBjaGFydHMgPSB0aGlzLl9jaGFydHM7XG4gICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgYW5pbXMgPSB7XG4gICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgIGNvbXBsZXRlOiBbXSxcbiAgICAgICAgICBwcm9ncmVzczogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNoYXJ0cy5zZXQoY2hhcnQsIGFuaW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFja1xuXHQgKi9cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBZGQgYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge0FuaW1hdGlvbltdfSBpdGVtcyAtIGFuaW1hdGlvbnNcblx0ICovXG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIENvdW50cyBudW1iZXIgb2YgYWN0aXZlIGFuaW1hdGlvbnMgZm9yIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgaGFzKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIFN0YXJ0IGFuaW1hdGluZyAoYWxsIGNoYXJ0cylcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0YXJ0KGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1zLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGFuaW1zLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpID0+IE1hdGgubWF4KGFjYywgY3VyLl9kdXJhdGlvbiksIDApO1xuICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgfVxuXG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcblx0ICogU3RvcCBhbGwgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGl0ZW1zW2ldLmNhbmNlbCgpO1xuICAgIH1cbiAgICBhbmltcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIERhdGUubm93KCksICdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlbW92ZSBjaGFydCBmcm9tIEFuaW1hdG9yXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cblxuLy8gc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgZGVmYXVsdCAvKiAjX19QVVJFX18gKi8gbmV3IEFuaW1hdG9yKCk7XG4iLCAiaW1wb3J0IGVmZmVjdHMgZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmVhc2luZy5qcyc7XG5pbXBvcnQge3Jlc29sdmV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7Y29sb3IgYXMgaGVscGVyc0NvbG9yfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sb3IuanMnO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICBib29sZWFuKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZmFjdG9yID4gMC41ID8gdG8gOiBmcm9tO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZyb21cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3JcbiAgICovXG4gIGNvbG9yKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICBjb25zdCBjMCA9IGhlbHBlcnNDb2xvcihmcm9tIHx8IHRyYW5zcGFyZW50KTtcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGhlbHBlcnNDb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG5cbiAgICB0byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICBjb25zdCBmcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuXG4gIHVwZGF0ZShjZmcsIHRvLCBkYXRlKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcblxuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICB0aGlzLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cblxuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgLy8gdXBkYXRlIGN1cnJlbnQgZXZhbHVhdGVkIHZhbHVlLCBmb3Igc21vb3RoZXIgYW5pbWF0aW9uc1xuICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHRpY2soZGF0ZSkge1xuICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLl9kdXJhdGlvbjtcbiAgICBjb25zdCBwcm9wID0gdGhpcy5fcHJvcDtcbiAgICBjb25zdCBmcm9tID0gdGhpcy5fZnJvbTtcbiAgICBjb25zdCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBjb25zdCB0byA9IHRoaXMuX3RvO1xuICAgIGxldCBmYWN0b3I7XG5cbiAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCAoZWxhcHNlZCA8IGR1cmF0aW9uKSk7XG5cbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XG4gICAgICB0aGlzLl9ub3RpZnkodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVsYXBzZWQgPCAwKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSBmcm9tO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG5cbiAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0aGlzLl9mbihmcm9tLCB0bywgZmFjdG9yKTtcbiAgfVxuXG4gIHdhaXQoKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCAodGhpcy5fcHJvbWlzZXMgPSBbXSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcHJvbWlzZXMucHVzaCh7cmVzLCByZWp9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IGFuaW1hdG9yIGZyb20gJy4vY29yZS5hbmltYXRvci5qcyc7XG5pbXBvcnQgQW5pbWF0aW9uIGZyb20gJy4vY29yZS5hbmltYXRpb24uanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gIH1cblxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG5cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmVkID0ge307XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBhbmltYXRpb25PcHRpb25zKSB7XG4gICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgIH1cblxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IHRvIGhhbmRsZSBhbmltYXRpb24gb2YgYG9wdGlvbnNgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2FuaW1hdGVPcHRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9IHZhbHVlcy5vcHRpb25zO1xuICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIC8vIEdvaW5nIHRvIHNoYXJlZCBvcHRpb25zOlxuICAgICAgLy8gQWZ0ZXIgYWxsIGFuaW1hdGlvbnMgYXJlIGRvbmUsIGFzc2lnbiB0aGUgc2hhcmVkIG9wdGlvbnMgb2JqZWN0IHRvIHRoZSBlbGVtZW50XG4gICAgICAvLyBTbyBhbnkgbmV3IHVwZGF0ZXMgdG8gdGhlIHNoYXJlZCBvcHRpb25zIGFyZSBvYnNlcnZlZFxuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICAgIC8vIHJlamVjdGVkLCBub29wXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IHByb3BzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAocHJvcC5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBhbiBleGlzdGluZyBhY3RpdmUgYW5pbWF0aW9uLCBsZXQncyB1cGRhdGUgdGhhdFxuICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGUoY2ZnLCB2YWx1ZSwgZGF0ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNmZyB8fCAhY2ZnLmR1cmF0aW9uKSB7XG4gICAgICAgIC8vIG5vdCBhbmltYXRlZCwgc2V0IGRpcmVjdGx5IHRvIG5ldyB2YWx1ZVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJ1bm5pbmdbcHJvcF0gPSBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKGNmZywgdGFyZ2V0LCBwcm9wLCB2YWx1ZSk7XG4gICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgYHRhcmdldGAgcHJvcGVydGllcyB0byBuZXcgdmFsdWVzLCB1c2luZyBjb25maWd1cmVkIGFuaW1hdGlvbnNcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIG9iamVjdCB0byB1cGRhdGVcblx0ICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyAtIG5ldyB0YXJnZXQgcHJvcGVydGllc1xuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbnx1bmRlZmluZWR9IC0gYHRydWVgIGlmIGFuaW1hdGlvbnMgd2VyZSBzdGFydGVkXG5cdCAqKi9cbiAgdXBkYXRlKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgLy8gTm90aGluZyBpcyBhbmltYXRlZCwganVzdCBhcHBseSB0aGUgbmV3IHZhbHVlcy5cbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKTtcblxuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiBQcm9taXNlLmFsbChydW5uaW5nKTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAvLyBHb2luZyBmcm9tIHNoYXJlZCBvcHRpb25zIHRvIGRpc3RpbmN0IG9uZTpcbiAgICAvLyBDcmVhdGUgbmV3IG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9sZCBzaGFyZWQgdmFsdWVzIGFuZCBzdGFydCB1cGRhdGluZyB0aGF0LlxuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG4iLCAiaW1wb3J0IEFuaW1hdGlvbnMgZnJvbSAnLi9jb3JlLmFuaW1hdGlvbnMuanMnO1xuaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2lzQXJyYXksIGlzRmluaXRlLCBpc09iamVjdCwgdmFsdWVPckRlZmF1bHQsIHJlc29sdmVPYmplY3RLZXksIGRlZmluZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7bGlzdGVuQXJyYXlFdmVudHMsIHVubGlzdGVuQXJyYXlFdmVudHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgc2lnbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKi9cblxuZnVuY3Rpb24gc2NhbGVDbGlwKHNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpIHtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJldmVyc2UgPSBvcHRzLnJldmVyc2U7XG4gIGNvbnN0IG1pbiA9IG9wdHMubWluID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICBjb25zdCBtYXggPSBvcHRzLm1heCA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcmV2ZXJzZSA/IG1heCA6IG1pbixcbiAgICBlbmQ6IHJldmVyc2UgPyBtaW4gOiBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuXG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcbiAgbGV0IHQsIHIsIGIsIGw7XG5cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgZmlsdGVyVmlzaWJsZSkge1xuICBjb25zdCBrZXlzID0gW107XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcyhmaWx0ZXJWaXNpYmxlKTtcbiAgbGV0IGksIGlsZW47XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XG4gIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBmb3VuZCA9IGZhbHNlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICBpZiAoZGF0YXNldEluZGV4ID09PSBkc0luZGV4KSB7XG4gICAgICBmb3VuZCA9IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5hbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb3RoZXJWYWx1ZSA9IHN0YWNrLnZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChpc0Zpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCAodmFsdWUgPT09IDAgfHwgc2lnbih2YWx1ZSkgPT09IHNpZ24ob3RoZXJWYWx1ZSkpKSkge1xuICAgICAgdmFsdWUgKz0gb3RoZXJWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWZvdW5kICYmICFvcHRpb25zLmFsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSwgbWV0YSkge1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8gJ3gnIDogJ3knO1xuICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgYWRhdGEgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICBsZXQgaSwgaWxlbiwga2V5O1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGFkYXRhW2ldID0ge1xuICAgICAgW2lBeGlzS2V5XToga2V5LFxuICAgICAgW3ZBeGlzS2V5XTogZGF0YVtrZXldXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWRhdGE7XG59XG5cbmZ1bmN0aW9uIGlzU3RhY2tlZChzY2FsZSwgbWV0YSkge1xuICBjb25zdCBzdGFja2VkID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICByZXR1cm4gc3RhY2tlZCB8fCAoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgIT09IHVuZGVmaW5lZCk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyQm91bmRzKHNjYWxlKSB7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW5EZWZpbmVkID8gbWluIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVN0YWNrKHN0YWNrcywgc3RhY2tLZXksIGluZGV4VmFsdWUpIHtcbiAgY29uc3Qgc3ViU3RhY2sgPSBzdGFja3Nbc3RhY2tLZXldIHx8IChzdGFja3Nbc3RhY2tLZXldID0ge30pO1xuICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuXG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhY2tzKGNvbnRyb2xsZXIsIHBhcnNlZCkge1xuICBjb25zdCB7Y2hhcnQsIF9jYWNoZWRNZXRhOiBtZXRhfSA9IGNvbnRyb2xsZXI7XG4gIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7IC8vIG1hcCBzdHJ1Y3R1cmUgaXMge3N0YWNrS2V5OiB7ZGF0YXNldEluZGV4OiB2YWx1ZX19XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgaW5kZXg6IGRhdGFzZXRJbmRleH0gPSBtZXRhO1xuICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICBjb25zdCBrZXkgPSBnZXRTdGFja0tleShpU2NhbGUsIHZTY2FsZSwgbWV0YSk7XG4gIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICBsZXQgc3RhY2s7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG5cbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlLCBtZXRhLnR5cGUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuXG4gICAgY29uc3QgdmlzdWFsVmFsdWVzID0gc3RhY2suX3Zpc3VhbFZhbHVlcyB8fCAoc3RhY2suX3Zpc3VhbFZhbHVlcyA9IHt9KTtcbiAgICB2aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICBjb25zdCBzY2FsZXMgPSBjaGFydC5zY2FsZXM7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzY2FsZXMpLmZpbHRlcihrZXkgPT4gc2NhbGVzW2tleV0uYXhpcyA9PT0gYXhpcykuc2hpZnQoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgcGFyc2VkOiB1bmRlZmluZWQsXG4gICAgcmF3OiB1bmRlZmluZWQsXG4gICAgZWxlbWVudCxcbiAgICBpbmRleCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgdHlwZTogJ2RhdGEnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICAvLyBOb3QgdXNpbmcgbWV0YS5pbmRleCBoZXJlLCBiZWNhdXNlIGl0IG1pZ2h0IGJlIGFscmVhZHkgdXBkYXRlZCBpZiB0aGUgZGF0YXNldCBjaGFuZ2VkIGxvY2F0aW9uXG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xuICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlcyAhPT0gdW5kZWZpbmVkICYmIHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVsZXRlIHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGlzRGlyZWN0VXBkYXRlTW9kZSA9IChtb2RlKSA9PiBtb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpID0+IHNoYXJlZCA/IGNhY2hlZCA6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlZCk7XG5jb25zdCBjcmVhdGVTdGFjayA9IChjYW5TdGFjaywgbWV0YSwgY2hhcnQpID0+IGNhblN0YWNrICYmICFtZXRhLmhpZGRlbiAmJiBtZXRhLl9zdGFja2VkXG4gICYmIHtrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksIHZhbHVlczogbnVsbH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YXNldCAoZS5nLiBDaGFydC5lbGVtZW50LkxpbmVFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhc2V0RWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBFbGVtZW50IHR5cGUgdXNlZCB0byBnZW5lcmF0ZSBhIG1ldGEgZGF0YSAoZS5nLiBDaGFydC5lbGVtZW50LlBvaW50RWxlbWVudCkuXG4gICAqL1xuICBzdGF0aWMgZGF0YUVsZW1lbnRUeXBlID0gbnVsbDtcblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGRhdGFzZXRJbmRleFxuXHQgKi9cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge2Jvb2xlYW4gfCBvYmplY3R9ICovXG4gICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaGFyZWRPcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdTdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0c0RlY2ltYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBuZXcudGFyZ2V0LmRhdGFzZXRFbGVtZW50VHlwZTtcbiAgICB0aGlzLmRhdGFFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YUVsZW1lbnRUeXBlO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgdGhpcy5hZGRFbGVtZW50cygpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5maWxsICYmICF0aGlzLmNoYXJ0LmlzUGx1Z2luRW5hYmxlZCgnZmlsbGVyJykpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlRyaWVkIHRvIHVzZSB0aGUgJ2ZpbGwnIG9wdGlvbiB3aXRob3V0IHRoZSAnRmlsbGVyJyBwbHVnaW4gZW5hYmxlZC4gUGxlYXNlIGltcG9ydCBhbmQgcmVnaXN0ZXIgdGhlICdGaWxsZXInIHBsdWdpbiBhbmQgbWFrZSBzdXJlIGl0IGlzIG5vdCBkaXNhYmxlZCBpbiB0aGUgb3B0aW9uc1wiKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVJbmRleChkYXRhc2V0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgfVxuXG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcblxuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcblxuICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICBjb25zdCB5aWQgPSBtZXRhLnlBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnlBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3knKSk7XG4gICAgY29uc3QgcmlkID0gbWV0YS5yQXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC5yQXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICdyJykpO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgIGNvbnN0IGlpZCA9IG1ldGEuaUF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeGlkLCB5aWQsIHJpZCk7XG4gICAgY29uc3QgdmlkID0gbWV0YS52QXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB5aWQsIHhpZCwgcmlkKTtcbiAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgIG1ldGEueVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHlpZCk7XG4gICAgbWV0YS5yU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQocmlkKTtcbiAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgIG1ldGEudlNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHZpZCk7XG4gIH1cblxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cblxuICBnZXRNZXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY2FsZUlEXG5cdCAqIEByZXR1cm4ge1NjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuc2NhbGVzW3NjYWxlSURdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0T3RoZXJTY2FsZShzY2FsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGVcbiAgICAgID8gbWV0YS52U2NhbGVcbiAgICAgIDogbWV0YS5pU2NhbGU7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoJ3Jlc2V0Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgLy8gSW4gb3JkZXIgdG8gY29ycmVjdGx5IGhhbmRsZSBkYXRhIGFkZGl0aW9uL2RlbGV0aW9uIGFuaW1hdGlvbiAoYW5kIHRodXMgc2ltdWxhdGVcbiAgICAvLyByZWFsLXRpbWUgY2hhcnRzKSwgd2UgbmVlZCB0byBtb25pdG9yIHRoZXNlIGRhdGEgbW9kaWZpY2F0aW9ucyBhbmQgc3luY2hyb25pemVcbiAgICAvLyB0aGUgaW50ZXJuYWwgbWV0YWRhdGEgYWNjb3JkaW5nbHkuXG5cbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgLy8gVGhpcyBjYXNlIGhhcHBlbnMgd2hlbiB0aGUgdXNlciByZXBsYWNlZCB0aGUgZGF0YSBhcnJheSBpbnN0YW5jZS5cbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIC8vIERpc2NhcmQgb2xkIHBhcnNlZCBkYXRhIGFuZCBzdGFja3NcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG5cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IHN0YWNrQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG5cbiAgICAvLyBtYWtlIHN1cmUgY2FjaGVkIF9zdGFja2VkIHN0YXR1cyBpcyBjdXJyZW50XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG5cbiAgICAvLyBkZXRlY3QgY2hhbmdlIGluIHN0YWNrIG9wdGlvblxuICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgLy8gcmVtb3ZlIHZhbHVlcyBmcm9tIG9sZCBzdGFja1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICB9XG5cbiAgICAvLyBSZS1zeW5jIG1ldGEgZGF0YSBpbiBjYXNlIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IG9yIGlmIHdlIG1pc3NlZFxuICAgIC8vIGFueSB1cGRhdGVzIGFuZCBzbyBtYWtlIHN1cmUgdGhhdCB3ZSBoYW5kbGUgbnVtYmVyIG9mIGRhdGFwb2ludHMgY2hhbmdpbmcuXG4gICAgdGhpcy5fcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cyk7XG5cbiAgICAvLyBpZiBzdGFjayBjaGFuZ2VkLCB1cGRhdGUgc3RhY2sgdmFsdWVzIGZvciB0aGUgd2hvbGUgZGF0YXNldFxuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogTWVyZ2VzIHVzZXItc3VwcGxpZWQgYW5kIGRlZmF1bHQgZGF0YXNldC1sZXZlbCBvcHRpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKi9cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcblxuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgIG1ldGEuX3NvcnRlZCA9IHRydWU7XG4gICAgICBwYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBwcmltaXRpdmUgdmFsdWVzXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGRhdGEgLSBkYXRhIGFycmF5LiBFeGFtcGxlIFsxLDMsNF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gc3RhcnQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHBhcnNlXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHBhcnNlZCBpdGVtIC0gaXRlbSBjb250YWluaW5nIGluZGV4IGFuZCBhIHBhcnNlZCB2YWx1ZVxuXHQgKiBmb3IgZWFjaCBzY2FsZSBpZC5cblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDF9XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW1sxLDJdLFszLDRdXVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eDogMCwgeTogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgW3t4OjEsIHk6NX0sIHt4OjIsIHk6MTB9XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLiBfY3VzdG9tIGlzIG9wdGlvbmFsXG5cdCAqIEV4YW1wbGU6IHt4U2NhbGUwOiAwLCB5U2NhbGUwOiAxLCBfY3VzdG9tOiB7cjogMTAsIGZvbzogJ2Jhcid9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3Qge3hBeGlzS2V5ID0gJ3gnLCB5QXhpc0tleSA9ICd5J30gPSB0aGlzLl9wYXJzaW5nO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXS5fdmlzdWFsVmFsdWVzXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcblxuICAgIGZ1bmN0aW9uIF9za2lwKCkge1xuICAgICAgcGFyc2VkID0gX3BhcnNlZFtpXTtcbiAgICAgIGNvbnN0IG90aGVyVmFsdWUgPSBwYXJzZWRbb3RoZXJTY2FsZS5heGlzXTtcbiAgICAgIHJldHVybiAhaXNGaW5pdGUocGFyc2VkW3NjYWxlLmF4aXNdKSB8fCBvdGhlck1pbiA+IG90aGVyVmFsdWUgfHwgb3RoZXJNYXggPCBvdGhlclZhbHVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGRhdGEgaXMgc29ydGVkLCB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZ1cnRoZXIgZnJvbSB0aGlzIGVuZCBvZiBhcnJheVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgLy8gaW4gdGhlIHNvcnRlZCBjYXNlLCBmaW5kIGZpcnN0IG5vbi1za2lwcGVkIHZhbHVlIGZyb20gb3RoZXIgZW5kIG9mIGFycmF5XG4gICAgICBmb3IgKGkgPSBpbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG5cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgbWV0YS5fY2xpcCA9IHRvQ2xpcCh2YWx1ZU9yRGVmYXVsdCh0aGlzLm9wdGlvbnMuY2xpcCwgZGVmYXVsdENsaXAobWV0YS54U2NhbGUsIG1ldGEueVNjYWxlLCB0aGlzLmdldE1heE92ZXJmbG93KCkpKSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuXG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5oaWRkZW4pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgYWN0aXZlLnB1c2goZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmRyYXcoY3R4LCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGEgc2V0IG9mIHByZWRlZmluZWQgc3R5bGUgcHJvcGVydGllcyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGUgZGF0YXNldFxuXHQgKiBvciB0aGUgZGF0YSBpZiB0aGUgaW5kZXggaXMgc3BlY2lmaWVkXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIGRhdGEgaW5kZXhcblx0ICogQHBhcmFtIHtib29sZWFufSBbYWN0aXZlXSAtIHRydWUgaWYgaG92ZXJcblx0ICogQHJldHVybiB7b2JqZWN0fSBzdHlsZSBvYmplY3Rcblx0ICovXG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuXG4gICAgY29udGV4dC5hY3RpdmUgPSAhIWFjdGl2ZTtcbiAgICBjb250ZXh0Lm1vZGUgPSBtb2RlO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVFbGVtZW50T3B0aW9ucyhlbGVtZW50VHlwZSwgbW9kZSA9ICdkZWZhdWx0JywgaW5kZXgpIHtcbiAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gZWxlbWVudFR5cGUgKyAnLScgKyBtb2RlO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBjb25zdCBzaGFyaW5nID0gdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nICYmIGRlZmluZWQoaW5kZXgpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjbG9uZUlmTm90U2hhcmVkKGNhY2hlZCwgc2hhcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0RWxlbWVudFNjb3BlS2V5cyh0aGlzLl90eXBlLCBlbGVtZW50VHlwZSk7XG4gICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbYCR7ZWxlbWVudFR5cGV9SG92ZXJgLCAnaG92ZXInLCBlbGVtZW50VHlwZSwgJyddIDogW2VsZW1lbnRUeXBlLCAnJ107XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgLy8gY29udGV4dCBpcyBwcm92aWRlZCBhcyBhIGZ1bmN0aW9uLCBhbmQgaXMgY2FsbGVkIG9ubHkgaWYgbmVlZGVkLFxuICAgIC8vIHNvIHdlIGRvbid0IGNyZWF0ZSBhIGNvbnRleHQgZm9yIGVhY2ggZWxlbWVudCBpZiBub3QgbmVlZGVkLlxuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAvLyBgJHNoYXJlZGAgaW5kaWNhdGVzIHRoaXMgc2V0IG9mIG9wdGlvbnMgY2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGVsZW1lbnRzLlxuICAgICAgLy8gU2hhcmluZyBpcyB1c2VkIHRvIHJlZHVjZSBudW1iZXIgb2YgcHJvcGVydGllcyB0byBjaGFuZ2UgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcblxuICAgICAgLy8gV2UgY2FjaGUgb3B0aW9ucyBieSBgbW9kZWAsIHdoaWNoIGNhbiBiZSAnYWN0aXZlJyBmb3IgZXhhbXBsZS4gVGhpcyBlbmFibGVzIHVzXG4gICAgICAvLyB0byBoYXZlIHRoZSAnYWN0aXZlJyBlbGVtZW50IG9wdGlvbnMgYW5kICdkZWZhdWx0JyBvcHRpb25zIHRvIHN3aXRjaCBiZXR3ZWVuXG4gICAgICAvLyB3aGVuIGludGVyYWN0aW5nLlxuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCB0cmFuc2l0aW9uLCBhY3RpdmUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGBhbmltYXRpb24tJHt0cmFuc2l0aW9ufWA7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGxldCBvcHRpb25zO1xuICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyhjaGFydCwgb3B0aW9ucyAmJiBvcHRpb25zLmFuaW1hdGlvbnMpO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgb3B0aW9ucyBvYmplY3Qgc2hhcmVkIGJldHdlZW4gZWxlbWVudHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZGV0ZXJtaW5pbmcgaWYgYG9wdGlvbnNgIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgdXBkYXRlZCBwcm9wZXJ0aWVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyB2NCwgcmVuYW1lIHRvIGdldFNoYXJlZE9wdGlvbnMgYW5kIHJlbW92ZSBleGNlc3MgZnVuY3Rpb25zXG4gICAqL1xuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciB1cGRhdGluZyBhbiBlbGVtZW50IHdpdGggbmV3IHByb3BlcnRpZXMsIHVzaW5nIGFuaW1hdGlvbnMgd2hlbiBhcHByb3ByaWF0ZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gYW5pbWF0ZSB0aGUgc2hhcmVkIG9wdGlvbnMsIHRoYXQgYXJlIHBvdGVudGlhbGx5IGFmZmVjdGluZyBtdWx0aXBsZSBlbGVtZW50cy5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICAvLyBXaGVuIGdvaW5nIGZyb20gYWN0aXZlIHRvIGluYWN0aXZlLCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgc2hhcmVkIG9wdGlvbnMuXG4gICAgICAvLyBUaGlzIHdheSB0aGUgb25jZSBob3ZlcmVkIGVsZW1lbnQgd2lsbCBlbmQgdXAgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzaGFyZWQgb3B0aW9ucyBpbnN0YW5jZSwgYWZ0ZXIgYW5pbWF0aW9uLlxuICAgICAgb3B0aW9uczogKCFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpKSB8fCBvcHRpb25zXG4gICAgfSk7XG4gIH1cblxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuXG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIEFwcGx5IGNoYW5nZXMgZGV0ZWN0ZWQgdGhyb3VnaCBhcnJheSBsaXN0ZW5lcnNcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG5cbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICAvLyBUT0RPOiBJdCBpcyBub3Qgb3B0aW1hbCB0byBhbHdheXMgcGFyc2UgdGhlIG9sZCBkYXRhXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgYmVjYXVzZSB3ZSBhcmUgbm90IGRldGVjdGluZyBkaXJlY3QgYXNzaWdubWVudHM6XG4gICAgICAvLyBjaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbNV0gPSAxMDtcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XS55ID0gMTA7XG4gICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaW5zZXJ0RWxlbWVudHMoc3RhcnQsIGNvdW50LCByZXNldE5ld0VsZW1lbnRzID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGE7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBtb3ZlKG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2Uoc3RhcnQsIGNvdW50KTtcblxuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG4gICAqL1xuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG5cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG5cbiAgX29uRGF0YVBvcCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCAtIDEsIDFdKTtcbiAgfVxuXG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cblxuICBfb25EYXRhVW5zaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgMCwgYXJndW1lbnRzLmxlbmd0aF0pO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge1xuICBfYXJyYXlVbmlxdWUsIGlzQXJyYXksIGlzTnVsbE9yVW5kZWYsXG4gIHZhbHVlT3JEZWZhdWx0LCByZXNvbHZlT2JqZWN0S2V5LCBzaWduLCBkZWZpbmVkXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFwib3B0aW1hbFwiIHNhbXBsZSBzaXplIHRvIG1haW50YWluIGJhcnMgZXF1YWxseSBzaXplZCB3aGlsZSBwcmV2ZW50aW5nIG92ZXJsYXAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgLy8gSWdub3JlIHRydW5jYXRlZCBwaXhlbHNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIC8vIGN1cnIgLSBwcmV2ID09PSAwIGlzIGlnbm9yZWRcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuXG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICBwcmV2ID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gc2NhbGUudGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVGljayhpKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cblxuICByZXR1cm4gbWluO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwiaWRlYWxcIiBjYXRlZ29yeSBiYXNlZCBvbiB0aGUgYWJzb2x1dGUgYmFyIHRoaWNrbmVzcyBvciwgaWYgdW5kZWZpbmVkIG9yIG51bGwsXG4gKiB1c2VzIHRoZSBzbWFsbGVzdCBpbnRlcnZhbCAoc2VlIGNvbXB1dGVNaW5TYW1wbGVTaXplKSB0aGF0IHByZXZlbnRzIGJhciBvdmVybGFwcGluZy4gVGhpc1xuICogbW9kZSBjdXJyZW50bHkgYWx3YXlzIGdlbmVyYXRlcyBiYXJzIGVxdWFsbHkgc2l6ZWQgKHVudGlsIHdlIGludHJvZHVjZSBzY3JpcHRhYmxlIG9wdGlvbnM/KS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgdGhpY2tuZXNzID0gb3B0aW9ucy5iYXJUaGlja25lc3M7XG4gIGxldCBzaXplLCByYXRpbztcblxuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gYmFyIHRoaWNrbmVzcyBpcyBlbmZvcmNlZCwgY2F0ZWdvcnkgYW5kIGJhciBwZXJjZW50YWdlcyBhcmUgaWdub3JlZC5cbiAgICAvLyBOb3RlKFNCKTogd2UgY291bGQgYWRkIHN1cHBvcnQgZm9yIHJlbGF0aXZlIGJhciB0aGlja25lc3MgKGUuZy4gYmFyVGhpY2tuZXNzOiAnNTAlJylcbiAgICAvLyBhbmQgZGVwcmVjYXRlIGJhclBlcmNlbnRhZ2Ugc2luY2UgdGhpcyB2YWx1ZSBpcyBpZ25vcmVkIHdoZW4gdGhpY2tuZXNzIGlzIGFic29sdXRlLlxuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIGFuIFwib3B0aW1hbFwiIGNhdGVnb3J5IHRoYXQgZ2xvYmFsbHkgYXJyYW5nZXMgYmFycyBzaWRlIGJ5IHNpZGUgKG5vIGdhcCB3aGVuXG4gKiBwZXJjZW50YWdlIG9wdGlvbnMgYXJlIDEpLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYW5kIGZvbGxvd2luZyBjYXRlZ29yaWVzLiBUaGlzIG1vZGVcbiAqIGdlbmVyYXRlcyBiYXJzIHdpdGggZGlmZmVyZW50IHdpZHRocyB3aGVuIGRhdGEgYXJlIG5vdCBldmVubHkgc3BhY2VkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuXG4gIGlmIChwcmV2ID09PSBudWxsKSB7XG4gICAgLy8gZmlyc3QgZGF0YTogaXRzIHNpemUgaXMgZG91YmxlIGJhc2VkIG9uIHRoZSBuZXh0IHBvaW50IG9yLFxuICAgIC8vIGlmIGl0J3MgYWxzbyB0aGUgbGFzdCBkYXRhLCB3ZSB1c2UgdGhlIHNjYWxlIHNpemUuXG4gICAgcHJldiA9IGN1cnIgLSAobmV4dCA9PT0gbnVsbCA/IHJ1bGVyLmVuZCAtIHJ1bGVyLnN0YXJ0IDogbmV4dCAtIGN1cnIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBsYXN0IGRhdGE6IGl0cyBzaXplIGlzIGFsc28gZG91YmxlIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBwb2ludC5cbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG5cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuXG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvOiBvcHRpb25zLmJhclBlcmNlbnRhZ2UsXG4gICAgc3RhcnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG5cbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG5cbiAgLy8gU3RvcmUgYGJhckVuZGAgKGZ1cnRoZXN0IGF3YXkgZnJvbSBvcmlnaW4pIGFzIHBhcnNlZCB2YWx1ZSxcbiAgLy8gdG8gbWFrZSBzdGFja2luZyBzdHJhaWdodCBmb3J3YXJkXG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuXG4gIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICBiYXJTdGFydCxcbiAgICBiYXJFbmQsXG4gICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgZW5kOiBlbmRWYWx1ZSxcbiAgICBtaW4sXG4gICAgbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcblxuICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBlbnRyeSA9IGRhdGFbaV07XG4gICAgaXRlbSA9IHt9O1xuICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgcGFyc2VkLnB1c2gocGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5cbmZ1bmN0aW9uIGJvcmRlclByb3BzKHByb3BlcnRpZXMpIHtcbiAgbGV0IHJldmVyc2UsIHN0YXJ0LCBlbmQsIHRvcCwgYm90dG9tO1xuICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA+IHByb3BlcnRpZXMueDtcbiAgICBzdGFydCA9ICdsZWZ0JztcbiAgICBlbmQgPSAncmlnaHQnO1xuICB9IGVsc2Uge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgc3RhcnQgPSAnYm90dG9tJztcbiAgICBlbmQgPSAndG9wJztcbiAgfVxuICBpZiAocmV2ZXJzZSkge1xuICAgIHRvcCA9ICdlbmQnO1xuICAgIGJvdHRvbSA9ICdzdGFydCc7XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gJ3N0YXJ0JztcbiAgICBib3R0b20gPSAnZW5kJztcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuXG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWRnZSA9PT0gdHJ1ZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHt0b3A6IHRydWUsIHJpZ2h0OiB0cnVlLCBib3R0b206IHRydWUsIGxlZnQ6IHRydWV9O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcblxuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuXG4gIHJlc1twYXJzZUVkZ2UoZWRnZSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RW5kKHYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHYgPT09ICdzdGFydCcgPyBzdGFydCA6IHYgPT09ICdlbmQnID8gZW5kIDogdjtcbn1cblxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG5cbiAgICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgICBiYXJQZXJjZW50YWdlOiAwLjksXG4gICAgZ3JvdXBlZDogdHJ1ZSxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIHNjYWxlczoge1xuICAgICAgX2luZGV4Xzoge1xuICAgICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF92YWx1ZV86IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuXHQgKiBPdmVycmlkaW5nIHByaW1pdGl2ZSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgYXJyYXkgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgb2JqZWN0IGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiB2YWx1ZS1zY2FsZSBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgLy8gZmxvYXQgYmFyOiBvbmx5IG9uZSBlbmQgb2YgdGhlIGJhciBpcyBjb25zaWRlcmVkIGJ5IGBzdXBlcmBcbiAgICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgY3VzdG9tLm1pbik7XG4gICAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIGN1c3RvbS5tYXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiAnJyArIGlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFtpU2NhbGUuYXhpc10pLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuXG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5zdGFjayA9IHRoaXMuZ2V0RGF0YXNldCgpLnN0YWNrO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCB2cGl4ZWxzID0gcmVzZXQgfHwgaXNOdWxsT3JVbmRlZihwYXJzZWRbdlNjYWxlLmF4aXNdKSA/IHtiYXNlLCBoZWFkOiBiYXNlfSA6IHRoaXMuX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGkpO1xuICAgICAgY29uc3QgaXBpeGVscyA9IHRoaXMuX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGksIHJ1bGVyKTtcbiAgICAgIGNvbnN0IHN0YWNrID0gKHBhcnNlZC5fc3RhY2tzIHx8IHt9KVt2U2NhbGUuYXhpc107XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrcyBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2xhc3RdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdIC0gVGhlIGRhdGEgaW5kZXggb2YgdGhlIHJ1bGVyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmdbXX0gVGhlIGxpc3Qgb2Ygc3RhY2sgSURzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgIGNvbnN0IGN1cnJlbnRQYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGRhdGFJbmRleCk7XG4gICAgY29uc3QgaVNjYWxlVmFsdWUgPSBjdXJyZW50UGFyc2VkICYmIGN1cnJlbnRQYXJzZWRbaVNjYWxlLmF4aXNdO1xuXG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5fcGFyc2VkLmZpbmQoaXRlbSA9PiBpdGVtW2lTY2FsZS5heGlzXSA9PT0gaVNjYWxlVmFsdWUpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhY2tlZCAgIHwgbWV0YS5zdGFja1xuICAgICAgLy8gICAgICAgICAgIHwgZm91bmQgfCBub3QgZm91bmQgfCB1bmRlZmluZWRcbiAgICAgIC8vIGZhbHNlICAgICB8ICAgeCAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIC8vIHRydWUgICAgICB8ICAgICAgIHwgICAgIHggICAgIHxcbiAgICAgIC8vIHVuZGVmaW5lZCB8ICAgICAgIHwgICAgIHggICAgIHwgICAgIHhcbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gc3RhY2tzPyB0aGF0IG1lYW5zIHRoZXJlIGlzIG5vIHZpc2libGUgZGF0YS4gTGV0J3Mgc3RpbGwgaW5pdGlhbGl6ZSBhbiBgdW5kZWZpbmVkYFxuICAgIC8vIHN0YWNrIHdoZXJlIHBvc3NpYmxlIGludmlzaWJsZSBiYXJzIHdpbGwgYmUgbG9jYXRlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjM2OFxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGVmZmVjdGl2ZSBudW1iZXIgb2Ygc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YWNrIGluZGV4IGZvciB0aGUgZ2l2ZW4gZGF0YXNldCBiYXNlZCBvbiBncm91cHMgYW5kIGJhciB2aXNpYmlsaXR5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFzZXRJbmRleF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIC0gVGhlIHN0YWNrIG5hbWUgdG8gZmluZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF1cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIHN0YWNrIGluZGV4XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U3RhY2tJbmRleChkYXRhc2V0SW5kZXgsIG5hbWUsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgY29uc3QgaW5kZXggPSAobmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgPyBzdGFja3MuaW5kZXhPZihuYW1lKVxuICAgICAgOiAtMTsgLy8gaW5kZXhPZiByZXR1cm5zIC0xIGlmIGVsZW1lbnQgaXMgbm90IHByZXNlbnRcblxuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJ1bGVyKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgcGl4ZWxzID0gW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIHBpeGVscyxcbiAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgLy8gYmFyIHRoaWNrbmVzcyByYXRpbyB1c2VkIGZvciBub24tZ3JvdXBlZCBiYXJzXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBOb3RlOiBwaXhlbCB2YWx1ZXMgYXJlIG5vdCBjbGFtcGVkIHRvIHRoZSBzY2FsZSBhcmVhLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzKGluZGV4KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiB7dlNjYWxlLCBfc3RhY2tlZCwgaW5kZXg6IGRhdGFzZXRJbmRleH0sIG9wdGlvbnM6IHtiYXNlOiBiYXNlVmFsdWUsIG1pbkJhckxlbmd0aH19ID0gdGhpcztcbiAgICBjb25zdCBhY3R1YWxCYXNlID0gYmFzZVZhbHVlIHx8IDA7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IGZsb2F0aW5nID0gaXNGbG9hdEJhcihjdXN0b20pO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgbGVuZ3RoID0gX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHZhbHVlO1xuICAgIGxldCBoZWFkLCBzaXplO1xuXG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIC8vIGJhcnMgY3Jvc3Npbmcgb3JpZ2luIGFyZSBub3Qgc3RhY2tlZFxuICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ICs9IHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG5cbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gbm90IHZpc2libGUsIG5vIGhlaWdodFxuICAgICAgaGVhZCA9IGJhc2U7XG4gICAgfVxuXG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuXG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuXG4gICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgIC8vIHZpc3VhbCBkYXRhIGNvb3JkaW5hdGVzIGFmdGVyIGFwcGx5aW5nIG1pbkJhckxlbmd0aFxuICAgICAgICBwYXJzZWQuX3N0YWNrc1t2U2NhbGUuYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoaGVhZCkgLSB2U2NhbGUuZ2V0VmFsdWVGb3JQaXhlbChiYXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2l6ZSxcbiAgICAgIGJhc2UsXG4gICAgICBoZWFkLFxuICAgICAgY2VudGVyOiBoZWFkICsgc2l6ZSAvIDJcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuXG4gICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgKHJhbmdlLmNodW5rICogc3RhY2tJbmRleCkgKyAocmFuZ2UuY2h1bmsgLyAyKTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJhbmdlLmNodW5rICogcmFuZ2UucmF0aW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igbm9uLWdyb3VwZWQgYmFyIGNoYXJ0cywgZXhhY3QgcGl4ZWwgdmFsdWVzIGFyZSB1c2VkXG4gICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmdldFBhcnNlZChpKVt2U2NhbGUuYXhpc10gIT09IG51bGwgJiYgIXJlY3RzW2ldLmhpZGRlbikge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnYnViYmxlJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2YgcHJpbWl0aXZlIHZhbHVlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIG9iamVjdHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gZGF0YS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpO1xuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcblxuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcblxuICAgIC8vIEluIGNhc2UgdmFsdWVzIHdlcmUgY2FjaGVkIChhbmQgdGh1cyBmcm96ZW4pLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB2YWx1ZXNcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlcywgeyRzaGFyZWQ6IGZhbHNlfSk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIHJhZGl1cyByZXNvbHV0aW9uXG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcblxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNPYmplY3QsIHJlc29sdmVPYmplY3RLZXksIHRvUGVyY2VudGFnZSwgdG9EaW1lbnNpb24sIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2Zvcm1hdE51bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGwuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIFBJLCBUQVUsIEhBTEZfUEksIF9hbmdsZUJldHdlZW59IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KSB7XG4gIGxldCByYXRpb1ggPSAxO1xuICBsZXQgcmF0aW9ZID0gMTtcbiAgbGV0IG9mZnNldFggPSAwO1xuICBsZXQgb2Zmc2V0WSA9IDA7XG4gIC8vIElmIHRoZSBjaGFydCdzIGNpcmN1bWZlcmVuY2UgaXNuJ3QgYSBmdWxsIGNpcmNsZSwgY2FsY3VsYXRlIHNpemUgYXMgYSByYXRpbyBvZiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBhcmNcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IGNhbGNNaW4gPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtYXhZID0gY2FsY01heChIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICByYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcbiAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgIG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XG4gIH1cbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvdWdobnV0Q29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnZG91Z2hudXQnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgdGhlIHJvdGF0aW9uIG9mIHRoZSBEb3VnaG51dFxuICAgICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHdlIGFuaW1hdGUgc2NhbGluZyB0aGUgRG91Z2hudXQgZnJvbSB0aGUgY2VudHJlXG4gICAgICBhbmltYXRlU2NhbGU6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ2NpcmN1bWZlcmVuY2UnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc3RhcnRBbmdsZScsICd4JywgJ3knLCAnb2Zmc2V0JywgJ2JvcmRlcldpZHRoJywgJ3NwYWNpbmcnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIC8vIFRoZSBwZXJjZW50YWdlIG9mIHRoZSBjaGFydCB0aGF0IHdlIGN1dCBvdXQgb2YgdGhlIG1pZGRsZS5cbiAgICBjdXRvdXQ6ICc1MCUnLFxuXG4gICAgLy8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cbiAgICBjaXJjdW1mZXJlbmNlOiAzNjAsXG5cbiAgICAvLyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjaGFydFxuICAgIHJhZGl1czogJzEwMCUnLFxuXG4gICAgLy8gU3BhY2luZyBiZXR3ZWVuIGFyY3NcbiAgICBzcGFjaW5nOiAwLFxuXG4gICAgaW5kZXhBeGlzOiAncicsXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYm9yZGVyRGFzaCcpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2hvdmVyQm9yZGVyRGFzaCcpLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIC8vIE5lZWQgdG8gb3ZlcnJpZGUgdGhlc2UgdG8gZ2l2ZSBhIG5pY2UgZGVmYXVsdFxuICAgIHBsdWdpbnM6IHtcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHt9XG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRlIGRhdGEgcGFyc2luZywgc2luY2Ugd2UgYXJlIG5vdCB1c2luZyBzY2FsZXNcblx0ICovXG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2V0dGVyID0gKGkpID0+ICtkYXRhW2ldO1xuXG4gICAgICBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIGNvbnN0IHtrZXkgPSAndmFsdWUnfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSwgaWxlbjtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRDaXJjdW1mZXJlbmNlKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCB0aGUgbWF4aW1hbCByb3RhdGlvbiAmIGNpcmN1bWZlcmVuY2UgZXh0ZW50c1xuXHQgKiBhY3Jvc3MgYWxsIHZpc2libGUgZGF0YXNldHMuXG5cdCAqL1xuICBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgIGxldCBtaW4gPSBUQVU7XG4gICAgbGV0IG1heCA9IC1UQVU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLnR5cGUgPT09IHRoaXMuX3R5cGUpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuXG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm90YXRpb24pO1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdGF0aW9uICsgY2lyY3VtZmVyZW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBtaW4sXG4gICAgICBjaXJjdW1mZXJlbmNlOiBtYXggLSBtaW4sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qge2NoYXJ0QXJlYX0gPSBjaGFydDtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBhcmNzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heCgoTWF0aC5taW4oY2hhcnRBcmVhLndpZHRoLCBjaGFydEFyZWEuaGVpZ2h0KSAtIHNwYWNpbmcpIC8gMiwgMCk7XG4gICAgY29uc3QgY3V0b3V0ID0gTWF0aC5taW4odG9QZXJjZW50YWdlKHRoaXMub3B0aW9ucy5jdXRvdXQsIG1heFNpemUpLCAxKTtcbiAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtYXhpbWFsIHJvdGF0aW9uICYgY2lyY3VtZmVyZW5jZSBsaW1pdHMuXG4gICAgLy8gSWYgd2Ugb25seSBjb25zaWRlciBvdXIgZGF0YXNldCwgdGhpcyBjYW4gY2F1c2UgcHJvYmxlbXMgd2hlbiB0d28gZGF0YXNldHNcbiAgICAvLyBhcmUgYm90aCBsZXNzIHRoYW4gYSBjaXJjbGUgd2l0aCBkaWZmZXJlbnQgcm90YXRpb25zIChzdGFydGluZyBhbmdsZXMpXG4gICAgY29uc3Qge2NpcmN1bWZlcmVuY2UsIHJvdGF0aW9ufSA9IHRoaXMuX2dldFJvdGF0aW9uRXh0ZW50cygpO1xuICAgIGNvbnN0IHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICBjb25zdCBtYXhXaWR0aCA9IChjaGFydEFyZWEud2lkdGggLSBzcGFjaW5nKSAvIHJhdGlvWDtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSAoY2hhcnRBcmVhLmhlaWdodCAtIHNwYWNpbmcpIC8gcmF0aW9ZO1xuICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSB0b0RpbWVuc2lvbih0aGlzLm9wdGlvbnMucmFkaXVzLCBtYXhSYWRpdXMpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgKiBjdXRvdXQsIDApO1xuICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYICogb3V0ZXJSYWRpdXM7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WSAqIG91dGVyUmFkaXVzO1xuXG4gICAgbWV0YS50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKTtcblxuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG5cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgaWYgKChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlKSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UobWV0YS5fcGFyc2VkW2ldICogY2lyY3VtZmVyZW5jZSAvIFRBVSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMjtcbiAgICBjb25zdCBhbmltYXRlU2NhbGUgPSByZXNldCAmJiBhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGxldCBzdGFydEFuZ2xlID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICBsZXQgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogY2VudGVyWSArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXNcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzdGFydEFuZ2xlICs9IGNpcmN1bWZlcmVuY2U7XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhbWV0YURhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWw7XG4gIH1cblxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcblxuICAgIGlmICghYXJjcykge1xuICAgICAgLy8gRmluZCB0aGUgb3V0bW9zdCB2aXNpYmxlIGRhdGFzZXRcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgb3B0aW9ucyA9IGNvbnRyb2xsZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIGlmIChvcHRpb25zLmJvcmRlckFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwLCBvcHRpb25zLmhvdmVyQm9yZGVyV2lkdGggfHwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgcmFkaXVzIGxlbmd0aCBvZmZzZXQgb2YgdGhlIGRhdGFzZXQgaW4gcmVsYXRpb24gdG8gdGhlIHZpc2libGUgZGF0YXNldHMgd2VpZ2h0cy4gVGhpcyBhbGxvd3MgZGV0ZXJtaW5pbmcgdGhlIGlubmVyIGFuZCBvdXRlciByYWRpdXMgY29ycmVjdGx5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICBsZXQgcmluZ1dlaWdodE9mZnNldCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFzZXRJbmRleDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlT3JEZWZhdWx0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLndlaWdodCwgMSksIDApO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN1bSBvZiBhbGwgdmlzaWJsZSBkYXRhIHNldCB3ZWlnaHRzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIF9zY2FsZVJhbmdlc0NoYW5nZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgc3BhbkdhcHM6IGZhbHNlLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBzY2FsZXM6IHtcbiAgICAgIF9pbmRleF86IHtcbiAgICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgIH0sXG4gICAgICBfdmFsdWVfOiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgfSxcbiAgICB9XG4gIH07XG5cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBkYXRhOiBwb2ludHMgPSBbXSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcblxuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuXG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cbiAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgIG9wdGlvbnNcbiAgICB9LCBtb2RlKTtcblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICBjb25zdCBwb2ludHNDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcblxuICAgICAgaWYgKGkgPCBzdGFydCB8fCBpID49IGVuZCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnNraXAgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbWV0YS5kYXRhc2V0LnVwZGF0ZUNvbnRyb2xQb2ludHModGhpcy5jaGFydC5jaGFydEFyZWEsIG1ldGEuaVNjYWxlLmF4aXMpO1xuICAgIHN1cGVyLmRyYXcoKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIFBJLCBmb3JtYXROdW1iZXIsIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BvbGFyQXJlYSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICBhbmltYXRlU2NhbGU6IHRydWVcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgICAgfSxcbiAgICB9LFxuICAgIGluZGV4QXhpczogJ3InLFxuICAgIHN0YXJ0QW5nbGU6IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgcGx1Z2luczoge1xuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGxhYmVsczoge1xuICAgICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGUsIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcblxuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG5cbiAgICAgICAgICAgICAgICAgIC8vIEV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGNvcnJlY3QgaXRlbVxuICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNjYWxlczoge1xuICAgICAgcjoge1xuICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBzdGFydEFuZ2xlOiAwXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcblxuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XS5yLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xuXG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgICAgaWYgKHBhcnNlZCA8IHJhbmdlLm1pbikge1xuICAgICAgICAgIHJhbmdlLm1pbiA9IHBhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuXG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSAocmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIGFuZ2xlICs9IHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGxldCBzdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICBsZXQgZW5kQW5nbGUgPSBhbmdsZSArIHRoaXMuX2NvbXB1dGVBbmdsZShpLCBtb2RlLCBkZWZhdWx0QW5nbGUpO1xuICAgICAgbGV0IG91dGVyUmFkaXVzID0gY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgPyBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKS5yKSA6IDA7XG4gICAgICBhbmdsZSA9IGVuZEFuZ2xlO1xuXG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChhcmMsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4odGhpcy5nZXRQYXJzZWQoaW5kZXgpLnIpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cbiIsICJpbXBvcnQgRG91Z2hudXRDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlci5kb3VnaG51dC5qcyc7XG5cbi8vIFBpZSBjaGFydHMgYXJlIERvdWdobnV0IGNoYXJ0IHdpdGggZGlmZmVyZW50IGRlZmF1bHRzXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaWVDb250cm9sbGVyIGV4dGVuZHMgRG91Z2hudXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncGllJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAwLFxuXG4gICAgLy8gVGhlIHJvdGF0aW9uIG9mIHRoZSBjaGFydCwgd2hlcmUgdGhlIGZpcnN0IGRhdGEgYXJjIGJlZ2lucy5cbiAgICByb3RhdGlvbjogMCxcblxuICAgIC8vIFRoZSB0b3RhbCBjaXJjdW1mZXJlbmNlIG9mIHRoZSBjaGFydC5cbiAgICBjaXJjdW1mZXJlbmNlOiAzNjAsXG5cbiAgICAvLyBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBjaGFydFxuICAgIHJhZGl1czogJzEwMCUnXG4gIH07XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge19wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAncmFkYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgICBzaG93TGluZTogdHJ1ZSxcbiAgICBlbGVtZW50czoge1xuICAgICAgbGluZToge1xuICAgICAgICBmaWxsOiAnc3RhcnQnXG4gICAgICB9XG4gICAgfSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgdlNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICB9O1xuICB9XG5cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBsYWJlbHMgPSBtZXRhLmlTY2FsZS5nZXRMYWJlbHMoKTtcblxuICAgIC8vIFVwZGF0ZSBMaW5lXG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgLy8gSW4gcmVzaXplIG1vZGUgb25seSBwb2ludCBsb2NhdGlvbnMgY2hhbmdlLCBzbyBubyBuZWVkIHRvIHNldCB0aGUgcG9pbnRzIG9yIG9wdGlvbnMuXG4gICAgaWYgKG1vZGUgIT09ICdyZXNpemUnKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIF9sb29wOiB0cnVlLFxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdGhpcy5nZXRQYXJzZWQoaSkucik7XG5cbiAgICAgIGNvbnN0IHggPSByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLng7XG4gICAgICBjb25zdCB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBhbmdsZTogcG9pbnRQb3NpdGlvbi5hbmdsZSxcbiAgICAgICAgc2tpcDogaXNOYU4oeCkgfHwgaXNOYU4oeSksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG5cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtpc051bWJlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgX3NjYWxlUmFuZ2VzQ2hhbmdlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdzY2F0dGVyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICBzaG93TGluZTogZmFsc2UsXG4gICAgZmlsbDogZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG5cbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgbW9kZTogJ3BvaW50J1xuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArICcpJ1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhOiBwb2ludHMgPSBbXX0gPSBtZXRhO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBhbmltYXRpb25zRGlzYWJsZWQgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgbGV0IHtzdGFydCwgY291bnR9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuXG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG5cbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcblxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtkYXRhc2V0OiBsaW5lLCBfZGF0YXNldH0gPSBtZXRhO1xuXG4gICAgICAvLyBVcGRhdGUgTGluZVxuICAgICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGxpbmUuX2RlY2ltYXRlZCA9ICEhX2RhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuXG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBtb2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMTEzMzNcbiAgICAgIGRlbGV0ZSBtZXRhLmRhdGFzZXQ7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBQb2ludHNcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuXG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IHtzaG93TGluZX0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHRoaXMuY2hhcnQucmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgIH1cblxuICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuXG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiAoTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSkgPiBtYXhHYXBMZW5ndGg7XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cblxuICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuXG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG59XG4iLCAiLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVyc1xuICogQHNpbmNlIDIuOC4wXG4gKiBAcHJpdmF0ZVxuICovXG5cbmltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydE9wdGlvbnN9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcblxuZXhwb3J0IHR5cGUgVGltZVVuaXQgPSAnbWlsbGlzZWNvbmQnIHwgJ3NlY29uZCcgfCAnbWludXRlJyB8ICdob3VyJyB8ICdkYXknIHwgJ3dlZWsnIHwgJ21vbnRoJyB8ICdxdWFydGVyJyB8ICd5ZWFyJztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlQWRhcHRlcjxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PiB7XG4gIHJlYWRvbmx5IG9wdGlvbnM6IFQ7XG4gIC8qKlxuICAgKiBXaWxsIGNhbGxlZCB3aXRoIGNoYXJ0IG9wdGlvbnMgYWZ0ZXIgYWRhcHRlciBjcmVhdGlvbi5cbiAgICovXG4gIGluaXQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGNoYXJ0T3B0aW9uczogQ2hhcnRPcHRpb25zKTogdm9pZDtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBtYXAgb2YgdGltZSBmb3JtYXRzIGZvciB0aGUgc3VwcG9ydGVkIGZvcm1hdHRpbmcgdW5pdHMgZGVmaW5lZFxuICAgKiBpbiBVbml0IGFzIHdlbGwgYXMgJ2RhdGV0aW1lJyByZXByZXNlbnRpbmcgYSBkZXRhaWxlZCBkYXRlL3RpbWUgc3RyaW5nLlxuICAgKi9cbiAgZm9ybWF0cyh0aGlzOiBEYXRlQWRhcHRlcjxUPik6IFJlY29yZDxUaW1lVW5pdCB8ICdkYXRldGltZScsIHN0cmluZz47XG4gIC8qKlxuICAgKiBQYXJzZXMgdGhlIGdpdmVuIGB2YWx1ZWAgYW5kIHJldHVybiB0aGUgYXNzb2NpYXRlZCB0aW1lc3RhbXAuXG4gICAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBwYXJzZSAodXN1YWxseSBjb21lcyBmcm9tIHRoZSBkYXRhKVxuICAgKiBAcGFyYW0gW2Zvcm1hdF0gLSB0aGUgZXhwZWN0ZWQgZGF0YSBmb3JtYXRcbiAgICovXG4gIHBhcnNlKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB2YWx1ZTogdW5rbm93biwgZm9ybWF0Pzogc3RyaW5nKTogbnVtYmVyIHwgbnVsbDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCBkYXRlIGluIHRoZSBzcGVjaWZpZWQgYGZvcm1hdGAgZm9yIGEgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgdGltZXN0YW1wIHRvIGZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0IC0gdGhlIGRhdGUvdGltZSB0b2tlblxuICAgKi9cbiAgZm9ybWF0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGFtb3VudGAgb2YgYHVuaXRgIHRvIHRoZSBnaXZlbiBgdGltZXN0YW1wYC5cbiAgICogQHBhcmFtIHRpbWVzdGFtcCAtIHRoZSBpbnB1dCB0aW1lc3RhbXBcbiAgICogQHBhcmFtIGFtb3VudCAtIHRoZSBhbW91bnQgdG8gYWRkXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBhZGQodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCBhbW91bnQ6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgYHVuaXRgIGJldHdlZW4gdGhlIGdpdmVuIHRpbWVzdGFtcHMuXG4gICAqIEBwYXJhbSBhIC0gdGhlIGlucHV0IHRpbWVzdGFtcCAocmVmZXJlbmNlKVxuICAgKiBAcGFyYW0gYiAtIHRoZSB0aW1lc3RhbXAgdG8gc3VidHJhY3RcbiAgICogQHBhcmFtIHVuaXQgLSB0aGUgdW5pdCBhcyBzdHJpbmdcbiAgICovXG4gIGRpZmYodGhpczogRGF0ZUFkYXB0ZXI8VD4sIGE6IG51bWJlciwgYjogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgc3RhcnQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqIEBwYXJhbSBbd2Vla2RheV0gLSB0aGUgSVNPIGRheSBvZiB0aGUgd2VlayB3aXRoIDEgYmVpbmcgTW9uZGF5XG4gICAqIGFuZCA3IGJlaW5nIFN1bmRheSAob25seSBuZWVkZWQgaWYgcGFyYW0gKnVuaXQqIGlzIGBpc29XZWVrYCkuXG4gICAqL1xuICBzdGFydE9mKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgdW5pdDogVGltZVVuaXQgfCAnaXNvV2VlaycsIHdlZWtkYXk/OiBudW1iZXIgfCBib29sZWFuKTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyBlbmQgb2YgYHVuaXRgIGZvciB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBlbmRPZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBhYnN0cmFjdDxUID0gdm9pZD4oKTogVCB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuXG4vKipcbiAqIERhdGUgYWRhcHRlciAoY3VycmVudCB1c2VkIGJ5IHRoZSB0aW1lIHNjYWxlKVxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnMuX2RhdGVcbiAqIEBtZW1iZXJvZiBDaGFydC5fYWRhcHRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIERhdGVBZGFwdGVyQmFzZSBpbXBsZW1lbnRzIERhdGVBZGFwdGVyIHtcblxuICAvKipcbiAgICogT3ZlcnJpZGUgZGVmYXVsdCBkYXRlIGFkYXB0ZXIgbWV0aG9kcy5cbiAgICogQWNjZXB0cyB0eXBlIHBhcmFtZXRlciB0byBkZWZpbmUgb3B0aW9ucyB0eXBlLlxuICAgKiBAZXhhbXBsZVxuICAgKiBDaGFydC5fYWRhcHRlcnMuX2RhdGUub3ZlcnJpZGU8e215QWRhcHRlck9wdGlvbjogc3RyaW5nfT4oe1xuICAgKiAgIGluaXQoKSB7XG4gICAqICAgICBjb25zb2xlLmxvZyh0aGlzLm9wdGlvbnMubXlBZGFwdGVyT3B0aW9uKTtcbiAgICogICB9XG4gICAqIH0pXG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGU8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4oXG4gICAgbWVtYmVyczogUGFydGlhbDxPbWl0PERhdGVBZGFwdGVyPFQ+LCAnb3B0aW9ucyc+PlxuICApIHtcbiAgICBPYmplY3QuYXNzaWduKERhdGVBZGFwdGVyQmFzZS5wcm90b3R5cGUsIG1lbWJlcnMpO1xuICB9XG5cbiAgcmVhZG9ubHkgb3B0aW9uczogQW55T2JqZWN0O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM/OiBBbnlPYmplY3QpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBpbml0KCkge31cblxuICBmb3JtYXRzKCk6IFJlY29yZDxUaW1lVW5pdCB8ICdkYXRldGltZScsIHN0cmluZz4ge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgcGFyc2UoKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBmb3JtYXQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGFkZCgpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZGlmZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgc3RhcnRPZigpOiBudW1iZXIge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZW5kT2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlckJhc2UgYXMge1xuICAgIG5ldyAob3B0aW9ucz86IEFueU9iamVjdCk6IERhdGVBZGFwdGVyO1xuICAgIG92ZXJyaWRlPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+KFxuICAgICAgbWVtYmVyczogUGFydGlhbDxPbWl0PERhdGVBZGFwdGVyPFQ+LCAnb3B0aW9ucyc+PlxuICAgICk6IHZvaWQ7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfbG9va3VwQnlLZXksIF9ybG9va3VwQnlLZXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7Z2V0UmVsYXRpdmVQb3NpdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge19hbmdsZUJldHdlZW4sIGdldEFuZ2xlRnJvbVBvaW50fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhLCBpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7e2F4aXM/OiBzdHJpbmcsIGludGVyc2VjdD86IGJvb2xlYW4sIGluY2x1ZGVJbnZpc2libGU/OiBib29sZWFufX0gSW50ZXJhY3Rpb25PcHRpb25zXG4gKiBAdHlwZWRlZiB7e2RhdGFzZXRJbmRleDogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBlbGVtZW50OiBpbXBvcnQoJy4vY29yZS5lbGVtZW50LmpzJykuZGVmYXVsdH19IEludGVyYWN0aW9uSXRlbVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuUG9pbnQgfSBQb2ludFxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRvIGJpbmFyeSBzZWFyY2ggd2hlbiBwb3NzaWJsZVxuICogQHBhcmFtIHtvYmplY3R9IG1ldGFzZXQgLSB0aGUgZGF0YXNldCBtZXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIHNob3VsZCB0aGUgZWxlbWVudCBpbnRlcnNlY3RcbiAqIEByZXR1cm5zIHt7bG86bnVtYmVyLCBoaTpudW1iZXJ9fSBpbmRpY2VzIHRvIHNlYXJjaCBkYXRhIGFycmF5IGJldHdlZW5cbiAqL1xuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGNvbnN0IHNwYW5HYXBzID0gbWV0YXNldC5kYXRhc2V0ID8gbWV0YXNldC5kYXRhc2V0Lm9wdGlvbnMgPyBtZXRhc2V0LmRhdGFzZXQub3B0aW9ucy5zcGFuR2FwcyA6IG51bGwgOiBudWxsO1xuXG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgIGNvbnN0IHt2U2NhbGV9ID0gY29udHJvbGxlci5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3Qge19wYXJzZWR9ID0gbWV0YXNldDtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZExvID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UoMCwgcmVzdWx0LmxvICsgMSlcbiAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgLmZpbmRJbmRleChcbiAgICAgICAgICAgIHBvaW50ID0+ICFpc051bGxPclVuZGVmKHBvaW50W3ZTY2FsZS5heGlzXSkpKTtcbiAgICAgICAgcmVzdWx0LmxvIC09IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkTG8pO1xuXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkSGkgPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZShyZXN1bHQuaGkpXG4gICAgICAgICAgLmZpbmRJbmRleChcbiAgICAgICAgICAgIHBvaW50ID0+ICFpc051bGxPclVuZGVmKHBvaW50W3ZTY2FsZS5heGlzXSkpKTtcbiAgICAgICAgcmVzdWx0LmhpICs9IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkSGkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgIC8vIF9zaGFyZWRPcHRpb25zIGluZGljYXRlcyB0aGF0IGVhY2ggZWxlbWVudCBoYXMgZXF1YWwgb3B0aW9ucyAtPiBlcXVhbCBwcm9wb3J0aW9uc1xuICAgICAgLy8gU28gd2UgY2FuIGRvIGEgcmFuZ2VkIGJpbmFyeSBzZWFyY2ggYmFzZWQgb24gdGhlIHJhbmdlIG9mIGZpcnN0IGVsZW1lbnQgYW5kXG4gICAgICAvLyBiZSBjb25maWRlbnQgdG8gZ2V0IHRoZSBmdWxsIHJhbmdlIG9mIGluZGljZXMgdGhhdCBjYW4gaW50ZXJzZWN0IHdpdGggdGhlIHZhbHVlLlxuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEZWZhdWx0IHRvIGFsbCBlbGVtZW50cywgd2hlbiBiaW5hcnkgc2VhcmNoIGNhbiBub3QgYmUgdXNlZC5cbiAgcmV0dXJuIHtsbzogMCwgaGk6IGRhdGEubGVuZ3RoIC0gMX07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHNlbGVjdCBjYW5kaWRhdGUgZWxlbWVudHMgZm9yIGludGVyYWN0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSB0aGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSBmb3IgZWFjaCB2aXNpYmxlIGl0ZW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBjb25zaWRlciBpbnRlcnNlY3RpbmcgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgaGFuZGxlciwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IHtpbmRleCwgZGF0YX0gPSBtZXRhc2V0c1tpXTtcbiAgICBjb25zdCB7bG8sIGhpfSA9IGJpbmFyeVNlYXJjaChtZXRhc2V0c1tpXSwgYXhpcywgdmFsdWUsIGludGVyc2VjdCk7XG4gICAgZm9yIChsZXQgaiA9IGxvOyBqIDw9IGhpOyArK2opIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgaGFuZGxlcihlbGVtZW50LCBpbmRleCwgaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgZGlzdGFuY2UgbWV0cmljIGZ1bmN0aW9uIGZvciB0d28gcG9pbnRzIGJhc2VkIG9uIHRoZVxuICogYXhpcyBtb2RlIHNldHRpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqL1xuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcblxuICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICBjb25zdCBkZWx0YVggPSB1c2VYID8gTWF0aC5hYnMocHQxLnggLSBwdDIueCkgOiAwO1xuICAgIGNvbnN0IGRlbHRhWSA9IHVzZVkgPyBNYXRoLmFicyhwdDEueSAtIHB0Mi55KSA6IDA7XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIGV2ZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcblxuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMsIHRydWUpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgcmFkaWFsIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG5cbiAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb24gZm9yIGEgY2FydGVzaWFuIGNoYXJ0XG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGVzIGFsb25nIHdoaWNoIHRvIG1lYXN1cmUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBpZiB0cnVlLCBvbmx5IGNvbnNpZGVyIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgdGhlIGVsZW1lbnQncyBhbmltYXRpb24gdGFyZ2V0IGluc3RlYWQgb2YgY3VycmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUludmlzaWJsZV0gLSBpbmNsdWRlIGludmlzaWJsZSBwb2ludHMgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY2hhcnQgYXJlYVxuICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IHRoZSBuZWFyZXN0IGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gZWxlbWVudC5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgaWYgKCFwb2ludEluQXJlYSAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBDYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBhdCB0aGUgc2FtZSBkaXN0YW5jZSBpbiB3aGljaCBjYXNlIHdlIHNvcnQgYnkgc2l6ZVxuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGNvbnNpZGVyaW5nIGFsbCB2aXNpYmxlIGl0ZW1zIGluIHRoZSBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBheGlzID09PSAncicgJiYgIWludGVyc2VjdFxuICAgID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbilcbiAgICA6IGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgaXRlbXMgbWF0Y2hpbmcgYWxvbmcgdGhlIGdpdmVuIFggb3IgWSBheGlzXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byBsb29rIGF0IGVsZW1lbnRzIGZyb21cbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIHRvIG1hdGNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgbGV0IGludGVyc2VjdHNJdGVtID0gZmFsc2U7XG5cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0gJiYgZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IGludGVyc2VjdHNJdGVtIHx8IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHdlIHdhbnQgdG8gdHJpZ2dlciBvbiBhbiBpbnRlcnNlY3QgYW5kIHdlIGRvbid0IGhhdmUgYW55IGl0ZW1zXG4gIC8vIHRoYXQgaW50ZXJzZWN0IHRoZSBwb3NpdGlvbiwgcmV0dXJuIG5vdGhpbmdcbiAgaWYgKGludGVyc2VjdCAmJiAhaW50ZXJzZWN0c0l0ZW0pIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIENvbnRhaW5zIGludGVyYWN0aW9uIHJlbGF0ZWQgZnVuY3Rpb25zXG4gKiBAbmFtZXNwYWNlIENoYXJ0LkludGVyYWN0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLy8gUGFydCBvZiB0aGUgcHVibGljIEFQSSB0byBmYWNpbGl0YXRlIGRldmVsb3BlcnMgY3JlYXRpbmcgdGhlaXIgb3duIG1vZGVzXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGRpZmZlcmVudCBtb2Rlc1xuICBtb2Rlczoge1xuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXguIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBwYXJhbWV0ZXIgaXMgdHJ1ZSwgd2Ugb25seSByZXR1cm4gaXRlbXMgaWYgd2UgaW50ZXJzZWN0IHNvbWV0aGluZ1xuXHRcdCAqIElmIHRoZSBvcHRpb25zLmludGVyc2VjdCBtb2RlIGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgYXQgdGhlIHNhbWUgaW5kZXggYXMgdGhhdCBpdGVtXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmluZGV4XG5cdFx0ICogQHNpbmNlIHYyLjQuMFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBpbmRleChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIC8vIERlZmF1bHQgYXhpcyBmb3IgaW5kZXggbW9kZSBpcyAneCcgdG8gbWF0Y2ggb2xkIGJlaGF2aW91clxuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSlcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuXG4gICAgICAgIC8vIGRvbid0IGNvdW50IGl0ZW1zIHRoYXQgYXJlIHNraXBwZWQgKG51bGwgZGF0YSlcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwgaW5kZXh9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUmV0dXJucyBpdGVtcyBpbiB0aGUgc2FtZSBkYXRhc2V0LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgaXMgZmFsc2UsIHdlIGZpbmQgdGhlIG5lYXJlc3QgaXRlbSBhbmQgcmV0dXJuIHRoZSBpdGVtcyBpbiB0aGF0IGRhdGFzZXRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuZGF0YXNldFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBkYXRhc2V0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGxldCBpdGVtcyA9IG9wdGlvbnMuaW50ZXJzZWN0XG4gICAgICAgID8gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSA6XG4gICAgICAgIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGZhbHNlLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG5cbiAgICAvKipcblx0XHQgKiBQb2ludCBtb2RlIHJldHVybnMgYWxsIGVsZW1lbnRzIHRoYXQgaGl0IHRlc3QgYmFzZWQgb24gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdFx0ICogb2YgdGhlIGV2ZW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBwb2ludChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogbmVhcmVzdCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnQgY2xvc2VzdCB0byB0aGUgcG9pbnRcblx0XHQgKiBAZnVuY3Rpb24gQ2hhcnQuSW50ZXJhY3Rpb24ubW9kZXMuaW50ZXJzZWN0XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIG5lYXJlc3QoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldE5lYXJlc3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeCBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeCBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnhcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogeSBtb2RlIHJldHVybnMgdGhlIGVsZW1lbnRzIHRoYXQgaGl0LXRlc3QgYXQgdGhlIGN1cnJlbnQgeSBjb29yZGluYXRlXG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLnlcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtkZWZpbmVkLCBlYWNoLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1BhZGRpbmd9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcblxuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhhcnJheSwgYXhpcykge1xuICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gU1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gKGJveGVzIHx8IFtdKS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBib3ggPSBib3hlc1tpXTtcbiAgICAoe3Bvc2l0aW9uOiBwb3MsIG9wdGlvbnM6IHtzdGFjaywgc3RhY2tXZWlnaHQgPSAxfX0gPSBib3gpO1xuICAgIGxheW91dEJveGVzLnB1c2goe1xuICAgICAgaW5kZXg6IGksXG4gICAgICBib3gsXG4gICAgICBwb3MsXG4gICAgICBob3Jpem9udGFsOiBib3guaXNIb3Jpem9udGFsKCksXG4gICAgICB3ZWlnaHQ6IGJveC53ZWlnaHQsXG4gICAgICBzdGFjazogc3RhY2sgJiYgKHBvcyArIHN0YWNrKSxcbiAgICAgIHN0YWNrV2VpZ2h0XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGxheW91dEJveGVzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG4vKipcbiAqIHN0b3JlIGRpbWVuc2lvbnMgdXNlZCBpbnN0ZWFkIG9mIGF2YWlsYWJsZSBjaGFydEFyZWEgaW4gZml0Qm94ZXNcbiAqKi9cbmZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gIGNvbnN0IHN0YWNrcyA9IGJ1aWxkU3RhY2tzKGxheW91dHMpO1xuICBjb25zdCB7dkJveE1heFdpZHRoLCBoQm94TWF4SGVpZ2h0fSA9IHBhcmFtcztcbiAgbGV0IGksIGlsZW4sIGxheW91dDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGxheW91dHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gbGF5b3V0c1tpXTtcbiAgICBjb25zdCB7ZnVsbFNpemV9ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdO1xuICAgIGNvbnN0IGZhY3RvciA9IHN0YWNrICYmIGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodDtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXlvdXQud2lkdGggPSB2Qm94TWF4V2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gZmFjdG9yID8gZmFjdG9yICogaEJveE1heEhlaWdodCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG5cbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsIGEsIGIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1heFBhZGRpbmdbYV0sIGNoYXJ0QXJlYVthXSkgKyBNYXRoLm1heChtYXhQYWRkaW5nW2JdLCBjaGFydEFyZWFbYl0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgLy8gZHluYW1pY2FsbHkgcGxhY2VkIGJveGVzIHNpemUgaXMgbm90IGNvbnNpZGVyZWRcbiAgaWYgKCFpc09iamVjdChwb3MpKSB7XG4gICAgaWYgKGxheW91dC5zaXplKSB7XG4gICAgICAvLyB0aGlzIGxheW91dCB3YXMgYWxyZWFkeSBjb3VudGVkIGZvciwgbGV0cyBmaXJzdCByZWR1Y2Ugb2xkIHNpemVcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cblxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG5cbiAgY29uc3QgbmV3V2lkdGggPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJXaWR0aCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlckhlaWdodCAtIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgJ3RvcCcsICdib3R0b20nKSk7XG4gIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgY29uc3QgaGVpZ2h0Q2hhbmdlZCA9IG5ld0hlaWdodCAhPT0gY2hhcnRBcmVhLmg7XG4gIGNoYXJ0QXJlYS53ID0gbmV3V2lkdGg7XG4gIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuXG4gIC8vIHJldHVybiBib29sZWFucyBvbiB0aGUgY2hhbmdlcyBwZXIgZGlyZWN0aW9uXG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiB1cGRhdGVQb3MocG9zKSB7XG4gICAgY29uc3QgY2hhbmdlID0gTWF0aC5tYXgobWF4UGFkZGluZ1twb3NdIC0gY2hhcnRBcmVhW3Bvc10sIDApO1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG4gIGNoYXJ0QXJlYS55ICs9IHVwZGF0ZVBvcygndG9wJyk7XG4gIGNoYXJ0QXJlYS54ICs9IHVwZGF0ZVBvcygnbGVmdCcpO1xuICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gIHVwZGF0ZVBvcygnYm90dG9tJyk7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcblxuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG5cbiAgcmV0dXJuIGhvcml6b250YWxcbiAgICA/IG1hcmdpbkZvclBvc2l0aW9ucyhbJ2xlZnQnLCAncmlnaHQnXSlcbiAgICA6IG1hcmdpbkZvclBvc2l0aW9ucyhbJ3RvcCcsICdib3R0b20nXSk7XG59XG5cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuXG4gICAgYm94LnVwZGF0ZShcbiAgICAgIGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudyxcbiAgICAgIGxheW91dC5oZWlnaHQgfHwgY2hhcnRBcmVhLmgsXG4gICAgICBnZXRNYXJnaW5zKGxheW91dC5ob3Jpem9udGFsLCBjaGFydEFyZWEpXG4gICAgKTtcbiAgICBjb25zdCB7c2FtZSwgb3RoZXJ9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuXG4gICAgLy8gRGltZW5zaW9ucyBjaGFuZ2VkIGFuZCB0aGVyZSB3ZXJlIG5vbiBmdWxsIHdpZHRoIGJveGVzIGJlZm9yZSB0aGlzXG4gICAgLy8gLT4gd2UgaGF2ZSB0byByZWZpdCB0aG9zZVxuICAgIHJlZml0IHw9IHNhbWUgJiYgcmVmaXRCb3hlcy5sZW5ndGg7XG5cbiAgICAvLyBDaGFydCBhcmVhIGNoYW5nZWQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuXG4gICAgaWYgKCFib3guZnVsbFNpemUpIHsgLy8gZnVsbFNpemUgYm94ZXMgZG9uJ3QgbmVlZCB0byBiZSByZS1maXR0ZWQgaW4gYW55IGNhc2VcbiAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuXG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cblxuZnVuY3Rpb24gcGxhY2VCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCB1c2VyUGFkZGluZyA9IHBhcmFtcy5wYWRkaW5nO1xuICBsZXQge3gsIHl9ID0gY2hhcnRBcmVhO1xuXG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuXG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTGF5b3V0SXRlbVxuICogQHR5cGVkZWYge29iamVjdH0gTGF5b3V0SXRlbVxuICogQHByb3Age3N0cmluZ30gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gaW4gdGhlIGNoYXJ0IGxheW91dC4gUG9zc2libGUgdmFsdWVzIGFyZVxuICogJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsIGFuZCAnY2hhcnRBcmVhJ1xuICogQHByb3Age251bWJlcn0gd2VpZ2h0IC0gVGhlIHdlaWdodCB1c2VkIHRvIHNvcnQgdGhlIGl0ZW0uIEhpZ2hlciB3ZWlnaHRzIGFyZSBmdXJ0aGVyIGF3YXkgZnJvbSB0aGUgY2hhcnQgYXJlYVxuICogQHByb3Age2Jvb2xlYW59IGZ1bGxTaXplIC0gaWYgdHJ1ZSwgYW5kIHRoZSBpdGVtIGlzIGhvcml6b250YWwsIHRoZW4gcHVzaCB2ZXJ0aWNhbCBib3hlcyBkb3duXG4gKiBAcHJvcCB7ZnVuY3Rpb259IGlzSG9yaXpvbnRhbCAtIHJldHVybnMgdHJ1ZSBpZiB0aGUgbGF5b3V0IGl0ZW0gaXMgaG9yaXpvbnRhbCAoaWUuIHRvcCBvciBib3R0b20pXG4gKiBAcHJvcCB7ZnVuY3Rpb259IHVwZGF0ZSAtIFRha2VzIHR3byBwYXJhbWV0ZXJzOiB3aWR0aCBhbmQgaGVpZ2h0LiBSZXR1cm5zIHNpemUgb2YgaXRlbVxuICogQHByb3Age2Z1bmN0aW9ufSBkcmF3IC0gRHJhd3MgdGhlIGVsZW1lbnRcbiAqIEBwcm9wIHtmdW5jdGlvbn0gW2dldFBhZGRpbmddIC0gIFJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFkZGluZyBvbiB0aGUgZWRnZXNcbiAqIEBwcm9wIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgaXRlbS4gTXVzdCBiZSB2YWxpZCBhZnRlciB1cGRhdGUoKVxuICogQHByb3Age251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGxlZnQgLSBMZWZ0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IHRvcCAtIFRvcCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSByaWdodCAtIFJpZ2h0IGVkZ2Ugb2YgdGhlIGl0ZW0uIFNldCBieSBsYXlvdXQgc3lzdGVtIGFuZCBjYW5ub3QgYmUgdXNlZCBpbiB1cGRhdGVcbiAqIEBwcm9wIHtudW1iZXJ9IGJvdHRvbSAtIEJvdHRvbSBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKi9cblxuLy8gVGhlIGxheW91dCBzZXJ2aWNlIGlzIHZlcnkgc2VsZiBleHBsYW5hdG9yeS4gIEl0J3MgcmVzcG9uc2libGUgZm9yIHRoZSBsYXlvdXQgd2l0aGluIGEgY2hhcnQuXG4vLyBTY2FsZXMsIExlZ2VuZHMgYW5kIFBsdWdpbnMgYWxsIHJlbHkgb24gdGhlIGxheW91dCBzZXJ2aWNlIGFuZCBjYW4gZWFzaWx5IHJlZ2lzdGVyIHRvIGJlIHBsYWNlZCBhbnl3aGVyZSB0aGV5IG5lZWRcbi8vIEl0IGlzIHRoaXMgc2VydmljZSdzIHJlc3BvbnNpYmlsaXR5IG9mIGNhcnJ5aW5nIG91dCB0aGF0IGxheW91dC5cbmV4cG9ydCBkZWZhdWx0IHtcblxuICAvKipcblx0ICogUmVnaXN0ZXIgYSBib3ggdG8gYSBjaGFydC5cblx0ICogQSBib3ggaXMgc2ltcGx5IGEgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCB0aGF0IHJlcXVpcmVzIGxheW91dC4gZWcuIFNjYWxlcywgTGVnZW5kLCBUaXRsZS5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gdXNlXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGFkZCB0byBiZSBsYWlkIG91dFxuXHQgKi9cbiAgYWRkQm94KGNoYXJ0LCBpdGVtKSB7XG4gICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIGl0ZW0gd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG5cbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuXG4gIC8qKlxuXHQgKiBSZW1vdmUgYSBsYXlvdXRJdGVtIGZyb20gYSBjaGFydFxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB0byByZW1vdmUgdGhlIGJveCBmcm9tXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gbGF5b3V0SXRlbSAtIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIHRoZSBsYXlvdXRcblx0ICovXG4gIHJlbW92ZUJveChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgIGNvbnN0IGluZGV4ID0gY2hhcnQuYm94ZXMgPyBjaGFydC5ib3hlcy5pbmRleE9mKGxheW91dEl0ZW0pIDogLTE7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY2hhcnQuYm94ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG5cdCAqIFNldHMgKG9yIHVwZGF0ZXMpIG9wdGlvbnMgb24gdGhlIGdpdmVuIGBpdGVtYC5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgaW4gd2hpY2ggdGhlIGl0ZW0gbGl2ZXMgKG9yIHdpbGwgYmUgYWRkZWQgdG8pXG5cdCAqIEBwYXJhbSB7TGF5b3V0SXRlbX0gaXRlbSAtIHRoZSBpdGVtIHRvIGNvbmZpZ3VyZSB3aXRoIHRoZSBnaXZlbiBvcHRpb25zXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gdGhlIG5ldyBpdGVtIG9wdGlvbnMuXG5cdCAqL1xuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBGaXRzIGJveGVzIG9mIHRoZSBnaXZlbiBjaGFydCBpbnRvIHRoZSBnaXZlbiBzaXplIGJ5IGhhdmluZyBlYWNoIGJveCBtZWFzdXJlIGl0c2VsZlxuXHQgKiB0aGVuIHJ1bm5pbmcgYSBmaXR0aW5nIGFsZ29yaXRobVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggdG8gZml0IGludG9cblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgdG8gZml0IGludG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pblBhZGRpbmcgLSBtaW5pbXVtIHBhZGRpbmcgcmVxdWlyZWQgZm9yIGVhY2ggc2lkZSBvZiBjaGFydCBhcmVhXG5cdCAqL1xuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhjaGFydC5vcHRpb25zLmxheW91dC5wYWRkaW5nKTtcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWF4KHdpZHRoIC0gcGFkZGluZy53aWR0aCwgMCk7XG4gICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgIGNvbnN0IGJveGVzID0gYnVpbGRMYXlvdXRCb3hlcyhjaGFydC5ib3hlcyk7XG4gICAgY29uc3QgdmVydGljYWxCb3hlcyA9IGJveGVzLnZlcnRpY2FsO1xuICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG5cbiAgICAvLyBCZWZvcmUgYW55IGNoYW5nZXMgYXJlIG1hZGUsIG5vdGlmeSBib3hlcyB0aGF0IGFuIHVwZGF0ZSBpcyBhYm91dCB0byBiZWluZ1xuICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjbGVhciBhbnkgY2FjaGVkIGRhdGEgKGUuZy4gc2NhbGUgbGltaXRzKVxuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRXNzZW50aWFsbHkgd2Ugbm93IGhhdmUgYW55IG51bWJlciBvZiBib3hlcyBvbiBlYWNoIG9mIHRoZSA0IHNpZGVzLlxuICAgIC8vIE91ciBjYW52YXMgbG9va3MgbGlrZSB0aGUgZm9sbG93aW5nLlxuICAgIC8vIFRoZSBhcmVhcyBMMSBhbmQgTDIgYXJlIHRoZSBsZWZ0IGF4ZXMuIFIxIGlzIHRoZSByaWdodCBheGlzLCBUMSBpcyB0aGUgdG9wIGF4aXMgYW5kXG4gICAgLy8gQjEgaXMgdGhlIGJvdHRvbSBheGlzXG4gICAgLy8gVGhlcmUgYXJlIGFsc28gNCBxdWFkcmFudC1saWtlIGxvY2F0aW9ucyAobGVmdCB0byByaWdodCBpbnN0ZWFkIG9mIGNsb2Nrd2lzZSkgcmVzZXJ2ZWQgZm9yIGNoYXJ0IG92ZXJsYXlzXG4gICAgLy8gVGhlc2UgbG9jYXRpb25zIGFyZSBzaW5nbGUtYm94IGxvY2F0aW9ucyBvbmx5LCB3aGVuIHRyeWluZyB0byByZWdpc3RlciBhIGNoYXJ0QXJlYSBsb2NhdGlvbiB0aGF0IGlzIGFscmVhZHkgdGFrZW4sXG4gICAgLy8gYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gICAgLy9cbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgVDEgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgVDIgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCBDMSB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDMiB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8IEwxIHwgTDIgfCAgICAgICAgICAgQ2hhcnRBcmVhIChDMCkgICAgICAgICAgICB8IFIxIHxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfC0tLS18ICAgICAgICAgICAgICAgICAgICAgICAgICAgfC0tLS18ICAgIHxcbiAgICAvLyB8ICAgIHwgICAgfCBDMyB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBDNCB8ICAgIHxcbiAgICAvLyB8ICAgIHwtLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLXxcbiAgICAvLyB8ICAgIHwgICAgfCAgICAgICAgICAgICAgICAgQjEgICAgICAgICAgICAgICAgICB8ICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8ICAgICAgICAgICAgICAgICAgQjIgKEZ1bGwgV2lkdGgpICAgICAgICAgICAgICAgICAgIHxcbiAgICAvLyB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICAvL1xuXG4gICAgY29uc3QgdmlzaWJsZVZlcnRpY2FsQm94Q291bnQgPSB2ZXJ0aWNhbEJveGVzLnJlZHVjZSgodG90YWwsIHdyYXApID0+XG4gICAgICB3cmFwLmJveC5vcHRpb25zICYmIHdyYXAuYm94Lm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2UgPyB0b3RhbCA6IHRvdGFsICsgMSwgMCkgfHwgMTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcblxuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcblxuICAgIC8vIEZpcnN0IGZpdCB0aGUgZnVsbFNpemUgYm94ZXMsIHRvIHJlZHVjZSBwcm9iYWJpbGl0eSBvZiByZS1maXR0aW5nLlxuICAgIGZpdEJveGVzKGJveGVzLmZ1bGxTaXplLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIC8vIFRoZW4gZml0IHZlcnRpY2FsIGJveGVzXG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCBob3Jpem9udGFsIGJveGVzXG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIC8vIGlmIHRoZSBhcmVhIGNoYW5nZWQsIHJlLWZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgfVxuXG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuXG4gICAgLy8gRmluYWxseSBwbGFjZSB0aGUgYm94ZXMgdG8gY29ycmVjdCBjb29yZGluYXRlc1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBNb3ZlIHRvIG9wcG9zaXRlIHNpZGUgb2YgY2hhcnRcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcblxuICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuXG4gICAgLy8gRmluYWxseSB1cGRhdGUgYm94ZXMgaW4gY2hhcnRBcmVhIChyYWRpYWwgc2NhbGUgZm9yIGV4YW1wbGUpXG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCAiXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgdGhhdCBhbGxvd3MgYWJzdHJhY3RpbmcgcGxhdGZvcm0gZGVwZW5kZW5jaWVzIGF3YXkgZnJvbSB0aGUgY2hhcnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgY29uc3RydWN0aW9uIHRpbWUsIHJldHVybnMgYSBjb250ZXh0MmQgaW5zdGFuY2UgaW1wbGVtZW50aW5nXG5cdCAqIHRoZSBbVzNDIENhbnZhcyAyRCBDb250ZXh0IEFQSSBzdGFuZGFyZF17QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC99LlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBUaGUgY2FudmFzIGZyb20gd2hpY2ggdG8gYWNxdWlyZSBjb250ZXh0IChwbGF0Zm9ybSBzcGVjaWZpYylcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBUaGUgY2hhcnQgb3B0aW9uc1xuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBDYWxsZWQgYXQgY2hhcnQgZGVzdHJ1Y3Rpb24gdGltZSwgcmVsZWFzZXMgYW55IHJlc291cmNlcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZXh0XG5cdCAqIHByZXZpb3VzbHkgcmV0dXJuZWQgYnkgdGhlIGFjcXVpcmVDb250ZXh0KCkgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dCAtIFRoZSBjb250ZXh0MmQgaW5zdGFuY2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIG1ldGhvZCBzdWNjZWVkZWQsIGVsc2UgZmFsc2Vcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZWdpc3RlcnMgdGhlIHNwZWNpZmllZCBsaXN0ZW5lciBvbiB0aGUgZ2l2ZW4gY2hhcnQuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byBsaXN0ZW4gZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gbGlzdGVuIGZvclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciAtIFJlY2VpdmVzIGEgbm90aWZpY2F0aW9uIChhbiBvYmplY3QgdGhhdCBpbXBsZW1lbnRzXG5cdCAqIHRoZSB7QGxpbmsgQ2hhcnRFdmVudH0gaW50ZXJmYWNlKSB3aGVuIGFuIGV2ZW50IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBvY2N1cnMuXG5cdCAqL1xuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgcHJldmlvdXNseSByZWdpc3RlcmVkIHdpdGggYWRkRXZlbnRMaXN0ZW5lci5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBDaGFydCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgKHtAbGluayBDaGFydEV2ZW50fSkgdHlwZSB0byByZW1vdmVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIGV2ZW50IHRhcmdldC5cblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjdXJyZW50IGRldmljZVBpeGVsUmF0aW8gb2YgdGhlIGRldmljZSB0aGlzIHBsYXRmb3JtIGlzIGNvbm5lY3RlZCB0by5cblx0ICovXG4gIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbWF4aW11bSBzaXplIGluIHBpeGVscyBvZiBnaXZlbiBjYW52YXMgZWxlbWVudC5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoXSAtIGNvbnRlbnQgd2lkdGggb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdIC0gY29udGVudCBoZWlnaHQgb2YgcGFyZW50IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb10gLSBhc3BlY3QgcmF0aW8gdG8gbWFpbnRhaW5cblx0ICovXG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGNhbnZhcyBpcyBhdHRhY2hlZCB0byB0aGUgcGxhdGZvcm0sIGZhbHNlIGlmIG5vdC5cblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGNvbmZpZyB3aXRoIHBsYXRmb3JtIHNwZWNpZmljIHJlcXVpcmVtZW50c1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29yZS9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICAgKi9cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgLy8gbm8tb3BcbiAgfVxufVxuIiwgIi8qKlxuICogUGxhdGZvcm0gZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gKG1pbmltYWwpLlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1OTEjaXNzdWVjb21tZW50LTMxOTU3NTkzOVxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHdpdGhvdXQgYWNjZXNzIHRvIHRoZSBET00gb3IgdG8gbWFueSBlbGVtZW50IHByb3BlcnRpZXNcbiAqIFRoaXMgcGxhdGZvcm0gaXMgdXNlZCBieSBkZWZhdWx0IGZvciBhbnkgY2hhcnQgcGFzc2VkIGFuIE9mZnNjcmVlbkNhbnZhcy5cbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5nZXRDb250ZXh0ICYmIGl0ZW0uZ2V0Q29udGV4dCgnMmQnKSB8fCBudWxsO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcub3B0aW9ucy5hbmltYXRpb24gPSBmYWxzZTtcbiAgfVxufVxuIiwgIi8qKlxuICogQ2hhcnQuUGxhdGZvcm0gaW1wbGVtZW50YXRpb24gZm9yIHRhcmdldGluZyBhIHdlYiBicm93c2VyXG4gKi9cblxuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IHtfZ2V0UGFyZW50Tm9kZSwgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgcmVhZFVzZWRTaXplLCBnZXRNYXhpbXVtU2l6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge3Rocm90dGxlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG5cbi8qKlxuICogRE9NIGV2ZW50IHR5cGVzIC0+IENoYXJ0LmpzIGV2ZW50IHR5cGVzLlxuICogTm90ZTogb25seSBldmVudHMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgYXJlIG1hcHBlZC5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzXG4gKi9cbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuXG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY2FudmFzIHN0eWxlIGFuZCByZW5kZXIgc2l6ZSB3aXRob3V0IG1vZGlmeWluZyB0aGUgY2FudmFzIGRpc3BsYXkgc2l6ZSxcbiAqIHNpbmNlIHJlc3BvbnNpdmVuZXNzIGlzIGhhbmRsZWQgYnkgdGhlIGNvbnRyb2xsZXIucmVzaXplKCkgbWV0aG9kLiBUaGUgY29uZmlnIGlzIHVzZWRcbiAqIHRvIGRldGVybWluZSB0aGUgYXNwZWN0IHJhdGlvIHRvIGFwcGx5IGluIGNhc2Ugbm8gZXhwbGljaXQgaGVpZ2h0IGhhcyBiZWVuIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuICogQHBhcmFtIHtudW1iZXJ9IFthc3BlY3RSYXRpb11cbiAqL1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuXG4gIC8vIE5PVEUoU0IpIGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgIT09IGNhbnZhcy53aWR0aDogaW4gdGhlIGZpcnN0IGNhc2UgaXRcbiAgLy8gcmV0dXJucyBudWxsIG9yICcnIGlmIG5vIGV4cGxpY2l0IHZhbHVlIGhhcyBiZWVuIHNldCB0byB0aGUgY2FudmFzIGF0dHJpYnV0ZS5cbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuICAvLyBDaGFydC5qcyBtb2RpZmllcyBzb21lIGNhbnZhcyB2YWx1ZXMgdGhhdCB3ZSB3YW50IHRvIHJlc3RvcmUgb24gZGVzdHJveVxuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBGb3JjZSBjYW52YXMgdG8gZGlzcGxheSBhcyBibG9jayB0byBhdm9pZCBleHRyYSBzcGFjZSBjYXVzZWQgYnkgaW5saW5lXG4gIC8vIGVsZW1lbnRzLCB3aGljaCB3b3VsZCBpbnRlcmZlcmUgd2l0aCB0aGUgcmVzcG9uc2l2ZSByZXNpemUgcHJvY2Vzcy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI1MzhcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgLy8gSW5jbHVkZSBwb3NzaWJsZSBib3JkZXJzIGluIHRoZSBzaXplXG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgIGlmIChjYW52YXMuc3R5bGUuaGVpZ2h0ID09PSAnJykge1xuICAgICAgLy8gSWYgbm8gZXhwbGljaXQgcmVuZGVyIGhlaWdodCBhbmQgc3R5bGUgaGVpZ2h0LCBsZXQncyBhcHBseSB0aGUgYXNwZWN0IHJhdGlvLFxuICAgICAgLy8gd2hpY2ggb25lIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHVzZXIgYnV0IGFsc28gYnkgY2hhcnRzIGFzIGRlZmF1bHQgb3B0aW9uXG4gICAgICAvLyAoaS5lLiBvcHRpb25zLmFzcGVjdFJhdGlvKS4gSWYgbm90IHNwZWNpZmllZCwgdXNlIGNhbnZhcyBhc3BlY3QgcmF0aW8gb2YgMi5cbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8vIERlZmF1bHQgcGFzc2l2ZSB0byB0cnVlIGFzIGV4cGVjdGVkIGJ5IENocm9tZSBmb3IgJ3RvdWNoc3RhcnQnIGFuZCAndG91Y2hlbmQnIGV2ZW50cy5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80Mjg3XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcblxuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKGNoYXJ0ICYmIGNoYXJ0LmNhbnZhcykge1xuICAgIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9kZUxpc3RDb250YWlucyhub2RlTGlzdCwgY2FudmFzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTGlzdCkge1xuICAgIGlmIChub2RlID09PSBjYW52YXMgfHwgbm9kZS5jb250YWlucyhjYW52YXMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuY29uc3QgZHJwTGlzdGVuaW5nQ2hhcnRzID0gbmV3IE1hcCgpO1xubGV0IG9sZERldmljZVBpeGVsUmF0aW8gPSAwO1xuXG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuXG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBzaXplIHNocmFuayBkdXJpbmcgY2hhcnQgcmVzaXplLCBsZXQncyBhc3N1bWVcbiAgICAgIC8vIHNjcm9sbGJhciBhcHBlYXJlZC4gU28gd2UgcmVzaXplIGFnYWluIHdpdGggdGhlIHNjcm9sbGJhciB2aXNpYmxlIC1cbiAgICAgIC8vIGVmZmVjdGl2ZWx5IG1ha2luZyBjaGFydCBzbWFsbGVyIGFuZCB0aGUgc2Nyb2xsYmFyIGhpZGRlbiBhZ2Fpbi5cbiAgICAgIC8vIEJlY2F1c2Ugd2UgYXJlIGluc2lkZSBgdGhyb3R0bGVkYCwgYW5kIGN1cnJlbnRseSBgdGlja2luZ2AsIHNjcm9sbFxuICAgICAgLy8gZXZlbnRzIGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIHdob2xlIDIgcmVzaXplIHByb2Nlc3MuXG4gICAgICAvLyBJZiB3ZSBhc3N1bWVkIHdyb25nIGFuZCBzb21ldGhpbmcgZWxzZSBoYXBwZW5lZCwgd2UgYXJlIHJlc2l6aW5nXG4gICAgICAvLyB0d2ljZSBpbiBhIGZyYW1lIChwb3RlbnRpYWwgcGVyZm9ybWFuY2UgaXNzdWUpXG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcblxuICAvLyBAdHMtaWdub3JlIHVudGlsIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzc4NjEgaW1wbGVtZW50ZWRcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIC8vIFdoZW4gaXRzIGNvbnRhaW5lcidzIGRpc3BsYXkgaXMgc2V0IHRvICdub25lJyB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhXG4gICAgLy8gc2l6ZSBvZiAoMCwgMCksIHdoaWNoIHdpbGwgY2F1c2UgdGhlIGNoYXJ0IHRvIGxvc2UgaXRzIG9yaWdpbmFsIGhlaWdodCwgc28gc2tpcFxuICAgIC8vIHJlc2l6aW5nIGluIHN1Y2ggY2FzZS5cbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG5cbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIG9ic2VydmVyKSB7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICAvLyBUaGlzIGNhc2UgY2FuIG9jY3VyIGlmIHRoZSBjaGFydCBpcyBkZXN0cm95ZWQgd2hpbGUgd2FpdGluZ1xuICAgIC8vIGZvciB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHRvIG9jY3VyLiBXZSBwcmV2ZW50IGNyYXNoZXMgYnkgY2hlY2tpbmdcbiAgICAvLyBmb3IgYSBkZXN0cm95ZWQgY2hhcnRcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCk7XG5cbiAgYWRkTGlzdGVuZXIoY2FudmFzLCB0eXBlLCBwcm94eSk7XG5cbiAgcmV0dXJuIHByb3h5O1xufVxuXG4vKipcbiAqIFBsYXRmb3JtIGNsYXNzIGZvciBjaGFydHMgdGhhdCBjYW4gYWNjZXNzIHRoZSBET00gYW5kIGdsb2JhbCB3aW5kb3cvZG9jdW1lbnQgcHJvcGVydGllc1xuICogQGV4dGVuZHMgQmFzZVBsYXRmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERvbVBsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG5cdCAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfVxuXHQgKi9cbiAgYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIC8vIFRvIHByZXZlbnQgY2FudmFzIGZpbmdlcnByaW50aW5nLCBzb21lIGFkZC1vbnMgdW5kZWZpbmUgdGhlIGdldENvbnRleHRcbiAgICAvLyBtZXRob2QsIGZvciBleGFtcGxlOiBodHRwczovL2dpdGh1Yi5jb20va2thcHNuZXIvQ2FudmFzQmxvY2tlclxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yODA3XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50L0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRGAgZmFpbHMgd2hlbiB0aGUgY2FudmFzIGlzXG4gICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciB3aGVuIHJ1bm5pbmcgaW4gYSBwcm90ZWN0ZWQgZW52aXJvbm1lbnQuIFdlIGNvdWxkIGd1ZXNzIHRoZVxuICAgIC8vIHR5cGVzIGZyb20gdGhlaXIgdG9TdHJpbmcoKSB2YWx1ZSBidXQgbGV0J3Mga2VlcCB0aGluZ3MgZmxleGlibGUgYW5kIGFzc3VtZSBpdCdzXG4gICAgLy8gYSBzdWZmaWNpZW50IGNvbmRpdGlvbiBpZiB0aGUgY2FudmFzIGhhcyBhIGNvbnRleHQyRCB3aGljaCBoYXMgY2FudmFzIGFzIGBjYW52YXNgLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxMDJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE1MlxuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIC8vIExvYWQgcGxhdGZvcm0gcmVzb3VyY2VzIG9uIGZpcnN0IGNoYXJ0IGNyZWF0aW9uLCB0byBtYWtlIGl0IHBvc3NpYmxlIHRvXG4gICAgICAvLyBpbXBvcnQgdGhlIGxpYnJhcnkgYmVmb3JlIHNldHRpbmcgcGxhdGZvcm0gb3B0aW9ucy5cbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuXHQgKi9cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgWydoZWlnaHQnLCAnd2lkdGgnXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcblxuICAgIC8vIFRoZSBjYW52YXMgcmVuZGVyIHNpemUgbWlnaHQgaGF2ZSBiZWVuIGNoYW5nZWQgKGFuZCB0aHVzIHRoZSBzdGF0ZSBzdGFjayBkaXNjYXJkZWQpLFxuICAgIC8vIHdlIGNhbid0IHVzZSBzYXZlKCkgYW5kIHJlc3RvcmUoKSB0byByZXN0b3JlIHRoZSBpbml0aWFsIHN0YXRlLiBTbyBtYWtlIHN1cmUgdGhhdCBhdFxuICAgIC8vIGxlYXN0IHRoZSBjYW52YXMgY29udGV4dCBpcyByZXNldCB0byB0aGUgZGVmYXVsdCBzdGF0ZSBieSBzZXR0aW5nIHRoZSBjYW52YXMgd2lkdGguXG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMTEvV0QtaHRtbDUtMjAxMTA1MjUvdGhlLWNhbnZhcy1lbGVtZW50Lmh0bWxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG5cbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBDYW4gaGF2ZSBvbmx5IG9uZSBsaXN0ZW5lciBwZXIgdHlwZSwgc28gbWFrZSBzdXJlIHByZXZpb3VzIGlzIHJlbW92ZWRcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuXG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuXHQgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuXG4gICAgaWYgKCFwcm94eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKi9cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cbiIsICJpbXBvcnQge19pc0RvbVN1cHBvcnRlZH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5pbXBvcnQgQmFzaWNQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2ljLmpzJztcbmltcG9ydCBEb21QbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmRvbS5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gIGlmICghX2lzRG9tU3VwcG9ydGVkKCkgfHwgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykpIHtcbiAgICByZXR1cm4gQmFzaWNQbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gRG9tUGxhdGZvcm07XG59XG5cbmV4cG9ydCB7QmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBEb21QbGF0Zm9ybX07XG4iLCAiaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge1BvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuaW1wb3J0IHR5cGUge0FuaW1hdGlvbn0gZnJvbSAnLi4vdHlwZXMvYW5pbWF0aW9uLmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudDxUID0gQW55T2JqZWN0LCBPID0gQW55T2JqZWN0PiB7XG5cbiAgc3RhdGljIGRlZmF1bHRzID0ge307XG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0gdW5kZWZpbmVkO1xuXG4gIHg6IG51bWJlcjtcbiAgeTogbnVtYmVyO1xuICBhY3RpdmUgPSBmYWxzZTtcbiAgb3B0aW9uczogTztcbiAgJGFuaW1hdGlvbnM6IFJlY29yZDxrZXlvZiBULCBBbmltYXRpb24+O1xuXG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKTogUG9pbnQge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fSBhcyBQb2ludDtcbiAgfVxuXG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBvciBmaW5hbCB2YWx1ZSBvZiBlYWNoIHByb3AuIENhbiByZXR1cm4gZXh0cmEgcHJvcGVydGllcyAod2hvbGUgb2JqZWN0KS5cbiAgICogQHBhcmFtIHByb3BzIC0gcHJvcGVydGllcyB0byBnZXRcbiAgICogQHBhcmFtIFtmaW5hbF0gLSBnZXQgdGhlIGZpbmFsIHZhbHVlIChhbmltYXRpb24gdGFyZ2V0KVxuICAgKi9cbiAgZ2V0UHJvcHM8UCBleHRlbmRzIChrZXlvZiBUKVtdPihwcm9wczogUCwgZmluYWw/OiBib29sZWFuKTogUGljazxULCBQW251bWJlcl0+O1xuICBnZXRQcm9wczxQIGV4dGVuZHMgc3RyaW5nPihwcm9wczogUFtdLCBmaW5hbD86IGJvb2xlYW4pOiBQYXJ0aWFsPFJlY29yZDxQLCB1bmtub3duPj47XG4gIGdldFByb3BzKHByb3BzOiBzdHJpbmdbXSwgZmluYWw/OiBib29sZWFuKTogUGFydGlhbDxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4ge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBpZiAoIWZpbmFsIHx8ICFhbmltcykge1xuICAgICAgLy8gbGV0J3Mgbm90IGNyZWF0ZSBhbiBvYmplY3QsIGlmIG5vdCBuZWVkZWRcbiAgICAgIHJldHVybiB0aGlzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH1cbiAgICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gICAgcHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgcmV0W3Byb3BdID0gYW5pbXNbcHJvcF0gJiYgYW5pbXNbcHJvcF0uYWN0aXZlKCkgPyBhbmltc1twcm9wXS5fdG8gOiB0aGlzW3Byb3AgYXMgc3RyaW5nXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtfZmFjdG9yaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBzdWJzZXQgb2YgdGlja3MgdG8gYmUgcGxvdHRlZCB0byBhdm9pZCBvdmVybGFwcGluZyBsYWJlbHMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdH0gc2NhbGVcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHJldHVybiB7VGlja1tdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IGRldGVybWluZWRNYXhUaWNrcyA9IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgdGlja3NMaW1pdCA9IE1hdGgubWluKHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lZE1heFRpY2tzLCBkZXRlcm1pbmVkTWF4VGlja3MpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcblxuICAvLyBJZiB0aGVyZSBhcmUgdG9vIG1hbnkgbWFqb3IgdGlja3MgdG8gZGlzcGxheSB0aGVtIGFsbFxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIG51bU1ham9ySW5kaWNlcyAvIHRpY2tzTGltaXQpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuXG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuXG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSkge1xuICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgY29uc3QgdGlja0xlbmd0aCA9IHNjYWxlLl90aWNrU2l6ZSgpO1xuICBjb25zdCBtYXhTY2FsZSA9IHNjYWxlLl9sZW5ndGggLyB0aWNrTGVuZ3RoICsgKG9mZnNldCA/IDAgOiAxKTtcbiAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5taW4obWF4U2NhbGUsIG1heENoYXJ0KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gbWFqb3JJbmRpY2VzXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrc0xpbWl0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG5cbiAgLy8gSWYgdGhlIG1ham9yIHRpY2tzIGFyZSBldmVubHkgc3BhY2VkIGFwYXJ0LCBwbGFjZSB0aGUgbWlub3IgdGlja3NcbiAgLy8gc28gdGhhdCB0aGV5IGRpdmlkZSB0aGUgbWFqb3IgdGlja3MgaW50byBldmVuIGNodW5rc1xuICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG4gIH1cblxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKi9cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtUaWNrW119IG5ld1RpY2tzXG4gKiBAcGFyYW0ge251bWJlcltdfSBtYWpvckluZGljZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKi9cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge1RpY2tbXX0gbmV3VGlja3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGFjaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yU3RhcnRdXG4gKiBAcGFyYW0ge251bWJlcn0gW21ham9yRW5kXVxuICovXG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG5cbiAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nKTtcbiAgaWYgKG1ham9yRW5kKSB7XG4gICAgbGVuZ3RoID0gbWFqb3JFbmQgLSBtYWpvclN0YXJ0O1xuICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICB9XG5cbiAgbmV4dCA9IHN0YXJ0O1xuXG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG5cbiAgZm9yIChpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgIH1cbiAgfVxufVxuXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJbXX0gYXJyXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcblxuICBpZiAobGVuIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4vY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2FsaWduUGl4ZWwsIF9tZWFzdXJlVGV4dCwgcmVuZGVyVGV4dCwgY2xpcEFyZWEsIHVuY2xpcEFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsLCBlYWNoLCBmaW5pdGVPckRlZmF1bHQsIGlzQXJyYXksIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBpc09iamVjdCwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9EZWdyZWVzLCB0b1JhZGlhbnMsIF9pbnQxNlJhbmdlLCBfbGltaXRWYWx1ZSwgSEFMRl9QSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RvTGVmdFJpZ2h0Q2VudGVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgdG9Gb250LCB0b1BhZGRpbmcsIF9hZGRHcmFjZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHthdXRvU2tpcH0gZnJvbSAnLi9jb3JlLnNjYWxlLmF1dG9za2lwLmpzJztcblxuY29uc3QgcmV2ZXJzZUFsaWduID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ2xlZnQnID8gJ3JpZ2h0JyA6IGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogYWxpZ247XG5jb25zdCBvZmZzZXRGcm9tRWRnZSA9IChzY2FsZSwgZWRnZSwgb2Zmc2V0KSA9PiBlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuY29uc3QgZ2V0VGlja3NMaW1pdCA9ICh0aWNrc0xlbmd0aCwgbWF4VGlja3NMaW1pdCkgPT4gTWF0aC5taW4obWF4VGlja3NMaW1pdCB8fCB0aWNrc0xlbmd0aCwgdGlja3NMZW5ndGgpO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHt7dmFsdWU6bnVtYmVyIHwgc3RyaW5nLCBsYWJlbD86c3RyaW5nLCBtYWpvcj86Ym9vbGVhbiwgJGNvbnRleHQ/OmFueX19IFRpY2tcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYXJyYXkgY29udGFpbmluZyBudW1JdGVtcyBmcm9tIGFyclxuICogQHBhcmFtIHthbnlbXX0gYXJyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtSXRlbXNcbiAqL1xuZnVuY3Rpb24gc2FtcGxlKGFyciwgbnVtSXRlbXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xuICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9mZnNldEdyaWRMaW5lc1xuICovXG5mdW5jdGlvbiBnZXRQaXhlbEZvckdyaWRMaW5lKHNjYWxlLCBpbmRleCwgb2Zmc2V0R3JpZExpbmVzKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgY29uc3QgdmFsaWRJbmRleCA9IE1hdGgubWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgY29uc3Qgc3RhcnQgPSBzY2FsZS5fc3RhcnRQaXhlbDtcbiAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICBjb25zdCBlcHNpbG9uID0gMWUtNjsgLy8gMWUtNiBpcyBtYXJnaW4gaW4gcGl4ZWxzIGZvciBhY2N1bXVsYXRlZCBlcnJvci5cbiAgbGV0IGxpbmVWYWx1ZSA9IHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4KTtcbiAgbGV0IG9mZnNldDtcblxuICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgIH1cbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcblxuICAgIC8vIFJldHVybiB1bmRlZmluZWQgaWYgdGhlIHBpeGVsIGlzIG91dCBvZiB0aGUgcmFuZ2VcbiAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVWYWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gY2FjaGVzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gIGVhY2goY2FjaGVzLCAoY2FjaGUpID0+IHtcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgICBsZXQgaTtcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgIH1cbiAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IGZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb250LCBmYWxsYmFjayk7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcblxuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRpY2ssXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3RpY2snXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xuICAvKiogQHR5cGUge0NhbnZhc1RleHRBbGlnbn0gKi9cbiAgbGV0IHJldCA9IF90b0xlZnRSaWdodENlbnRlcihhbGlnbik7XG4gIGlmICgocmV2ZXJzZSAmJiBwb3NpdGlvbiAhPT0gJ3JpZ2h0JykgfHwgKCFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSkge1xuICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHRpdGxlQXJncyhzY2FsZSwgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pIHtcbiAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgY2hhcnR9ID0gc2NhbGU7XG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcbiAgbGV0IHJvdGF0aW9uID0gMDtcbiAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcblxuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWSA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWSA9IChjaGFydEFyZWEuYm90dG9tICsgY2hhcnRBcmVhLnRvcCkgLyAyICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICB9IGVsc2Uge1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVggPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWCA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICByb3RhdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAtSEFMRl9QSSA6IEhBTEZfUEk7XG4gIH1cbiAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAqL1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICAvKiogQHR5cGUge0NoYXJ0fSAqL1xuICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG5cbiAgICAvLyBpbXBsZW1lbnRzIGJveFxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBzY2FsZS1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgLyoqIEB0eXBlIHtzdHJpbmc9fSAqL1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcj19ICovXG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7VGlja1tdfSAqL1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICAvKiogQHR5cGUge29iamVjdFtdfG51bGx9ICovXG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXXxudWxsfSAqL1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0fG51bGx9ICovXG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHthbnl9IG9wdGlvbnNcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcblxuICAgIHRoaXMuYXhpcyA9IG9wdGlvbnMuYXhpcztcblxuICAgIC8vIHBhcnNlIG1pbi9tYXggdmFsdWUsIHNvIHdlIGNhbiBwcm9wZXJseSBkZXRlcm1pbmUgbWluL21heCBmb3Igb3RoZXIgc2NhbGVzXG4gICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhIHN1cHBvcnRlZCBpbnB1dCB2YWx1ZSB0byBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cblx0ICogQHBhcmFtIHsqfSByYXdcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgcGFyc2UocmF3LCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIHJhdztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBtaW5EZWZpbmVkOiBib29sZWFuLCBtYXhEZWZpbmVkOiBib29sZWFufX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNhblN0YWNrXG5cdCAqIEByZXR1cm4ge3ttaW46IG51bWJlciwgbWF4OiBudW1iZXJ9fVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGdldE1pbk1heChjYW5TdGFjaykge1xuICAgIGxldCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHJhbmdlO1xuXG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIG1pbiA8PSBtYXggd2hlbiBvbmx5IG1pbiBvciBtYXggaXMgZGVmaW5lZCBieSB1c2VyIGFuZCB0aGUgZGF0YSBpcyBvdXRzaWRlIHRoYXQgcmFuZ2VcbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogR2V0IHRoZSBwYWRkaW5nIG5lZWRlZCBmb3IgdGhlIHNjYWxlXG5cdCAqIEByZXR1cm4ge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19IHRoZSBuZWNlc3NhcnkgcGFkZGluZ1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc2NhbGUgdGljayBvYmplY3RzXG5cdCAqIEByZXR1cm4ge1RpY2tbXX1cblx0ICogQHNpbmNlIDIuN1xuXHQgKi9cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7c3RyaW5nW119XG5cdCAqL1xuICBnZXRMYWJlbHMoKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVscyB8fCAodGhpcy5pc0hvcml6b250YWwoKSA/IGRhdGEueExhYmVscyA6IGRhdGEueUxhYmVscykgfHwgZGF0YS5sYWJlbHMgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7aW1wb3J0KCcuLi90eXBlcy5qcycpLkxhYmVsSXRlbVtdfVxuICAgKi9cbiAgZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8vIFdoZW4gYSBuZXcgbGF5b3V0IGlzIGNyZWF0ZWQsIHJlc2V0IHRoZSBkYXRhIGxpbWl0cyBjYWNoZVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cblxuICAvLyBUaGVzZSBtZXRob2RzIGFyZSBvcmRlcmVkIGJ5IGxpZmVjeWNsZS4gVXRpbGl0aWVzIHRoZW4gZm9sbG93LlxuICAvLyBBbnkgZnVuY3Rpb24gZGVmaW5lZCBoZXJlIGlzIGluaGVyaXRlZCBieSBhbGwgc2NhbGUgdHlwZXMuXG4gIC8vIEFueSBmdW5jdGlvbiBjYW4gYmUgZXh0ZW5kZWQgYnkgdGhlIHNjYWxlIHR5cGVcblxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbdGhpc10pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIHRoZSBtYXggd2lkdGggaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXhIZWlnaHQgLSB0aGUgbWF4IGhlaWdodCBpbiBwaXhlbHNcblx0ICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSBtYXJnaW5zIC0gdGhlIHNwYWNlIGJldHdlZW4gdGhlIGVkZ2Ugb2YgdGhlIG90aGVyIHNjYWxlcyBhbmQgZWRnZSBvZiB0aGUgY2hhcnRcblx0ICogICBUaGlzIHNwYWNlIGNvbWVzIGZyb20gdHdvIHNvdXJjZXM6XG5cdCAqICAgICAtIHBhZGRpbmcgLSBzcGFjZSB0aGF0J3MgcmVxdWlyZWQgdG8gc2hvdyB0aGUgbGFiZWxzIGF0IHRoZSBlZGdlcyBvZiB0aGUgc2NhbGVcblx0ICogICAgIC0gdGhpY2tuZXNzIG9mIHNjYWxlcyBvciBsZWdlbmRzIGluIGFub3RoZXIgb3JpZW50YXRpb25cblx0ICovXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvLCBncmFjZSwgdGlja3M6IHRpY2tPcHRzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzYW1wbGVTaXplID0gdGlja09wdHMuc2FtcGxlU2l6ZTtcblxuICAgIC8vIFVwZGF0ZSBMaWZlY3ljbGUgLSBQcm9iYWJseSBkb24ndCB3YW50IHRvIGV2ZXIgZXh0ZW5kIG9yIG92ZXJ3cml0ZSB0aGlzIGZ1bmN0aW9uIDspXG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcblxuICAgIC8vIEFic29yYiB0aGUgbWFzdGVyIG1lYXN1cmVtZW50c1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgdG9wOiAwLFxuICAgICAgYm90dG9tOiAwXG4gICAgfSwgbWFyZ2lucyk7XG5cbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcblxuICAgIC8vIERpbWVuc2lvbnNcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuXG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG5cbiAgICAvLyBEYXRhIG1pbi9tYXhcbiAgICBpZiAoIXRoaXMuX2RhdGFMaW1pdHNDYWNoZWQpIHtcbiAgICAgIHRoaXMuYmVmb3JlRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmFmdGVyRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5fcmFuZ2UgPSBfYWRkR3JhY2UodGhpcywgZ3JhY2UsIGJlZ2luQXRaZXJvKTtcbiAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuXG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuXG4gICAgLy8gQWxsb3cgbW9kaWZpY2F0aW9uIG9mIHRpY2tzIGluIGNhbGxiYWNrLlxuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG5cbiAgICAvLyBDb21wdXRlIHRpY2sgcm90YXRpb24gYW5kIGZpdCB1c2luZyBhIHNhbXBsZWQgc3Vic2V0IG9mIGxhYmVsc1xuICAgIC8vIFdlIGdlbmVyYWxseSBkb24ndCBuZWVkIHRvIGNvbXB1dGUgdGhlIHNpemUgb2YgZXZlcnkgc2luZ2xlIGxhYmVsIGZvciBkZXRlcm1pbmluZyBzY2FsZSBzaXplXG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuXG4gICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBoZXJlLCBvbmNlIGZyb20gY29yZS5jb250cm9sbGVyLnVwZGF0ZUxheW91dC5cbiAgICAvLyBIZXJlIHdlIGhhdmVuJ3QgYmVlbiBwb3NpdGlvbmVkIHlldCwgYnV0IGRpbWVuc2lvbnMgYXJlIGNvcnJlY3QuXG4gICAgLy8gVmFyaWFibGVzIHNldCBpbiBjb25maWd1cmUgYXJlIG5lZWRlZCBmb3IgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgYW5kXG4gICAgLy8gaXQncyBvayB0aGF0IGNvb3JkaW5hdGVzIGFyZSBub3QgY29ycmVjdCB0aGVyZSwgb25seSBkaW1lbnNpb25zIG1hdHRlci5cbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuXG4gICAgLy8gVGljayBSb3RhdGlvblxuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpOyAvLyBQcmVjb25kaXRpb25zOiBudW1iZXIgb2YgdGlja3MgYW5kIHNpemVzIG9mIGxhcmdlc3QgbGFiZWxzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcblxuICAgIC8vIEF1dG8tc2tpcFxuICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmICh0aWNrT3B0cy5hdXRvU2tpcCB8fCB0aWNrT3B0cy5zb3VyY2UgPT09ICdhdXRvJykpIHtcbiAgICAgIHRoaXMudGlja3MgPSBhdXRvU2tpcCh0aGlzLCB0aGlzLnRpY2tzKTtcbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgdGhpcy5hZnRlckF1dG9Ta2lwKCk7XG4gICAgfVxuXG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgLy8gR2VuZXJhdGUgbGFiZWxzIHVzaW5nIGFsbCBub24tc2tpcHBlZCB0aWNrc1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuXG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpOyAvLyBQcmVjb25kaXRpb25zOiBsYWJlbCByb3RhdGlvbiBhbmQgbGFiZWwgc2l6ZXMgbXVzdCBiZSBjYWxjdWxhdGVkIGJlZm9yZWhhbmRcbiAgICB0aGlzLmFmdGVyRml0KCk7XG5cbiAgICAvLyBJTVBPUlRBTlQ6IGFmdGVyIHRoaXMgcG9pbnQsIHdlIGNvbnNpZGVyIHRoYXQgYHRoaXMudGlja3NgIHdpbGwgTkVWRVIgY2hhbmdlIVxuXG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgLy8gYnkgZGVmYXVsdCB2ZXJ0aWNhbCBzY2FsZXMgYXJlIGZyb20gYm90dG9tIHRvIHRvcCwgc28gcGl4ZWxzIGFyZSByZXZlcnNlZFxuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cblxuICBhZnRlclVwZGF0ZSgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vXG5cbiAgYmVmb3JlU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IDA7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcblxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYmVmb3JlIGNhbGN1bGF0aW5nIHJvdGF0aW9uXG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHBhZGRpbmdcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cblxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGwodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG5cbiAgLy8gRGF0YSBsaW1pdHNcbiAgYmVmb3JlRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZURhdGFMaW1pdHMnKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgYWZ0ZXJEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gIH1cblxuICAvL1xuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX0gdGhlIHRpY2tzXG5cdCAqL1xuICBidWlsZFRpY2tzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBhZnRlckJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgfVxuXG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgLyoqXG5cdCAqIENvbnZlcnQgdGlja3MgdG8gbGFiZWwgc3RyaW5nc1xuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICovXG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IG51bVRpY2tzID0gZ2V0VGlja3NMaW1pdCh0aGlzLnRpY2tzLmxlbmd0aCwgb3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBtYXhMYWJlbFdpZHRoID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG4gICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgLy8gRXN0aW1hdGUgdGhlIHdpZHRoIG9mIGVhY2ggZ3JpZCBiYXNlZCBvbiB0aGUgY2FudmFzIHdpZHRoLCB0aGUgbWF4aW11bVxuICAgIC8vIGxhYmVsIHdpZHRoIGFuZCB0aGUgbnVtYmVyIG9mIHRpY2sgaW50ZXJ2YWxzXG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuXG4gICAgLy8gQWxsb3cgMyBwaXhlbHMgeDIgcGFkZGluZyBlaXRoZXIgc2lkZSBmb3IgbGFiZWwgcmVhZGFiaWxpdHlcbiAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpXG5cdFx0XHRcdC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZSgobGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIDYpIC8gdGlja1dpZHRoLCAtMSwgMSkpLFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4SGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSAtIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhMYWJlbEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSlcbiAgICAgICkpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgIH1cblxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cblxuICAvL1xuXG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIC8vIFJlc2V0XG4gICAgY29uc3QgbWluU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcblxuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgICBtaW5TaXplLndpZHRoID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZE9wdHMpICsgdGl0bGVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGJvdGhlciBmaXR0aW5nIHRoZSB0aWNrcyBpZiB3ZSBhcmUgbm90IHNob3dpbmcgdGhlIGxhYmVsc1xuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcblxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIC8vIEEgaG9yaXpvbnRhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIGhlaWdodC5cbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBIHZlcnRpY2FsIGF4aXMgaXMgbW9yZSBjb25zdHJhaW5lZCBieSB0aGUgd2lkdGguIExhYmVscyBhcmUgdGhlXG4gICAgICAgIC8vIGRvbWluYW50IGZhY3RvciBoZXJlLCBzbyBnZXQgdGhhdCBsZW5ndGggZmlyc3QgYW5kIGFjY291bnQgZm9yIHBhZGRpbmdcbiAgICAgICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGlja09wdHMubWlycm9yID8gMCA6IGNvcyAqIHdpZGVzdC53aWR0aCArIHNpbiAqIGhpZ2hlc3QuaGVpZ2h0O1xuXG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG5cbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IG1pblNpemUud2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LmhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b207XG4gICAgfVxuICB9XG5cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcblxuICAgICAgLy8gRW5zdXJlIHRoYXQgb3VyIHRpY2tzIGFyZSBhbHdheXMgaW5zaWRlIHRoZSBjYW52YXMuIFdoZW4gcm90YXRlZCwgdGlja3MgYXJlIHJpZ2h0IGFsaWduZWRcbiAgICAgIC8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHJpZ2h0IHBhZGRpbmcgaXMgZG9taW5hdGVkIGJ5IHRoZSBmb250IGhlaWdodFxuICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICBpZiAobGFiZWxzQmVsb3dUaWNrcykge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gc2luICogbGFzdC5oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBzaW4gKiBmaXJzdC5oZWlnaHQ7XG4gICAgICAgICAgcGFkZGluZ1JpZ2h0ID0gY29zICogbGFzdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgcGFkZGluZ0xlZnQgPSBmaXJzdC53aWR0aCAvIDI7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGp1c3QgcGFkZGluZyB0YWtpbmcgaW50byBhY2NvdW50IGNoYW5nZXMgaW4gb2Zmc2V0c1xuICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0IC8gMjtcbiAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIG1hcmdpbnMgYW5kIHBhZGRpbmcgaW50ZXJhY3Rpb25zXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaGFuZGxlTWFyZ2lucygpIHtcbiAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICB9XG4gIH1cblxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIFNoYXJlZCBNZXRob2RzXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRpY2tzKSB7XG4gICAgdGhpcy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKTtcblxuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcblxuICAgIC8vIFRpY2tzIHNob3VsZCBiZSBza2lwcGVkIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBudWxsIG9yIHVuZGVmLCBzbyBsZXRzIHJlbW92ZSB0aG9zZS5cbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICBsZXQgbGFiZWxTaXplcyA9IHRoaXMuX2xhYmVsU2l6ZXM7XG5cbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCwgdGhpcy5vcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMge3dpZHRoLCBoZWlnaHQsIG9mZnNldH0gb2JqZWN0cyBmb3IgdGhlIGZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3QgdGlja1xuXHQgKiBsYWJlbHMgd2hlcmUgb2Zmc2V0IGluZGljYXRlcyB0aGUgYW5jaG9yIHBvaW50IG9mZnNldCBmcm9tIHRoZSB0b3AgaW4gcGl4ZWxzLlxuXHQgKiBAcmV0dXJuIHt7IGZpcnN0OiBvYmplY3QsIGxhc3Q6IG9iamVjdCwgd2lkZXN0OiBvYmplY3QsIGhpZ2hlc3Q6IG9iamVjdCwgd2lkdGhzOiBBcnJheSwgaGVpZ2h0czogYXJyYXkgfX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGdldFRpY2tzTGltaXQobGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSk7XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge2RhdGE6IHt9LCBnYzogW119O1xuICAgICAgbGluZUhlaWdodCA9IHRpY2tGb250LmxpbmVIZWlnaHQ7XG4gICAgICB3aWR0aCA9IGhlaWdodCA9IDA7XG4gICAgICAvLyBVbmRlZmluZWQgbGFiZWxzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0J3MgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovIChsYWJlbFtqXSk7XG4gICAgICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWYobmVzdGVkTGFiZWwpICYmICFpc0FycmF5KG5lc3RlZExhYmVsKSkge1xuICAgICAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIG5lc3RlZExhYmVsKTtcbiAgICAgICAgICAgIGhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGhzLnB1c2god2lkdGgpO1xuICAgICAgaGVpZ2h0cy5wdXNoKGhlaWdodCk7XG4gICAgICB3aWRlc3RMYWJlbFNpemUgPSBNYXRoLm1heCh3aWR0aCwgd2lkZXN0TGFiZWxTaXplKTtcbiAgICAgIGhpZ2hlc3RMYWJlbFNpemUgPSBNYXRoLm1heChoZWlnaHQsIGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgIH1cbiAgICBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCk7XG5cbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG5cbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZpcnN0OiB2YWx1ZUF0KDApLFxuICAgICAgbGFzdDogdmFsdWVBdChsZW5ndGggLSAxKSxcbiAgICAgIHdpZGVzdDogdmFsdWVBdCh3aWRlc3QpLFxuICAgICAgaGlnaGVzdDogdmFsdWVBdChoaWdoZXN0KSxcbiAgICAgIHdpZHRocyxcbiAgICAgIGhlaWdodHMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgbGFiZWwgdG8gZGlzcGxheSBpbiB0aGUgdG9vbHRpcCBmb3IgdGhlIGdpdmVuIHZhbHVlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBwb2ludC4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHsqfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVc2VkIHRvIGdldCB0aGUgZGF0YSB2YWx1ZSBmcm9tIGEgZ2l2ZW4gcGl4ZWwuIFRoaXMgaXMgdGhlIGludmVyc2Ugb2YgZ2V0UGl4ZWxGb3JWYWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGxvY2F0aW9uIG9mIHRoZSB0aWNrIGF0IHRoZSBnaXZlbiBpbmRleFxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiBhIHBlcmNlbnRhZ2Ugb2Ygc2NhbGVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkZWNpbWFsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG5cbiAgICBjb25zdCBwaXhlbCA9IHRoaXMuX3N0YXJ0UGl4ZWwgKyBkZWNpbWFsICogdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiBfaW50MTZSYW5nZSh0aGlzLl9hbGlnblRvUGl4ZWxzID8gX2FsaWduUGl4ZWwodGhpcy5jaGFydCwgcGl4ZWwsIDApIDogcGl4ZWwpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgcGl4ZWwgZm9yIHRoZSBtaW5pbXVtIGNoYXJ0IHZhbHVlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRCYXNlVmFsdWUoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG5cbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBuZWVkZWQgYnkgbGFiZWwgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG5cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGZvciAxIHRpY2sgaW4gYXhpcyBkaXJlY3Rpb24uXG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcblxuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb24sIGJvcmRlcn0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICBjb25zdCB0bCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWQpO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZGlzcGxheSA/IGJvcmRlck9wdHMud2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy50b3ApO1xuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5ib3R0b20pIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHRoaXMudG9wICsgdGw7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5yaWdodCk7XG4gICAgICB0eDEgPSB0aGlzLnJpZ2h0IC0gdGw7XG4gICAgICB0eDIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmxlZnQpICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGltaXQgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQsIHRpY2tzTGVuZ3RoKTtcbiAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpKTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoT2Zmc2V0O1xuXG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgbGluZVZhbHVlID0gZ2V0UGl4ZWxGb3JHcmlkTGluZSh0aGlzLCBpLCBvZmZzZXQpO1xuXG4gICAgICAvLyBTa2lwIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHkxID0gdHkyID0geTEgPSB5MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuXG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICB5ID0gdGhpcy5ib3R0b20gLSBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeSA9ICgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMikgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSAoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpIC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHggPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKS50ZXh0QWxpZ247XG4gICAgfVxuXG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gb3B0aW9uVGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgcGl4ZWwgPSB0aGlzLmdldFBpeGVsRm9yVGljayhpKSArIG9wdGlvblRpY2tzLmxhYmVsT2Zmc2V0O1xuICAgICAgZm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBsaW5lSGVpZ2h0ID0gZm9udC5saW5lSGVpZ2h0O1xuICAgICAgbGluZUNvdW50ID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbC5sZW5ndGggOiAxO1xuICAgICAgY29uc3QgaGFsZkNvdW50ID0gbGluZUNvdW50IC8gMjtcbiAgICAgIGNvbnN0IGNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgbGV0IHRpY2tUZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuXG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0IC8gMiAtIGhhbGZDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmVseS1pZlxuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCAmJiAhb3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgICB4ICs9IChsaW5lSGVpZ2h0IC8gMikgKiBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkgPSBwaXhlbDtcbiAgICAgICAgdGV4dE9mZnNldCA9ICgxIC0gbGluZUNvdW50KSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICBsZXQgYmFja2Ryb3A7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuXG4gICAgICAgIGxldCB0b3AgPSB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSAwIC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2lubmVyJzpcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFja2Ryb3AgPSB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgbGFiZWxQYWRkaW5nLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgbGFiZWxQYWRkaW5nLmhlaWdodCxcblxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIGZvbnQsXG4gICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICBzdHJva2VDb2xvcixcbiAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgICAgYmFja2Ryb3AsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuXG4gICAgaWYgKHJvdGF0aW9uKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9XG5cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcblxuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsaWduO1xuICB9XG5cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcblxuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG5cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgaWYgKG1pcnJvcikge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyB0aWNrQW5kUGFkZGluZztcblxuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG5cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIHJldHVybiB7dG9wOiAwLCBsZWZ0OiB0aGlzLmxlZnQsIGJvdHRvbTogY2hhcnQuaGVpZ2h0LCByaWdodDogdGhpcy5yaWdodH07XG4gICAgfSBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIHt0b3A6IHRoaXMudG9wLCBsZWZ0OiAwLCBib3R0b206IHRoaXMuYm90dG9tLCByaWdodDogY2hhcnQud2lkdGh9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7YmFja2dyb3VuZENvbG9yfSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0fSA9IHRoaXM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBjdHguZmlsbFJlY3QobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JpZC5kcmF3VGlja3MpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MSwgeTogaXRlbS50eTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0udHgyLCB5OiBpdGVtLnR5Mn0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbG9yOiBpdGVtLnRpY2tDb2xvcixcbiAgICAgICAgICAgICAgd2lkdGg6IGl0ZW0udGlja1dpZHRoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBpdGVtLnRpY2tCb3JkZXJEYXNoT2Zmc2V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge1xuICAgIGNvbnN0IHtjaGFydCwgY3R4LCBvcHRpb25zOiB7Ym9yZGVyLCBncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBpZiAoIWF4aXNXaWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0TGluZVdpZHRoID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgwKSkubGluZVdpZHRoO1xuICAgIGNvbnN0IGJvcmRlclZhbHVlID0gdGhpcy5fYm9yZGVyVmFsdWU7XG4gICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy53aWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmNvbG9yO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuXG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5fY29tcHV0ZUxhYmVsQXJlYSgpO1xuICAgIGlmIChhcmVhKSB7XG4gICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBjb25zdCByZW5kZXJUZXh0T3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgY29uc3QgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIHJlbmRlclRleHRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcblxuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnQgPSB0b0ZvbnQodGl0bGUuZm9udCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICBjb25zdCBhbGlnbiA9IHRpdGxlLmFsaWduO1xuICAgIGxldCBvZmZzZXQgPSBmb250LmxpbmVIZWlnaHQgLyAyO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG5cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxuXG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9sYXllcnMoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgY29uc3QgZ3ogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmdyaWQgJiYgb3B0cy5ncmlkLnosIC0xKTtcbiAgICBjb25zdCBieiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuYm9yZGVyICYmIG9wdHMuYm9yZGVyLnosIDApO1xuXG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBkcmF3IGhhcyBiZWVuIG92ZXJyaWRkZW4gYnkgY3VzdG9tIHNjYWxlXG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt7XG4gICAgICB6OiBneixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogYnosXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHZpc2libGUgZGF0YXNldCBtZXRhcyB0aGF0IGFyZSBhdHRhY2hlZCB0byB0aGlzIHNjYWxlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZV0gLSBpZiBzcGVjaWZpZWQsIGFsc28gZmlsdGVyIGJ5IGRhdGFzZXQgdHlwZVxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKiBAcHJvdGVjdGVkXG4gXHQgKi9cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG4iLCAiaW1wb3J0IHttZXJnZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXN9IGZyb20gJy4vY29yZS5kZWZhdWx0cy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tpZDogc3RyaW5nLCBkZWZhdWx0czogYW55LCBvdmVycmlkZXM/OiBhbnksIGRlZmF1bHRSb3V0ZXM6IGFueX19IElDaGFydENvbXBvbmVudFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBpc0ZvclR5cGUodHlwZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmlzUHJvdG90eXBlT2YuY2FsbCh0aGlzLnR5cGUucHJvdG90eXBlLCB0eXBlLnByb3RvdHlwZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIHNjb3BlIHdoZXJlIGl0ZW1zIGRlZmF1bHRzIHdlcmUgcmVnaXN0ZXJlZCB0by5cblx0ICovXG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG5cbiAgICBpZiAoaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHBhcmVudCBpcyByZWdpc3RlcmVkIGFuZCBub3RlIHRoZSBzY29wZSB3aGVyZSBpdHMgZGVmYXVsdHMgYXJlLlxuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuXG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICAvLyBhbHJlYWR5IHJlZ2lzdGVyZWRcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG5cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdD99XG5cdCAqL1xuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtJQ2hhcnRDb21wb25lbnR9IGl0ZW1cblx0ICovXG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuXG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cblxuICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlc1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRlZmF1bHRzIGFuZCBrZWVwIGV4aXN0aW5nIGRlZmF1bHRzXG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG5cbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuXG4gIGlmIChpdGVtLmRlZmF1bHRSb3V0ZXMpIHtcbiAgICByb3V0ZURlZmF1bHRzKHNjb3BlLCBpdGVtLmRlZmF1bHRSb3V0ZXMpO1xuICB9XG5cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc0lDaGFydENvbXBvbmVudChwcm90bykge1xuICByZXR1cm4gJ2lkJyBpbiBwcm90byAmJiAnZGVmYXVsdHMnIGluIHByb3RvO1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4vY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgVHlwZWRSZWdpc3RyeSBmcm9tICcuL2NvcmUudHlwZWRSZWdpc3RyeS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGwsIF9jYXBpdGFsaXplfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgdGhpcy5lbGVtZW50cyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KEVsZW1lbnQsICdlbGVtZW50cycpO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KE9iamVjdCwgJ3BsdWdpbnMnKTtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgLy8gT3JkZXIgaXMgaW1wb3J0YW50LCBTY2FsZSBoYXMgRWxlbWVudCBpbiBwcm90b3R5cGUgY2hhaW4sXG4gICAgLy8gc28gU2NhbGVzIG11c3QgYmUgYmVmb3JlIEVsZW1lbnRzLiBQbHVnaW5zIGFyZSBhIGZhbGxiYWNrLCBzbyBub3QgbGlzdGVkIGhlcmUuXG4gICAgdGhpcy5fdHlwZWRSZWdpc3RyaWVzID0gW3RoaXMuY29udHJvbGxlcnMsIHRoaXMuc2NhbGVzLCB0aGlzLmVsZW1lbnRzXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgYWRkQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIEVsZW1lbnR9IGFyZ3Ncblx0ICovXG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn1cblx0ICovXG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIEVsZW1lbnR9XG5cdCAqL1xuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJucyB7dHlwZW9mIFNjYWxlfVxuXHQgKi9cbiAgZ2V0U2NhbGUoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnNjYWxlcywgJ3NjYWxlJyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIERhdGFzZXRDb250cm9sbGVyfSBhcmdzXG5cdCAqL1xuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICByZW1vdmVFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4udHlwZW9mIFNjYWxlfSBhcmdzXG5cdCAqL1xuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgbG9vcGFibGUgYXJnc1xuICAgICAgICAvLyBVc2UgY2FzZTpcbiAgICAgICAgLy8gIGltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zLmpzJztcbiAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHBsdWdpbnMpO1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG1peGVkIHR5cGVzIGluIHRoZSBsb29wYWJsZSwgbWFrZSBzdXJlIHRob3NlIGFyZVxuICAgICAgICAgIC8vIHJlZ2lzdGVyZWQgaW4gY29ycmVjdCByZWdpc3RyeVxuICAgICAgICAgIC8vIFVzZSBjYXNlOiAodHJlZW1hcCBleHBvcnRpbmcgY29udHJvbGxlciwgZWxlbWVudHMgZXRjKVxuICAgICAgICAgIC8vICBpbXBvcnQgKiBhcyB0cmVlbWFwIGZyb20gJ2NoYXJ0anMtY2hhcnQtdHJlZW1hcC5qcyc7XG4gICAgICAgICAgLy8gIENoYXJ0LnJlZ2lzdGVyKHRyZWVtYXApO1xuXG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9leGVjKG1ldGhvZCwgcmVnaXN0cnksIGNvbXBvbmVudCkge1xuICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGJlZm9yZVJlZ2lzdGVyIC8gYmVmb3JlVW5yZWdpc3RlclxuICAgIHJlZ2lzdHJ5W21ldGhvZF0oY29tcG9uZW50KTtcbiAgICBjYWxsKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTsgLy8gYWZ0ZXJSZWdpc3RlciAvIGFmdGVyVW5yZWdpc3RlclxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcGx1Z2lucyBpcyB0aGUgZmFsbGJhY2sgcmVnaXN0cnlcbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuIiwgImltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IHtjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsdWdpbnMvcGx1Z2luLnRvb2x0aXAuanMnKS5kZWZhdWx0IH0gVG9vbHRpcFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGZpbHRlckNhbGxiYWNrXG4gKiBAcGFyYW0ge3twbHVnaW46IG9iamVjdCwgb3B0aW9uczogb2JqZWN0fX0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG4gKiBAcGFyYW0ge2FycmF5fSBbYXJyYXldXG4gKiBAcGFyYW0ge29iamVjdH0gW3RoaXNBcmddXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgZm9yIGBjaGFydGAgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UgZm9yIHdoaWNoIHBsdWdpbnMgc2hvdWxkIGJlIGNhbGxlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ZpbHRlckNhbGxiYWNrfSBbZmlsdGVyXSAtIEZpbHRlcmluZyBmdW5jdGlvbiBmb3IgbGltaXRpbmcgd2hpY2ggcGx1Z2lucyBhcmUgbm90aWZpZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59IGZhbHNlIGlmIGFueSBvZiB0aGUgcGx1Z2lucyByZXR1cm4gZmFsc2UsIGVsc2UgcmV0dXJucyB0cnVlLlxuXHQgKi9cbiAgbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICBpZiAoaG9vayA9PT0gJ2JlZm9yZUluaXQnKSB7XG4gICAgICB0aGlzLl9pbml0ID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHRydWUpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAnaW5zdGFsbCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuXG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsQ2FsbGJhY2sobWV0aG9kLCBwYXJhbXMsIHBsdWdpbikgPT09IGZhbHNlICYmIGFyZ3MuY2FuY2VsYWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbnZhbGlkYXRlKCkge1xuICAgIC8vIFdoZW4gcGx1Z2lucyBhcmUgcmVnaXN0ZXJlZCwgdGhlcmUgaXMgdGhlIHBvc3NpYmlsaXR5IG9mIGEgZG91YmxlXG4gICAgLy8gaW52YWxpZGF0ZSBzaXR1YXRpb24uIEluIHRoaXMgY2FzZSwgd2Ugb25seSB3YW50IHRvIGludmFsaWRhdGUgb25jZS5cbiAgICAvLyBJZiB3ZSBpbnZhbGlkYXRlIG11bHRpcGxlIHRpbWVzLCB0aGUgYF9vbGRDYWNoZWAgaXMgbG9zdCBhbmQgYWxsIG9mIHRoZVxuICAgIC8vIHBsdWdpbnMgYXJlIHJlc3RhcnRlZCB3aXRob3V0IGJlaW5nIGNvcnJlY3RseSBzdG9wcGVkLlxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODE0N1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG5cbiAgICB0aGlzLl9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG5cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIC8vIG9wdGlvbnMgPT09IGZhbHNlID0+IGFsbCBwbHVnaW5zIGFyZSBkaXNhYmxlZFxuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2NvcmUuY29uZmlnLmpzJykuZGVmYXVsdH0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFsbFBsdWdpbnMoY29uZmlnKSB7XG4gIGNvbnN0IGxvY2FsSWRzID0ge307XG4gIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJlZ2lzdHJ5LnBsdWdpbnMuaXRlbXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgfVxuXG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtwbHVnaW5zLCBsb2NhbElkc307XG59XG5cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG5cbiAgZm9yIChjb25zdCBwbHVnaW4gb2YgcGx1Z2lucykge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IG9wdHMgPSBnZXRPcHRzKG9wdGlvbnNbaWRdLCBhbGwpO1xuICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgcGx1Z2luLFxuICAgICAgb3B0aW9uczogcGx1Z2luT3B0cyhjaGFydC5jb25maWcsIHtwbHVnaW4sIGxvY2FsOiBsb2NhbElkc1tpZF19LCBvcHRzLCBjb250ZXh0KVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgLy8gbWFrZSBzdXJlIHBsdWdpbiBkZWZhdWx0cyBhcmUgaW4gc2NvcGVzIGZvciBsb2NhbCAobm90IHJlZ2lzdGVyZWQpIHBsdWdpbnNcbiAgICBzY29wZXMucHVzaChwbHVnaW4uZGVmYXVsdHMpO1xuICB9XG4gIHJldHVybiBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBbJyddLCB7XG4gICAgLy8gVGhlc2UgYXJlIGp1c3QgZGVmYXVsdHMgdGhhdCBwbHVnaW5zIGNhbiBvdmVycmlkZVxuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMsIHtvdmVycmlkZXMsIGRlc2NyaXB0b3JzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHttZXJnZUlmLCByZXNvbHZlT2JqZWN0S2V5LCBpc0FycmF5LCBpc0Z1bmN0aW9uLCB2YWx1ZU9yRGVmYXVsdCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7X2F0dGFjaENvbnRleHQsIF9jcmVhdGVSZXNvbHZlciwgX2Rlc2NyaXB0b3JzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29uZmlnLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9O1xuICBjb25zdCBkYXRhc2V0T3B0aW9ucyA9IChvcHRpb25zLmRhdGFzZXRzIHx8IHt9KVt0eXBlXSB8fCB7fTtcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGluZGV4QXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gaW5kZXhBeGlzID8gJ19pbmRleF8nIDogJ192YWx1ZV8nO1xufVxuXG5mdW5jdGlvbiBpZE1hdGNoZXNBeGlzKGlkKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScgfHwgaWQgPT09ICdyJykge1xuICAgIHJldHVybiBpZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBheGlzRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAneSc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIC4uLnNjYWxlT3B0aW9ucykge1xuICBpZiAoaWRNYXRjaGVzQXhpcyhpZCkpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgZm9yIChjb25zdCBvcHRzIG9mIHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGF4aXMgPSBvcHRzLmF4aXNcbiAgICAgIHx8IGF4aXNGcm9tUG9zaXRpb24ob3B0cy5wb3NpdGlvbilcbiAgICAgIHx8IGlkLmxlbmd0aCA+IDEgJiYgaWRNYXRjaGVzQXhpcyhpZFswXS50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAoYXhpcykge1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRldGVybWluZSB0eXBlIG9mICcke2lkfScgYXhpcy4gUGxlYXNlIHByb3ZpZGUgJ2F4aXMnIG9yICdwb3NpdGlvbicgb3B0aW9uLmApO1xufVxuXG5mdW5jdGlvbiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsIGF4aXMsIGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSA9PT0gaWQpIHtcbiAgICByZXR1cm4ge2F4aXN9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSB7XG4gIGlmIChjb25maWcuZGF0YSAmJiBjb25maWcuZGF0YS5kYXRhc2V0cykge1xuICAgIGNvbnN0IGJvdW5kRHMgPSBjb25maWcuZGF0YS5kYXRhc2V0cy5maWx0ZXIoKGQpID0+IGQueEF4aXNJRCA9PT0gaWQgfHwgZC55QXhpc0lEID09PSBpZCk7XG4gICAgaWYgKGJvdW5kRHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneCcsIGJvdW5kRHNbMF0pIHx8IGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3knLCBib3VuZERzWzBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBjaGFydERlZmF1bHRzID0gb3ZlcnJpZGVzW2NvbmZpZy50eXBlXSB8fCB7c2NhbGVzOiB7fX07XG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHNjYWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gRmlyc3QgZmlndXJlIG91dCBmaXJzdCBzY2FsZSBpZCdzIHBlciBheGlzLlxuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZiwgcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpLCBkZWZhdWx0cy5zY2FsZXNbc2NhbGVDb25mLnR5cGVdKTtcbiAgICBjb25zdCBkZWZhdWx0SWQgPSBnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzKGF4aXMsIGNoYXJ0SW5kZXhBeGlzKTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gY2hhcnREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG5cbiAgLy8gVGhlbiBtZXJnZSBkYXRhc2V0IGRlZmF1bHRzIHRvIHNjYWxlIGNvbmZpZ3NcbiAgY29uZmlnLmRhdGEuZGF0YXNldHMuZm9yRWFjaChkYXRhc2V0ID0+IHtcbiAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IGNvbmZpZy50eXBlO1xuICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBvdmVycmlkZXNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGRhdGFzZXREZWZhdWx0cy5zY2FsZXMgfHwge307XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaChkZWZhdWx0SUQgPT4ge1xuICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgYXhpcztcbiAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFt7YXhpc30sIGNvbmZpZ1NjYWxlc1tpZF0sIGRlZmF1bHRTY2FsZU9wdGlvbnNbZGVmYXVsdElEXV0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhcHBseSBzY2FsZSBkZWZhdWx0cywgaWYgbm90IG92ZXJyaWRkZW4gYnkgZGF0YXNldCBkZWZhdWx0c1xuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIG1lcmdlSWYoc2NhbGUsIFtkZWZhdWx0cy5zY2FsZXNbc2NhbGUudHlwZV0sIGRlZmF1bHRzLnNjYWxlXSk7XG4gIH0pO1xuXG4gIHJldHVybiBzY2FsZXM7XG59XG5cbmZ1bmN0aW9uIGluaXRPcHRpb25zKGNvbmZpZykge1xuICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuXG4gIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIGNvbmZpZy5kYXRhID0gaW5pdERhdGEoY29uZmlnLmRhdGEpO1xuXG4gIGluaXRPcHRpb25zKGNvbmZpZyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuY29uc3Qga2V5Q2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBrZXlzQ2FjaGVkID0gbmV3IFNldCgpO1xuXG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICBsZXQga2V5cyA9IGtleUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBnZW5lcmF0ZSgpO1xuICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb25maWcge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSBpbml0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cblxuICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgdGhpcy5fY29uZmlnLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9wdGlvbnM7XG4gIH1cblxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2NvbmZpZztcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICB9XG5cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBvcHRpb25zLlxuICAgKiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdCBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEByZXR1cm4ge3N0cmluZ1tdW119XG4gICAqL1xuICBkYXRhc2V0U2NvcGVLZXlzKGRhdGFzZXRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoZGF0YXNldFR5cGUsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbiBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgZGF0YXNldCBhbmltYXRpb24gb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNpdGlvblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgdHJhbnNpdGlvbikge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmUgdXNlZCBmb3IgbG9va2luZyB1cCB0aGUgYGFuaW1hdGlvbnNgIGFuZCBgYW5pbWF0aW9uYCBrZXlzXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICcnXG4gICAgICAgIF1cbiAgICAgIF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGVsZW1lbnQgb3B0aW9ucyB0aGF0IGJlbG9uZ1xuICAgKiB0byBhbiBkYXRhc2V0LiBUaGVzZSBrZXlzIGRvIG5vdCBpbmNsdWRlIHRoZSBkYXRhc2V0IGl0c2VsZiwgYmVjYXVzZSBpdFxuICAgKiBpcyBub3QgdW5kZXIgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXRUeXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9ucyBzY29wZSBrZXlzIGZvciByZXNvbHZpbmcgcGx1Z2luIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7e2lkOiBzdHJpbmcsIGFkZGl0aW9uYWxPcHRpb25TY29wZXM/OiBzdHJpbmdbXX19IHBsdWdpblxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7aWR9YCxcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXG4gICAgICBdXSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgY29uc3QgX3Njb3BlQ2FjaGUgPSB0aGlzLl9zY29wZUNhY2hlO1xuICAgIGxldCBjYWNoZSA9IF9zY29wZUNhY2hlLmdldChtYWluU2NvcGUpO1xuICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgb2JqZWN0cyBmcm9tIG9wdGlvbnMgYW5kIGRlZmF1bHRzIGZvciBvcHRpb24gdmFsdWUgcmVzb2x1dGlvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1haW5TY29wZSAtIFRoZSBtYWluIHNjb3BlIG9iamVjdCBmb3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdW119IGtleUxpc3RzIC0gVGhlIGFycmF5cyBvZiBrZXlzIGluIHJlc29sdXRpb24gb3JkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVzZXRDYWNoZV0gLSByZXNldCB0aGUgY2FjaGUgZm9yIHRoaXMgbWFpblNjb3BlXG4gICAqL1xuICBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZS5nZXQoa2V5TGlzdHMpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2NvcGVzID0gbmV3IFNldCgpO1xuXG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHNjb3Blcyk7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICB9XG4gICAgaWYgKGtleXNDYWNoZWQuaGFzKGtleUxpc3RzKSkge1xuICAgICAgY2FjaGUuc2V0KGtleUxpc3RzLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGVzIGZvciByZXNvbHZpbmcgY2hhcnQgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAgICovXG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LCAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvODUzMVxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IG5hbWVzXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb258b2JqZWN0fSBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgLy8gc3ViUmVzb2x2ZXIgaXMgcGFzc2VkIHRvIHNjcmlwdGFibGUgb3B0aW9ucy4gSXQgc2hvdWxkIG5vdCByZXNvbHZlIHRvIGhvdmVyIG9wdGlvbnMuXG4gICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3RbXX0gc2NvcGVzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gW3ByZWZpeGVzXVxuICAgKiBAcGFyYW0ge3tzY3JpcHRhYmxlOiBib29sZWFuLCBpbmRleGFibGU6IGJvb2xlYW4sIGFsbEtleXM/OiBib29sZWFufX0gW2Rlc2NyaXB0b3JEZWZhdWx0c11cbiAgICovXG4gIGNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddLCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCB7cmVzb2x2ZXJ9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbnRleHQpXG4gICAgICA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICAgIDogcmVzb2x2ZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xuICBsZXQgY2FjaGUgPSByZXNvbHZlckNhY2hlLmdldChzY29wZXMpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmVzb2x2ZXJDYWNoZS5zZXQoc2NvcGVzLCBjYWNoZSk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGNhY2hlZCA9IHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cblxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnNvbWUoKGtleSkgPT4gaXNGdW5jdGlvbih2YWx1ZVtrZXldKSk7XG5cbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICBjb25zdCB7aXNTY3JpcHRhYmxlLCBpc0luZGV4YWJsZX0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuXG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XG4gICAgY29uc3QgdmFsdWUgPSAoaW5kZXhhYmxlIHx8IHNjcmlwdGFibGUpICYmIHByb3h5W3Byb3BdO1xuICAgIGlmICgoc2NyaXB0YWJsZSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaGFzRnVuY3Rpb24odmFsdWUpKSlcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCBhbmltYXRvciBmcm9tICcuL2NvcmUuYW5pbWF0b3IuanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IEludGVyYWN0aW9uIGZyb20gJy4vY29yZS5pbnRlcmFjdGlvbi5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge19kZXRlY3RQbGF0Zm9ybX0gZnJvbSAnLi4vcGxhdGZvcm0vaW5kZXguanMnO1xuaW1wb3J0IFBsdWdpblNlcnZpY2UgZnJvbSAnLi9jb3JlLnBsdWdpbnMuanMnO1xuaW1wb3J0IHJlZ2lzdHJ5IGZyb20gJy4vY29yZS5yZWdpc3RyeS5qcyc7XG5pbXBvcnQgQ29uZmlnLCB7ZGV0ZXJtaW5lQXhpcywgZ2V0SW5kZXhBeGlzfSBmcm9tICcuL2NvcmUuY29uZmlnLmpzJztcbmltcG9ydCB7cmV0aW5hU2NhbGUsIF9pc0RvbVN1cHBvcnRlZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmRvbS5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgdWlkLCB2YWx1ZU9yRGVmYXVsdCwgX2VsZW1lbnRzRXF1YWwsIGlzTnVsbE9yVW5kZWYsIHNldHNFcXVhbCwgZGVmaW5lZCwgaXNGdW5jdGlvbiwgX2lzQ2xpY2tFdmVudH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjbGVhckNhbnZhcywgY2xpcEFyZWEsIGNyZWF0ZUNvbnRleHQsIHVuY2xpcEFyZWEsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7dmVyc2lvbn0gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJztcbmltcG9ydCB7ZGVib3VuY2V9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkNoYXJ0RXZlbnQgfSBDaGFydEV2ZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5Qb2ludCB9IFBvaW50XG4gKi9cblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxDYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Db21wbGV0ZSwgW2NvbnRleHRdLCBjaGFydCk7XG59XG5cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbENhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cblxuLyoqXG4gKiBDaGFydC5qcyBjYW4gdGFrZSBhIHN0cmluZyBpZCBvZiBhIGNhbnZhcyBlbGVtZW50LCBhIDJkIGNvbnRleHQsIG9yIGEgY2FudmFzIGVsZW1lbnQgaXRzZWxmLlxuICogQXR0ZW1wdCB0byB1bndyYXAgdGhlIGl0ZW0gcGFzc2VkIGludG8gdGhlIGNoYXJ0IGNvbnN0cnVjdG9yIHNvIHRoYXQgaXQgaXMgYSBjYW52YXMgZWxlbWVudCAoaWYgcG9zc2libGUpLlxuICovXG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBhcnJheSBiYXNlZCBxdWVyaWVzIChzdWNoIGFzIGpRdWVyeSlcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuXG4gIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgYW55IG9iamVjdCBhc3NvY2lhdGVkIHRvIGEgY2FudmFzIChpbmNsdWRpbmcgYSBjb250ZXh0MmQpXG4gICAgaXRlbSA9IGl0ZW0uY2FudmFzO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcblxuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFydEV2ZW50fSBlXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR8bnVsbH0gbGFzdEV2ZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluQ2hhcnRBcmVhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ2xpY2tcbiAqIEByZXR1cm5zIHtDaGFydEV2ZW50fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUxhc3RFdmVudChlLCBsYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKSB7XG4gIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGlzQ2xpY2spIHtcbiAgICByZXR1cm4gbGFzdEV2ZW50O1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplRm9yQXJlYShzY2FsZSwgY2hhcnRBcmVhLCBmaWVsZCkge1xuICByZXR1cm4gc2NhbGUub3B0aW9ucy5jbGlwID8gc2NhbGVbZmllbGRdIDogY2hhcnRBcmVhW2ZpZWxkXTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YXNldEFyZWEobWV0YSwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICBpZiAoeFNjYWxlICYmIHlTY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ2xlZnQnKSxcbiAgICAgIHJpZ2h0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ3JpZ2h0JyksXG4gICAgICB0b3A6IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAndG9wJyksXG4gICAgICBib3R0b206IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAnYm90dG9tJylcbiAgICB9O1xuICB9XG4gIHJldHVybiBjaGFydEFyZWE7XG59XG5cbmNsYXNzIENoYXJ0IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgc3RhdGljIGluc3RhbmNlcyA9IGluc3RhbmNlcztcbiAgc3RhdGljIG92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgc3RhdGljIHJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gIHN0YXRpYyB2ZXJzaW9uID0gdmVyc2lvbjtcbiAgc3RhdGljIGdldENoYXJ0ID0gZ2V0Q2hhcnQ7XG5cbiAgc3RhdGljIHJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgc3RhdGljIHVucmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG5cbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXNseSB1c2VkIGFzcGVjdCByYXRpbyB0byBkZXRlcm1pbmUgaWYgYSByZXNpemVcbiAgICAvLyBpcyBuZWVkZWQgZHVyaW5nIHVwZGF0ZXMuIERvIHRoaXMgYWZ0ZXIgX29wdGlvbnMgaXMgc2V0IHNpbmNlXG4gICAgLy8gYXNwZWN0UmF0aW8gdXNlcyBhIGdldHRlclxuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgLyoqIEB0eXBlIHs/e2F0dGFjaD86IGZ1bmN0aW9uLCBkZXRhY2g/OiBmdW5jdGlvbiwgcmVzaXplPzogZnVuY3Rpb259fSAqL1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuXG4gICAgLy8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgLy8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG4gICAgICAvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuICAgICAgLy8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIC8vIElmIGFzcGVjdFJhdGlvIGlzIGRlZmluZWQgaW4gb3B0aW9ucywgdXNlIHRoYXQuXG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICAvLyBJZiBtYWludGFpbkFzcGVjdFJhdGlvIGlzIHRydXRobHkgYW5kIHdlIGhhZCBwcmV2aW91c2x5IGRldGVybWluZWQgX2FzcGVjdFJhdGlvLCB1c2UgdGhhdFxuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGVcbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCByZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuXG4gICAgLy8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0IHRvIGl0cyBjb250YWluZXIgb3IgdG8gZXhwbGljaXQgZGltZW5zaW9ucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdXG5cdCAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuXG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG5cbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcblxuICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICAvLyBUaGUgcmVzaXplIHVwZGF0ZSBpcyBkZWxheWVkLCBvbmx5IGRyYXcgd2l0aG91dCB1cGRhdGluZy5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuXG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0ICovXG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuXG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgLy8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG5cbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG5cbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG5cbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcywge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG5cdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0cyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcblxuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcblxuICAgIC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgaGF2ZSBjb3JyZWN0IG1ldGEgZGF0YSBjb3VudHNcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIC8vIE5ldyBjb250cm9sbGVycyB3aWxsIGJlIHJlc2V0IGFmdGVyIHRoZSBsYXlvdXQgcGFzcywgc28gd2Ugb25seSB3YW50IHRvIG1vZGlmeVxuICAgICAgLy8gZWxlbWVudHMgYWRkZWQgdG8gbmV3IGRhdGFzZXRzXG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG5cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSBjb250cm9sbGVycyBpZiB3ZSBoYXZlIGFuaW1hdGlvbnNcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuICAgICAgLy8gUmVzZXQgaXMgZG9uZSB0byBnZXQgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgaW5pdGlhbCBhbmltYXRpb25cbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuXG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuXG4gICAgLy8gUmVwbGF5IGxhc3QgZXZlbnQgZnJvbSBiZWZvcmUgdXBkYXRlLCBvciBzZXQgaG92ZXIgc3R5bGVzIG9uIGFjdGl2ZSBlbGVtZW50c1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG5cbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgLy8gVGhlIGNvbmZpZ3VyZWQgZXZlbnRzIGhhdmUgY2hhbmdlZC4gUmViaW5kLlxuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG5cbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICAvLyBTa2lwIGRyYXdpbmcgYW5kIGNvbmZpZ3VyaW5nIGNoYXJ0QXJlYSBib3hlcyB3aGVuIGNoYXJ0QXJlYSBpcyB6ZXJvIG9yIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBpbiBjb3JlLnNjYWxlLnVwZGF0ZSBhbmQgb25jZSBoZXJlLlxuICAgICAgLy8gSGVyZSB0aGUgYm94ZXMgYXJlIGZ1bGx5IHVwZGF0ZWQgYW5kIGF0IHRoZWlyIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzVXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgLy8gVW5zZXQgcGVuZGluZyByZXNpemUgcmVxdWVzdCBub3cgdG8gYXZvaWQgcG9zc2libGUgcmVjdXJzaW9uIHdpdGhpbiBfcmVzaXplXG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQmVjYXVzZSBvZiBwbHVnaW4gaG9va3MgKGJlZm9yZS9hZnRlckRhdGFzZXRzRHJhdyksIGRhdGFzZXRzIGNhbid0XG4gICAgLy8gY3VycmVudGx5IGJlIHBhcnQgb2YgbGF5ZXJzLiBJbnN0ZWFkLCB3ZSBkcmF3XG4gICAgLy8gbGF5ZXJzIDw9IDAgYmVmb3JlKGRlZmF1bHQsIGJhY2t3YXJkIGNvbXBhdCksIGFuZCB0aGUgcmVzdCBhZnRlclxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aCAmJiBsYXllcnNbaV0ueiA8PSAwOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmF3RGF0YXNldHMoKTtcblxuICAgIC8vIFJlc3Qgb2YgbGF5ZXJzXG4gICAgZm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRHJhdycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1ldGEudmlzaWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIHZpc2libGUgZGF0YXNldCBtZXRhcyBpbiBkcmF3aW5nIG9yZGVyXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNEcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c0RyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdEYXRhc2V0cygpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c0RyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXREcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGNsaXAgPSBtZXRhLl9jbGlwO1xuICAgIGNvbnN0IHVzZUNsaXAgPSAhY2xpcC5kaXNhYmxlZDtcbiAgICBjb25zdCBhcmVhID0gZ2V0RGF0YXNldEFyZWEobWV0YSwgdGhpcy5jaGFydEFyZWEpO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBtZXRhLFxuICAgICAgaW5kZXg6IG1ldGEuaW5kZXgsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwge1xuICAgICAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIGNsaXAubGVmdCxcbiAgICAgICAgcmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gdGhpcy53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxuICAgICAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIGNsaXAudG9wLFxuICAgICAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IHRoaXMuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWV0YS5jb250cm9sbGVyLmRyYXcoKTtcblxuICAgIGlmICh1c2VDbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXREcmF3JywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGlzIGluIHRoZSBjaGFydCBhcmVhLlxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzIChzZWUsIGUuZy4sIGdldFJlbGF0aXZlUG9zaXRpb24pXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNQb2ludEluQXJlYShwb2ludCkge1xuICAgIHJldHVybiBfaXNQb2ludEluQXJlYShwb2ludCwgdGhpcy5jaGFydEFyZWEsIHRoaXMuX21pblBhZGRpbmcpO1xuICB9XG5cbiAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBtb2RlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuXG4gICAgaWYgKCFtZXRhKSB7XG4gICAgICBtZXRhID0ge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgaGlkZGVuOiBudWxsLFx0XHRcdC8vIFNlZSBpc0RhdGFzZXRWaXNpYmxlKCkgY29tbWVudFxuICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICBvcmRlcjogZGF0YXNldCAmJiBkYXRhc2V0Lm9yZGVyIHx8IDAsXG4gICAgICAgIGluZGV4OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICBfcGFyc2VkOiBbXSxcbiAgICAgICAgX3NvcnRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBtZXRhc2V0cy5wdXNoKG1ldGEpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhO1xuICB9XG5cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge2NoYXJ0OiB0aGlzLCB0eXBlOiAnY2hhcnQnfSkpO1xuICB9XG5cbiAgZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xuICB9XG5cbiAgaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuICAgIC8vIG1ldGEuaGlkZGVuIGlzIGEgcGVyIGNoYXJ0IGRhdGFzZXQgaGlkZGVuIGZsYWcgb3ZlcnJpZGUgd2l0aCAzIHN0YXRlczogaWYgdHJ1ZSBvciBmYWxzZSxcbiAgICAvLyB0aGUgZGF0YXNldC5oaWRkZW4gdmFsdWUgaXMgaWdub3JlZCwgZWxzZSBpZiBudWxsLCB0aGUgZGF0YXNldCBoaWRkZW4gc3RhdGUgaXMgcmV0dXJuZWQuXG4gICAgcmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIWRhdGFzZXQuaGlkZGVuO1xuICB9XG5cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG5cbiAgdG9nZ2xlRGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuXG4gIGdldERhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuXG4gICAgaWYgKGRlZmluZWQoZGF0YUluZGV4KSkge1xuICAgICAgbWV0YS5kYXRhW2RhdGFJbmRleF0uaGlkZGVuID0gIXZpc2libGU7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XG4gICAgICAvLyBBbmltYXRlIHZpc2libGUgc3RhdGUsIHNvIGhpZGUgYW5pbWF0aW9uIGNhbiBiZSBzZWVuLiBUaGlzIGNvdWxkIGJlIGhhbmRsZWQgYmV0dGVyIGlmIHVwZGF0ZSAvIHVwZGF0ZURhdGFzZXQgcmV0dXJuZWQgYSBQcm9taXNlLlxuICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHt2aXNpYmxlfSk7XG4gICAgICB0aGlzLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cblxuICBoaWRlKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgZmFsc2UpO1xuICB9XG5cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChtZXRhICYmIG1ldGEuY29udHJvbGxlcikge1xuICAgICAgbWV0YS5jb250cm9sbGVyLl9kZXN0cm95KCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICB9XG5cbiAgX3N0b3AoKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGVzdHJveScpO1xuICAgIGNvbnN0IHtjYW52YXMsIGN0eH0gPSB0aGlzO1xuXG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcblxuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCk7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEZXN0cm95Jyk7XG4gIH1cblxuICB0b0Jhc2U2NEltYWdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuXG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZSwgeCwgeSkgPT4ge1xuICAgICAgZS5vZmZzZXRYID0geDtcbiAgICAgIGUub2Zmc2V0WSA9IHk7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgfTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLmV2ZW50cywgKHR5cGUpID0+IF9hZGQodHlwZSwgbGlzdGVuZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuXG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IF9yZW1vdmUgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgcGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGRldGFjaGVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xuICAgICAgX3JlbW92ZSgnYXR0YWNoJywgYXR0YWNoZWQpO1xuXG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgIF9hZGQoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcbiAgICB9O1xuXG4gICAgZGV0YWNoZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG5cbiAgICAgIF9yZW1vdmUoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcblxuICAgICAgLy8gU3RvcCBhbmltYXRpbmcgYW5kIHJlbW92ZSBtZXRhc2V0cywgc28gd2hlbiByZS1hdHRhY2hlZCwgdGhlIGFuaW1hdGlvbnMgc3RhcnQgZnJvbSBiZWdpbm5pbmcuXG4gICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICB0aGlzLl9yZXNpemUoMCwgMCk7XG5cbiAgICAgIF9hZGQoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICB9O1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XG4gICAgICBhdHRhY2hlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIGVhY2godGhpcy5fbGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgICBlYWNoKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xuICAgIGxldCBtZXRhLCBpdGVtLCBpLCBpbGVuO1xuXG4gICAgaWYgKG1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcbiAgICAgIG1ldGEuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgKGhvdmVyZWQpIGVsZW1lbnRzXG5cdCAqIEByZXR1cm5zIGFycmF5XG5cdCAqL1xuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBhY3RpdmUgKGhvdmVyZWQpIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGFjdGl2ZUVsZW1lbnRzIE5ldyBhY3RpdmUgZGF0YSBwb2ludHNcblx0ICovXG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgdXNlIHRoZSBwcmV2aW91cyBtb3VzZSBldmVudCB0byBvdmVycmlkZSB0aGUgYWN0aXZlIGVsZW1lbnRzIGluIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLnBsdWdpbnMuanMnKS5maWx0ZXJDYWxsYmFja30gW2ZpbHRlcl0gLSBGaWx0ZXJpbmcgZnVuY3Rpb24gZm9yIGxpbWl0aW5nIHdoaWNoIHBsdWdpbnMgYXJlIG5vdGlmaWVkXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIGhvb2ssIGFyZ3MsIGZpbHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBwbHVnaW4gd2l0aCB0aGUgc3BlY2lmaWMgSUQgaXMgcmVnaXN0ZXJlZCBhbmQgZW5hYmxlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGx1Z2luSWQgLSBUaGUgSUQgb2YgdGhlIHBsdWdpbiBvZiB3aGljaCB0byBjaGVjayBpZiBpdCBpcyBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNQbHVnaW5FbmFibGVkKHBsdWdpbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMuX2NhY2hlLmZpbHRlcihwID0+IHAucGx1Z2luLmlkID09PSBwbHVnaW5JZCkubGVuZ3RoID09PSAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LmRhdGFzZXRJbmRleCA9PT0geS5kYXRhc2V0SW5kZXggJiYgeC5pbmRleCA9PT0geS5pbmRleCkpO1xuICAgIGNvbnN0IGRlYWN0aXZhdGVkID0gZGlmZihsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcblxuICAgIGlmIChkZWFjdGl2YXRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShkZWFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZhdGVkLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2V2ZW50SGFuZGxlcihlLCByZXBsYXkpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICByZXBsYXksXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYShlKVxuICAgIH07XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKSA9PiAocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUubmF0aXZlLnR5cGUpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgYXJncy5pbkNoYXJ0QXJlYSk7XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG5cbiAgICBpZiAoY2hhbmdlZCB8fCBhcmdzLmNoYW5nZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSB0aGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSB0cnVlIGlmIHRoZSBldmVudCB3YXMgcmVwbGF5ZWQgYnkgYHVwZGF0ZWBcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9oYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlIGV2ZW50IGlzIHJlcGxheWVkIGZyb20gYHVwZGF0ZWAsIHdlIHNob3VsZCBldmFsdWF0ZSB3aXRoIHRoZSBmaW5hbCBwb3NpdGlvbnMuXG4gICAgLy9cbiAgICAvLyBUaGUgYHJlcGxheWA6XG4gICAgLy8gSXQncyB0aGUgbGFzdCBldmVudCAoZXhjbHVkaW5nIGNsaWNrKSB0aGF0IGhhcyBvY2N1cnJlZCBiZWZvcmUgYHVwZGF0ZWAuXG4gICAgLy8gU28gbW91c2UgaGFzIG5vdCBtb3ZlZC4gSXQncyBhbHNvIG92ZXIgdGhlIGNoYXJ0LCBiZWNhdXNlIHRoZXJlIGlzIGEgYHJlcGxheWAuXG4gICAgLy9cbiAgICAvLyBUaGUgd2h5OlxuICAgIC8vIElmIGFuaW1hdGlvbnMgYXJlIGFjdGl2ZSwgdGhlIGVsZW1lbnRzIGhhdmVuJ3QgbW92ZWQgeWV0IGNvbXBhcmVkIHRvIHN0YXRlIGJlZm9yZSB1cGRhdGUuXG4gICAgLy8gQnV0IGlmIHRoZXkgd2lsbCwgd2UgYXJlIGFjdGl2YXRpbmcgdGhlIGVsZW1lbnRzIHRoYXQgd291bGQgYmUgYWN0aXZlLCBpZiB0aGlzIGNoZWNrXG4gICAgLy8gd2FzIGRvbmUgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuID0+IFwiZmluYWwgcG9zaXRpb25zXCIuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYW5pbWF0aW9ucywgdGhlIFwiZmluYWxcIiBhbmQgXCJjdXJyZW50XCIgcG9zaXRpb25zIGFyZSBlcXVhbC5cbiAgICAvLyBUaGlzIGlzIGRvbmUgc28gd2UgZG8gbm90IGhhdmUgdG8gZXZhbHVhdGUgdGhlIGFjdGl2ZSBlbGVtZW50cyBlYWNoIGFuaW1hdGlvbiBmcmFtZVxuICAgIC8vIC0gaXQgd291bGQgYmUgZXhwZW5zaXZlLlxuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IGlzQ2xpY2sgPSBfaXNDbGlja0V2ZW50KGUpO1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IGRldGVybWluZUxhc3RFdmVudChlLCB0aGlzLl9sYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKTtcblxuICAgIGlmIChpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gU2V0IF9sYXN0RXZlbnQgdG8gbnVsbCB3aGlsZSB3ZSBhcmUgcHJvY2Vzc2luZyB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHJlY3Vyc2lvbiBpZiB0aGUgaGFuZGxlciBjYWxscyBjaGFydC51cGRhdGUoKVxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcblxuICAgICAgLy8gSW52b2tlIG9uSG92ZXIgaG9va1xuICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuXG4gICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkIHx8IHJlcGxheSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGxhc3RFdmVudDtcblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IGxhc3RBY3RpdmUgLSBQcmV2aW91c2x5IGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluQ2hhcnRBcmVhIC0gSXMgdGhlIGV2ZW50IGluc2lkZSBjaGFydEFyZWFcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VGaW5hbFBvc2l0aW9uIC0gU2hvdWxkIHRoZSBldmFsdWF0aW9uIGJlIGRvbmUgd2l0aCBjdXJyZW50IG9yIGZpbmFsIChhZnRlciBhbmltYXRpb24pIGVsZW1lbnQgcG9zaXRpb25zXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSAtIFRoZSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHByYXZhdGVcbiAgICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG5cbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxufVxuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBpbnZhbGlkYXRlUGx1Z2lucygpIHtcbiAgcmV0dXJuIGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgZ2V0QW5nbGVGcm9tUG9pbnQsIFRBVSwgSEFMRl9QSSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtQSSwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X3JlYWRWYWx1ZVRvUHJvcHN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB0eXBlIHtBcmNPcHRpb25zLCBQb2ludH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGVsZW1lbnQ6IEFyY0VsZW1lbnQsIGVuZEFuZ2xlOiBudW1iZXIpIHtcbiAgY29uc3Qge3N0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCB4LCB5LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXN9ID0gZWxlbWVudDtcbiAgbGV0IGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBvdXRlclJhZGl1cztcblxuICAvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwcGluZyB0aGUgYXJjIGFuZCBkcmF3aW5nIGEgZG91YmxlLXdpZHRoIGJvcmRlclxuICAvLyBFbmxhcmdlIHRoZSBjbGlwcGluZyBhcmMgYnkgMC4zMyBwaXhlbHMgdG8gZWxpbWluYXRlIGdsaXRjaGVzIGJldHdlZW4gYm9yZGVyc1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gIGlmIChpbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG4gICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuXG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBib3JkZXIgcmFkaXVzIGZyb20gdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYXJjOiBBcmNFbGVtZW50LCBpbm5lclJhZGl1czogbnVtYmVyLCBvdXRlclJhZGl1czogbnVtYmVyLCBhbmdsZURlbHRhOiBudW1iZXIpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuXG4gIC8vIE91dGVyIGxpbWl0cyBhcmUgY29tcGxpY2F0ZWQuIFdlIHdhbnQgdG8gY29tcHV0ZSB0aGUgYXZhaWxhYmxlIGFuZ3VsYXIgZGlzdGFuY2UgYXRcbiAgLy8gYSByYWRpdXMgb2Ygb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSBmb3Igc21hbGwgYW5ndWxhciBkaXN0YW5jZXMsIHRoaXMgdGVybSBsaW1pdHMuXG4gIC8vIFdlIGNvbXB1dGUgYXQgciA9IG91dGVyUmFkaXVzIC0gYm9yZGVyUmFkaXVzIGJlY2F1c2UgdGhpcyBjaXJjbGUgZGVmaW5lcyB0aGUgY2VudGVyIG9mIHRoZSBib3JkZXIgY29ybmVycy5cbiAgLy9cbiAgLy8gSWYgdGhlIGJvcmRlclJhZGl1cyBpcyBsYXJnZSwgdGhhdCB2YWx1ZSBjYW4gYmVjb21lIG5lZ2F0aXZlLlxuICAvLyBUaGlzIGNhdXNlcyB0aGUgb3V0ZXIgYm9yZGVycyB0byBsb3NlIHRoZWlyIHJhZGl1cyBlbnRpcmVseSwgd2hpY2ggaXMgcmF0aGVyIHVuZXhwZWN0ZWQuIFRvIHNvbHZlIHRoYXQsIGlmIGJvcmRlclJhZGl1cyA+IG91dGVyUmFkaXVzXG4gIC8vIHdlIGtub3cgdGhhdCB0aGUgdGhpY2tuZXNzIHRlcm0gd2lsbCBkb21pbmF0ZSBhbmQgY29tcHV0ZSB0aGUgbGltaXRzIGF0IHRoYXQgcG9pbnRcbiAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKSA9PiB7XG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCAociwg8J2cgykgdG8gKHgsIHkpXG4gKi9cbmZ1bmN0aW9uIHJUaGV0YVRvWFkocjogbnVtYmVyLCB0aGV0YTogbnVtYmVyLCB4OiBudW1iZXIsIHk6IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpLFxuICB9O1xufVxuXG5cbi8qKlxuICogUGF0aCB0aGUgYXJjLCByZXNwZWN0aW5nIGJvcmRlciByYWRpdXMgYnkgc2VwYXJhdGluZyBpbnRvIGxlZnQgYW5kIHJpZ2h0IGhhbHZlcy5cbiAqXG4gKiAgIFN0YXJ0ICAgICAgRW5kXG4gKlxuICogICAgMS0tLT5hLS0tPjIgICAgT3V0ZXJcbiAqICAgLyAgICAgICAgICAgXFxcbiAqICAgOCAgICAgICAgICAgM1xuICogICB8ICAgICAgICAgICB8XG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgNyAgICAgICAgICAgNFxuICogICBcXCAgICAgICAgICAgL1xuICogICAgNjwtLS1iPC0tLTUgICAgSW5uZXJcbiAqL1xuZnVuY3Rpb24gcGF0aEFyYyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGVuZDogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZTogc3RhcnQsIHBpeGVsTWFyZ2luLCBpbm5lclJhZGl1czogaW5uZXJSfSA9IGVsZW1lbnQ7XG5cbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcblxuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG5cbiAgaWYgKHNwYWNpbmcpIHtcbiAgICAvLyBXaGVuIHNwYWNpbmcgaXMgcHJlc2VudCwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCBpdGVtc1xuICAgIC8vIFNvIHdlIGFkanVzdCB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZSBvZiB0aGUgYXJjIHN1Y2ggdGhhdFxuICAgIC8vIHRoZSBkaXN0YW5jZSBpcyB0aGUgc2FtZSBhcyBpdCB3b3VsZCBiZSB3aXRob3V0IHRoZSBzcGFjaW5nXG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG5cbiAgY29uc3QgYmV0YSA9IE1hdGgubWF4KDAuMDAxLCBhbHBoYSAqIG91dGVyUmFkaXVzIC0gb2Zmc2V0IC8gUEkpIC8gb3V0ZXJSYWRpdXM7XG4gIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gKGFscGhhIC0gYmV0YSkgLyAyO1xuICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnQgKyBhbmdsZU9mZnNldCArIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IGVuZEFuZ2xlID0gZW5kIC0gYW5nbGVPZmZzZXQgLSBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCB7b3V0ZXJTdGFydCwgb3V0ZXJFbmQsIGlubmVyU3RhcnQsIGlubmVyRW5kfSA9IHBhcnNlQm9yZGVyUmFkaXVzKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcblxuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyU3RhcnQ7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyRW5kO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBvdXRlclN0YXJ0IC8gb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIG91dGVyRW5kIC8gb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cztcblxuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gVGhlIGZpcnN0IGFyYyBzZWdtZW50cyBmcm9tIHBvaW50IDEgdG8gcG9pbnQgYSB0byBwb2ludCAyXG4gICAgY29uc3Qgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlID0gKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgMiB0byBwb2ludCAzXG4gICAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyRW5kLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIGVuZEFuZ2xlICsgSEFMRl9QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCAzIHRvIHBvaW50IDRcbiAgICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA0IHRvIHBvaW50IDVcbiAgICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJFbmQsIGVuZEFuZ2xlICsgSEFMRl9QSSwgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGlubmVyIGFyYyBmcm9tIHBvaW50IDUgdG8gcG9pbnQgYiB0byBwb2ludCA2XG4gICAgY29uc3QgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlID0gKChlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSkgKyAoc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpKSkgLyAyO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHRydWUpO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDYgdG8gcG9pbnQgN1xuICAgIGlmIChpbm5lclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzLCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDcgdG8gcG9pbnQgOFxuICAgIGNvbnN0IHA4ID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIHN0YXJ0QW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA4IHRvIHBvaW50IDFcbiAgICBpZiAob3V0ZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgIGNvbnN0IG91dGVyU3RhcnRYID0gTWF0aC5jb3Mob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyU3RhcnRZID0gTWF0aC5zaW4ob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJTdGFydFgsIG91dGVyU3RhcnRZKTtcblxuICAgIGNvbnN0IG91dGVyRW5kWCA9IE1hdGguY29zKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJFbmRZID0gTWF0aC5zaW4ob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyRW5kWCwgb3V0ZXJFbmRZKTtcbiAgfVxuXG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gZHJhd0FyYyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICB9XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBkcmF3Qm9yZGVyKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlLCBvcHRpb25zfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlLCBib3JkZXJEYXNoLCBib3JkZXJEYXNoT2Zmc2V0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcblxuICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlckRhc2ggfHwgW10pO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSBib3JkZXJEYXNoT2Zmc2V0O1xuXG4gIGlmIChpbm5lcikge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdyb3VuZCc7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAnYmV2ZWwnO1xuICB9XG5cbiAgbGV0IGVuZEFuZ2xlID0gZWxlbWVudC5lbmRBbmdsZTtcbiAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKCFmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJjUHJvcHMgZXh0ZW5kcyBQb2ludCB7XG4gIHN0YXJ0QW5nbGU6IG51bWJlcjtcbiAgZW5kQW5nbGU6IG51bWJlcjtcbiAgaW5uZXJSYWRpdXM6IG51bWJlcjtcbiAgb3V0ZXJSYWRpdXM6IG51bWJlcjtcbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudDxBcmNQcm9wcywgQXJjT3B0aW9ucz4ge1xuXG4gIHN0YXRpYyBpZCA9ICdhcmMnO1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJBbGlnbjogJ2NlbnRlcicsXG4gICAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogdW5kZWZpbmVkLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBib3JkZXJXaWR0aDogMixcbiAgICBvZmZzZXQ6IDAsXG4gICAgc3BhY2luZzogMCxcbiAgICBhbmdsZTogdW5kZWZpbmVkLFxuICAgIGNpcmN1bGFyOiB0cnVlLFxuICB9O1xuXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbiAgfTtcblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJ1xuICB9O1xuXG4gIGNpcmN1bWZlcmVuY2U6IG51bWJlcjtcbiAgZW5kQW5nbGU6IG51bWJlcjtcbiAgZnVsbENpcmNsZXM6IG51bWJlcjtcbiAgaW5uZXJSYWRpdXM6IG51bWJlcjtcbiAgb3V0ZXJSYWRpdXM6IG51bWJlcjtcbiAgcGl4ZWxNYXJnaW46IG51bWJlcjtcbiAgc3RhcnRBbmdsZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gMDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKGNoYXJ0WDogbnVtYmVyLCBjaGFydFk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGUsIGRpc3RhbmNlfSA9IGdldEFuZ2xlRnJvbVBvaW50KHBvaW50LCB7eDogY2hhcnRYLCB5OiBjaGFydFl9KTtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHJBZGp1c3QgPSAodGhpcy5vcHRpb25zLnNwYWNpbmcgKyB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIC8gMjtcbiAgICBjb25zdCBfY2lyY3VtZmVyZW5jZSA9IHZhbHVlT3JEZWZhdWx0KGNpcmN1bWZlcmVuY2UsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgbm9uWmVyb0JldHdlZW4gPSBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkgJiYgc3RhcnRBbmdsZSAhPT0gZW5kQW5nbGU7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBub25aZXJvQmV0d2VlbjtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG5cbiAgICByZXR1cm4gKGJldHdlZW5BbmdsZXMgJiYgd2l0aGluUmFkaXVzKTtcbiAgfVxuXG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJ1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbikge1xuICAgIHJldHVybiB0aGlzLmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZHJhdyhjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gNDtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuXG4gICAgaWYgKGNpcmN1bWZlcmVuY2UgPT09IDAgfHwgdGhpcy5pbm5lclJhZGl1cyA8IDAgfHwgdGhpcy5vdXRlclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgY29uc3QgaGFsZkFuZ2xlID0gKHRoaXMuc3RhcnRBbmdsZSArIHRoaXMuZW5kQW5nbGUpIC8gMjtcbiAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiBvZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiBvZmZzZXQpO1xuICAgIGNvbnN0IGZpeCA9IDEgLSBNYXRoLnNpbihNYXRoLm1pbihQSSwgY2lyY3VtZmVyZW5jZSB8fCAwKSk7XG4gICAgY29uc3QgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0ICogZml4O1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG5cbiAgICBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgZHJhd0JvcmRlcihjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2JlemllckludGVycG9sYXRpb24sIF9wb2ludEluTGluZSwgX3N0ZXBwZWRJbnRlcnBvbGF0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50ZXJwb2xhdGlvbi5qcyc7XG5pbXBvcnQge19jb21wdXRlU2VnbWVudHMsIF9ib3VuZFNlZ21lbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuc2VnbWVudC5qcyc7XG5pbXBvcnQge19zdGVwcGVkTGluZVRvLCBfYmV6aWVyQ3VydmVUb30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge191cGRhdGVCZXppZXJDb250cm9sUG9pbnRzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY3VydmUuanMnO1xuaW1wb3J0IHt2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xuICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNhcFN0eWxlLCBvcHRpb25zLmJvcmRlckNhcFN0eWxlKTtcbiAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2gsIG9wdGlvbnMuYm9yZGVyRGFzaCkpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xuICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJKb2luU3R5bGUsIG9wdGlvbnMuYm9yZGVySm9pblN0eWxlKTtcbiAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xufVxuXG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7YW55fVxuICovXG5mdW5jdGlvbiBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZExpbmVUbztcbiAgfVxuXG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG5cbiAgcmV0dXJuIGxpbmVUbztcbn1cblxuZnVuY3Rpb24gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtzdGFydDogcGFyYW1zU3RhcnQgPSAwLCBlbmQ6IHBhcmFtc0VuZCA9IGNvdW50IC0gMX0gPSBwYXJhbXM7XG4gIGNvbnN0IHtzdGFydDogc2VnbWVudFN0YXJ0LCBlbmQ6IHNlZ21lbnRFbmR9ID0gc2VnbWVudDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocGFyYW1zRW5kLCBzZWdtZW50RW5kKTtcbiAgY29uc3Qgb3V0c2lkZSA9IHBhcmFtc1N0YXJ0IDwgc2VnbWVudFN0YXJ0ICYmIHBhcmFtc0VuZCA8IHNlZ21lbnRTdGFydCB8fCBwYXJhbXNTdGFydCA+IHNlZ21lbnRFbmQgJiYgcGFyYW1zRW5kID4gc2VnbWVudEVuZDtcblxuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZSBwYXRoIGZyb20gcG9pbnRzLCBncm91cGluZyBieSB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG4gKiBQb2ludHMgbmVlZCB0byBiZSBpbiBvcmRlciBieSB4LWNvb3JkaW5hdGUgZm9yIHRoaXMgdG8gd29yayBlZmZpY2llbnRseVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuICovXG5mdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCB7cG9pbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGxvb3AsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCBsaW5lTWV0aG9kID0gZ2V0TGluZU1ldGhvZChvcHRpb25zKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGksIHBvaW50LCBwcmV2O1xuXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcblxuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhIHNraXBwZWQgcG9pbnQgaW5zaWRlIGEgc2VnbWVudCwgc3BhbkdhcHMgbXVzdCBiZSB0cnVlXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKG1vdmUpIHtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBtb3ZlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICB9XG5cbiAgICBwcmV2ID0gcG9pbnQ7XG4gIH1cblxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cblxuICByZXR1cm4gISFsb29wO1xufVxuXG4vKipcbiAqIENyZWF0ZSBwYXRoIGZyb20gcG9pbnRzLCBncm91cGluZyBieSB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG4gKiBQb2ludHMgbmVlZCB0byBiZSBpbiBvcmRlciBieSB4LWNvb3JkaW5hdGUgZm9yIHRoaXMgdG8gd29yayBlZmZpY2llbnRseVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8UGF0aDJEfSBjdHggLSBDb250ZXh0XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gc2VnbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5tb3ZlIC0gbW92ZSB0byBzdGFydGluZyBwb2ludCAodnMgbGluZSB0byBpdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLmVuZCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIGVuZGluZyBhdCBgc3RhcnRgICsgYGNvdW50YCBpbmRleFxuICovXG5mdW5jdGlvbiBmYXN0UGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHByZXZYLCBtaW5ZLCBtYXhZLCBsYXN0WTtcblxuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIC8vIERyYXcgbGluZSB0byBtYXhZIGFuZCBtaW5ZLCB1c2luZyB0aGUgYXZlcmFnZSB4LWNvb3JkaW5hdGVcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgLy8gTGluZSB0byB5LXZhbHVlIG9mIGxhc3QgcG9pbnQgaW4gZ3JvdXAuIFNvIHRoZSBsaW5lIGNvbnRpbnVlc1xuICAgICAgLy8gZnJvbSBjb3JyZWN0IHBvc2l0aW9uLiBOb3QgdXNpbmcgbW92ZSwgdG8gaGF2ZSBzb2xpZCBwYXRoLlxuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuXG4gIGlmIChtb3ZlKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleCgwKV07XG4gICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgeCA9IHBvaW50Lng7XG4gICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7IC8vIHRydW5jYXRlZCB4LWNvb3JkaW5hdGVcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgLy8gRm9yIGZpcnN0IHBvaW50IGluIGdyb3VwLCBjb3VudFggaXMgYDBgLCBzbyBhdmVyYWdlIHdpbGwgYmUgYHhgIC8gMS5cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHgpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdYKCk7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbmV4dCB4LXBvc2l0aW9uLCB1c2luZyB0aGUgZmlyc3QgKG9yIG9ubHkpXG4gICAgICAvLyB5LXZhbHVlIGluIHRoYXQgZ3JvdXBcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICB9XG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB5LXZhbHVlIGluIGdyb3VwXG4gICAgbGFzdFkgPSB5O1xuICB9XG4gIGRyYXdYKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZSAtIHRoZSBsaW5lXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKSB7XG4gIGNvbnN0IG9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgY29uc3QgdXNlRmFzdFBhdGggPSAhbGluZS5fZGVjaW1hdGVkICYmICFsaW5lLl9sb29wICYmICFvcHRzLnRlbnNpb24gJiYgb3B0cy5jdWJpY0ludGVycG9sYXRpb25Nb2RlICE9PSAnbW9ub3RvbmUnICYmICFvcHRzLnN0ZXBwZWQgJiYgIWJvcmRlckRhc2g7XG4gIHJldHVybiB1c2VGYXN0UGF0aCA/IGZhc3RQYXRoU2VnbWVudCA6IHBhdGhTZWdtZW50O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVySW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBfcG9pbnRJbkxpbmU7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cblxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7c2VnbWVudHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc2VnbWVudC5zdHlsZSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChzZWdtZW50TWV0aG9kKGN0eCwgbGluZSwgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSkpIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIGRyYXcoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgaWYgKHVzZVBhdGgyRCAmJiAhbGluZS5vcHRpb25zLnNlZ21lbnQpIHtcbiAgICBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfSBlbHNlIHtcbiAgICBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdsaW5lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJDYXBTdHlsZTogJ2J1dHQnLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgYm9yZGVySm9pblN0eWxlOiAnbWl0ZXInLFxuICAgIGJvcmRlcldpZHRoOiAzLFxuICAgIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnZGVmYXVsdCcsXG4gICAgZmlsbDogZmFsc2UsXG4gICAgc3BhbkdhcHM6IGZhbHNlLFxuICAgIHN0ZXBwZWQ6IGZhbHNlLFxuICAgIHRlbnNpb246IDAsXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cblxuICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG4gIH07XG5cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVDb250cm9sUG9pbnRzKGNoYXJ0QXJlYSwgaW5kZXhBeGlzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBvaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xuICB9XG5cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBfY29tcHV0ZVNlZ21lbnRzKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gIH1cblxuICAvKipcblx0ICogRmlyc3Qgbm9uLXNraXBwZWQgcG9pbnQgb24gdGhpcyBsaW5lXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgZmlyc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBMYXN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGxhc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGNvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEludGVycG9sYXRlIGEgcG9pbnQgaW4gdGhpcyBsaW5lIGF0IHRoZSBzYW1lIHZhbHVlIG9uIGBwcm9wZXJ0eWAgYXNcblx0ICogdGhlIHJlZmVyZW5jZSBgcG9pbnRgIHByb3ZpZGVkXG5cdCAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBwb2ludCAtIHRoZSByZWZlcmVuY2UgcG9pbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gdGhlIHByb3BlcnR5IHRvIG1hdGNoIG9uXG5cdCAqIEByZXR1cm5zIHtQb2ludEVsZW1lbnR8dW5kZWZpbmVkfVxuXHQgKi9cbiAgaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRoaXMsIHtwcm9wZXJ0eSwgc3RhcnQ6IHZhbHVlLCBlbmQ6IHZhbHVlfSk7XG5cbiAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBcHBlbmQgYSBzZWdtZW50IG9mIHRoaXMgbGluZSB0byBjdXJyZW50IHBhdGguXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlZ21lbnQuc3RhcnQgLSBzdGFydCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiBcdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LmVuZCAtIGVuZCBpbmRleCBvZiB0aGUgc2VnbWVudCwgcmVmZXJyaW5nIHRoZSBwb2ludHMgYXJyYXlcbiBcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VnbWVudC5sb29wIC0gaW5kaWNhdGVzIHRoYXQgdGhlIHNlZ21lbnQgaXMgYSBsb29wXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcblx0ICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLnJldmVyc2UgLSBwYXRoIHRoZSBzZWdtZW50IGZyb20gZW5kIHRvIHN0YXJ0XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuc3RhcnQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBzdGFydGluZyBmcm9tIGBzdGFydGAgaW5kZXhcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcblx0ICogQHJldHVybnMge3VuZGVmaW5lZHxib29sZWFufSAtIHRydWUgaWYgdGhlIHNlZ21lbnQgaXMgYSBmdWxsIGxvb3AgKHBhdGggc2hvdWxkIGJlIGNsb3NlZClcblx0ICovXG4gIHBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBBcHBlbmQgYWxsIHNlZ21lbnRzIG9mIHRoaXMgbGluZSB0byBjdXJyZW50IHBhdGguXG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdXG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIGxpbmUgaXMgYSBmdWxsIGxvb3AgKHBhdGggc2hvdWxkIGJlIGNsb3NlZClcblx0ICovXG4gIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcblxuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8ICh0aGlzLnBvaW50cy5sZW5ndGggLSBzdGFydCk7XG5cbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICAgIGxvb3AgJj0gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuXHQgKiBAcGFyYW0ge29iamVjdH0gY2hhcnRBcmVhXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbY291bnRdXG5cdCAqL1xuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuXG4gICAgaWYgKHBvaW50cy5sZW5ndGggJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCkge1xuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgZHJhdyhjdHgsIHRoaXMsIHN0YXJ0LCBjb3VudCk7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYW5pbWF0ZWQpIHtcbiAgICAgIC8vIFdoZW4gbGluZSBpcyBhbmltYXRlZCwgdGhlIGNvbnRyb2wgcG9pbnRzIGFuZCBwYXRoIGFyZSBub3QgY2FjaGVkLlxuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2RyYXdQb2ludCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHR5cGUge1xuICBDYXJ0ZXNpYW5QYXJzZWREYXRhLFxuICBDaGFydEFyZWEsXG4gIFBvaW50LFxuICBQb2ludEhvdmVyT3B0aW9ucyxcbiAgUG9pbnRPcHRpb25zLFxufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGluUmFuZ2UoZWw6IFBvaW50RWxlbWVudCwgcG9zOiBudW1iZXIsIGF4aXM6ICd4JyB8ICd5JywgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cblxuZXhwb3J0IHR5cGUgUG9pbnRQcm9wcyA9IFBvaW50XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQ8UG9pbnRQcm9wcywgUG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+IHtcblxuICBzdGF0aWMgaWQgPSAncG9pbnQnO1xuXG4gIHBhcnNlZDogQ2FydGVzaWFuUGFyc2VkRGF0YTtcbiAgc2tpcD86IGJvb2xlYW47XG4gIHN0b3A/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlcldpZHRoOiAxLFxuICAgIGhpdFJhZGl1czogMSxcbiAgICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICAgIGhvdmVyUmFkaXVzOiA0LFxuICAgIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICAgIHJhZGl1czogMyxcbiAgICByb3RhdGlvbjogMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWDogbnVtYmVyLCBtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cblxuICBpblhSYW5nZShtb3VzZVg6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVk6IG51bWJlciwgdXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uPzogYm9vbGVhbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuXG4gIHNpemUob3B0aW9ucz86IFBhcnRpYWw8UG9pbnRPcHRpb25zICYgUG9pbnRIb3Zlck9wdGlvbnM+KSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGxldCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCAwO1xuICAgIHJhZGl1cyA9IE1hdGgubWF4KHJhZGl1cywgcmFkaXVzICYmIG9wdGlvbnMuaG92ZXJSYWRpdXMgfHwgMCk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIHJldHVybiAocmFkaXVzICsgYm9yZGVyV2lkdGgpICogMjtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGFyZWE6IENoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuXG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGYWxsYmFja3Mgc2hvdWxkIG5ldmVyIGJlIGhpdCBpbiBwcmFjdGljZVxuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgX2lzQmV0d2VlbiwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHthZGRSb3VuZGVkUmVjdFBhdGh9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHt0b1RSQkwsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqIEB0eXBlZGVmIHt7IHg6IG51bWJlciwgeTogbnVtYmVyLCBiYXNlOiBudW1iZXIsIGhvcml6b250YWw6IGJvb2xlYW4sIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19IEJhclByb3BzICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgYm91bmRzIG9mIHRoZSBiYXIgcmVnYXJkbGVzcyBvZiB0aGUgb3JpZW50YXRpb25cbiAqIEBwYXJhbSB7QmFyRWxlbWVudH0gYmFyIHRoZSBiYXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dXG4gKiBAcmV0dXJuIHtvYmplY3R9IGJvdW5kcyBvZiB0aGUgYmFyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovIChiYXIuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXSwgdXNlRmluYWxQb3NpdGlvbikpO1xuXG4gIGxldCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIGhhbGY7XG5cbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cblxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBza2lwID8gMCA6IF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB7ZW5hYmxlQm9yZGVyUmFkaXVzfSA9IGJhci5nZXRQcm9wcyhbJ2VuYWJsZUJvcmRlclJhZGl1cyddKTtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gIGNvbnN0IG8gPSB0b1RSQkxDb3JuZXJzKHZhbHVlKTtcbiAgY29uc3QgbWF4UiA9IE1hdGgubWluKG1heFcsIG1heEgpO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCwgYXNzdW1lIHRoZSB1c2VyIGtub3dzIHdoYXQgdGhleSBhcmUgZG9pbmdcbiAgLy8gYW5kIGFwcGx5IGFzIGRpcmVjdGVkLlxuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdG9wTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLmxlZnQsIG8udG9wTGVmdCwgMCwgbWF4UiksXG4gICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgYm90dG9tTGVmdDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLmxlZnQsIG8uYm90dG9tTGVmdCwgMCwgbWF4UiksXG4gICAgYm90dG9tUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5yaWdodCwgby5ib3R0b21SaWdodCwgMCwgbWF4UilcbiAgfTtcbn1cblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpblJhbmdlKGJhciwgeCwgeSwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBza2lwWCA9IHggPT09IG51bGw7XG4gIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcEJvdGggPSBza2lwWCAmJiBza2lwWTtcbiAgY29uc3QgYm91bmRzID0gYmFyICYmICFza2lwQm90aCAmJiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKTtcblxuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpXG5cdFx0JiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuXG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuXG4vKipcbiAqIEFkZCBhIHBhdGggb2YgYSByZWN0YW5nbGUgdG8gdGhlIGN1cnJlbnQgc3ViLXBhdGhcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggQ29udGV4dFxuICogQHBhcmFtIHsqfSByZWN0IEJvdW5kaW5nIHJlY3RcbiAqL1xuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZWN0KHJlY3QsIGFtb3VudCwgcmVmUmVjdCA9IHt9KSB7XG4gIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB5ID0gcmVjdC55ICE9PSByZWZSZWN0LnkgPyAtYW1vdW50IDogMDtcbiAgY29uc3QgdyA9IChyZWN0LnggKyByZWN0LncgIT09IHJlZlJlY3QueCArIHJlZlJlY3QudyA/IGFtb3VudCA6IDApIC0geDtcbiAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LnggKyB4LFxuICAgIHk6IHJlY3QueSArIHksXG4gICAgdzogcmVjdC53ICsgdyxcbiAgICBoOiByZWN0LmggKyBoLFxuICAgIHJhZGl1czogcmVjdC5yYWRpdXNcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7aW5mbGF0ZUFtb3VudCwgb3B0aW9uczoge2JvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3J9fSA9IHRoaXM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgaW5mbGF0ZUFtb3VudCkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBpblJhbmdlKG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHksIGJhc2UsIGhvcml6b250YWx9ID0gLyoqIEB0eXBlIHtCYXJQcm9wc30gKi8gKHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICB9O1xuICB9XG5cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuIiwgImltcG9ydCB7RG91Z2hudXRDb250cm9sbGVyLCBQb2xhckFyZWFDb250cm9sbGVyLCBkZWZhdWx0c30gZnJvbSAnLi4vaW5kZXguanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0LCBDaGFydERhdGFzZXR9IGZyb20gJy4uL3R5cGVzLmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBDb2xvcnNQbHVnaW5PcHRpb25zIHtcbiAgZW5hYmxlZD86IGJvb2xlYW47XG4gIGZvcmNlT3ZlcnJpZGU/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ29sb3JzRGVzY3JpcHRvciB7XG4gIGJhY2tncm91bmRDb2xvcj86IHVua25vd247XG4gIGJvcmRlckNvbG9yPzogdW5rbm93bjtcbn1cblxuY29uc3QgQk9SREVSX0NPTE9SUyA9IFtcbiAgJ3JnYig1NCwgMTYyLCAyMzUpJywgLy8gYmx1ZVxuICAncmdiKDI1NSwgOTksIDEzMiknLCAvLyByZWRcbiAgJ3JnYigyNTUsIDE1OSwgNjQpJywgLy8gb3JhbmdlXG4gICdyZ2IoMjU1LCAyMDUsIDg2KScsIC8vIHllbGxvd1xuICAncmdiKDc1LCAxOTIsIDE5MiknLCAvLyBncmVlblxuICAncmdiKDE1MywgMTAyLCAyNTUpJywgLy8gcHVycGxlXG4gICdyZ2IoMjAxLCAyMDMsIDIwNyknIC8vIGdyZXlcbl07XG5cbi8vIEJvcmRlciBjb2xvcnMgd2l0aCA1MCUgdHJhbnNwYXJlbmN5XG5jb25zdCBCQUNLR1JPVU5EX0NPTE9SUyA9IC8qICNfX1BVUkVfXyAqLyBCT1JERVJfQ09MT1JTLm1hcChjb2xvciA9PiBjb2xvci5yZXBsYWNlKCdyZ2IoJywgJ3JnYmEoJykucmVwbGFjZSgnKScsICcsIDAuNSknKSk7XG5cbmZ1bmN0aW9uIGdldEJvcmRlckNvbG9yKGk6IG51bWJlcikge1xuICByZXR1cm4gQk9SREVSX0NPTE9SU1tpICUgQk9SREVSX0NPTE9SUy5sZW5ndGhdO1xufVxuXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kQ29sb3IoaTogbnVtYmVyKSB7XG4gIHJldHVybiBCQUNLR1JPVU5EX0NPTE9SU1tpICUgQkFDS0dST1VORF9DT0xPUlMubGVuZ3RoXTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVEZWZhdWx0RGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJvcmRlckNvbG9yID0gZ2V0Qm9yZGVyQ29sb3IoaSk7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZ2V0QmFja2dyb3VuZENvbG9yKGkpO1xuXG4gIHJldHVybiArK2k7XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplRG91Z2hudXREYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldC5kYXRhLm1hcCgoKSA9PiBnZXRCb3JkZXJDb2xvcihpKyspKTtcblxuICByZXR1cm4gaTtcbn1cblxuZnVuY3Rpb24gY29sb3JpemVQb2xhckFyZWFEYXRhc2V0KGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgaTogbnVtYmVyKSB7XG4gIGRhdGFzZXQuYmFja2dyb3VuZENvbG9yID0gZGF0YXNldC5kYXRhLm1hcCgoKSA9PiBnZXRCYWNrZ3JvdW5kQ29sb3IoaSsrKSk7XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGdldENvbG9yaXplcihjaGFydDogQ2hhcnQpIHtcbiAgbGV0IGkgPSAwO1xuXG4gIHJldHVybiAoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBkYXRhc2V0SW5kZXg6IG51bWJlcikgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG5cbiAgICBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIERvdWdobnV0Q29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplRG91Z2hudXREYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlciBpbnN0YW5jZW9mIFBvbGFyQXJlYUNvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZVBvbGFyQXJlYURhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVEZWZhdWx0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMoXG4gIGRlc2NyaXB0b3JzOiBDb2xvcnNEZXNjcmlwdG9yW10gfCBSZWNvcmQ8c3RyaW5nLCBDb2xvcnNEZXNjcmlwdG9yPlxuKSB7XG4gIGxldCBrOiBudW1iZXIgfCBzdHJpbmc7XG5cbiAgZm9yIChrIGluIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKGRlc2NyaXB0b3JzW2tdLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3JzW2tdLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb24oXG4gIGRlc2NyaXB0b3I6IENvbG9yc0Rlc2NyaXB0b3Jcbikge1xuICByZXR1cm4gZGVzY3JpcHRvciAmJiAoZGVzY3JpcHRvci5ib3JkZXJDb2xvciB8fCBkZXNjcmlwdG9yLmJhY2tncm91bmRDb2xvcik7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zKCkge1xuICByZXR1cm4gZGVmYXVsdHMuYm9yZGVyQ29sb3IgIT09ICdyZ2JhKDAsMCwwLDAuMSknIHx8IGRlZmF1bHRzLmJhY2tncm91bmRDb2xvciAhPT0gJ3JnYmEoMCwwLDAsMC4xKSc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdjb2xvcnMnLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBmb3JjZU92ZXJyaWRlOiBmYWxzZVxuICB9IGFzIENvbG9yc1BsdWdpbk9wdGlvbnMsXG5cbiAgYmVmb3JlTGF5b3V0KGNoYXJ0OiBDaGFydCwgX2FyZ3MsIG9wdGlvbnM6IENvbG9yc1BsdWdpbk9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtkYXRhc2V0c30sXG4gICAgICBvcHRpb25zOiBjaGFydE9wdGlvbnNcbiAgICB9ID0gY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IHtlbGVtZW50c30gPSBjaGFydE9wdGlvbnM7XG5cbiAgICBjb25zdCBjb250YWluc0NvbG9yRGVmZW5pdGlvbiA9IChcbiAgICAgIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMoZGF0YXNldHMpIHx8XG4gICAgICBjb250YWluc0NvbG9yc0RlZmluaXRpb24oY2hhcnRPcHRpb25zKSB8fFxuICAgICAgKGVsZW1lbnRzICYmIGNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbnMoZWxlbWVudHMpKSB8fFxuICAgICAgY29udGFpbnNEZWZhdWx0Q29sb3JzRGVmZW5pdGlvbnMoKSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuZm9yY2VPdmVycmlkZSAmJiBjb250YWluc0NvbG9yRGVmZW5pdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yaXplciA9IGdldENvbG9yaXplcihjaGFydCk7XG5cbiAgICBkYXRhc2V0cy5mb3JFYWNoKGNvbG9yaXplcik7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfbGltaXRWYWx1ZSwgX2xvb2t1cEJ5S2V5LCBpc051bGxPclVuZGVmLCByZXNvbHZlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICAvKipcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIExhcmdlc3QgVHJpYW5nbGUgVGhyZWUgQnVja2V0cyBhbGdvcml0aG0uXG4gICAqXG4gICAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uIGJ5IFN2ZWlubiBTdGVpbmFyc3NvblxuICAgKiBpbiBodHRwczovL2dpdGh1Yi5jb20vc3ZlaW5uLXN0ZWluYXJzc29uL2Zsb3QtZG93bnNhbXBsZS9ibG9iL21hc3Rlci9qcXVlcnkuZmxvdC5kb3duc2FtcGxlLmpzXG4gICAqXG4gICAqIFRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBpcyBNSVQgbGljZW5zZWQuXG4gICAqL1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICAvLyBUaGVyZSBhcmUgbGVzcyBwb2ludHMgdGhhbiB0aGUgdGhyZXNob2xkLCByZXR1cm5pbmcgdGhlIHdob2xlIGFycmF5XG4gIGlmIChzYW1wbGVzID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICB9XG5cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG5cbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICAvLyBTdGFydGluZyBmcm9tIG9mZnNldFxuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcblxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVthXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG5cbiAgICAvLyBBZGRpbmcgb2Zmc2V0XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuXG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuXG4gICAgYXZnWCAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IHJhbmdlT2ZmcyA9IE1hdGguZmxvb3IoaSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCByYW5nZVRvID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3Qge3g6IHBvaW50QXgsIHk6IHBvaW50QXl9ID0gZGF0YVthXTtcblxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIGNoYW5nZWQgZnJvbSB0aGUgb3JpZ2luYWwgYWxnb3JpdGhtIHdoaWNoIGluaXRpYWxpemVzIHRoZXNlXG4gICAgLy8gdmFsdWVzIHRvIDEuIFRoZSByZWFzb24gZm9yIHRoaXMgY2hhbmdlIGlzIHRoYXQgaWYgdGhlIGFyZWEgaXMgc21hbGwsIG5leHRBXG4gICAgLy8gd291bGQgbmV2ZXIgYmUgc2V0IGFuZCB0aHVzIGEgY3Jhc2ggd291bGQgb2NjdXIgaW4gdGhlIG5leHQgbG9vcCBhcyBgYWAgd291bGQgYmVjb21lXG4gICAgLy8gYHVuZGVmaW5lZGAuIFNpbmNlIHRoZSBhcmVhIGlzIGFsd2F5cyBwb3NpdGl2ZSwgYnV0IGNvdWxkIGJlIDAgaW4gdGhlIGNhc2Ugb2YgYSBmbGF0IHRyYWNlLFxuICAgIC8vIGluaXRpYWxpemluZyB3aXRoIGEgbmVnYXRpdmUgbnVtYmVyIGlzIHRoZSBjb3JyZWN0IHNvbHV0aW9uLlxuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG5cbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChhcmVhID4gbWF4QXJlYSkge1xuICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgbWF4QXJlYVBvaW50ID0gZGF0YVtqXTtcbiAgICAgICAgbmV4dEEgPSBqO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG5cbiAgLy8gSW5jbHVkZSB0aGUgbGFzdCBwb2ludFxuICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gZGF0YVtlbmRJbmRleF07XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG5cbiAgY29uc3QgeE1pbiA9IGRhdGFbc3RhcnRdLng7XG4gIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICBjb25zdCBkeCA9IHhNYXggLSB4TWluO1xuXG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcblxuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAvLyBEZXRlcm1pbmUgYG1pbllgIC8gYG1heFlgIGFuZCBgYXZnWGAgd2hpbGUgd2Ugc3RheSB3aXRoaW4gc2FtZSB4LXBvc2l0aW9uXG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICAvLyBVc2UgcG9pbnQueCBoZXJlIGJlY2F1c2Ugd2UncmUgY29tcHV0aW5nIHRoZSBhdmVyYWdlIGRhdGEgYHhgIHZhbHVlXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQdXNoIHVwIHRvIDQgcG9pbnRzLCAzIGZvciB0aGUgbGFzdCBpbnRlcnZhbCBhbmQgdGhlIGZpcnN0IHBvaW50IGZvciB0aGlzIGludGVydmFsXG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgLy8gVGhlIGludGVydmFsIGlzIGRlZmluZWQgYnkgNCBwb2ludHM6IHN0YXJ0LCBtaW4sIG1heCwgZW5kLlxuICAgICAgICAvLyBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgYWxyZWFkeSBjb25zaWRlcmVkIGF0IHRoaXMgcG9pbnQsIHNvIHdlIG5lZWQgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gICAgICAgIC8vIG9mIHRoZSBvdGhlciBwb2ludHMgdG8gYWRkLiBXZSBuZWVkIHRvIHNvcnQgdGhlc2UgcG9pbnRzIHRvIGVuc3VyZSB0aGUgZGVjaW1hdGVkIGRhdGFcbiAgICAgICAgLy8gaXMgc3RpbGwgc29ydGVkIGFuZCB0aGVuIGVuc3VyZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlcy5cbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcblxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MSAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDFdLFxuICAgICAgICAgICAgeDogYXZnWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgZGVjaW1hdGVkLnB1c2goe1xuICAgICAgICAgICAgLi4uZGF0YVtpbnRlcm1lZGlhdGVJbmRleDJdLFxuICAgICAgICAgICAgeDogYXZnWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3RJbmRleCA9PT0gc3RhcnRJbmRleCB3aWxsIG9jY3VyIHdoZW4gYSByYW5nZSBoYXMgb25seSAxIHBvaW50IHdoaWNoIGNvdWxkXG4gICAgICAvLyBoYXBwZW4gd2l0aCB2ZXJ5IHVuZXZlbiBkYXRhXG4gICAgICBpZiAoaSA+IDAgJiYgbGFzdEluZGV4ICE9PSBzdGFydEluZGV4KSB7XG4gICAgICAgIC8vIExhc3QgcG9pbnQgaW4gdGhlIHByZXZpb3VzIGludGVydmFsXG4gICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IG9mIHRoZSBuZXcgaW50ZXJ2YWxcbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCkge1xuICBpZiAoZGF0YXNldC5fZGVjaW1hdGVkKSB7XG4gICAgY29uc3QgZGF0YSA9IGRhdGFzZXQuX2RhdGE7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICBkZWxldGUgZGF0YXNldC5fZGF0YTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudDtcblxuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuXG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcblxuICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIC8vIFRoZSBkZWNpbWF0aW9uIHBsdWdpbiBtYXkgaGF2ZSBiZWVuIHByZXZpb3VzbHkgZW5hYmxlZC4gTmVlZCB0byByZW1vdmUgb2xkIGBkYXRhc2V0Ll9kYXRhYCBoYW5kbGVyc1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBc3N1bWUgdGhlIGVudGlyZSBjaGFydCBpcyBhdmFpbGFibGUgdG8gc2hvdyBhIGZldyBtb3JlIHBvaW50cyB0aGFuIG5lZWRlZFxuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gY2hhcnQud2lkdGg7XG5cbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcblxuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIC8vIERlY2ltYXRpb24gaXMgb25seSBzdXBwb3J0ZWQgZm9yIGxpbmVzIHRoYXQgaGF2ZSBhbiBYIGluZGV4QXhpc1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICAvLyBPbmx5IGxpbmUgZGF0YXNldHMgYXJlIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIC8vIE9ubHkgbGluZWFyIGludGVycG9sYXRpb24gaXMgc3VwcG9ydGVkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICAvLyBQbHVnaW4gb25seSBzdXBwb3J0cyBkYXRhIHRoYXQgZG9lcyBub3QgbmVlZCBwYXJzaW5nXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHtzdGFydCwgY291bnR9ID0gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgZGF0YSk7XG4gICAgICBjb25zdCB0aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCA0ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgICBpZiAoY291bnQgPD0gdGhyZXNob2xkKSB7XG4gICAgICAgIC8vIE5vIGRlY2ltYXRpb24gaXMgcmVxdWlyZWQgdW50aWwgd2UgYXJlIGFib3ZlIHRoaXMgdGhyZXNob2xkXG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSB3ZSBhcmUgc2VlaW5nIHRoaXMgZGF0YXNldFxuICAgICAgICAvLyBXZSBvdmVycmlkZSB0aGUgJ2RhdGEnIHByb3BlcnR5IHdpdGggYSBzZXR0ZXIgdGhhdCBzdG9yZXMgdGhlXG4gICAgICAgIC8vIHJhdyBkYXRhIGluIF9kYXRhLCBidXQgcmVhZHMgdGhlIGRlY2ltYXRlZCBkYXRhIGZyb20gX2RlY2ltYXRlZFxuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBQb2ludCB0aGUgY2hhcnQgdG8gdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICBsZXQgZGVjaW1hdGVkO1xuICAgICAgc3dpdGNoIChvcHRpb25zLmFsZ29yaXRobSkge1xuICAgICAgY2FzZSAnbHR0Yic6XG4gICAgICAgIGRlY2ltYXRlZCA9IGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pbi1tYXgnOlxuICAgICAgICBkZWNpbWF0ZWQgPSBtaW5NYXhEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgfVxuXG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG5cbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHtfYm91bmRTZWdtZW50LCBfYm91bmRTZWdtZW50cywgX25vcm1hbGl6ZUFuZ2xlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGxldCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuXG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG5cbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBib3VuZGFyeSBub3Qgc3VwcG9ydGluZyBgc2VnbWVudHNgIChzaW1wbGVBcmMpXG4gICAgICAvLyBCb3VuZHMgYXJlIHByb3ZpZGVkIGFzIGB0YXJnZXRgIGZvciBwYXJ0aWFsIGNpcmNsZSwgb3IgdW5kZWZpbmVkIGZvciBmdWxsIGNpcmNsZVxuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIEdldCBhbGwgc2VnbWVudHMgZnJvbSBgdGFyZ2V0YCB0aGF0IGludGVyc2VjdCB0aGUgYm91bmRzIG9mIGN1cnJlbnQgc2VnbWVudCBvZiBgbGluZWBcbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcblxuICAgIGZvciAoY29uc3QgdGd0IG9mIHRhcmdldFNlZ21lbnRzKSB7XG4gICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG5cbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcblxuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQ7XG59XG5cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gIGlmIChhICYmIGIpIHtcbiAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gIH1cbiAgcmV0dXJuIGEgPyBhW3Byb3BdIDogYiA/IGJbcHJvcF0gOiAwO1xufVxuIiwgIi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5wb2ludC5qcycpLmRlZmF1bHQgfSBQb2ludEVsZW1lbnRcbiAqL1xuXG5pbXBvcnQge0xpbmVFbGVtZW50fSBmcm9tICcuLi8uLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfcG9pbnRzRnJvbVNlZ21lbnRzfSBmcm9tICcuL2ZpbGxlci5zZWdtZW50LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdIHwgeyB4OiBudW1iZXI7IHk6IG51bWJlcjsgfX0gYm91bmRhcnlcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50P31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgX2xvb3AgPSBmYWxzZTtcblxuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgIHBvaW50cyxcbiAgICBvcHRpb25zOiB7dGVuc2lvbjogMH0sXG4gICAgX2xvb3AsXG4gICAgX2Z1bGxMb29wOiBfbG9vcFxuICB9KSA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5maWxsICE9PSBmYWxzZTtcbn1cbiIsICJpbXBvcnQge2lzT2JqZWN0LCBpc0Zpbml0ZSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uLy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLnNjYWxlLmpzJykuZGVmYXVsdCB9IFNjYWxlXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJykuZGVmYXVsdCB9IExpbmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vdHlwZXMvaW5kZXguanMnKS5GaWxsVGFyZ2V0IH0gRmlsbFRhcmdldFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuQ29tcGxleEZpbGxUYXJnZXQgfSBDb21wbGV4RmlsbFRhcmdldFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICBsZXQgZmlsbCA9IHNvdXJjZS5maWxsO1xuICBjb25zdCB2aXNpdGVkID0gW2luZGV4XTtcbiAgbGV0IHRhcmdldDtcblxuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG5cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSBzb3VyY2VzW2ZpbGxdO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG5cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgLyoqIEB0eXBlIHtzdHJpbmcgfCB7dmFsdWU6IG51bWJlcn19ICovXG4gIGNvbnN0IGZpbGwgPSBwYXJzZUZpbGxPcHRpb24obGluZSk7XG5cbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG5cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG5cbiAgaWYgKGlzRmluaXRlKHRhcmdldCkgJiYgTWF0aC5mbG9vcih0YXJnZXQpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gZGVjb2RlVGFyZ2V0SW5kZXgoZmlsbFswXSwgaW5kZXgsIHRhcmdldCwgY291bnQpO1xuICB9XG5cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG5cbiAgaWYgKHRhcmdldCA9PT0gaW5kZXggfHwgdGFyZ2V0IDwgMCB8fCB0YXJnZXQgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RmlsbFRhcmdldCB8IENvbXBsZXhGaWxsVGFyZ2V0fSBmaWxsXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHJldHVybnMge251bWJlciB8IG51bGx9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFZhbHVlXG4gKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcblxuICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgIHZhbHVlID0gc3RhcnRWYWx1ZTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHZhbHVlID0gc2NhbGUub3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWluIDogc2NhbGUubWF4O1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG5cbiAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgIGZpbGwgPSAhIW9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtfaXNCZXR3ZWVufSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3sgY2hhcnQ6IENoYXJ0OyBzY2FsZTogU2NhbGU7IGluZGV4OiBudW1iZXI7IGxpbmU6IExpbmVFbGVtZW50OyB9fSBzb3VyY2VcbiAqIEByZXR1cm4ge0xpbmVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBmb3IgKGxldCBqID0gc2VnbWVudC5zdGFydDsgaiA8PSBzZWdtZW50LmVuZDsgaisrKSB7XG4gICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgTGluZUVsZW1lbnQoe3BvaW50cywgb3B0aW9uczoge319KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudFtdfVxuICovXG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdsaW5lJyk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICBpZiAobWV0YS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZWxvdztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50fSBzb3VyY2VQb2ludFxuICogQHBhcmFtIHtMaW5lRWxlbWVudFtdfSBsaW5lc0JlbG93XG4gKi9cbmZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgY29uc3QgcG9zdHBvbmVkID0gW107XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKykge1xuICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgcG9pbnR9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuXG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIC8vIEZpcnN0IHBvaW50IG9mIGFuIHNlZ21lbnQgLT4gbmVlZCB0byBhZGQgYW5vdGhlciBwb2ludCBiZWZvcmUgdGhpcyxcbiAgICAgIC8vIGZyb20gbmV4dCBsaW5lIGJlbG93LlxuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgLy8gSW4gdGhlIG1pZGRsZSBvZiBhbiBzZWdtZW50LCBubyBuZWVkIHRvIGFkZCBtb3JlIHBvaW50cy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHt7cG9pbnQ/OiBQb2ludEVsZW1lbnQsIGZpcnN0PzogYm9vbGVhbiwgbGFzdD86IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG4iLCAiaW1wb3J0IHtUQVV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vLyBUT0RPOiB1c2UgZWxlbWVudHMuQXJjRWxlbWVudCBpbnN0ZWFkXG5leHBvcnQgY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuXG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzRmluaXRlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2dldFRhcmdldFBpeGVsLCBfZ2V0VGFyZ2V0VmFsdWV9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtfYnVpbGRTdGFja0xpbmV9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5zdGFjay5qcyc7XG5pbXBvcnQge3NpbXBsZUFyY30gZnJvbSAnLi9zaW1wbGVBcmMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG5cbiAgaWYgKGlzRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG5cbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuXG4gIGlmIChpc0Zpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG5cbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuIiwgImltcG9ydCB7Y2xpcEFyZWEsIHVuY2xpcEFyZWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfZmluZFNlZ21lbnRFbmQsIF9nZXRCb3VuZHMsIF9zZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5pbXBvcnQge19nZXRUYXJnZXR9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcblxuICBjdHguc2F2ZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblxuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuXG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuXG4iLCAiLyoqXG4gKiBQbHVnaW4gYmFzZWQgb24gZGlzY3Vzc2lvbiBmcm9tIHRoZSBmb2xsb3dpbmcgQ2hhcnQuanMgaXNzdWVzOlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjM4MCNpc3N1ZWNvbW1lbnQtMjc5OTYxNTY5XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNDQwI2lzc3VlY29tbWVudC0yNTY0NjE4OTdcbiAqL1xuXG5pbXBvcnQgTGluZUVsZW1lbnQgZnJvbSAnLi4vLi4vZWxlbWVudHMvZWxlbWVudC5saW5lLmpzJztcbmltcG9ydCB7X2RyYXdmaWxsfSBmcm9tICcuL2ZpbGxlci5kcmF3aW5nLmpzJztcbmltcG9ydCB7X3Nob3VsZEFwcGx5RmlsbH0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2RlY29kZUZpbGwsIF9yZXNvbHZlVGFyZ2V0fSBmcm9tICcuL2ZpbGxlci5vcHRpb25zLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2ZpbGxlcicsXG5cbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgIHNvdXJjZSA9IG51bGw7XG5cbiAgICAgIGlmIChsaW5lICYmIGxpbmUub3B0aW9ucyAmJiBsaW5lIGluc3RhbmNlb2YgTGluZUVsZW1lbnQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICBpZiAoIXNvdXJjZSB8fCBzb3VyY2UuZmlsbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5maWxsID0gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlLmxpbmUudXBkYXRlQ29udHJvbFBvaW50cyhhcmVhLCBzb3VyY2UuYXhpcyk7XG4gICAgICBpZiAoZHJhdyAmJiBzb3VyY2UuZmlsbCkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuXG4gICAgICBpZiAoX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcblxuICAgIGlmICghX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRoLCBkcmF3UG9pbnRMZWdlbmQsIHJlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtcbiAgX2lzQmV0d2VlbixcbiAgY2FsbGJhY2sgYXMgY2FsbCxcbiAgY2xpcEFyZWEsXG4gIGdldFJ0bEFkYXB0ZXIsXG4gIG92ZXJyaWRlVGV4dERpcmVjdGlvbixcbiAgcmVzdG9yZVRleHREaXJlY3Rpb24sXG4gIHRvRm9udCxcbiAgdG9QYWRkaW5nLFxuICB1bmNsaXBBcmVhLFxuICB2YWx1ZU9yRGVmYXVsdCxcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19hbGlnblN0YXJ0RW5kLCBfdGV4dFgsIF90b0xlZnRSaWdodENlbnRlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3RvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICovXG5cbmNvbnN0IGdldEJveFNpemUgPSAobGFiZWxPcHRzLCBmb250U2l6ZSkgPT4ge1xuICBsZXQge2JveEhlaWdodCA9IGZvbnRTaXplLCBib3hXaWR0aCA9IGZvbnRTaXplfSA9IGxhYmVsT3B0cztcblxuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuXG5jb25zdCBpdGVtc0VxdWFsID0gKGEsIGIpID0+IGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmRhdGFzZXRJbmRleCA9PT0gYi5kYXRhc2V0SW5kZXggJiYgYS5pbmRleCA9PT0gYi5pbmRleDtcblxuZXhwb3J0IGNsYXNzIExlZ2VuZCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3sgY3R4OiBhbnk7IG9wdGlvbnM6IGFueTsgY2hhcnQ6IGFueTsgfX0gY29uZmlnXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcblxuICAgIC8vIENvbnRhaW5zIGhpdCBib3hlcyBmb3IgZWFjaCBkYXRhc2V0IChpbiBkYXRhc2V0IG9yZGVyKVxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuICAgIC8qKlxuIFx0XHQgKiBAcHJpdmF0ZVxuIFx0XHQgKi9cbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG5cbiAgICAvLyBBcmUgd2UgaW4gZG91Z2hudXQgbW9kZSB3aGljaCBoYXMgYSBkaWZmZXJlbnQgZGF0YSB0eXBlXG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMubGVnZW5kSXRlbXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxpbmVXaWR0aHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG5cbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gdGhpcy5fbWFyZ2lucy5sZWZ0O1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IHRoaXMuX21hcmdpbnMudG9wO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gIH1cblxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGwobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuXG4gICAgaWYgKGxhYmVsT3B0cy5maWx0ZXIpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuZmlsdGVyKChpdGVtKSA9PiBsYWJlbE9wdHMuZmlsdGVyKGl0ZW0sIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cblxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gIH1cblxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuXG4gICAgLy8gVGhlIGxlZ2VuZCBtYXkgbm90IGJlIGRpc3BsYXllZCBmb3IgYSB2YXJpZXR5IG9mIHJlYXNvbnMgaW5jbHVkaW5nXG4gICAgLy8gdGhlIGZhY3QgdGhhdCB0aGUgZGVmYXVsdHMgZ290IHNldCB0byBgZmFsc2VgLlxuICAgIC8vIFdoZW4gdGhlIGxlZ2VuZCBpcyBub3QgZGlzcGxheWVkLCB0aGVyZSBhcmUgbm8gZ3VhcmFudGVlcyB0aGF0IHRoZSBvcHRpb25zXG4gICAgLy8gYXJlIGNvcnJlY3RseSBmb3JtYXR0ZWQgc28gd2UgbmVlZCB0byBiYWlsIG91dCBhcyBlYXJseSBhcyBwb3NzaWJsZS5cbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDsgLy8gZmlsbCBhbGwgdGhlIHdpZHRoXG4gICAgICBoZWlnaHQgPSB0aGlzLl9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0OyAvLyBmaWxsIGFsbCB0aGUgaGVpZ2h0XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpICsgMTA7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9maXRSb3dzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhXaWR0aCwgb3B0aW9uczoge2xhYmVsczoge3BhZGRpbmd9fX0gPSB0aGlzO1xuICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgIC8vIFdpZHRoIG9mIGVhY2ggbGluZSBvZiBsZWdlbmQgYm94ZXMuIExhYmVscyB3cmFwIG9udG8gbXVsdGlwbGUgbGluZXMgd2hlbiB0aGVyZSBhcmUgdG9vIG1hbnkgdG8gZml0IG9uIG9uZVxuICAgIGNvbnN0IGxpbmVXaWR0aHMgPSB0aGlzLmxpbmVXaWR0aHMgPSBbMF07XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuXG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuXG4gICAgICBpZiAoaSA9PT0gMCB8fCBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gMV0gKyBpdGVtV2lkdGggKyAyICogcGFkZGluZyA+IG1heFdpZHRoKSB7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAoaSA+IDAgPyAwIDogMSldID0gMDtcbiAgICAgICAgdG9wICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gIH1cblxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgbGFiZWxGb250LCBib3hXaWR0aCwgX2l0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuXG4gICAgbGV0IHRvdGFsV2lkdGggPSBwYWRkaW5nO1xuICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcblxuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcblxuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3Qge2l0ZW1XaWR0aCwgaXRlbUhlaWdodH0gPSBjYWxjdWxhdGVJdGVtU2l6ZShib3hXaWR0aCwgbGFiZWxGb250LCBjdHgsIGxlZ2VuZEl0ZW0sIF9pdGVtSGVpZ2h0KTtcblxuICAgICAgLy8gSWYgdG9vIHRhbGwsIGdvIHRvIG5ldyBjb2x1bW5cbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBoaXRib3ggd2lkdGggYW5kIGhlaWdodCBoZXJlLiBGaW5hbCBwb3NpdGlvbiB3aWxsIGJlIHVwZGF0ZWQgaW4gYGRyYXdgXG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcblxuICAgICAgLy8gR2V0IG1heCB3aWR0aFxuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcblxuICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoO1xuICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pOyAvLyBwcmV2aW91cyBjb2x1bW4gc2l6ZVxuXG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cblxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc0hvcml6b250YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ3RvcCcgfHwgdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAnYm90dG9tJztcbiAgfVxuXG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2RyYXcoKTtcblxuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuXG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuXG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcblxuICAgIC8vIGN1cnJlbnQgcG9zaXRpb25cbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB0aGUgY3R4IGZvciB0aGUgYm94XG4gICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICBjb25zdCBsaW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVXaWR0aCwgMSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5maWxsU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUNhcCwgJ2J1dHQnKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2hPZmZzZXQsIDApO1xuICAgICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lSm9pbiwgJ21pdGVyJyk7XG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5zdHJva2VTdHlsZSwgZGVmYXVsdENvbG9yKTtcblxuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG5cbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICAvLyBSZWNhbGN1bGF0ZSB4IGFuZCB5IGZvciBkcmF3UG9pbnQoKSBiZWNhdXNlIGl0cyBleHBlY3RpbmdcbiAgICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG5cbiAgICAgICAgLy8gRHJhdyBwb2ludFN0eWxlIGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgZHJhd1BvaW50TGVnZW5kKGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclksIGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggJiYgYm94V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRHJhdyBib3ggYXMgbGVnZW5kIHN5bWJvbFxuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gd2hlbiBib3hIZWlnaHQgPCBmb250U2l6ZSAod2FudCBpdCBjZW50ZXJlZClcbiAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IHhCb3hMZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIoeCwgYm94V2lkdGgpO1xuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxlZ2VuZEl0ZW0uYm9yZGVyUmFkaXVzKTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gSG9yaXpvbnRhbFxuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yOyAvLyBmb3Igc3RyaWtldGhyb3VnaCBlZmZlY3RcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gcmVuZGVyIGluIGNvcnJlY3QgY29sb3VyXG5cbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG5cbiAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcblxuICAgICAgZHJhd0xlZ2VuZEJveChyZWFsWCwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcblxuICAgICAgLy8gRmlsbCB0aGUgYWN0dWFsIGxhYmVsXG4gICAgICBmaWxsVGV4dChydGxIZWxwZXIueCh4KSwgeSwgbGVnZW5kSXRlbSk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBmb250TGluZUhlaWdodCA9IGxhYmVsRm9udC5saW5lSGVpZ2h0O1xuICAgICAgICBjdXJzb3IueSArPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzdG9yZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gb3B0cy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG5cbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuXG4gICAgLy8gVGhlc2UgZGVmYXVsdHMgYXJlIHVzZWQgd2hlbiB0aGUgbGVnZW5kIGlzIHZlcnRpY2FsLlxuICAgIC8vIFdoZW4gaG9yaXpvbnRhbCwgdGhleSBhcmUgY29tcHV0ZWQgYmVsb3cuXG4gICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgbGV0IG1heFdpZHRoID0gdGhpcy53aWR0aDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBNb3ZlIGxlZnQgLyByaWdodCBzbyB0aGF0IHRoZSB0aXRsZSBpcyBhYm92ZSB0aGUgbGVnZW5kIGxpbmVzXG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGRvd24gc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBzdGFjayBpbiBldmVyeSBhbGlnbm1lbnRcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2Uga25vdyB0aGUgbGVmdCBlZGdlIG9mIHRoZSBpbm5lciBsZWdlbmQgYm94LCBjb21wdXRlIHRoZSBjb3JyZWN0XG4gICAgLy8gWCBjb29yZGluYXRlIGZyb20gdGhlIHRpdGxlIGFsaWdubWVudFxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcblxuICAgIC8vIENhbnZhcyBzZXR1cFxuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKF90b0xlZnRSaWdodENlbnRlcihwb3NpdGlvbikpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG5cbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb21wdXRlVGl0bGVIZWlnaHQoKSB7XG4gICAgY29uc3QgdGl0bGVPcHRzID0gdGhpcy5vcHRpb25zLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICByZXR1cm4gdGl0bGVPcHRzLmRpc3BsYXkgPyB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlUGFkZGluZy5oZWlnaHQgOiAwO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcblxuICAgIGlmIChfaXNCZXR3ZWVuKHgsIHRoaXMubGVmdCwgdGhpcy5yaWdodClcbiAgICAgICYmIF9pc0JldHdlZW4oeSwgdGhpcy50b3AsIHRoaXMuYm90dG9tKSkge1xuICAgICAgLy8gU2VlIGlmIHdlIGFyZSB0b3VjaGluZyBvbmUgb2YgdGhlIGRhdGFzZXQgYm94ZXNcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcblxuICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpXG4gICAgICAgICAgJiYgX2lzQmV0d2Vlbih5LCBoaXRCb3gudG9wLCBoaXRCb3gudG9wICsgaGl0Qm94LmhlaWdodCkpIHtcbiAgICAgICAgICAvLyBUb3VjaGluZyBhbiBlbGVtZW50XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFydCBldmVudCBhbHJlYWR5IGhhcyByZWxhdGl2ZSBwb3NpdGlvbiBpbiBpdFxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsKG9wdHMub25MZWF2ZSwgW2UsIHByZXZpb3VzLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG5cbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uSG92ZXIsIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaG92ZXJlZEl0ZW0pIHtcbiAgICAgIGNhbGwob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCkge1xuICBjb25zdCBpdGVtV2lkdGggPSBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KTtcbiAgY29uc3QgaXRlbUhlaWdodCA9IGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGxhYmVsRm9udC5saW5lSGVpZ2h0KTtcbiAgcmV0dXJuIHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtV2lkdGgobGVnZW5kSXRlbSwgYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4KSB7XG4gIGxldCBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW0udGV4dDtcbiAgaWYgKGxlZ2VuZEl0ZW1UZXh0ICYmIHR5cGVvZiBsZWdlbmRJdGVtVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBsZWdlbmRJdGVtVGV4dCA9IGxlZ2VuZEl0ZW1UZXh0LnJlZHVjZSgoYSwgYikgPT4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiKTtcbiAgfVxuICByZXR1cm4gYm94V2lkdGggKyAobGFiZWxGb250LnNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtVGV4dCkud2lkdGg7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1IZWlnaHQoX2l0ZW1IZWlnaHQsIGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KSB7XG4gIGxldCBpdGVtSGVpZ2h0ID0gX2l0ZW1IZWlnaHQ7XG4gIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0KGxlZ2VuZEl0ZW0sIGZvbnRMaW5lSGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gaXRlbUhlaWdodDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGxlZ2VuZEl0ZW0udGV4dCA/IGxlZ2VuZEl0ZW0udGV4dC5sZW5ndGggOiAwO1xuICByZXR1cm4gZm9udExpbmVIZWlnaHQgKiBsYWJlbEhlaWdodDtcbn1cblxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnbGVnZW5kJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogTGVnZW5kLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuXG4gIC8vIER1cmluZyB0aGUgYmVmb3JlVXBkYXRlIHN0ZXAsIHRoZSBsYXlvdXQgY29uZmlndXJhdGlvbiBuZWVkcyB0byBydW5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaWYgdGhlIGxlZ2VuZCBwb3NpdGlvbiBjaGFuZ2VzICh2aWEgYW4gb3B0aW9uIHVwZGF0ZSlcbiAgLy8gdGhlIGxheW91dCBzeXN0ZW0gcmVzcGVjdHMgdGhlIGNoYW5nZS4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy83NTI3XG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIC8vIFRoZSBsYWJlbHMgbmVlZCB0byBiZSBidWlsdCBhZnRlciBkYXRhc2V0cyBhcmUgdXBkYXRlZCB0byBlbnN1cmUgdGhhdCBjb2xvcnNcbiAgLy8gYW5kIG90aGVyIHN0eWxpbmcgYXJlIGNvcnJlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNjk2OFxuICBhZnRlclVwZGF0ZShjaGFydCkge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsZWdlbmQuYnVpbGRMYWJlbHMoKTtcbiAgICBsZWdlbmQuYWRqdXN0SGl0Qm94ZXMoKTtcbiAgfSxcblxuXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIHdlaWdodDogMTAwMCxcblxuICAgIC8vIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGhhbmRsZVxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG5cbiAgICBsYWJlbHM6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGJveFdpZHRoOiA0MCxcbiAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgLy8gR2VuZXJhdGVzIGxhYmVscyBzaG93biBpbiB0aGUgbGVnZW5kXG4gICAgICAvLyBWYWxpZCBwcm9wZXJ0aWVzIHRvIHJldHVybjpcbiAgICAgIC8vIHRleHQgOiB0ZXh0IHRvIGRpc3BsYXlcbiAgICAgIC8vIGZpbGxTdHlsZSA6IGZpbGwgb2YgY29sb3VyZWQgYm94XG4gICAgICAvLyBzdHJva2VTdHlsZTogc3Ryb2tlIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gaGlkZGVuIDogaWYgdGhpcyBsZWdlbmQgaXRlbSByZWZlcnMgdG8gYSBoaWRkZW4gaXRlbVxuICAgICAgLy8gbGluZUNhcCA6IGNhcCBzdHlsZSBmb3IgbGluZVxuICAgICAgLy8gbGluZURhc2hcbiAgICAgIC8vIGxpbmVEYXNoT2Zmc2V0IDpcbiAgICAgIC8vIGxpbmVKb2luIDpcbiAgICAgIC8vIGxpbmVXaWR0aCA6XG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yLCB1c2VCb3JkZXJSYWRpdXMsIGJvcmRlclJhZGl1c319ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHVzZUJvcmRlclJhZGl1cyAmJiAoYm9yZGVyUmFkaXVzIHx8IHN0eWxlLmJvcmRlclJhZGl1cyksXG5cbiAgICAgICAgICAgIC8vIEJlbG93IGlzIGV4dHJhIGRhdGEgdXNlZCBmb3IgdG9nZ2xpbmcgdGhlIGRhdGFzZXRzXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGl0bGU6IHtcbiAgICAgIGNvbG9yOiAoY3R4KSA9PiBjdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgdGV4dDogJycsXG4gICAgfVxuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtQSSwgaXNBcnJheSwgdG9QYWRkaW5nLCB0b0ZvbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfdG9MZWZ0UmlnaHRDZW50ZXIsIF9hbGlnblN0YXJ0RW5kfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcbmltcG9ydCB7cmVuZGVyVGV4dH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBUaXRsZSBleHRlbmRzIEVsZW1lbnQge1xuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgIHRoaXMuX3BhZGRpbmcgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcblxuICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IG1heEhlaWdodDtcblxuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRleHRTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gdGV4dFNpemU7XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG5cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICB0aXRsZVkgPSB0b3AgKyBvZmZzZXQ7XG4gICAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICB0aXRsZVggPSBsZWZ0ICsgb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogLTAuNTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpdGxlWCA9IHJpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICByb3RhdGlvbiA9IFBJICogMC41O1xuICAgICAgfVxuICAgICAgbWF4V2lkdGggPSBib3R0b20gLSB0b3A7XG4gICAgfVxuICAgIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRPcHRzID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGZvbnRPcHRzLmxpbmVIZWlnaHQ7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aGlzLl9kcmF3QXJncyhvZmZzZXQpO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcblxuICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIHRpdGxlT3B0cyk7XG4gIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3RpdGxlJyxcblxuICAvKipcblx0ICogRm9yIHRlc3RzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWxlbWVudDogVGl0bGUsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMjAwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgdG8gYmUgYWJvdmVcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsICJpbXBvcnQge1RpdGxlfSBmcm9tICcuL3BsdWdpbi50aXRsZS5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdzdWJ0aXRsZScsXG5cbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICBvcHRpb25zLFxuICAgICAgY2hhcnRcbiAgICB9KTtcblxuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG5cbiAgc3RvcChjaGFydCkge1xuICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgbWFwLmRlbGV0ZShjaGFydCk7XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwICAgICAgICAgLy8gYnkgZGVmYXVsdCBncmVhdGVyIHRoYW4gbGVnZW5kICgxMDAwKSBhbmQgc21hbGxlciB0aGFuIHRpdGxlICgyMDAwKVxuICB9LFxuXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH0sXG59O1xuIiwgImltcG9ydCBBbmltYXRpb25zIGZyb20gJy4uL2NvcmUvY29yZS5hbmltYXRpb25zLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7ZWFjaCwgbm9vcCwgaXNOdWxsT3JVbmRlZiwgaXNBcnJheSwgX2VsZW1lbnRzRXF1YWwsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5pbXBvcnQge2dldFJ0bEFkYXB0ZXIsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiwgcmVzdG9yZVRleHREaXJlY3Rpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5ydGwuanMnO1xuaW1wb3J0IHtkaXN0YW5jZUJldHdlZW5Qb2ludHMsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIGRyYXdQb2ludH0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMnKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudCB9IEFjdGl2ZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMnKS5JbnRlcmFjdGlvbkl0ZW0gfSBJbnRlcmFjdGlvbkl0ZW1cbiAqL1xuXG5jb25zdCBwb3NpdGlvbmVycyA9IHtcbiAgLyoqXG5cdCAqIEF2ZXJhZ2UgbW9kZSBwbGFjZXMgdGhlIHRvb2x0aXAgYXQgdGhlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnRzIHNob3duXG5cdCAqL1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4U2V0ID0gbmV3IFNldCgpO1xuICAgIGxldCB5ID0gMDtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4U2V0LmFkZChwb3MueCk7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm8gdmlzaWJsZSBpdGVtcyB3aGVyZSBmb3VuZCwgcmV0dXJuIGZhbHNlIHNvIHdlIGRvbid0IGhhdmUgdG8gZGl2aWRlIGJ5IDAgd2hpY2ggcmVkdWNlcyBpbiBOYU5cbiAgICBpZiAoY291bnQgPT09IDAgfHwgeFNldC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgeEF2ZXJhZ2UgPSBbLi4ueFNldF0ucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyB4U2V0LnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogeEF2ZXJhZ2UsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuXHQgKiBHZXRzIHRoZSB0b29sdGlwIHBvc2l0aW9uIG5lYXJlc3Qgb2YgdGhlIGl0ZW0gbmVhcmVzdCB0byB0aGUgZXZlbnQgcG9zaXRpb25cblx0ICovXG4gIG5lYXJlc3QoaXRlbXMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG5cbiAgICAgICAgaWYgKGQgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlID0gZDtcbiAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuXG4vLyBIZWxwZXIgdG8gcHVzaCBvciBjb25jYXQgYmFzZWQgb24gaWYgdGhlIDJuZCBwYXJhbWV0ZXIgaXMgYW4gYXJyYXkgb3Igbm90XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gIGlmICh0b1B1c2gpIHtcbiAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICAvLyBiYXNlID0gYmFzZS5jb25jYXQodG9QdXNoKTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYXJyYXkgb2Ygc3RyaW5ncyBzcGxpdCBieSBuZXdsaW5lXG4gKiBAcGFyYW0geyp9IHN0ciAtIFRoZSB2YWx1ZSB0byBzcGxpdCBieSBuZXdsaW5lLlxuICogQHJldHVybnMge3N0cmluZ3xzdHJpbmdbXX0gdmFsdWUgaWYgbmV3bGluZSBwcmVzZW50IC0gUmV0dXJuZWQgZnJvbSBTdHJpbmcgc3BsaXQoKSBtZXRob2RcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBzcGxpdE5ld2xpbmVzKHN0cikge1xuICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCdcXG4nKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5cbi8qKlxuICogUHJpdmF0ZSBoZWxwZXIgdG8gY3JlYXRlIGEgdG9vbHRpcCBpdGVtIG1vZGVsXG4gKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuICogQHBhcmFtIHtBY3RpdmVFbGVtZW50fSBpdGVtIC0ge2VsZW1lbnQsIGluZGV4LCBkYXRhc2V0SW5kZXh9IHRvIGNyZWF0ZSB0aGUgdG9vbHRpcCBpdGVtIGZvclxuICogQHJldHVybiBuZXcgdG9vbHRpcCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcblxuICByZXR1cm4ge1xuICAgIGNoYXJ0LFxuICAgIGxhYmVsLFxuICAgIHBhcnNlZDogY29udHJvbGxlci5nZXRQYXJzZWQoaW5kZXgpLFxuICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgIGZvcm1hdHRlZFZhbHVlOiB2YWx1ZSxcbiAgICBkYXRhc2V0OiBjb250cm9sbGVyLmdldERhdGFzZXQoKSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIGRhdGFzZXRJbmRleCxcbiAgICBlbGVtZW50XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaXplIG9mIHRoZSB0b29sdGlwXG4gKi9cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuXG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuXG4gIC8vIENvdW50IG9mIGFsbCBsaW5lcyBpbiB0aGUgYm9keVxuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG5cbiAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IHRpdGxlTGluZUNvdW50ICogdGl0bGVGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZ1xuXHRcdFx0KyBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tO1xuICB9XG4gIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgaGVpZ2h0IGRlcGVuZGluZyBvbiBib3hIZWlnaHRcbiAgICBjb25zdCBib2R5TGluZUhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IE1hdGgubWF4KGJveEhlaWdodCwgYm9keUZvbnQubGluZUhlaWdodCkgOiBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGhlaWdodCArPSBib2R5TGluZUl0ZW1Db3VudCAqIGJvZHlMaW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSBib2R5TGluZUl0ZW1Db3VudCkgKiBib2R5Rm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gIH1cbiAgaWYgKGZvb3RlckxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcFxuXHRcdFx0KyBmb290ZXJMaW5lQ291bnQgKiBmb290ZXJGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICB9XG5cbiAgLy8gVGl0bGUgd2lkdGhcbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuXG4gIGN0eC5zYXZlKCk7XG5cbiAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSB3aWR0aFxuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcblxuICAvLyBCb2R5IGxpbmVzIG1heSBpbmNsdWRlIHNvbWUgZXh0cmEgd2lkdGggZHVlIHRvIHRoZSBjb2xvciBib3hcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgYmFjayB0byAwXG4gIHdpZHRoUGFkZGluZyA9IDA7XG5cbiAgLy8gRm9vdGVyIHdpZHRoXG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG5cbiAgY3R4LnJlc3RvcmUoKTtcblxuICAvLyBBZGQgcGFkZGluZ1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuXG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSkge1xuICBjb25zdCB7eSwgaGVpZ2h0fSA9IHNpemU7XG5cbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuXG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuXG4gIGlmIChkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpKSB7XG4gICAgeEFsaWduID0gJ2NlbnRlcic7XG4gIH1cblxuICByZXR1cm4geEFsaWduO1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBnZXQgdGhlIGFsaWdubWVudCBvZiBhIHRvb2x0aXAgZ2l2ZW4gdGhlIHNpemVcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG5cbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICBsZXQge3gsIHdpZHRofSA9IHNpemU7XG4gIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09ICh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBsb2NhdGlvbiBhIHRvb2x0aXAgbmVlZHMgdG8gYmUgcGxhY2VkIGF0IGdpdmVuIHRoZSBpbml0aWFsIHBvc2l0aW9uICh2aWEgdGhlIHZtKSBhbmQgdGhlIHNpemUgYW5kIGFsaWdubWVudFxuICovXG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG5cbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcblxuICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgeCArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICB4IC09IE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgY2FyZXRTaXplO1xuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSArIGNhcmV0U2l6ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuXG4gIHJldHVybiBhbGlnbiA9PT0gJ2NlbnRlcidcbiAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLyAyXG4gICAgOiBhbGlnbiA9PT0gJ3JpZ2h0J1xuICAgICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC0gcGFkZGluZy5yaWdodFxuICAgICAgOiB0b29sdGlwLnggKyBwYWRkaW5nLmxlZnQ7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGJ1aWxkIGJlZm9yZSBhbmQgYWZ0ZXIgYm9keSBsaW5lc1xuICovXG5mdW5jdGlvbiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhjYWxsYmFjaykge1xuICByZXR1cm4gcHVzaE9yQ29uY2F0KFtdLCBzcGxpdE5ld2xpbmVzKGNhbGxiYWNrKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuXG5jb25zdCBkZWZhdWx0Q2FsbGJhY2tzID0ge1xuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgIGlmICh0b29sdGlwSXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICBjb25zdCBsYWJlbENvdW50ID0gbGFiZWxzID8gbGFiZWxzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICB9IGVsc2UgaWYgKGxhYmVsQ291bnQgPiAwICYmIGl0ZW0uZGF0YUluZGV4IDwgbGFiZWxDb3VudCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIGFmdGVyVGl0bGU6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbSwgZGF0YSlcbiAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgaWYgKHRoaXMgJiYgdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICB9XG5cbiAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuXG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICBsYWJlbCArPSAnOiAnO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG4gIGxhYmVsQ29sb3IodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgIH07XG4gIH0sXG4gIGxhYmVsVGV4dENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICB9LFxuICBsYWJlbFBvaW50U3R5bGUodG9vbHRpcEl0ZW0pIHtcbiAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgIH07XG4gIH0sXG4gIGFmdGVyTGFiZWw6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGFmdGVyQm9keTogbm9vcCxcblxuICAvLyBBcmdzIGFyZTogKHRvb2x0aXBJdGVtcywgZGF0YSlcbiAgYmVmb3JlRm9vdGVyOiBub29wLFxuICBmb290ZXI6IG5vb3AsXG4gIGFmdGVyRm9vdGVyOiBub29wXG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayBmcm9tIG9iamVjdCB3aXRoIGNvbnRleHQgYW5kIGFyZ3VtZW50cy5cbiAqIElmIGNhbGxiYWNrIHJldHVybnMgYHVuZGVmaW5lZGAsIHRoZW4gd2lsbCBiZSBpbnZva2VkIGRlZmF1bHQgY2FsbGJhY2suXG4gKiBAcGFyYW0ge1JlY29yZDxrZXlvZiB0eXBlb2YgZGVmYXVsdENhbGxiYWNrcywgRnVuY3Rpb24+fSBjYWxsYmFja3NcbiAqIEBwYXJhbSB7a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3N9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gY3R4XG4gKiBAcGFyYW0geyp9IGFyZ1xuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCBuYW1lLCBjdHgsIGFyZykge1xuICBjb25zdCByZXN1bHQgPSBjYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG5cbiAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRDYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIENoYXJ0LlRvb2x0aXAucG9zaXRpb25lcnNcbiAgICovXG4gIHN0YXRpYyBwb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIC8vIFRPRE86IFY0LCBtYWtlIHRoaXMgcHJpdmF0ZSwgcmVuYW1lIHRvIGBfbGFiZWxTdHlsZXNgLCBhbmQgY29tYmluZSB3aXRoIGBsYWJlbFBvaW50U3R5bGVzYFxuICAgIC8vIGFuZCBgbGFiZWxUZXh0Q29sb3JzYCB0byBjcmVhdGUgYSBzaW5nbGUgdmFyaWFibGVcbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcblxuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGNvbnRleHQgfHxcblx0XHRcdCh0aGlzLiRjb250ZXh0ID0gY3JlYXRlVG9vbHRpcENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMsIHRoaXMuX3Rvb2x0aXBJdGVtcykpO1xuICB9XG5cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcblxuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICBjb25zdCB0aXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ3RpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcblxuICAgIGxldCBsaW5lcyA9IFtdO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZVRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlclRpdGxlKSk7XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYmVmb3JlQm9keScsIHRoaXMsIHRvb2x0aXBJdGVtcylcbiAgICApO1xuICB9XG5cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG5cbiAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpID0+IHtcbiAgICAgIGNvbnN0IGJvZHlJdGVtID0ge1xuICAgICAgICBiZWZvcmU6IFtdLFxuICAgICAgICBsaW5lczogW10sXG4gICAgICAgIGFmdGVyOiBbXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNjb3BlZCA9IG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYmVmb3JlLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2JlZm9yZUxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWwnLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYWZ0ZXJMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG5cbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cblxuICBnZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKFxuICAgICAgaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2sob3B0aW9ucy5jYWxsYmFja3MsICdhZnRlckJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIC8vIEdldCB0aGUgZm9vdGVyIGFuZCBiZWZvcmVGb290ZXIgYW5kIGFmdGVyRm9vdGVyIGxpbmVzXG4gIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2Zvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG4gICAgY29uc3QgYWZ0ZXJGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlckZvb3RlcicsIHRoaXMsIHRvb2x0aXBJdGVtcyk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gYWN0aXZlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b29sdGlwSXRlbXMucHVzaChjcmVhdGVUb29sdGlwSXRlbSh0aGlzLmNoYXJ0LCBhY3RpdmVbaV0pKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIGZpbHRlciBmdW5jdGlvbiwgdXNlIGl0IHRvIG1vZGlmeSB0aGUgdG9vbHRpcCBpdGVtc1xuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCBhIHNvcnRpbmcgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpID0+IG9wdGlvbnMuaXRlbVNvcnQoYSwgYiwgZGF0YSkpO1xuICAgIH1cblxuICAgIC8vIERldGVybWluZSBjb2xvcnMgZm9yIGJveGVzXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsQ29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxQb2ludFN0eWxlJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxUZXh0Q29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gbGFiZWxQb2ludFN0eWxlcztcbiAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IGxhYmVsVGV4dENvbG9ycztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgcmV0dXJuIHRvb2x0aXBJdGVtcztcbiAgfVxuXG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG5cbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG5cbiAgICAgIHRoaXMudGl0bGUgPSB0aGlzLmdldFRpdGxlKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJlZm9yZUJvZHkgPSB0aGlzLmdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYm9keSA9IHRoaXMuZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5hZnRlckJvZHkgPSB0aGlzLmdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5mb290ZXIgPSB0aGlzLmdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuXG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuXG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG5cbiAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIHg6IGJhY2tncm91bmRQb2ludC54LFxuICAgICAgICB5OiBiYWNrZ3JvdW5kUG9pbnQueSxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHQsXG4gICAgICAgIGNhcmV0WDogcG9zaXRpb24ueCxcbiAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7Y2hhcnQ6IHRoaXMuY2hhcnQsIHRvb2x0aXA6IHRoaXMsIHJlcGxheX0pO1xuICAgIH1cbiAgfVxuXG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcblxuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG5cbiAgZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7Y2FyZXRTaXplLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBjb25zdCB7eDogcHRYLCB5OiBwdFl9ID0gdG9vbHRpcFBvaW50O1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XG4gICAgbGV0IHgxLCB4MiwgeDMsIHkxLCB5MiwgeTM7XG5cbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG5cbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBMZWZ0IGRyYXdzIGJvdHRvbSAtPiB0b3AsIHRoaXMgeTEgaXMgb24gdGhlIGJvdHRvbVxuICAgICAgICB5MSA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSBwdFggKyB3aWR0aDtcbiAgICAgICAgeDIgPSB4MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBSaWdodCBkcmF3cyB0b3AgLT4gYm90dG9tLCB0aHVzIHkxIGlzIG9uIHRoZSB0b3BcbiAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgIH1cblxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cblxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gVG9wIGRyYXdzIGxlZnQgLT4gcmlnaHQsIHRodXMgeDEgaXMgb24gdGhlIGxlZnRcbiAgICAgICAgeDEgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkxID0gcHRZICsgaGVpZ2h0O1xuICAgICAgICB5MiA9IHkxICsgY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIEJvdHRvbSBkcmF3cyByaWdodCAtPiBsZWZ0LCB0aHVzIHgxIGlzIG9uIHRoZSByaWdodFxuICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeTMgPSB5MTtcbiAgICB9XG4gICAgcmV0dXJuIHt4MSwgeDIsIHgzLCB5MSwgeTIsIHkzfTtcbiAgfVxuXG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG5cbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy50aXRsZUFsaWduLCBvcHRpb25zKTtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuXG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy50aXRsZUNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7IC8vIExpbmUgSGVpZ2h0IGFuZCBzcGFjaW5nXG5cbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7IC8vIElmIExhc3QsIGFkZCBtYXJnaW4sIHJlbW92ZSBzcGFjaW5nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvciA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRofSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG5cbiAgICBpZiAob3B0aW9ucy51c2VQb2ludFN0eWxlKSB7XG4gICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgcmFkaXVzOiBNYXRoLm1pbihib3hXaWR0aCwgYm94SGVpZ2h0KSAvIDIsIC8vIGZpdCB0aGUgY2lyY2xlIGluIHRoZSBib3hcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAvLyB4IGFuZCB5IHRvIGJlIGNlbnRlciBvZiBmaWd1cmUgKGluc3RlYWQgb2YgdG9wIGxlZnQpXG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcblxuICAgICAgLy8gRmlsbCB0aGUgcG9pbnQgd2l0aCB3aGl0ZSBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICBkcmF3UG9pbnQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHBvaW50XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsYWJlbENvbG9yLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3JkZXJcbiAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9yLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGggfHwgMSk7IC8vIFRPRE8sIHY0IHJlbW92ZSBmYWxsYmFja1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9yLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG5cbiAgICAgIC8vIEZpbGwgYSB3aGl0ZSByZWN0IHNvIHRoYXQgY29sb3VycyBtZXJnZSBuaWNlbHkgaWYgdGhlIG9wYWNpdHkgaXMgPCAxXG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKTtcbiAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9yLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogb3V0ZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG5cbiAgICAgICAgLy8gSW5uZXIgc3F1YXJlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9ybWFsIHJlY3RcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBmaWxsU3R5bGVcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gIH1cblxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG5cbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuXG4gICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgIH07XG5cbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG5cbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcblxuICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiwgb3B0aW9ucyk7XG5cbiAgICAvLyBCZWZvcmUgYm9keSBsaW5lc1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgeExpbmVQYWRkaW5nID0gZGlzcGxheUNvbG9ycyAmJiBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiAhPT0gJ3JpZ2h0J1xuICAgICAgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gKGJveFdpZHRoIC8gMiArIGJveFBhZGRpbmcpIDogKGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcpXG4gICAgICA6IDA7XG5cbiAgICAvLyBEcmF3IGJvZHkgbGluZXMgbm93XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGJvZHkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG5cbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICAvLyBEcmF3IExlZ2VuZC1saWtlIGJveGVzIGlmIG5lZWRlZFxuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICAvLyBSZXNldCBmb3IgYW55IGxpbmVzIHRoYXQgZG9uJ3QgaW5jbHVkZSBjb2xvcmJveFxuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBiYWNrIHRvIDAgZm9yIGFmdGVyIGJvZHlcbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcblxuICAgIC8vIEFmdGVyIGJvZHkgbGluZXNcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZzsgLy8gUmVtb3ZlIGxhc3QgYm9keSBzcGFjaW5nXG4gIH1cblxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMuZm9vdGVyQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgcHQueSArPSBvcHRpb25zLmZvb3Rlck1hcmdpblRvcDtcblxuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuZm9vdGVyQ29sb3I7XG4gICAgICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LmZpbGwoKTtcblxuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGUgeC95IGFuaW1hdGlvbiB0YXJnZXRzIHdoZW4gX2FjdGl2ZSBlbGVtZW50cyBhcmUgYW5pbWF0aW5nIHRvb1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgaWYgdGhlIHRvb2x0aXAgd2lsbCBkcmF3IGFueXRoaW5nXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB0b29sdGlwIHdpbGwgcmVuZGVyXG4gICAqL1xuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cblxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgbGV0IG9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG5cbiAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcHQgPSB7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnlcbiAgICB9O1xuXG4gICAgLy8gSUUxMS9FZGdlIGRvZXMgbm90IGxpa2UgdmVyeSBzbWFsbCBvcGFjaXRpZXMsIHNvIHNuYXAgdG8gMFxuICAgIG9wYWNpdHkgPSBNYXRoLmFicyhvcGFjaXR5KSA8IDFlLTMgPyAwIDogb3BhY2l0eTtcblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICAgIC8vIFRydXRoeS9mYWxzZXkgdmFsdWUgZm9yIGVtcHR5IHRvb2x0aXBcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG5cbiAgICAgIC8vIERyYXcgQmFja2dyb3VuZFxuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG5cbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIHB0LnkgKz0gcGFkZGluZy50b3A7XG5cbiAgICAgIC8vIFRpdGxlc1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEJvZHlcbiAgICAgIHRoaXMuZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEZvb3RlclxuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBlbGVtZW50cyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhlIHRvb2x0aXBcblx0ICovXG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cblxuICAvKipcblx0ICogU2V0IGFjdGl2ZSBlbGVtZW50cyBpbiB0aGUgdG9vbHRpcFxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmVFbGVtZW50cyBBcnJheSBvZiBhY3RpdmUgZGF0YXNldEluZGV4L2luZGV4IHBhaXJzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZXZlbnRQb3NpdGlvbiBTeW50aGV0aWMgZXZlbnQgcG9zaXRpb24gdXNlZCBpbiBwb3NpdGlvbmluZ1xuXHQgKi9cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuXG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB0aGlzLl9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBldmVudFBvc2l0aW9uKTtcblxuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBhbiBldmVudFxuXHQgKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGUgLSBUaGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdG9vbHRpcCBjaGFuZ2VkXG5cdCAqL1xuICBoYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhID0gdHJ1ZSkge1xuICAgIGlmIChyZXBsYXkgJiYgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IGZhbHNlO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuXG4gICAgLy8gV2hlbiB0aGVyZSBhcmUgbXVsdGlwbGUgaXRlbXMgc2hvd24sIGJ1dCB0aGUgdG9vbHRpcCBwb3NpdGlvbiBpcyBuZWFyZXN0IG1vZGVcbiAgICAvLyBhbiB1cGRhdGUgbWF5IG5lZWQgdG8gYmUgbWFkZSBiZWNhdXNlIG91ciBwb3NpdGlvbiBtYXkgaGF2ZSBjaGFuZ2VkIGV2ZW4gdGhvdWdoXG4gICAgLy8gdGhlIGl0ZW1zIGFyZSB0aGUgc2FtZSBhcyBiZWZvcmUuXG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG5cbiAgICAvLyBSZW1lbWJlciBMYXN0IEFjdGl2ZXNcbiAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcblxuICAgIC8vIE9ubHkgaGFuZGxlIHRhcmdldCBldmVudCBvbiB0b29sdGlwIGNoYW5nZVxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG5cbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEhlbHBlciBmb3IgZGV0ZXJtaW5pbmcgdGhlIGFjdGl2ZSBlbGVtZW50cyBmb3IgZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uSXRlbVtdfSBsYXN0QWN0aXZlIC0gUHJldmlvdXNseSBhY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVwbGF5XSAtIFRoaXMgaXMgYSByZXBsYXllZCBldmVudCAoZnJvbSB1cGRhdGUpXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luQ2hhcnRBcmVhXSAtIFRoZSBldmVudCBpcyBpbnNpZGUgY2hhcnRBcmVhXG5cdCAqIEByZXR1cm5zIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICAvLyBCdXQgbWFrZSBzdXJlIHRoYXQgYWN0aXZlIGVsZW1lbnRzIGFyZSBzdGlsbCB2YWxpZC5cbiAgICAgIHJldHVybiBsYXN0QWN0aXZlLmZpbHRlcihpID0+XG4gICAgICAgIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1tpLmRhdGFzZXRJbmRleF0gJiZcbiAgICAgICAgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpLmRhdGFzZXRJbmRleCkuY29udHJvbGxlci5nZXRQYXJzZWQoaS5pbmRleCkgIT09IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIEFjdGl2ZSBFbGVtZW50cyBmb3IgdG9vbHRpcHNcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuXG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9XG5cbiAgLyoqXG5cdCAqIERldGVybWluZSBpZiB0aGUgYWN0aXZlIGVsZW1lbnRzICsgZXZlbnQgY29tYmluYXRpb24gY2hhbmdlcyB0aGVcblx0ICogdG9vbHRpcCBwb3NpdGlvblxuXHQgKiBAcGFyYW0ge2FycmF5fSBhY3RpdmUgLSBBY3RpdmUgZWxlbWVudHNcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gRXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIHBvc2l0aW9uIGNoYW5nZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcG9zaXRpb24gaGFzIGNoYW5nZWRcblx0ICovXG4gIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgY29uc3Qge2NhcmV0WCwgY2FyZXRZLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIGFjdGl2ZSwgZSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uICE9PSBmYWxzZSAmJiAoY2FyZXRYICE9PSBwb3NpdGlvbi54IHx8IGNhcmV0WSAhPT0gcG9zaXRpb24ueSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG5cbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcblxuICAgIGlmICh0b29sdGlwICYmIHRvb2x0aXAuX3dpbGxSZW5kZXIoKSkge1xuICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgdG9vbHRpcFxuICAgICAgfTtcblxuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3Jywgey4uLmFyZ3MsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0b29sdGlwLmRyYXcoY2hhcnQuY3R4KTtcblxuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIC8vIElmIHRoZSBldmVudCBpcyByZXBsYXllZCBmcm9tIGB1cGRhdGVgLCB3ZSBzaG91bGQgZXZhbHVhdGUgd2l0aCB0aGUgZmluYWwgcG9zaXRpb25zLlxuICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgLy8gbm90aWZ5IGNoYXJ0IGFib3V0IHRoZSBjaGFuZ2UsIHNvIGl0IHdpbGwgcmVuZGVyXG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBleHRlcm5hbDogbnVsbCxcbiAgICBwb3NpdGlvbjogJ2F2ZXJhZ2UnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgIHRpdGxlRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICB0aXRsZVNwYWNpbmc6IDIsXG4gICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgdGl0bGVBbGlnbjogJ2xlZnQnLFxuICAgIGJvZHlDb2xvcjogJyNmZmYnLFxuICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgIGJvZHlGb250OiB7XG4gICAgfSxcbiAgICBib2R5QWxpZ246ICdsZWZ0JyxcbiAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgIGZvb3RlclNwYWNpbmc6IDIsXG4gICAgZm9vdGVyTWFyZ2luVG9wOiA2LFxuICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZm9vdGVyQWxpZ246ICdsZWZ0JyxcbiAgICBwYWRkaW5nOiA2LFxuICAgIGNhcmV0UGFkZGluZzogMixcbiAgICBjYXJldFNpemU6IDUsXG4gICAgY29ybmVyUmFkaXVzOiA2LFxuICAgIGJveEhlaWdodDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIGJveFdpZHRoOiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgbXVsdGlLZXlCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgZGlzcGxheUNvbG9yczogdHJ1ZSxcbiAgICBib3hQYWRkaW5nOiAwLFxuICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwKScsXG4gICAgYm9yZGVyV2lkdGg6IDAsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdjYXJldFgnLCAnY2FyZXRZJ10sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICB9XG4gICAgfSxcbiAgICBjYWxsYmFja3M6IGRlZmF1bHRDYWxsYmFja3NcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgYm9keUZvbnQ6ICdmb250JyxcbiAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgdGl0bGVGb250OiAnZm9udCdcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG5cbiAgLy8gUmVzb2x2ZSBhZGRpdGlvbmFsbHkgZnJvbSBgaW50ZXJhY3Rpb25gIG9wdGlvbnMgYW5kIGRlZmF1bHRzLlxuICBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzOiBbJ2ludGVyYWN0aW9uJ11cbn07XG4iLCAiaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWYsIHZhbHVlT3JEZWZhdWx0LCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpID0+IHtcbiAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5kZXggPSBsYWJlbHMucHVzaChyYXcpIC0gMTtcbiAgICBhZGRlZExhYmVscy51bnNoaWZ0KHtpbmRleCwgbGFiZWw6IHJhd30pO1xuICB9IGVsc2UgaWYgKGlzTmFOKHJhdykpIHtcbiAgICBpbmRleCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIGluZGV4O1xufTtcblxuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuXG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuXG5mdW5jdGlvbiBfZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgIHJldHVybiBsYWJlbHNbdmFsdWVdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnY2F0ZWdvcnknO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogX2dldExhYmVsRm9yVmFsdWVcbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgfVxuXG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBJZiB3ZSBhcmUgdmlld2luZyBzb21lIHN1YnNldCBvZiBsYWJlbHMsIHNsaWNlIHRoZSBvcmlnaW5hbCBhcnJheVxuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcblxuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBNYXRoLm1heChsYWJlbHMubGVuZ3RoIC0gKG9mZnNldCA/IDAgOiAxKSwgMSk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuXG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBfZ2V0TGFiZWxGb3JWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB2ZXJ0aWNhbCBjYXRlZ29yeSBzY2FsZSByZXZlcnNlIGlzIGludmVydGVkLlxuICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gZ2V0IGRhdGEgdmFsdWUgbG9jYXRpb25zLiBWYWx1ZSBjYW4gZWl0aGVyIGJlIGFuIGluZGV4IG9yIGEgbnVtZXJpY2FsIHZhbHVlXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgLy8gTXVzdCBvdmVycmlkZSBiYXNlIGltcGxlbWVudGF0aW9uIGJlY2F1c2UgaXQgY2FsbHMgZ2V0UGl4ZWxGb3JWYWx1ZVxuICAvLyBhbmQgY2F0ZWdvcnkgc2NhbGUgY2FuIGhhdmUgZHVwbGljYXRlIHZhbHVlc1xuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmJvdHRvbTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHthbG1vc3RFcXVhbHMsIGFsbW9zdFdob2xlLCBuaWNlTnVtLCBfZGVjaW1hbFBsYWNlcywgX3NldE1pbkFuZE1heEJ5S2V5LCBzaWduLCB0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHNldCBvZiBsaW5lYXIgdGlja3MgZm9yIGFuIGF4aXNcbiAqIDEuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuc3RlcCBhcmUgZGVmaW5lZDpcbiAqICAgIGlmIChtYXggLSBtaW4pIC8gc3RlcCBpcyBhbiBpbnRlZ2VyLCB0aWNrcyBhcmUgZ2VuZXJhdGVkIGFzIFttaW4sIG1pbiArIHN0ZXAsIC4uLiwgbWF4XVxuICogICAgTm90ZSB0aGF0IHRoZSBnZW5lcmF0aW9uT3B0aW9ucy5tYXhDb3VudCBzZXR0aW5nIGlzIHJlc3BlY3RlZCBpbiB0aGlzIHNjZW5hcmlvXG4gKlxuICogMi4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIGFuZCBnZW5lcmF0aW9uT3B0aW9ucy5jb3VudCBpcyBkZWZpbmVkXG4gKiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBjb3VudFxuICogICAgVGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzcGFjaW5nLCAuLi4sIG1heF1cbiAqXG4gKiAzLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5jb3VudCBpcyBkZWZpbmVkXG4gKiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIGNvdW50XG4gKlxuICogNC4gQ29tcHV0ZSBvcHRpbWFsIHNwYWNpbmcgb2YgdGlja3MgdXNpbmcgbmljZU51bSBhbGdvcml0aG1cbiAqXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFycmF5IG9mIHRpY2sgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgLy8gVG8gZ2V0IGEgXCJuaWNlXCIgdmFsdWUgZm9yIHRoZSB0aWNrIHNwYWNpbmcsIHdlIHdpbGwgdXNlIHRoZSBhcHByb3ByaWF0ZWx5IG5hbWVkXG4gIC8vIFwibmljZSBudW1iZXJcIiBhbGdvcml0aG0uIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTA2ODgxL25pY2UtbGFiZWwtYWxnb3JpdGhtLWZvci1jaGFydHMtd2l0aC1taW5pbXVtLXRpY2tzXG4gIC8vIGZvciBkZXRhaWxzLlxuXG4gIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gIGNvbnN0IHtib3VuZHMsIHN0ZXAsIG1pbiwgbWF4LCBwcmVjaXNpb24sIGNvdW50LCBtYXhUaWNrcywgbWF4RGlnaXRzLCBpbmNsdWRlQm91bmRzfSA9IGdlbmVyYXRpb25PcHRpb25zO1xuICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICBjb25zdCBtYXhTcGFjZXMgPSBtYXhUaWNrcyAtIDE7XG4gIGNvbnN0IHttaW46IHJtaW4sIG1heDogcm1heH0gPSBkYXRhUmFuZ2U7XG4gIGNvbnN0IG1pbkRlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtaW4pO1xuICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgY29uc3QgY291bnREZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYoY291bnQpO1xuICBjb25zdCBtaW5TcGFjaW5nID0gKHJtYXggLSBybWluKSAvIChtYXhEaWdpdHMgKyAxKTtcbiAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIGxldCBmYWN0b3IsIG5pY2VNaW4sIG5pY2VNYXgsIG51bVNwYWNlcztcblxuICAvLyBCZXlvbmQgTUlOX1NQQUNJTkcgZmxvYXRpbmcgcG9pbnQgbnVtYmVycyBiZWluZyB0byBsb3NlIHByZWNpc2lvblxuICAvLyBzdWNoIHRoYXQgd2UgY2FuJ3QgZG8gdGhlIG1hdGggbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRpY2tzXG4gIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xuICB9XG5cbiAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAtIE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpO1xuICBpZiAobnVtU3BhY2VzID4gbWF4U3BhY2VzKSB7XG4gICAgLy8gSWYgdGhlIGNhbGN1bGF0ZWQgbnVtIG9mIHNwYWNlcyBleGNlZWRzIG1heE51bVNwYWNlcywgcmVjYWxjdWxhdGUgaXRcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcbiAgICAvLyBJZiB0aGUgdXNlciBzcGVjaWZpZWQgYSBwcmVjaXNpb24sIHJvdW5kIHRvIHRoYXQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuXG4gIGlmIChib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgfSBlbHNlIHtcbiAgICBuaWNlTWluID0gcm1pbjtcbiAgICBuaWNlTWF4ID0gcm1heDtcbiAgfVxuXG4gIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQgJiYgc3RlcCAmJiBhbG1vc3RXaG9sZSgobWF4IC0gbWluKSAvIHN0ZXAsIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgIC8vIENhc2UgMTogSWYgbWluLCBtYXggYW5kIHN0ZXBTaXplIGFyZSBzZXQgYW5kIHRoZXkgbWFrZSBhbiBldmVubHkgc3BhY2VkIHNjYWxlIHVzZSBpdC5cbiAgICAvLyBzcGFjaW5nID0gc3RlcDtcbiAgICAvLyBudW1TcGFjZXMgPSAobWF4IC0gbWluKSAvIHNwYWNpbmc7XG4gICAgLy8gTm90ZSB0aGF0IHdlIHJvdW5kIGhlcmUgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIGFsbW9zdFdob2xlIHRyYW5zbGF0ZWQgYW4gRlAgZXJyb3JcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBudW1TcGFjZXM7XG4gICAgbmljZU1pbiA9IG1pbjtcbiAgICBuaWNlTWF4ID0gbWF4O1xuICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgIC8vIENhc2VzIDIgJiAzLCB3ZSBoYXZlIGEgY291bnQgc3BlY2lmaWVkLiBIYW5kbGUgb3B0aW9uYWwgdXNlciBkZWZpbmVkIGVkZ2VzIHRvIHRoZSByYW5nZS5cbiAgICAvLyBTb21ldGltZXMgdGhlc2UgYXJlIG5vLW9wcywgYnV0IGl0IG1ha2VzIHRoZSBjb2RlIGEgbG90IGNsZWFyZXJcbiAgICAvLyBhbmQgd2hlbiBhIHVzZXIgZGVmaW5lZCByYW5nZSBpcyBzcGVjaWZpZWQsIHdlIHdhbnQgdGhlIGNvcnJlY3QgdGlja3NcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICAvLyBDYXNlIDRcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcblxuICAgIC8vIElmIHZlcnkgY2xvc2UgdG8gb3VyIHJvdW5kZWQgdmFsdWUsIHVzZSBpdC5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIHNwYWNpbmcgd2lsbCBoYXZlIGNoYW5nZWQgaW4gY2FzZXMgMSwgMiwgYW5kIDMgc28gdGhlIGZhY3RvciBjYW5ub3QgYmUgY29tcHV0ZWRcbiAgLy8gdW50aWwgdGhpcyBwb2ludFxuICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoXG4gICAgX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksXG4gICAgX2RlY2ltYWxQbGFjZXMobmljZU1pbilcbiAgKTtcbiAgZmFjdG9yID0gTWF0aC5wb3coMTAsIGlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSA/IGRlY2ltYWxQbGFjZXMgOiBwcmVjaXNpb24pO1xuICBuaWNlTWluID0gTWF0aC5yb3VuZChuaWNlTWluICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG5cbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuXG4gICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICBqKys7IC8vIFNraXAgbmljZU1pblxuICAgICAgfVxuICAgICAgLy8gSWYgdGhlIG5leHQgbmljZSB0aWNrIGlzIGNsb3NlIHRvIG1pbiwgc2tpcCBpdFxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcbiAgICBjb25zdCB0aWNrVmFsdWUgPSBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICBpZiAobWF4RGVmaW5lZCAmJiB0aWNrVmFsdWUgPiBtYXgpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogdGlja1ZhbHVlfSk7XG4gIH1cblxuICBpZiAobWF4RGVmaW5lZCAmJiBpbmNsdWRlQm91bmRzICYmIG5pY2VNYXggIT09IG1heCkge1xuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0aWNrIGlzIHRvbyBjbG9zZSB0byBtYXgsIHJlcGxhY2UgaXQgd2l0aCBtYXgsIGVsc2UgYWRkIG1heFxuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuXG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXM7XG5cbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuXG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcblxuICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgIHNldE1heCgwKTtcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcbiAgICAgICAgc2V0TWluKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgbGV0IG9mZnNldCA9IG1heCA9PT0gMCA/IDEgOiBNYXRoLmFicyhtYXggKiAwLjA1KTtcblxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG5cbiAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgc2V0TWluKG1pbiAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG5cbiAgZ2V0VGlja0xpbWl0KCkge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcblxuICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBzY2FsZXMuJHt0aGlzLmlkfS50aWNrcy5zdGVwU2l6ZTogJHtzdGVwU2l6ZX0gd291bGQgcmVzdWx0IGdlbmVyYXRpbmcgdXAgdG8gJHttYXhUaWNrc30gdGlja3MuIExpbWl0aW5nIHRvIDEwMDAuYCk7XG4gICAgICAgIG1heFRpY2tzID0gMTAwMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4VGlja3MgPSB0aGlzLmNvbXB1dGVUaWNrTGltaXQoKTtcbiAgICAgIG1heFRpY2tzTGltaXQgPSBtYXhUaWNrc0xpbWl0IHx8IDExO1xuICAgIH1cblxuICAgIGlmIChtYXhUaWNrc0xpbWl0KSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG5cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIC8vIEZpZ3VyZSBvdXQgd2hhdCB0aGUgbWF4IG51bWJlciBvZiB0aWNrcyB3ZSBjYW4gc3VwcG9ydCBpdCBpcyBiYXNlZCBvbiB0aGUgc2l6ZSBvZlxuICAgIC8vIHRoZSBheGlzIGFyZWEuIEZvciBub3csIHdlIHNheSB0aGF0IHRoZSBtaW5pbXVtIHRpY2sgc3BhY2luZyBpbiBwaXhlbHMgbXVzdCBiZSA0MFxuICAgIC8vIFdlIGFsc28gbGltaXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIHRvIDExIHdoaWNoIGdpdmVzIGEgbmljZSAxMCBzcXVhcmVzIG9uXG4gICAgLy8gdGhlIGdyYXBoLiBNYWtlIHN1cmUgd2UgYWx3YXlzIGhhdmUgYXQgbGVhc3QgMiB0aWNrc1xuICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgbWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG5cbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSBvdXIgbWF4IGFuZCBtaW4gZ2l2ZW4gdGhlIHRpY2sgdmFsdWVzLFxuICAgIC8vIHNpbmNlIHdlIHByb2JhYmx5IGhhdmUgZXhwYW5kZWQgdGhlIHJhbmdlIG9mIHRoZSBzY2FsZVxuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG5cbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG5cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG59XG4iLCAiaW1wb3J0IHtpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3RvUmFkaWFuc30gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcblxuICBzdGF0aWMgaWQgPSAnbGluZWFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgIH1cbiAgfTtcblxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBtYXggOiAxO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgbGVuZ3RoID0gaG9yaXpvbnRhbCA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLm9wdGlvbnMudGlja3MubWluUm90YXRpb24pO1xuICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgIGNvbnN0IHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKTtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGxlbmd0aCAvIE1hdGgubWluKDQwLCB0aWNrRm9udC5saW5lSGVpZ2h0IC8gcmF0aW8pKTtcbiAgfVxuXG4gIC8vIFV0aWxzXG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuIiwgImltcG9ydCB7ZmluaXRlT3JEZWZhdWx0LCBpc0Zpbml0ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7X3NldE1pbkFuZE1heEJ5S2V5LCBsb2cxMH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcblxuY29uc3QgbG9nMTBGbG9vciA9IHYgPT4gTWF0aC5mbG9vcihsb2cxMCh2KSk7XG5jb25zdCBjaGFuZ2VFeHBvbmVudCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih2KSArIG0pO1xuXG5mdW5jdGlvbiBpc01ham9yKHRpY2tWYWwpIHtcbiAgY29uc3QgcmVtYWluID0gdGlja1ZhbCAvIChNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih0aWNrVmFsKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuXG5mdW5jdGlvbiBzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIHtcbiAgY29uc3QgcmFuZ2VTdGVwID0gTWF0aC5wb3coMTAsIHJhbmdlRXhwKTtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKG1pbiAvIHJhbmdlU3RlcCk7XG4gIGNvbnN0IGVuZCA9IE1hdGguY2VpbChtYXggLyByYW5nZVN0ZXApO1xuICByZXR1cm4gZW5kIC0gc3RhcnQ7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0RXhwKG1pbiwgbWF4KSB7XG4gIGNvbnN0IHJhbmdlID0gbWF4IC0gbWluO1xuICBsZXQgcmFuZ2VFeHAgPSBsb2cxMEZsb29yKHJhbmdlKTtcbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPiAxMCkge1xuICAgIHJhbmdlRXhwKys7XG4gIH1cbiAgd2hpbGUgKHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkgPCAxMCkge1xuICAgIHJhbmdlRXhwLS07XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKHJhbmdlRXhwLCBsb2cxMEZsb29yKG1pbikpO1xufVxuXG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbG9nYXJpdGhtaWMgdGlja3NcbiAqIEBwYXJhbSBnZW5lcmF0aW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aWNrc1xuICogQHBhcmFtIGRhdGFSYW5nZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3RbXX0gYXJyYXkgb2YgdGljayBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHttaW4sIG1heH0pIHtcbiAgbWluID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgbWluKTtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWluRXhwID0gbG9nMTBGbG9vcihtaW4pO1xuICBsZXQgZXhwID0gc3RhcnRFeHAobWluLCBtYXgpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGNvbnN0IHN0ZXBTaXplID0gTWF0aC5wb3coMTAsIGV4cCk7XG4gIGNvbnN0IGJhc2UgPSBtaW5FeHAgPiBleHAgPyBNYXRoLnBvdygxMCwgbWluRXhwKSA6IDA7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5yb3VuZCgobWluIC0gYmFzZSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKChtaW4gLSBiYXNlKSAvIHN0ZXBTaXplIC8gMTApICogc3RlcFNpemUgKiAxMDtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcigoc3RhcnQgLSBvZmZzZXQpIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgdmFsdWUgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBNYXRoLnJvdW5kKChiYXNlICsgb2Zmc2V0ICsgc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uKTtcbiAgd2hpbGUgKHZhbHVlIDwgbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWUsIG1ham9yOiBpc01ham9yKHZhbHVlKSwgc2lnbmlmaWNhbmR9KTtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gc2lnbmlmaWNhbmQgPCAxNSA/IDE1IDogMjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpZ25pZmljYW5kKys7XG4gICAgfVxuICAgIGlmIChzaWduaWZpY2FuZCA+PSAyMCkge1xuICAgICAgZXhwKys7XG4gICAgICBzaWduaWZpY2FuZCA9IDI7XG4gICAgICBwcmVjaXNpb24gPSBleHAgPj0gMCA/IDEgOiBwcmVjaXNpb247XG4gICAgfVxuICAgIHZhbHVlID0gTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfVxuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHZhbHVlKTtcbiAgdGlja3MucHVzaCh7dmFsdWU6IGxhc3RUaWNrLCBtYWpvcjogaXNNYWpvcihsYXN0VGljayksIHNpZ25pZmljYW5kfSk7XG5cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICdsb2dhcml0aG1pYyc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLFxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgY29uc3QgdmFsdWUgPSBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLnBhcnNlLmFwcGx5KHRoaXMsIFtyYXcsIGluZGV4XSk7XG4gICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgJiYgdmFsdWUgPiAwID8gdmFsdWUgOiBudWxsO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG5cbiAgICB0aGlzLm1pbiA9IGlzRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmVnaW5BdFplcm8pIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGlmIGRhdGEgaGFzIGAwYCBpbiBpdCBvciBgYmVnaW5BdFplcm9gIGlzIHRydWUsIG1pbiAobm9uIHplcm8pIHZhbHVlIGlzIGF0IGJvdHRvbVxuICAgIC8vIG9mIHNjYWxlLCBhbmQgaXQgZG9lcyBub3QgZXF1YWwgc3VnZ2VzdGVkTWluLCBsb3dlciB0aGUgbWluIGJvdW5kIGJ5IG9uZSBleHAuXG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiAhaXNGaW5pdGUodGhpcy5fdXNlck1pbikpIHtcbiAgICAgIHRoaXMubWluID0gbWluID09PSBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCkgPyBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgLTEpIDogY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7IC8vIGluY2x1ZGVzIG51bGxcbiAgICAgICAgc2V0TWluKDEpO1xuICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWF4LCAtMSkpO1xuICAgIH1cbiAgICBpZiAobWF4IDw9IDApIHtcblxuICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1pbiwgKzEpKTtcbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcblxuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuXG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG5cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cblxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgIHJldHVybiBNYXRoLnBvdygxMCwgdGhpcy5fc3RhcnRWYWx1ZSArIGRlY2ltYWwgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxufVxuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtfbG9uZ2VzdFRleHQsIGFkZFJvdW5kZWRSZWN0UGF0aCwgcmVuZGVyVGV4dCwgX2lzUG9pbnRJbkFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtIQUxGX1BJLCBUQVUsIHRvRGVncmVlcywgdG9SYWRpYW5zLCBfbm9ybWFsaXplQW5nbGUsIFBJfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgTGluZWFyU2NhbGVCYXNlIGZyb20gJy4vc2NhbGUubGluZWFyYmFzZS5qcyc7XG5pbXBvcnQgVGlja3MgZnJvbSAnLi4vY29yZS9jb3JlLnRpY2tzLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHQsIGlzQXJyYXksIGlzRmluaXRlLCBjYWxsYmFjayBhcyBjYWxsQ2FsbGJhY2ssIGlzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dCwgdG9Gb250LCB0b1BhZGRpbmcsIHRvVFJCTENvcm5lcnN9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIG9wdHMuZGlzcGxheSkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGlja09wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogcG9zLFxuICAgIGVuZDogcG9zICsgc2l6ZVxuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBmaXQgYSByYWRpYWwgbGluZWFyIHNjYWxlIHdpdGggcG9pbnQgbGFiZWxzXG4gKi9cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuXG4gIC8vIFJpZ2h0LCB0aGlzIGlzIHJlYWxseSBjb25mdXNpbmcgYW5kIHRoZXJlIGlzIGEgbG90IG9mIG1hdGhzIGdvaW5nIG9uIGhlcmVcbiAgLy8gVGhlIGdpc3Qgb2YgdGhlIHByb2JsZW0gaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbm5uaWNrLzY5NmNjOWM1NWY0YjBiZWI4ZmU5XG4gIC8vXG4gIC8vIFJlYWN0aW9uOiBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My90b29tdWNoc2NpZW5jZS5naWZcbiAgLy9cbiAgLy8gU29sdXRpb246XG4gIC8vXG4gIC8vIFdlIGFzc3VtZSB0aGUgcmFkaXVzIG9mIHRoZSBwb2x5Z29uIGlzIGhhbGYgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyBhdCBmaXJzdFxuICAvLyBhdCBlYWNoIGluZGV4IHdlIGNoZWNrIGlmIHRoZSB0ZXh0IG92ZXJsYXBzLlxuICAvL1xuICAvLyBXaGVyZSBpdCBkb2VzLCB3ZSBzdG9yZSB0aGF0IGFuZ2xlIGFuZCB0aGF0IGluZGV4LlxuICAvL1xuICAvLyBBZnRlciBmaW5kaW5nIHRoZSBsYXJnZXN0IGluZGV4IGFuZCBhbmdsZSB3ZSBjYWxjdWxhdGUgaG93IG11Y2ggd2UgbmVlZCB0byByZW1vdmVcbiAgLy8gZnJvbSB0aGUgc2hhcGUgcmFkaXVzIHRvIG1vdmUgdGhlIHBvaW50IGlud2FyZHMgYnkgdGhhdCB4LlxuICAvL1xuICAvLyBXZSBhdmVyYWdlIHRoZSBsZWZ0IGFuZCByaWdodCBkaXN0YW5jZXMgdG8gZ2V0IHRoZSBtYXhpbXVtIHNoYXBlIHJhZGl1cyB0aGF0IGNhbiBmaXQgaW4gdGhlIGJveFxuICAvLyBhbG9uZyB3aXRoIGxhYmVscy5cbiAgLy9cbiAgLy8gT25jZSB3ZSBoYXZlIHRoYXQsIHdlIGNhbiBmaW5kIHRoZSBjZW50cmUgcG9pbnQgZm9yIHRoZSBjaGFydCwgYnkgdGFraW5nIHRoZSB4IHRleHQgcHJvdHJ1c2lvblxuICAvLyBvbiBlYWNoIHNpZGUsIHJlbW92aW5nIHRoYXQgZnJvbSB0aGUgc2l6ZSwgaGFsdmluZyBpdCBhbmQgYWRkaW5nIHRoZSBsZWZ0IHggcHJvdHJ1c2lvbiB3aWR0aC5cbiAgLy9cbiAgLy8gVGhpcyB3aWxsIG1lYW4gd2UgaGF2ZSBhIHNoYXBlIGZpdHRlZCB0byB0aGUgY2FudmFzLCBhcyBsYXJnZSBhcyBpdCBjYW4gYmUgd2l0aCB0aGUgbGFiZWxzXG4gIC8vIGFuZCBwb3NpdGlvbiBpdCBpbiB0aGUgbW9zdCBzcGFjZSBlZmZpY2llbnQgbWFubmVyXG4gIC8vXG4gIC8vIGh0dHBzOi8vZGwuZHJvcGJveHVzZXJjb250ZW50LmNvbS91LzM0NjAxMzYzL3llYWhzY2llbmNlLmdpZlxuXG4gIC8vIEdldCBtYXhpbXVtIHJhZGl1cyBvZiB0aGUgcG9seWdvbi4gRWl0aGVyIGhhbGYgdGhlIGhlaWdodCAobWludXMgdGhlIHRleHQgd2lkdGgpIG9yIGhhbGYgdGhlIHdpZHRoLlxuICAvLyBVc2UgdGhpcyB0byBjYWxjdWxhdGUgdGhlIG9mZnNldCArIGNoYW5nZS4gLSBNYWtlIHN1cmUgTC9SIHByb3RydXNpb24gaXMgYXQgbGVhc3QgMCB0byBzdG9wIGlzc3VlcyB3aXRoIGNlbnRyZSBwb2ludHNcbiAgY29uc3Qgb3JpZyA9IHtcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgIHQ6IHNjYWxlLnRvcCArIHNjYWxlLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgfTtcbiAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgY29uc3QgcGFkZGluZyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBwb2ludExhYmVsT3B0cy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gcG9pbnRMYWJlbE9wdHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcbiAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcblxuICAgIGNvbnN0IGFuZ2xlUmFkaWFucyA9IF9ub3JtYWxpemVBbmdsZShzY2FsZS5nZXRJbmRleEFuZ2xlKGkpICsgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgIGNvbnN0IGhMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueCwgdGV4dFNpemUudywgMCwgMTgwKTtcbiAgICBjb25zdCB2TGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLnksIHRleHRTaXplLmgsIDkwLCAyNzApO1xuICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gIH1cblxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcbiAgICBvcmlnLmwgLSBsaW1pdHMubCxcbiAgICBsaW1pdHMuciAtIG9yaWcucixcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcbiAgICBsaW1pdHMuYiAtIG9yaWcuYlxuICApO1xuXG4gIC8vIE5vdyB0aGF0IHRleHQgc2l6ZSBpcyBkZXRlcm1pbmVkLCBjb21wdXRlIHRoZSBmdWxsIHBvc2l0aW9uc1xuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZSwgaExpbWl0cywgdkxpbWl0cykge1xuICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpO1xuICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKGhMaW1pdHMuc3RhcnQgPCBvcmlnLmwpIHtcbiAgICB4ID0gKG9yaWcubCAtIGhMaW1pdHMuc3RhcnQpIC8gc2luO1xuICAgIGxpbWl0cy5sID0gTWF0aC5taW4obGltaXRzLmwsIG9yaWcubCAtIHgpO1xuICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XG4gICAgeCA9IChoTGltaXRzLmVuZCAtIG9yaWcucikgLyBzaW47XG4gICAgbGltaXRzLnIgPSBNYXRoLm1heChsaW1pdHMuciwgb3JpZy5yICsgeCk7XG4gIH1cbiAgaWYgKHZMaW1pdHMuc3RhcnQgPCBvcmlnLnQpIHtcbiAgICB5ID0gKG9yaWcudCAtIHZMaW1pdHMuc3RhcnQpIC8gY29zO1xuICAgIGxpbWl0cy50ID0gTWF0aC5taW4obGltaXRzLnQsIG9yaWcudCAtIHkpO1xuICB9IGVsc2UgaWYgKHZMaW1pdHMuZW5kID4gb3JpZy5iKSB7XG4gICAgeSA9ICh2TGltaXRzLmVuZCAtIG9yaWcuYikgLyBjb3M7XG4gICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGluZGV4LCBpdGVtT3B0cykge1xuICBjb25zdCBvdXRlckRpc3RhbmNlID0gc2NhbGUuZHJhd2luZ0FyZWE7XG4gIGNvbnN0IHtleHRyYSwgYWRkaXRpb25hbEFuZ2xlLCBwYWRkaW5nLCBzaXplfSA9IGl0ZW1PcHRzO1xuICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nLCBhZGRpdGlvbmFsQW5nbGUpO1xuICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKF9ub3JtYWxpemVBbmdsZShwb2ludExhYmVsUG9zaXRpb24uYW5nbGUgKyBIQUxGX1BJKSkpO1xuICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICBjb25zdCBsZWZ0ID0gbGVmdEZvclRleHRBbGlnbihwb2ludExhYmVsUG9zaXRpb24ueCwgc2l6ZS53LCB0ZXh0QWxpZ24pO1xuICByZXR1cm4ge1xuICAgIC8vIGlmIHRvIGRyYXcgb3Igb3ZlcmxhcHBlZFxuICAgIHZpc2libGU6IHRydWUsXG5cbiAgICAvLyBUZXh0IHBvc2l0aW9uXG4gICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXG4gICAgeSxcblxuICAgIC8vIFRleHQgcmVuZGVyaW5nIGRhdGFcbiAgICB0ZXh0QWxpZ24sXG5cbiAgICAvLyBCb3VuZGluZyBib3hcbiAgICBsZWZ0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICBib3R0b206IHkgKyBzaXplLmhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpIHtcbiAgaWYgKCFhcmVhKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCBhcGV4ZXNJbkFyZWEgPSBfaXNQb2ludEluQXJlYSh7eDogbGVmdCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IGJvdHRvbX0sIGFyZWEpIHx8XG4gICAgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiB0b3B9LCBhcmVhKSB8fCBfaXNQb2ludEluQXJlYSh7eDogcmlnaHQsIHk6IGJvdHRvbX0sIGFyZWEpO1xuICByZXR1cm4gIWFwZXhlc0luQXJlYTtcbn1cblxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgY29uc3QgaXRlbXMgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCB7Y2VudGVyUG9pbnRMYWJlbHMsIGRpc3BsYXl9ID0gb3B0cy5wb2ludExhYmVscztcbiAgY29uc3QgaXRlbU9wdHMgPSB7XG4gICAgZXh0cmE6IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDIsXG4gICAgYWRkaXRpb25hbEFuZ2xlOiBjZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDBcbiAgfTtcbiAgbGV0IGFyZWE7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBpdGVtT3B0cy5wYWRkaW5nID0gcGFkZGluZ1tpXTtcbiAgICBpdGVtT3B0cy5zaXplID0gbGFiZWxTaXplc1tpXTtcblxuICAgIGNvbnN0IGl0ZW0gPSBjcmVhdGVQb2ludExhYmVsSXRlbShzY2FsZSwgaSwgaXRlbU9wdHMpO1xuICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgaWYgKGRpc3BsYXkgPT09ICdhdXRvJykge1xuICAgICAgaXRlbS52aXNpYmxlID0gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpO1xuICAgICAgaWYgKGl0ZW0udmlzaWJsZSkge1xuICAgICAgICBhcmVhID0gaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDAgfHwgYW5nbGUgPT09IDE4MCkge1xuICAgIHJldHVybiAnY2VudGVyJztcbiAgfSBlbHNlIGlmIChhbmdsZSA8IDE4MCkge1xuICAgIHJldHVybiAnbGVmdCc7XG4gIH1cblxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cblxuZnVuY3Rpb24gbGVmdEZvclRleHRBbGlnbih4LCB3LCBhbGlnbikge1xuICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHc7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAodyAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiB5Rm9yQW5nbGUoeSwgaCwgYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSA5MCB8fCBhbmdsZSA9PT0gMjcwKSB7XG4gICAgeSAtPSAoaCAvIDIpO1xuICB9IGVsc2UgaWYgKGFuZ2xlID4gMjcwIHx8IGFuZ2xlIDwgOTApIHtcbiAgICB5IC09IGg7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0cywgaXRlbSkge1xuICBjb25zdCB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IGl0ZW07XG4gIGNvbnN0IHtiYWNrZHJvcENvbG9yfSA9IG9wdHM7XG5cbiAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhvcHRzLmJvcmRlclJhZGl1cyk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG5cbiAgICBjb25zdCBiYWNrZHJvcExlZnQgPSBsZWZ0IC0gcGFkZGluZy5sZWZ0O1xuICAgIGNvbnN0IGJhY2tkcm9wVG9wID0gdG9wIC0gcGFkZGluZy50b3A7XG4gICAgY29uc3QgYmFja2Ryb3BXaWR0aCA9IHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgYmFja2Ryb3BIZWlnaHQgPSBib3R0b20gLSB0b3AgKyBwYWRkaW5nLmhlaWdodDtcblxuICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgIHg6IGJhY2tkcm9wTGVmdCxcbiAgICAgICAgeTogYmFja2Ryb3BUb3AsXG4gICAgICAgIHc6IGJhY2tkcm9wV2lkdGgsXG4gICAgICAgIGg6IGJhY2tkcm9wSGVpZ2h0LFxuICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgIH0pO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmZpbGxSZWN0KGJhY2tkcm9wTGVmdCwgYmFja2Ryb3BUb3AsIGJhY2tkcm9wV2lkdGgsIGJhY2tkcm9wSGVpZ2h0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb2ludExhYmVsc319ID0gc2NhbGU7XG5cbiAgZm9yIChsZXQgaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IGl0ZW0gPSBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zW2ldO1xuICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAvLyBvdmVybGFwcGluZ1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gcG9pbnRMYWJlbHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgZHJhd1BvaW50TGFiZWxCb3goY3R4LCBvcHRzQXRJbmRleCwgaXRlbSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgIGNvbnN0IHt4LCB5LCB0ZXh0QWxpZ259ID0gaXRlbTtcblxuICAgIHJlbmRlclRleHQoXG4gICAgICBjdHgsXG4gICAgICBzY2FsZS5fcG9pbnRMYWJlbHNbaV0sXG4gICAgICB4LFxuICAgICAgeSArIChwbEZvbnQubGluZUhlaWdodCAvIDIpLFxuICAgICAgcGxGb250LFxuICAgICAge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICAvLyBEcmF3IGNpcmN1bGFyIGFyY3MgYmV0d2VlbiB0aGUgcG9pbnRzXG4gICAgY3R4LmFyYyhzY2FsZS54Q2VudGVyLCBzY2FsZS55Q2VudGVyLCByYWRpdXMsIDAsIFRBVSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRHJhdyBzdHJhaWdodCBsaW5lcyBjb25uZWN0aW5nIGVhY2ggaW5kZXhcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdSYWRpdXNMaW5lKHNjYWxlLCBncmlkTGluZU9wdHMsIHJhZGl1cywgbGFiZWxDb3VudCwgYm9yZGVyT3B0cykge1xuICBjb25zdCBjdHggPSBzY2FsZS5jdHg7XG4gIGNvbnN0IGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuXG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcblxuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICBjdHguc2V0TGluZURhc2goYm9yZGVyT3B0cy5kYXNoIHx8IFtdKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyT3B0cy5kYXNoT2Zmc2V0O1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQocGFyZW50LCBpbmRleCwgbGFiZWwpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgbGFiZWwsXG4gICAgaW5kZXgsXG4gICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGlhbExpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGlzcGxheTogdHJ1ZSxcblxuICAgIC8vIEJvb2xlYW4gLSBXaGV0aGVyIHRvIGFuaW1hdGUgc2NhbGluZyB0aGUgY2hhcnQgZnJvbSB0aGUgY2VudHJlXG4gICAgYW5pbWF0ZTogdHJ1ZSxcbiAgICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG5cbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgYm9yZGVyRGFzaDogW10sXG4gICAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLjBcbiAgICB9LFxuXG4gICAgZ3JpZDoge1xuICAgICAgY2lyY3VsYXI6IGZhbHNlXG4gICAgfSxcblxuICAgIHN0YXJ0QW5nbGU6IDAsXG5cbiAgICAvLyBsYWJlbCBzZXR0aW5nc1xuICAgIHRpY2tzOiB7XG4gICAgICAvLyBCb29sZWFuIC0gU2hvdyBhIGJhY2tkcm9wIHRvIHRoZSBzY2FsZSBsYWJlbFxuICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG5cbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9LFxuXG4gICAgcG9pbnRMYWJlbHM6IHtcbiAgICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcblxuICAgICAgLy8gTnVtYmVyIC0gVGhlIGJhY2tkcm9wIHBhZGRpbmcgYWJvdmUgJiBiZWxvdyB0aGUgbGFiZWwgaW4gcGl4ZWxzXG4gICAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG5cbiAgICAgIC8vIEJvb2xlYW4gLSBpZiB0cnVlLCBzaG93IHBvaW50IGxhYmVsc1xuICAgICAgZGlzcGxheTogdHJ1ZSxcblxuICAgICAgLy8gTnVtYmVyIC0gUG9pbnQgbGFiZWwgZm9udCBzaXplIGluIHBpeGVsc1xuICAgICAgZm9udDoge1xuICAgICAgICBzaXplOiAxMFxuICAgICAgfSxcblxuICAgICAgLy8gRnVuY3Rpb24gLSBVc2VkIHRvIGNvbnZlcnQgcG9pbnQgbGFiZWxzXG4gICAgICBjYWxsYmFjayhsYWJlbCkge1xuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuXG4gICAgICAvLyBOdW1iZXIgLSBBZGRpdGlvbmwgcGFkZGluZyBiZXR3ZWVuIHNjYWxlIGFuZCBwb2ludExhYmVsXG4gICAgICBwYWRkaW5nOiA1LFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgY2VudGVyIHBvaW50IGxhYmVscyB0byBzbGljZXMgaW4gcG9sYXIgY2hhcnRcbiAgICAgIGNlbnRlclBvaW50TGFiZWxzOiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgICAndGlja3MuY29sb3InOiAnY29sb3InXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmdbXX0gKi9cbiAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgIHRoaXMuX3BvaW50TGFiZWxJdGVtcyA9IFtdO1xuICB9XG5cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAvLyBTZXQgdGhlIHVuY29uc3RyYWluZWQgZGltZW5zaW9uIGJlZm9yZSBsYWJlbCByb3RhdGlvblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xuICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgoZmFsc2UpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuXG4gICAgLy8gQ29tbW9uIGJhc2UgaW1wbGVtZW50YXRpb24gdG8gaGFuZGxlIG1pbiwgbWF4LCBiZWdpbkF0WmVyb1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpY2tzIGJhc2VkIG9uIHRoZSBzY2FsZSBkaW1lbnNpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cblxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcblxuICAgIC8vIFBvaW50IGxhYmVsc1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbENhbGxiYWNrKHRoaXMub3B0aW9ucy5wb2ludExhYmVscy5jYWxsYmFjaywgW3ZhbHVlLCBpbmRleF0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKHYsIGkpID0+IHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkpO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIHNldENlbnRlclBvaW50KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSB7XG4gICAgdGhpcy54Q2VudGVyICs9IE1hdGguZmxvb3IoKGxlZnRNb3ZlbWVudCAtIHJpZ2h0TW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHRvcE1vdmVtZW50IC0gYm90dG9tTW92ZW1lbnQpIC8gMik7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSAtPSBNYXRoLm1pbih0aGlzLmRyYXdpbmdBcmVhIC8gMiwgTWF0aC5tYXgobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpKTtcbiAgfVxuXG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuXG4gICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gIH1cblxuICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICAvLyBUYWtlIGludG8gYWNjb3VudCBoYWxmIGZvbnQgc2l6ZSArIHRoZSB5UGFkZGluZyBvZiB0aGUgdG9wIHZhbHVlXG4gICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICByZXR1cm4gKHRoaXMubWF4IC0gdmFsdWUpICogc2NhbGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gIH1cblxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG5cbiAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCBwb2ludExhYmVscyA9IHRoaXMuX3BvaW50TGFiZWxzIHx8IFtdO1xuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cblxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnlDZW50ZXIsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cblxuICBnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG5cbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XG4gICAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2FuZ2xlTGluZXMsIGdyaWQsIGJvcmRlcn0gPSBvcHRzO1xuICAgIGNvbnN0IGxhYmVsQ291bnQgPSB0aGlzLl9wb2ludExhYmVscy5sZW5ndGg7XG5cbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcblxuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCB8fCAoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPCAwKSkge1xuICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGljay52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dChpbmRleCk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXhCb3JkZXIgPSBib3JkZXIuc2V0Q29udGV4dChjb250ZXh0KTtcblxuICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKHRoaXMsIG9wdHNBdEluZGV4LCBvZmZzZXQsIGxhYmVsQ291bnQsIG9wdHNBdEluZGV4Qm9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlTGluZXMuZGlzcGxheSkge1xuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgZm9yIChpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcblxuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdCb3JkZXIoKSB7fVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3TGFiZWxzKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuXG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgb2Zmc2V0LCB3aWR0aDtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnhDZW50ZXIsIHRoaXMueUNlbnRlcik7XG4gICAgY3R4LnJvdGF0ZShzdGFydEFuZ2xlKTtcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKChpbmRleCA9PT0gMCAmJiB0aGlzLm1pbiA+PSAwKSAmJiAhb3B0cy5yZXZlcnNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcblxuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICBjdHguZmlsbFJlY3QoXG4gICAgICAgICAgLXdpZHRoIC8gMiAtIHBhZGRpbmcubGVmdCxcbiAgICAgICAgICAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCxcbiAgICAgICAgICB3aWR0aCArIHBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgdGlja0ZvbnQuc2l6ZSArIHBhZGRpbmcuaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGgsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge31cbn1cbiIsICJpbXBvcnQgYWRhcHRlcnMgZnJvbSAnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbCwgaXNGaW5pdGUsIGlzTnVsbE9yVW5kZWYsIG1lcmdlSWYsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvUmFkaWFucywgaXNOdW1iZXIsIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7X2FycmF5VW5pcXVlLCBfZmlsdGVyQmV0d2VlbiwgX2xvb2t1cH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5UaW1lVW5pdCB9IFVuaXRcbiAqIEB0eXBlZGVmIHt7Y29tbW9uOiBib29sZWFuLCBzaXplOiBudW1iZXIsIHN0ZXBzPzogbnVtYmVyfX0gSW50ZXJ2YWxcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9jb3JlL2NvcmUuYWRhcHRlcnMuanMnKS5EYXRlQWRhcHRlciB9IERhdGVBZGFwdGVyXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7T2JqZWN0PFVuaXQsIEludGVydmFsPn1cbiAqL1xuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcblxuLyoqXG4gKiBAdHlwZSB7VW5pdFtdfVxuICovXG5jb25zdCBVTklUUyA9IC8qKiBAdHlwZSBVbml0W10gKi8gLyogI19fUFVSRV9fICovIChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqL1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHsqfSBpbnB1dFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwYXJzZShzY2FsZSwgaW5wdXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYoaW5wdXQpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuXG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG5cbiAgLy8gT25seSBwYXJzZSBpZiBpdCdzIG5vdCBhIHRpbWVzdGFtcCBhbHJlYWR5XG4gIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuXG4gIHJldHVybiArdmFsdWU7XG59XG5cbi8qKlxuICogRmlndXJlcyBvdXQgd2hhdCB1bml0IHJlc3VsdHMgaW4gYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGF1dG8tZ2VuZXJhdGVkIHRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYXBhY2l0eVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpIDwgaWxlbiAtIDE7ICsraSkge1xuICAgIGNvbnN0IGludGVydmFsID0gSU5URVJWQUxTW1VOSVRTW2ldXTtcbiAgICBjb25zdCBmYWN0b3IgPSBpbnRlcnZhbC5zdGVwcyA/IGludGVydmFsLnN0ZXBzIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCB0byBmb3JtYXQgYSBzZXQgb2YgdGlja3Mgd2l0aFxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtVGlja3NcbiAqIEBwYXJhbSB7VW5pdH0gbWluVW5pdFxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybiB7VW5pdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVU5JVFNbbWluVW5pdCA/IFVOSVRTLmluZGV4T2YobWluVW5pdCkgOiAwXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VuaXR9IHVuaXRcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHRpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZVxuICogQHBhcmFtIHtudW1iZXJbXX0gW3RpbWVzdGFtcHNdIC0gaWYgZGVmaW5lZCwgc25hcCB0byB0aGVzZSB0aW1lc3RhbXBzXG4gKi9cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuICogQHBhcmFtIHtvYmplY3R9IG1hcFxuICogQHBhcmFtIHtVbml0fSBtYWpvclVuaXRcbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICovXG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcblxuICBmb3IgKG1ham9yID0gZmlyc3Q7IG1ham9yIDw9IGxhc3Q7IG1ham9yID0gK2FkYXB0ZXIuYWRkKG1ham9yLCAxLCBtYWpvclVuaXQpKSB7XG4gICAgaW5kZXggPSBtYXBbbWFqb3JdO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aWNrc1tpbmRleF0ubWFqb3IgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUaW1lU2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7VW5pdHx1bmRlZmluZWR9IFttYWpvclVuaXRdXG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgLyoqIEB0eXBlIHtPYmplY3Q8bnVtYmVyLG9iamVjdD59ICovXG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcblxuICAgIHRpY2tzLnB1c2goe1xuICAgICAgdmFsdWUsXG4gICAgICBtYWpvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFdlIHNldCB0aGUgbWFqb3IgdGlja3Mgc2VwYXJhdGVseSBmcm9tIHRoZSBhYm92ZSBsb29wIGJlY2F1c2UgY2FsbGluZyBzdGFydE9mIGZvciBldmVyeSB0aWNrXG4gIC8vIGlzIGV4cGVuc2l2ZSB3aGVuIHRoZXJlIGlzIGEgbGFyZ2UgbnVtYmVyIG9mIHRpY2tzXG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAvKipcbiAgICAgKiBTY2FsZSBib3VuZGFyeSBzdHJhdGVneSAoYnlwYXNzZWQgYnkgbWluL21heCB0aW1lIG9wdGlvbnMpXG4gICAgICogLSBgZGF0YWA6IG1ha2Ugc3VyZSBkYXRhIGFyZSBmdWxseSB2aXNpYmxlLCB0aWNrcyBvdXRzaWRlIGFyZSByZW1vdmVkXG4gICAgICogLSBgdGlja3NgOiBtYWtlIHN1cmUgdGlja3MgYXJlIGZ1bGx5IHZpc2libGUsIGRhdGEgb3V0c2lkZSBhcmUgdHJ1bmNhdGVkXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9wdWxsLzQ1NTZcbiAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgKi9cbiAgICBib3VuZHM6ICdkYXRhJyxcblxuICAgIGFkYXB0ZXJzOiB7fSxcbiAgICB0aW1lOiB7XG4gICAgICBwYXJzZXI6IGZhbHNlLCAvLyBmYWxzZSA9PSBhIHBhdHRlcm4gc3RyaW5nIGZyb20gb3IgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCBjb252ZXJ0cyBpdHMgYXJndW1lbnQgdG8gYSB0aW1lc3RhbXBcbiAgICAgIHVuaXQ6IGZhbHNlLCAvLyBmYWxzZSA9PSBhdXRvbWF0aWMgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgcm91bmQ6IGZhbHNlLCAvLyBub25lLCBvciBvdmVycmlkZSB3aXRoIHdlZWssIG1vbnRoLCB5ZWFyLCBldGMuXG4gICAgICBpc29XZWVrZGF5OiBmYWxzZSwgLy8gb3ZlcnJpZGUgd2VlayBzdGFydCBkYXlcbiAgICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgICB9LFxuICAgIHRpY2tzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRpY2tzIGdlbmVyYXRpb24gaW5wdXQgdmFsdWVzOlxuICAgICAgICogLSAnYXV0byc6IGdlbmVyYXRlcyBcIm9wdGltYWxcIiB0aWNrcyBiYXNlZCBvbiBzY2FsZSBzaXplIGFuZCB0aW1lIG9wdGlvbnMuXG4gICAgICAgKiAtICdkYXRhJzogZ2VuZXJhdGVzIHRpY2tzIGZyb20gZGF0YSAoaW5jbHVkaW5nIGxhYmVscyBmcm9tIGRhdGEge3R8eHx5fSBvYmplY3RzKS5cbiAgICAgICAqIC0gJ2xhYmVscyc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIHVzZXIgZ2l2ZW4gYGRhdGEubGFiZWxzYCB2YWx1ZXMgT05MWS5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTA3XG4gICAgICAgKiBAc2luY2UgMi43LjBcbiAgICAgICAqL1xuICAgICAgc291cmNlOiAnYXV0bycsXG5cbiAgICAgIGNhbGxiYWNrOiBmYWxzZSxcblxuICAgICAgbWFqb3I6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuXHQgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICAvKiogQHR5cGUge3tkYXRhOiBudW1iZXJbXSwgbGFiZWxzOiBudW1iZXJbXSwgYWxsOiBudW1iZXJbXX19ICovXG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcblxuICAgIC8qKiBAdHlwZSB7VW5pdH0gKi9cbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgLyoqIEB0eXBlIHtVbml0PX0gKi9cbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0KHNjYWxlT3B0cywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICAvKiogQHR5cGUge0RhdGVBZGFwdGVyfSAqL1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IGFkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcblxuICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcblxuICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGJlZm9yZSBpbnRyb2R1Y2luZyBhZGFwdGVyLCBgZGlzcGxheUZvcm1hdHNgIHdhc1xuICAgIC8vIHN1cHBvc2VkIHRvIGNvbnRhaW4gKmFsbCogdW5pdC9zdHJpbmcgcGFpcnMgYnV0IHRoaXMgY2FuJ3QgYmUgcmVzb2x2ZWRcbiAgICAvLyB3aGVuIGxvYWRpbmcgdGhlIHNjYWxlIChhZGFwdGVycyBhcmUgbG9hZGVkIGFmdGVyd2FyZCksIHNvIGxldCdzIHBvcHVsYXRlXG4gICAgLy8gbWlzc2luZyBmb3JtYXRzIG9uIHVwZGF0ZVxuICAgIG1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xuXG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcblxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRzKTtcblxuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHsqfSByYXdcblx0ICogQHBhcmFtIHtudW1iZXI/fSBbaW5kZXhdXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGlmIChyYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZSh0aGlzLCByYXcpO1xuICB9XG5cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdW5pdCA9IG9wdGlvbnMudGltZS51bml0IHx8ICdkYXknO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuXG4gICAgLyoqXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGJvdW5kc1xuXHRcdCAqL1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIHVzZXIgcHJvdmlkZWQgYG1pbmAgYW5kIGBtYXhgIGxhYmVscyAvIGRhdGEgYm91bmRzIGNhbiBiZSBpZ25vcmVkXG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICAvLyBMYWJlbHMgYXJlIGFsd2F5cyBjb25zaWRlcmVkLCB3aGVuIHVzZXIgZGlkIG5vdCBmb3JjZSBib3VuZHNcbiAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcblxuICAgICAgLy8gSWYgYGJvdW5kc2AgaXMgYCd0aWNrcydgIGFuZCBgdGlja3Muc291cmNlYCBpcyBgJ2xhYmVscydgLFxuICAgICAgLy8gZGF0YSBib3VuZHMgYXJlIGlnbm9yZWQgKGFuZCBkb24ndCBuZWVkIHRvIGJlIGRldGVybWluZWQpXG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1pbiA9IGlzRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiArYWRhcHRlci5zdGFydE9mKERhdGUubm93KCksIHVuaXQpO1xuICAgIG1heCA9IGlzRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiArYWRhcHRlci5lbmRPZihEYXRlLm5vdygpLCB1bml0KSArIDE7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBtYXggaXMgc3RyaWN0bHkgaGlnaGVyIHRoYW4gbWluIChyZXF1aXJlZCBieSB0aGUgdGltZXNlcmllcyBsb29rdXAgdGFibGUpXG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgIHRoaXMubWF4ID0gTWF0aC5tYXgobWluICsgMSwgbWF4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXG4gICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiB7bWluLCBtYXh9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuXG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG5cbiAgICBjb25zdCB0aWNrcyA9IF9maWx0ZXJCZXR3ZWVuKHRpbWVzdGFtcHMsIG1pbiwgbWF4KTtcblxuICAgIC8vIFBSSVZBVEVcbiAgICAvLyBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyByZWxpZXMgb24gdGhlIG51bWJlciBvZiB0aWNrcyBzbyB3ZSBkb24ndCB1c2UgaXQgd2hlblxuICAgIC8vIGF1dG9Ta2lwIGlzIGVuYWJsZWQgYmVjYXVzZSB3ZSBkb24ndCB5ZXQga25vdyB3aGF0IHRoZSBmaW5hbCBudW1iZXIgb2YgdGlja3Mgd2lsbCBiZVxuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCB0aWNrcywgdGhpcy5fbWFqb3JVbml0KTtcbiAgfVxuXG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgLy8gT2Zmc2V0cyBmb3IgYmFyIGNoYXJ0cyBuZWVkIHRvIGJlIGhhbmRsZWQgd2l0aCB0aGUgYXV0byBza2lwcGVkXG4gICAgLy8gdGlja3MuIE9uY2UgdGlja3MgaGF2ZSBiZWVuIHNraXBwZWQsIHdlIHJlLWNvbXB1dGUgdGhlIG9mZnNldHMuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXRBZnRlckF1dG9za2lwKSB7XG4gICAgICB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKHRpY2sgPT4gK3RpY2sudmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhcnQgYW5kIGVuZCBvZmZzZXRzIGZyb20gZWRnZXMgaW4gdGhlIGZvcm0gb2Yge3N0YXJ0LCBlbmR9XG5cdCAqIHdoZXJlIGVhY2ggdmFsdWUgaXMgYSByZWxhdGl2ZSB3aWR0aCB0byB0aGUgc2NhbGUgYW5kIHJhbmdlcyBiZXR3ZWVuIDAgYW5kIDEuXG5cdCAqIFRoZXkgYWRkIGV4dHJhIG1hcmdpbnMgb24gdGhlIGJvdGggc2lkZXMgYnkgc2NhbGluZyBkb3duIHRoZSBvcmlnaW5hbCBzY2FsZS5cblx0ICogT2Zmc2V0cyBhcmUgYWRkZWQgd2hlbiB0aGUgYG9mZnNldGAgb3B0aW9uIGlzIHRydWUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5pdE9mZnNldHModGltZXN0YW1wcyA9IFtdKSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBsZXQgZmlyc3QsIGxhc3Q7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcblxuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdlbmVyYXRlcyBhIG1heGltdW0gb2YgYGNhcGFjaXR5YCB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHJvdW5kZWQgdG8gdGhlXG5cdCAqIGBtaW5vcmAgdW5pdCB1c2luZyB0aGUgZ2l2ZW4gc2NhbGUgdGltZSBgb3B0aW9uc2AuXG5cdCAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgY29uc3Qgc3RlcFNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnRpY2tzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG5cbiAgICAvLyBGb3IgJ3dlZWsnIHVuaXQsIGhhbmRsZSB0aGUgZmlyc3QgZGF5IG9mIHdlZWsgb3B0aW9uXG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG5cbiAgICAvLyBBbGlnbiBmaXJzdCB0aWNrcyBvbiB1bml0XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG5cbiAgICAvLyBQcmV2ZW50IGJyb3dzZXIgZnJvbSBmcmVlemluZyBpbiBjYXNlIHVzZXIgb3B0aW9ucyByZXF1ZXN0IG1pbGxpb25zIG9mIG1pbGxpc2Vjb25kc1xuICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuXG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydChzb3J0ZXIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKi9cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG5cbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZm9ybWF0XG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGZvcm1hdCh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IGZtdCA9IGZvcm1hdCB8fCBmb3JtYXRzW3VuaXRdO1xuICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh2YWx1ZSwgZm10KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBGdW5jdGlvbiB0byBmb3JtYXQgYW4gaW5kaXZpZHVhbCB0aWNrIG1hcmtcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gW2Zvcm1hdF1cblx0ICogQHJldHVybiB7c3RyaW5nfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiBjYWxsKGZvcm1hdHRlciwgW3RpbWUsIGluZGV4LCB0aWNrc10sIHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcblxuICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh0aW1lLCBmb3JtYXQgfHwgKG1ham9yID8gbWFqb3JGb3JtYXQgOiBtaW5vckZvcm1hdCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0W119IHRpY2tzXG5cdCAqL1xuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24odGljay52YWx1ZSwgaSwgdGlja3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBvcyAqICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxcblx0ICogQHJldHVybiB7e3c6bnVtYmVyLCBoOm51bWJlcn19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxTaXplKGxhYmVsKSB7XG4gICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpY2tMYWJlbFdpZHRoID0gdGhpcy5jdHgubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIGNvbnN0IGFuZ2xlID0gdG9SYWRpYW5zKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aWNrc09wdHMubWF4Um90YXRpb24gOiB0aWNrc09wdHMubWluUm90YXRpb24pO1xuICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIGNvbnN0IHRpY2tGb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkuc2l6ZTtcblxuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGV4YW1wbGVUaW1lXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBjb25zdCBkaXNwbGF5Rm9ybWF0cyA9IHRpbWVPcHRzLmRpc3BsYXlGb3JtYXRzO1xuXG4gICAgLy8gcGljayB0aGUgbG9uZ2VzdCBmb3JtYXQgKG1pbGxpc2Vjb25kcykgZm9yIGd1ZXNzdGltYXRpb25cbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW2V4YW1wbGVUaW1lXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XG4gICAgLy8gc3VidHJhY3QgMSAtIGlmIG9mZnNldCB0aGVuIHRoZXJlJ3Mgb25lIGxlc3MgbGFiZWwgdGhhbiB0aWNrXG4gICAgLy8gaWYgbm90IG9mZnNldCB0aGVuIG9uZSBoYWxmIGxhYmVsIHBhZGRpbmcgaXMgYWRkZWQgdG8gZWFjaCBlbmQgbGVhdmluZyByb29tIGZvciBvbmUgbGVzcyBsYWJlbFxuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuXG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxUaW1lc3RhbXBzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5sYWJlbHMgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChwYXJzZSh0aGlzLCBsYWJlbHNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHZhbHVlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgLy8gSXQgc2VlbXMgdG8gYmUgc29tZXdoYXQgZmFzdGVyIHRvIGRvIHNvcnRpbmcgZmlyc3RcbiAgICByZXR1cm4gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KHNvcnRlcikpO1xuICB9XG59XG4iLCAiaW1wb3J0IFRpbWVTY2FsZSBmcm9tICcuL3NjYWxlLnRpbWUuanMnO1xuaW1wb3J0IHtfbG9va3VwQnlLZXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuLyoqXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgdGhlIGdpdmVuIHNvdXJjZSBgdmFsYCB1c2luZyB0aGUgdGFibGUuIElmIHZhbHVlIGlzIG91dCBvZiBib3VuZHMsIHZhbHVlc1xuICogYXQgZWRnZXMgYXJlIHVzZWQgZm9yIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IHRhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXZlcnNlXSBsb29rdXAgdGltZSBiYXNlZCBvbiBwb3NpdGlvbiBpbnN0ZWFkIG9mIHZpY2UgdmVyc2FcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUodGFibGUsIHZhbCwgcmV2ZXJzZSkge1xuICBsZXQgbG8gPSAwO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgcHJldlNvdXJjZSwgbmV4dFNvdXJjZSwgcHJldlRhcmdldCwgbmV4dFRhcmdldDtcbiAgaWYgKHJldmVyc2UpIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS5wb3MgJiYgdmFsIDw9IHRhYmxlW2hpXS5wb3MpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3BvcycsIHZhbCkpO1xuICAgIH1cbiAgICAoe3BvczogcHJldlNvdXJjZSwgdGltZTogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7cG9zOiBuZXh0U291cmNlLCB0aW1lOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10udGltZSAmJiB2YWwgPD0gdGFibGVbaGldLnRpbWUpIHtcbiAgICAgICh7bG8sIGhpfSA9IF9sb29rdXBCeUtleSh0YWJsZSwgJ3RpbWUnLCB2YWwpKTtcbiAgICB9XG4gICAgKHt0aW1lOiBwcmV2U291cmNlLCBwb3M6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3RpbWU6IG5leHRTb3VyY2UsIHBvczogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9XG5cbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICByZXR1cm4gc3BhbiA/IHByZXZUYXJnZXQgKyAobmV4dFRhcmdldCAtIHByZXZUYXJnZXQpICogKHZhbCAtIHByZXZTb3VyY2UpIC8gc3BhbiA6IHByZXZUYXJnZXQ7XG59XG5cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ3RpbWVzZXJpZXMnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0gVGltZVNjYWxlLmRlZmF1bHRzO1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXX0gKi9cbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX21pblBvcyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIHRoaXMuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1pbik7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3M7XG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiB7dGltZSwgcG9zfSBvYmplY3RzIHVzZWQgdG8gaW50ZXJwb2xhdGUgYSBzcGVjaWZpYyBgdGltZWAgb3IgcG9zaXRpb25cblx0ICogKGBwb3NgKSBvbiB0aGUgc2NhbGUsIGJ5IHNlYXJjaGluZyBlbnRyaWVzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIHJlcXVlc3RlZCB2YWx1ZS4gYHBvc2AgaXNcblx0ICogYSBkZWNpbWFsIGJldHdlZW4gMCBhbmQgMTogMCBiZWluZyB0aGUgc3RhcnQgb2YgdGhlIHNjYWxlIChsZWZ0IG9yIHRvcCkgYW5kIDEgdGhlIG90aGVyXG5cdCAqIGV4dHJlbWl0eSAobGVmdCArIHdpZHRoIG9yIHRvcCArIGhlaWdodCkuIE5vdGUgdGhhdCBpdCB3b3VsZCBiZSBtb3JlIG9wdGltaXplZCB0byBkaXJlY3RseVxuXHQgKiBzdG9yZSBwcmUtY29tcHV0ZWQgcGl4ZWxzLCBidXQgdGhlIHNjYWxlIGRpbWVuc2lvbnMgYXJlIG5vdCBndWFyYW50ZWVkIGF0IHRoZSB0aW1lIHdlIG5lZWRcblx0ICogdG8gY3JlYXRlIHRoZSBsb29rdXAgdGFibGUuIFRoZSB0YWJsZSBBTFdBWVMgY29udGFpbnMgYXQgbGVhc3QgdHdvIGl0ZW1zOiBtaW4gYW5kIG1heC5cblx0ICogQHBhcmFtIHtudW1iZXJbXX0gdGltZXN0YW1wc1xuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpdGVtcy5sZW5ndGggPCAyKSB7XG4gICAgICAvLyBJbiBjYXNlIHRoZXJlIGlzIGxlc3MgdGhhdCAyIHRpbWVzdGFtcHMgYmV0d2VlbiBtaW4gYW5kIG1heCwgdGhlIHNjYWxlIGlzIGRlZmluZWQgYnkgbWluIGFuZCBtYXhcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXG4gICAgICAgIHt0aW1lOiBtYXgsIHBvczogMX1cbiAgICAgIF07XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgIHByZXYgPSBpdGVtc1tpIC0gMV07XG4gICAgICBjdXJyID0gaXRlbXNbaV07XG5cbiAgICAgIC8vIG9ubHkgYWRkIHBvaW50cyB0aGF0IGJyZWFrcyB0aGUgc2NhbGUgbGluZWFyaXR5XG4gICAgICBpZiAoTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcbiAgICAgICAgdGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cblxuICAvKipcbiAgICAqIEdlbmVyYXRlcyBhbGwgdGltZXN0YW1wcyBkZWZpbmVkIGluIHRoZSBkYXRhLlxuICAgICogSW1wb3J0YW50OiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIHRpY2tzIG91dHNpZGUgdGhlIG1pbiBhbmQgbWF4IHJhbmdlLCBpdCdzIHRoZVxuICAgICogcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNhbGxpbmcgY29kZSB0byBjbGFtcCB2YWx1ZXMgaWYgbmVlZGVkLlxuICAgICogQHByb3RlY3RlZFxuICAgICovXG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHN1cGVyLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgaWYgKCF0aW1lc3RhbXBzLmluY2x1ZGVzKG1pbikgfHwgIXRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aW1lc3RhbXBzLnNwbGljZSgwLCAwLCBtaW4pO1xuICAgIH1cbiAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWF4KSB8fCB0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGltZXN0YW1wcy5wdXNoKG1heCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lc3RhbXBzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIGFsbCB0aW1lc3RhbXBzXG5cdCAqIEByZXR1cm4ge251bWJlcltdfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCB8fCBbXTtcblxuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgLy8gSWYgY29tYmluaW5nIGxhYmVscyBhbmQgZGF0YSAoZGF0YSBtaWdodCBub3QgY29udGFpbiBhbGwgbGFiZWxzKSxcbiAgICAgIC8vIHdlIG5lZWQgdG8gcmVjaGVjayB1bmlxdWVuZXNzIGFuZCBzb3J0XG4gICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXN0YW1wcyA9IGRhdGEubGVuZ3RoID8gZGF0YSA6IGxhYmVsO1xuICAgIH1cbiAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcblxuICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIE1pbGxpc2Vjb25kcyBzaW5jZSBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRpbWVTZXJpZXNTY2FsZTtcbiIsICJleHBvcnQgKiBmcm9tICcuL2NvbnRyb2xsZXJzL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29yZS9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2VsZW1lbnRzL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGxhdGZvcm0vaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wbHVnaW5zL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc2NhbGVzL2luZGV4LmpzJztcblxuaW1wb3J0ICogYXMgY29udHJvbGxlcnMgZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBlbGVtZW50cyBmcm9tICcuL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHBsdWdpbnMgZnJvbSAnLi9wbHVnaW5zL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHNjYWxlcyBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmV4cG9ydCB7XG4gIGNvbnRyb2xsZXJzLFxuICBlbGVtZW50cyxcbiAgcGx1Z2lucyxcbiAgc2NhbGVzLFxufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyYWJsZXMgPSBbXG4gIGNvbnRyb2xsZXJzLFxuICBlbGVtZW50cyxcbiAgcGx1Z2lucyxcbiAgc2NhbGVzLFxuXTtcbiIsICJpbXBvcnQge0NoYXJ0LCByZWdpc3RlcmFibGVzfSBmcm9tICcuLi9kaXN0L2NoYXJ0LmpzJztcblxuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5cbmV4cG9ydCAqIGZyb20gJy4uL2Rpc3QvY2hhcnQuanMnO1xuZXhwb3J0IGRlZmF1bHQgQ2hhcnQ7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQU1BLE9BQUMsU0FBVUEsU0FBUUMsV0FBVTtBQUMzQjtBQUdBLFNBQUMsV0FBWTtBQUNYLGNBQUksV0FBVztBQUNmLGNBQUksVUFBVSxDQUFDLE1BQU0sT0FBTyxVQUFVLEdBQUc7QUFDekMsbUJBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxVQUFVLENBQUNELFFBQU8sdUJBQXVCLEVBQUUsR0FBRztBQUN4RSxZQUFBQSxRQUFPLHdCQUNMQSxRQUFPLFFBQVEsQ0FBQyxJQUFJLHVCQUF1QjtBQUM3QyxZQUFBQSxRQUFP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QUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0gsR0FBRztBQUFBLEVBQ0o7QUFDQSxNQUFNLFVBQVU7QUFBQSxJQUNmLFFBQVE7QUFBQSxJQUNSLGFBQWE7QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFdBQVc7QUFBQSxJQUNYLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLGNBQWM7QUFBQSxJQUNkLElBQUk7QUFBQSxJQUNKLFNBQVM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFdBQVc7QUFBQSxJQUNYLFFBQVE7QUFBQSxJQUNSLFVBQVU7QUFBQSxJQUNWLFNBQVM7QUFBQSxJQUNULEtBQUs7QUFBQSxJQUNMLGFBQWE7QUFBQSxJQUNiLFNBQVM7QUFBQSxJQUNULFNBQVM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLEtBQUs7QUFBQSxJQUNMLE9BQU87QUFBQSxJQUNQLFNBQVM7QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLFNBQVM7QUFBQSxJQUNULFVBQVU7QUFBQSxJQUNWLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLEtBQUs7QUFBQSxJQUNMLFFBQVE7QUFBQSxJQUNSLFFBQVE7QUFBQSxJQUNSLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLEtBQUs7QUFBQSxJQUNMLFFBQVE7QUFBQSxJQUNSLFFBQVE7QUFBQSxJQUNSLFVBQVU7QUFBQSxJQUNWLFFBQVE7QUFBQSxJQUNSLFFBQVE7QUFBQSxJQUNSLFVBQVU7QUFBQSxJQUNWLFVBQVU7QUFBQSxJQUNWLFVBQVU7QUFBQSxJQUNWLFVBQVU7QUFBQSxJQUNWLFFBQVE7QUFBQSxJQUNSLFNBQVM7QUFBQSxJQUNULFdBQVc7QUFBQSxJQUNYLEtBQUs7QUFBQSxJQUNMLFFBQVE7QUFBQSxJQUNSLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLE9BQU87QUFBQSxJQUNQLEtBQUs7QUFBQSxJQUNMLFNBQVM7QUFBQSxJQUNULFFBQVE7QUFBQSxJQUNSLFNBQVM7QUFBQSxJQUNULE9BQU87QUFBQSxJQUNQLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLFdBQVc7QUFBQSxJQUNYLFNBQVM7QUFBQSxJQUNULFlBQVk7QUFBQSxJQUNaLEtBQUs7QUFBQSxJQUNMLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLFdBQVc7QUFBQSxJQUNYLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxJQUNOLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLFFBQVE7QUFBQSxJQUNSLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLFNBQVM7QUFBQSxJQUNULEtBQUs7QUFBQSxJQUNMLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNULEtBQUs7QUFBQSxJQUNMLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLFlBQVk7QUFBQSxJQUNaLEtBQUs7QUFBQSxJQUNMLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLFFBQVE7QUFBQSxJQUNSLE1BQU07QUFBQSxJQUNOLFdBQVc7QUFBQSxJQUNYLEtBQUs7QUFBQSxJQUNMLFVBQVU7QUFBQSxJQUNWLFlBQVk7QUFBQSxJQUNaLFNBQVM7QUFBQSxJQUNULFVBQVU7QUFBQSxJQUNWLFNBQVM7QUFBQSxJQUNULFlBQVk7QUFBQSxJQUNaLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNULE9BQU87QUFBQSxJQUNQLFNBQVM7QUFBQSxJ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U0FBUztBQUFBLGdCQUNULE1BQU07QUFBQSxjQUNSO0FBQUEsY0FDQSxNQUFNO0FBQUEsZ0JBQ0osU0FBUztBQUFBLGNBQ1g7QUFBQSxZQUNGO0FBQUEsWUFDQSxHQUFHO0FBQUEsY0FDRCxPQUFPO0FBQUEsZ0JBQ0wsU0FBUztBQUFBLGdCQUNULE1BQU07QUFBQSxjQUNSO0FBQUEsY0FDQSxNQUFNO0FBQUEsZ0JBQ0osU0FBUztBQUFBLGNBQ1g7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUFBLFVBQ0EsU0FBUztBQUFBLFlBQ1AsU0FBUztBQUFBLGNBQ1AsV0FBVztBQUFBLGdCQUNULE9BQU8sU0FBVSxTQUFTO0FBQ3hCLHNCQUFJLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFFckMsc0JBQUksT0FBTztBQUNULDZCQUFTO0FBQUEsa0JBQ1g7QUFDQSxzQkFBSSxRQUFRLE9BQU8sTUFBTSxNQUFNO0FBQzdCLDZCQUFTLElBQUksS0FBSyxhQUFhLFNBQVMsRUFBRSxPQUFPLFlBQVksVUFBVSxNQUFNLENBQUMsRUFBRSxPQUFPLFFBQVEsT0FBTyxDQUFDO0FBQUEsa0JBQ3pHO0FBQ0EseUJBQU87QUFBQSxnQkFDVDtBQUFBLGNBQ0Y7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjsiLAogICJuYW1lcyI6IFsid2luZG93IiwgImRvY3VtZW50IiwgImNhbGxiYWNrIiwgInRvcGJhciIsICJ0byIsICJDdXN0b21FdmVudCIsICJ0byIsICJjbG9zdXJlIiwgImNhbGxiYWNrIiwgImNhbGxiYWNrIiwgImxpdmVTb2NrZXQiLCAiY2xvc3VyZSIsICJjYWxsYmFjayIsICJ0byIsICJlIiwgImlzRW1wdHkiLCAiZGVib3VuY2UiLCAiZmlsZSIsICJtb3JwaEF0dHJzIiwgIm1vcnBoZG9tIiwgImNoaWxkcmVuT25seSIsICJ0YXJnZXRDb250YWluZXIiLCAiZnJvbSIsICJjbG9uZSIsICJlbCIsICJza2lwIiwgImRlZmF1bHRzIiwgIm5hbWVzIiwgInJlc29sdmUiLCAiaXNBcnJheSIsICJpbnB1dHNVbnVzZWQiLCAib25seUhpZGRlbklucHV0cyIsICJlbGVtZW50cyIsICJsb2NrIiwgImxvYWRpbmciLCAiZW50cnkiLCAiaW5wdXQiLCAiY2xvc3VyZSIsICJjYWxsYmFjayIsICJ0byIsICJlbGVtZW50cyIsICJyYW5nZSIsICJjbG9uZSIsICJjb2xvciIsICJub29wIiwgInVpZCIsICJpZCIsICJpc051bGxPclVuZGVmIiwgInZhbHVlIiwgInVuZGVmaW5lZCIsICJpc0FycmF5IiwgIkFycmF5IiwgInR5cGUiLCAiT2JqZWN0IiwgInByb3RvdHlwZSIsICJ0b1N0cmluZyIsICJjYWxsIiwgInNsaWNlIiwgImlzT2JqZWN0IiwgImlzTnVtYmVyRmluaXRlIiwgIk51bWJlciIsICJpc0Zpbml0ZSIsICJmaW5pdGVPckRlZmF1bHQiLCAiZGVmYXVsdFZhbHVlIiwgInZhbHVlT3JEZWZhdWx0IiwgInRvUGVyY2VudGFnZSIsICJkaW1lbnNpb24iLCAiZW5kc1dpdGgiLCAicGFyc2VGbG9hdCIsICJ0b0RpbWVuc2lvbiIsICJjYWxsYmFjayIsICJmbiIsICJhcmdzIiwgInRoaXNBcmciLCAiYXBwbHkiLCAiZWFjaCIsICJsb29wYWJsZSIsICJyZXZlcnNlIiwgImkiLCAibGVuIiwgImtleXMiLCAibGVuZ3RoIiwgIl9lbGVtZW50c0VxdWFsIiwgImEwIiwgImExIiwgImlsZW4iLCAidjAiLCAidjEiLCAiZGF0YXNldEluZGV4IiwgImluZGV4IiwgImNsb25lIiwgInNvdXJjZSIsICJtYXAiLCAidGFyZ2V0IiwgImNyZWF0ZSIsICJrbGVuIiwgImsiLCAiaXNWYWxpZEtleSIsICJrZXkiLCAiaW5kZXhPZiIsICJfbWVyZ2VyIiwgIm9wdGlvbnMiLCAidHZhbCIsICJzdmFsIiwgIm1lcmdlIiwgInNvdXJjZXMiLCAibWVyZ2VyIiwgImN1cnJlbnQiLCAibWVyZ2VJZiIsICJfbWVyZ2VySWYiLCAiaGFzT3duUHJvcGVydHkiLCAia2V5UmVzb2x2ZXJzIiwgInYiLCAieCIsICJvIiwgInkiLCAiX3NwbGl0S2V5IiwgImtleSIsICJwYXJ0cyIsICJzcGxpdCIsICJrZXlzIiwgInRtcCIsICJwYXJ0IiwgImVuZHNXaXRoIiwgInNsaWNlIiwgInB1c2giLCAiX2dldEtleVJlc29sdmVyIiwgIm9iaiIsICJrIiwgInJlc29sdmVPYmplY3RLZXkiLCAicmVzb2x2ZXIiLCAiX2NhcGl0YWxpemUiLCAic3RyIiwgImNoYXJBdCIsICJ0b1VwcGVyQ2FzZSIsICJkZWZpbmVkIiwgInZhbHVlIiwgImlzRnVuY3Rpb24iLCAic2V0c0VxdWFsIiwgImEiLCAiYiIsICJzaXplIiwgIml0ZW0iLCAiaGFzIiwgIl9pc0NsaWNrRXZlbnQiLCAiZSIsICJ0eXBlIiwgIlBJIiwgIk1hdGgiLCAiVEFVIiwgIlBJVEFVIiwgIklORklOSVRZIiwgIk51bWJlciIsICJQT1NJVElWRV9JTkZJTklUWSIsICJSQURfUEVSX0RFRyIsICJIQUxGX1BJIiwgIlFVQVJURVJfUEkiLCAiVFdPX1RISVJEU19QSSIsICJsb2cxMCIsICJzaWduIiwgImFsbW9zdEVxdWFscyIsICJlcHNpbG9uIiwgImFicyIsICJuaWNlTnVtIiwgInJhbmdlIiwgInJvdW5kZWRSYW5nZSIsICJyb3VuZCIsICJuaWNlUmFuZ2UiLCAicG93IiwgImZsb29yIiwgImZyYWN0aW9uIiwgIm5pY2VGcmFjdGlvbiIsICJfZmFjdG9yaXplIiwgInJlc3VsdCIsICJzcXJ0IiwgImkiLCAic29ydCIsICJwb3AiLCAiaXNOb25QcmltaXRpdmUiLCAibiIsICJTeW1ib2wiLCAidG9QcmltaXRpdmUiLCAiaXNOdW1iZXIiLCAiaXNOYU4iLCAicGFyc2VGbG9hdCIsICJpc0Zpbml0ZSIsICJhbG1vc3RXaG9sZSIsICJyb3VuZGVkIiwgIl9zZXRNaW5BbmRNYXhCeUtleSIsICJhcnJheSIsICJ0YXJnZXQiLCAicHJvcGVydHkiLCAiaWxlbiIsICJsZW5ndGgiLCAibWluIiwgIm1heCIsICJ0b1JhZGlhbnMiLCAiZGVncmVlcyIsICJ0b0RlZ3JlZXMiLCAicmFkaWFucyIsICJfZGVjaW1hbFBsYWNlcyIsICJpc0Zpbml0ZU51bWJlciIsICJwIiwgImdldEFuZ2xlRnJvbVBvaW50IiwgImNlbnRyZVBvaW50IiwgImFuZ2xlUG9pbnQiLCAiZGlzdGFuY2VGcm9tWENlbnRlciIsICJkaXN0YW5jZUZyb21ZQ2VudGVyIiwgInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsICJhbmdsZSIsICJhdGFuMiIsICJkaXN0YW5jZSIsICJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCAicHQxIiwgInB0MiIsICJfYW5nbGVEaWZmIiwgIl9ub3JtYWxpemVBbmdsZSIsICJfYW5nbGVCZXR3ZWVuIiwgInN0YXJ0IiwgImVuZCIsICJzYW1lQW5nbGVJc0Z1bGxDaXJjbGUiLCAicyIsICJhbmdsZVRvU3RhcnQiLCAiYW5nbGVUb0VuZCIsICJzdGFydFRvQW5nbGUiLCAiZW5kVG9BbmdsZSIsICJfbGltaXRWYWx1ZSIsICJfaW50MTZSYW5nZSIsICJfaXNCZXR3ZWVuIiwgIl9sb29rdXAiLCAidGFibGUiLCAiY21wIiwgImluZGV4IiwgImhpIiwgImxvIiwgIm1pZCIsICJfbG9va3VwQnlLZXkiLCAibGFzdCIsICJ0aSIsICJfcmxvb2t1cEJ5S2V5IiwgIl9maWx0ZXJCZXR3ZWVuIiwgInZhbHVlcyIsICJhcnJheUV2ZW50cyIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJsaXN0ZW5lciIsICJfY2hhcnRqcyIsICJsaXN0ZW5lcnMiLCAiT2JqZWN0IiwgImRlZmluZVByb3BlcnR5IiwgImNvbmZpZ3VyYWJsZSIsICJlbnVtZXJhYmxlIiwgImZvckVhY2giLCAibWV0aG9kIiwgImJhc2UiLCAiYXJncyIsICJyZXMiLCAiYXBwbHkiLCAib2JqZWN0IiwgInVubGlzdGVuQXJyYXlFdmVudHMiLCAic3R1YiIsICJpbmRleE9mIiwgInNwbGljZSIsICJfYXJyYXlVbmlxdWUiLCAiaXRlbXMiLCAic2V0IiwgIlNldCIsICJBcnJheSIsICJmcm9tIiwgInJlcXVlc3RBbmltRnJhbWUiLCAid2luZG93IiwgImNhbGxiYWNrIiwgInJlcXVlc3RBbmltYXRpb25GcmFtZSIsICJ0aHJvdHRsZWQiLCAiZm4iLCAidGhpc0FyZyIsICJhcmdzVG9Vc2UiLCAidGlja2luZyIsICJhcmdzIiwgImNhbGwiLCAiYXBwbHkiLCAiZGVib3VuY2UiLCAiZGVsYXkiLCAidGltZW91dCIsICJjbGVhclRpbWVvdXQiLCAic2V0VGltZW91dCIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAiYWxpZ24iLCAiX2FsaWduU3RhcnRFbmQiLCAic3RhcnQiLCAiZW5kIiwgIl90ZXh0WCIsICJsZWZ0IiwgInJpZ2h0IiwgInJ0bCIsICJjaGVjayIsICJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsICJtZXRhIiwgInBvaW50cyIsICJhbmltYXRpb25zRGlzYWJsZWQiLCAicG9pbnRDb3VudCIsICJsZW5ndGgiLCAiY291bnQiLCAiX3NvcnRlZCIsICJpU2NhbGUiLCAidlNjYWxlIiwgIl9wYXJzZWQiLCAic3BhbkdhcHMiLCAiZGF0YXNldCIsICJvcHRpb25zIiwgImF4aXMiLCAibWluIiwgIm1heCIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiZ2V0VXNlckJvdW5kcyIsICJNYXRoIiwgIl9sb29rdXBCeUtleSIsICJsbyIsICJnZXRQaXhlbEZvclZhbHVlIiwgImRpc3RhbmNlVG9EZWZpbmVkTG8iLCAic2xpY2UiLCAicmV2ZXJzZSIsICJmaW5kSW5kZXgiLCAicG9pbnQiLCAiaXNOdWxsT3JVbmRlZiIsICJfbGltaXRWYWx1ZSIsICJoaSIsICJkaXN0YW5jZVRvRGVmaW5lZEhpIiwgIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCAieFNjYWxlIiwgInlTY2FsZSIsICJfc2NhbGVSYW5nZXMiLCAibmV3UmFuZ2VzIiwgInhtaW4iLCAieG1heCIsICJ5bWluIiwgInltYXgiLCAiY2hhbmdlZCIsICJPYmplY3QiLCAiYXNzaWduIiwgImF0RWRnZSIsICJ0IiwgImVsYXN0aWNJbiIsICJzIiwgInAiLCAicG93IiwgInNpbiIsICJUQVUiLCAiZWxhc3RpY091dCIsICJlZmZlY3RzIiwgImxpbmVhciIsICJlYXNlSW5RdWFkIiwgImVhc2VPdXRRdWFkIiwgImVhc2VJbk91dFF1YWQiLCAiZWFzZUluQ3ViaWMiLCAiZWFzZU91dEN1YmljIiwgImVhc2VJbk91dEN1YmljIiwgImVhc2VJblF1YXJ0IiwgImVhc2VPdXRRdWFydCIsICJlYXNlSW5PdXRRdWFydCIsICJlYXNlSW5RdWludCIsICJlYXNlT3V0UXVpbnQiLCAiZWFzZUluT3V0UXVpbnQiLCAiZWFzZUluU2luZSIsICJjb3MiLCAiSEFMRl9QSSIsICJlYXNlT3V0U2luZSIsICJlYXNlSW5PdXRTaW5lIiwgIlBJIiwgImVhc2VJbkV4cG8iLCAiZWFzZU91dEV4cG8iLCAiZWFzZUluT3V0RXhwbyIsICJlYXNlSW5DaXJjIiwgInNxcnQiLCAiZWFzZU91dENpcmMiLCAiZWFzZUluT3V0Q2lyYyIsICJlYXNlSW5FbGFzdGljIiwgImVhc2VPdXRFbGFzdGljIiwgImVhc2VJbk91dEVsYXN0aWMiLCAiZWFzZUluQmFjayIsICJlYXNlT3V0QmFjayIsICJlYXNlSW5PdXRCYWNrIiwgImVhc2VJbkJvdW5jZSIsICJlYXNlT3V0Qm91bmNlIiwgIm0iLCAiZCIsICJlYXNlSW5PdXRCb3VuY2UiLCAiaXNQYXR0ZXJuT3JHcmFkaWVudCIsICJ2YWx1ZSIsICJ0eXBlIiwgInRvU3RyaW5nIiwgImNvbG9yIiwgIkNvbG9yIiwgImdldEhvdmVyQ29sb3IiLCAic2F0dXJhdGUiLCAiZGFya2VuIiwgImhleFN0cmluZyIsICJudW1iZXJzIiwgImNvbG9ycyIsICJhcHBseUFuaW1hdGlvbnNEZWZhdWx0cyIsICJkZWZhdWx0cyIsICJzZXQiLCAidW5kZWZpbmVkIiwgImR1cmF0aW9uIiwgImVhc2luZyIsICJmcm9tIiwgImxvb3AiLCAidG8iLCAiZGVzY3JpYmUiLCAiX2ZhbGxiYWNrIiwgIl9pbmRleGFibGUiLCAiX3NjcmlwdGFibGUiLCAibmFtZSIsICJwcm9wZXJ0aWVzIiwgImFjdGl2ZSIsICJhbmltYXRpb24iLCAicmVzaXplIiwgInNob3ciLCAiYW5pbWF0aW9ucyIsICJ2aXNpYmxlIiwgImhpZGUiLCAidiIsICJhcHBseUxheW91dHNEZWZhdWx0cyIsICJhdXRvUGFkZGluZyIsICJwYWRkaW5nIiwgInRvcCIsICJib3R0b20iLCAiaW50bENhY2hlIiwgIk1hcCIsICJnZXROdW1iZXJGb3JtYXQiLCAibG9jYWxlIiwgImNhY2hlS2V5IiwgIkpTT04iLCAic3RyaW5naWZ5IiwgImZvcm1hdHRlciIsICJnZXQiLCAiSW50bCIsICJOdW1iZXJGb3JtYXQiLCAiZm9ybWF0TnVtYmVyIiwgIm51bSIsICJmb3JtYXQiLCAiZm9ybWF0dGVycyIsICJ2YWx1ZXMiLCAiaXNBcnJheSIsICJudW1lcmljIiwgInRpY2tWYWx1ZSIsICJpbmRleCIsICJ0aWNrcyIsICJjaGFydCIsICJub3RhdGlvbiIsICJkZWx0YSIsICJtYXhUaWNrIiwgImFicyIsICJjYWxjdWxhdGVEZWx0YSIsICJsb2dEZWx0YSIsICJsb2cxMCIsICJudW1EZWNpbWFsIiwgImlzTmFOIiwgImZsb29yIiwgIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsICJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCAibG9nYXJpdGhtaWMiLCAicmVtYWluIiwgInNpZ25pZmljYW5kIiwgImluY2x1ZGVzIiwgImFwcGx5U2NhbGVEZWZhdWx0cyIsICJkaXNwbGF5IiwgIm9mZnNldCIsICJiZWdpbkF0WmVybyIsICJib3VuZHMiLCAiY2xpcCIsICJncmFjZSIsICJncmlkIiwgImxpbmVXaWR0aCIsICJkcmF3T25DaGFydEFyZWEiLCAiZHJhd1RpY2tzIiwgInRpY2tMZW5ndGgiLCAidGlja1dpZHRoIiwgIl9jdHgiLCAidGlja0NvbG9yIiwgImJvcmRlciIsICJkYXNoIiwgImRhc2hPZmZzZXQiLCAid2lkdGgiLCAidGl0bGUiLCAidGV4dCIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJtaXJyb3IiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VDb2xvciIsICJhdXRvU2tpcCIsICJhdXRvU2tpcFBhZGRpbmciLCAibGFiZWxPZmZzZXQiLCAiVGlja3MiLCAibWlub3IiLCAibWFqb3IiLCAiY3Jvc3NBbGlnbiIsICJzaG93TGFiZWxCYWNrZHJvcCIsICJiYWNrZHJvcENvbG9yIiwgImJhY2tkcm9wUGFkZGluZyIsICJyb3V0ZSIsICJzdGFydHNXaXRoIiwgIm92ZXJyaWRlcyIsICJjcmVhdGUiLCAiZGVzY3JpcHRvcnMiLCAiZ2V0U2NvcGUiLCAibm9kZSIsICJrZXkiLCAia2V5cyIsICJzcGxpdCIsICJpIiwgIm4iLCAiayIsICJyb290IiwgInNjb3BlIiwgIm1lcmdlIiwgIkRlZmF1bHRzIiwgImNvbnN0cnVjdG9yIiwgIl9kZXNjcmlwdG9ycyIsICJfYXBwbGllcnMiLCAiYmFja2dyb3VuZENvbG9yIiwgImJvcmRlckNvbG9yIiwgImRhdGFzZXRzIiwgImRldmljZVBpeGVsUmF0aW8iLCAiY29udGV4dCIsICJwbGF0Zm9ybSIsICJnZXREZXZpY2VQaXhlbFJhdGlvIiwgImVsZW1lbnRzIiwgImV2ZW50cyIsICJmb250IiwgImZhbWlseSIsICJzaXplIiwgInN0eWxlIiwgImxpbmVIZWlnaHQiLCAid2VpZ2h0IiwgImhvdmVyIiwgImhvdmVyQmFja2dyb3VuZENvbG9yIiwgImN0eCIsICJob3ZlckJvcmRlckNvbG9yIiwgImhvdmVyQ29sb3IiLCAiaW5kZXhBeGlzIiwgImludGVyYWN0aW9uIiwgIm1vZGUiLCAiaW50ZXJzZWN0IiwgImluY2x1ZGVJbnZpc2libGUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJvbkhvdmVyIiwgIm9uQ2xpY2siLCAicGFyc2luZyIsICJwbHVnaW5zIiwgInJlc3BvbnNpdmUiLCAic2NhbGUiLCAic2NhbGVzIiwgInNob3dMaW5lIiwgImRyYXdBY3RpdmVFbGVtZW50c09uVG9wIiwgIm92ZXJyaWRlIiwgInRhcmdldFNjb3BlIiwgInRhcmdldE5hbWUiLCAic2NvcGVPYmplY3QiLCAidGFyZ2V0U2NvcGVPYmplY3QiLCAicHJpdmF0ZU5hbWUiLCAiZGVmaW5lUHJvcGVydGllcyIsICJ3cml0YWJsZSIsICJlbnVtZXJhYmxlIiwgImxvY2FsIiwgInRhcmdldCIsICJpc09iamVjdCIsICJ2YWx1ZU9yRGVmYXVsdCIsICJhcHBsaWVycyIsICJmb3JFYWNoIiwgInRvRm9udFN0cmluZyIsICJfbWVhc3VyZVRleHQiLCAiZGF0YSIsICJnYyIsICJsb25nZXN0IiwgInN0cmluZyIsICJ0ZXh0V2lkdGgiLCAibWVhc3VyZVRleHQiLCAicHVzaCIsICJfbG9uZ2VzdFRleHQiLCAiYXJyYXlPZlRoaW5ncyIsICJjYWNoZSIsICJnYXJiYWdlQ29sbGVjdCIsICJzYXZlIiwgImlsZW4iLCAiaiIsICJqbGVuIiwgInRoaW5nIiwgIm5lc3RlZFRoaW5nIiwgInJlc3RvcmUiLCAiZ2NMZW4iLCAic3BsaWNlIiwgIl9hbGlnblBpeGVsIiwgInBpeGVsIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImhhbGZXaWR0aCIsICJyb3VuZCIsICJjbGVhckNhbnZhcyIsICJjYW52YXMiLCAiZ2V0Q29udGV4dCIsICJyZXNldFRyYW5zZm9ybSIsICJjbGVhclJlY3QiLCAiaGVpZ2h0IiwgImRyYXdQb2ludCIsICJ4IiwgInkiLCAiZHJhd1BvaW50TGVnZW5kIiwgInciLCAieE9mZnNldCIsICJ5T2Zmc2V0IiwgImNvcm5lclJhZGl1cyIsICJ4T2Zmc2V0VyIsICJ5T2Zmc2V0VyIsICJwb2ludFN0eWxlIiwgInJvdGF0aW9uIiwgInJhZGl1cyIsICJyYWQiLCAiUkFEX1BFUl9ERUciLCAidHJhbnNsYXRlIiwgInJvdGF0ZSIsICJkcmF3SW1hZ2UiLCAiYmVnaW5QYXRoIiwgImVsbGlwc2UiLCAiYXJjIiwgImNsb3NlUGF0aCIsICJtb3ZlVG8iLCAiVFdPX1RISVJEU19QSSIsICJsaW5lVG8iLCAiUVVBUlRFUl9QSSIsICJTUVJUMV8yIiwgInJlY3QiLCAiZmlsbCIsICJib3JkZXJXaWR0aCIsICJzdHJva2UiLCAiX2lzUG9pbnRJbkFyZWEiLCAiYXJlYSIsICJtYXJnaW4iLCAiY2xpcEFyZWEiLCAidW5jbGlwQXJlYSIsICJfc3RlcHBlZExpbmVUbyIsICJwcmV2aW91cyIsICJmbGlwIiwgIm1pZHBvaW50IiwgIl9iZXppZXJDdXJ2ZVRvIiwgImJlemllckN1cnZlVG8iLCAiY3AxeCIsICJjcDJ4IiwgImNwMXkiLCAiY3AyeSIsICJzZXRSZW5kZXJPcHRzIiwgIm9wdHMiLCAidHJhbnNsYXRpb24iLCAiZmlsbFN0eWxlIiwgInRleHRBbGlnbiIsICJ0ZXh0QmFzZWxpbmUiLCAiZGVjb3JhdGVUZXh0IiwgImxpbmUiLCAic3RyaWtldGhyb3VnaCIsICJ1bmRlcmxpbmUiLCAibWV0cmljcyIsICJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCAiYWN0dWFsQm91bmRpbmdCb3hSaWdodCIsICJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsICJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCAieURlY29yYXRpb24iLCAic3Ryb2tlU3R5bGUiLCAiZGVjb3JhdGlvbldpZHRoIiwgImRyYXdCYWNrZHJvcCIsICJvbGRDb2xvciIsICJmaWxsUmVjdCIsICJyZW5kZXJUZXh0IiwgImxpbmVzIiwgInN0cm9rZVdpZHRoIiwgInN0cm9rZUNvbG9yIiwgImJhY2tkcm9wIiwgInN0cm9rZVRleHQiLCAibWF4V2lkdGgiLCAiZmlsbFRleHQiLCAiTnVtYmVyIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJoIiwgInRvcExlZnQiLCAiYm90dG9tTGVmdCIsICJib3R0b21SaWdodCIsICJ0b3BSaWdodCIsICJMSU5FX0hFSUdIVCIsICJGT05UX1NUWUxFIiwgInRvTGluZUhlaWdodCIsICJtYXRjaGVzIiwgIm1hdGNoIiwgIm51bWJlck9yWmVybyIsICJfcmVhZFZhbHVlVG9Qcm9wcyIsICJwcm9wcyIsICJyZXQiLCAib2JqUHJvcHMiLCAicmVhZCIsICJwcm9wIiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgInRvUGFkZGluZyIsICJvYmoiLCAidG9Gb250IiwgImZhbGxiYWNrIiwgInBhcnNlSW50IiwgImNvbnNvbGUiLCAid2FybiIsICJyZXNvbHZlIiwgImlucHV0cyIsICJpbmZvIiwgImNhY2hlYWJsZSIsICJfYWRkR3JhY2UiLCAibWlubWF4IiwgImNoYW5nZSIsICJ0b0RpbWVuc2lvbiIsICJrZWVwWmVybyIsICJhZGQiLCAiY3JlYXRlQ29udGV4dCIsICJwYXJlbnRDb250ZXh0IiwgIl9jcmVhdGVSZXNvbHZlciIsICJzY29wZXMiLCAicHJlZml4ZXMiLCAicm9vdFNjb3BlcyIsICJnZXRUYXJnZXQiLCAiZmluYWxSb290U2NvcGVzIiwgIl9yZXNvbHZlIiwgIlN5bWJvbCIsICJ0b1N0cmluZ1RhZyIsICJfY2FjaGVhYmxlIiwgIl9zY29wZXMiLCAiX3Jvb3RTY29wZXMiLCAiX2dldFRhcmdldCIsICJQcm94eSIsICJkZWxldGVQcm9wZXJ0eSIsICJfa2V5cyIsICJfY2FjaGVkIiwgIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwgImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsICJSZWZsZWN0IiwgImdldFByb3RvdHlwZU9mIiwgImhhcyIsICJnZXRLZXlzRnJvbUFsbFNjb3BlcyIsICJvd25LZXlzIiwgInN0b3JhZ2UiLCAiX3N0b3JhZ2UiLCAiX2F0dGFjaENvbnRleHQiLCAicHJveHkiLCAic3ViUHJveHkiLCAiZGVzY3JpcHRvckRlZmF1bHRzIiwgIl9wcm94eSIsICJfY29udGV4dCIsICJfc3ViUHJveHkiLCAiX3N0YWNrIiwgIlNldCIsICJzZXRDb250ZXh0IiwgInJlY2VpdmVyIiwgIl9yZXNvbHZlV2l0aENvbnRleHQiLCAiYWxsS2V5cyIsICJjb25maWd1cmFibGUiLCAic2NyaXB0YWJsZSIsICJpbmRleGFibGUiLCAiX2FsbEtleXMiLCAiaXNTY3JpcHRhYmxlIiwgImlzRnVuY3Rpb24iLCAiaXNJbmRleGFibGUiLCAicmVhZEtleSIsICJwcmVmaXgiLCAiX2NhcGl0YWxpemUiLCAibmVlZHNTdWJSZXNvbHZlciIsICJwcm90b3R5cGUiLCAiaGFzT3duUHJvcGVydHkiLCAiX3Jlc29sdmVTY3JpcHRhYmxlIiwgIl9yZXNvbHZlQXJyYXkiLCAiZ2V0VmFsdWUiLCAiRXJyb3IiLCAiQXJyYXkiLCAiam9pbiIsICJkZWxldGUiLCAiY3JlYXRlU3ViUmVzb2x2ZXIiLCAiYXJyIiwgImZpbHRlciIsICJpdGVtIiwgInJlc29sdmVyIiwgInJlc29sdmVGYWxsYmFjayIsICJwYXJlbnQiLCAicmVzb2x2ZU9iamVjdEtleSIsICJhZGRTY29wZXMiLCAicGFyZW50U2NvcGVzIiwgInBhcmVudEZhbGxiYWNrIiwgImFsbFNjb3BlcyIsICJhZGRTY29wZXNGcm9tS2V5IiwgInN1YkdldFRhcmdldCIsICJyZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMiLCAiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwgIl9wYXJzaW5nIiwgInBhcnNlZCIsICJyIiwgInBhcnNlIiwgIkVQU0lMT04iLCAiZ2V0UG9pbnQiLCAic2tpcCIsICJnZXRWYWx1ZUF4aXMiLCAic3BsaW5lQ3VydmUiLCAiZmlyc3RQb2ludCIsICJtaWRkbGVQb2ludCIsICJhZnRlclBvaW50IiwgImN1cnJlbnQiLCAibmV4dCIsICJkMDEiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgImQxMiIsICJzMDEiLCAiczEyIiwgImZhIiwgImZiIiwgIm1vbm90b25lQWRqdXN0IiwgImRlbHRhSyIsICJtSyIsICJwb2ludHNMZW4iLCAiYWxwaGFLIiwgImJldGFLIiwgInRhdUsiLCAic3F1YXJlZE1hZ25pdHVkZSIsICJwb2ludEN1cnJlbnQiLCAicG9pbnRBZnRlciIsICJhbG1vc3RFcXVhbHMiLCAibW9ub3RvbmVDb21wdXRlIiwgInZhbHVlQXhpcyIsICJwb2ludEJlZm9yZSIsICJpUGl4ZWwiLCAidlBpeGVsIiwgInNwbGluZUN1cnZlTW9ub3RvbmUiLCAic2xvcGVEZWx0YSIsICJzaWduIiwgImNhcENvbnRyb2xQb2ludCIsICJwdCIsICJjYXBCZXppZXJQb2ludHMiLCAiaW5BcmVhIiwgImluQXJlYVByZXYiLCAiaW5BcmVhTmV4dCIsICJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsICJjb250cm9sUG9pbnRzIiwgImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCAicHJldiIsICJ0ZW5zaW9uIiwgIl9pc0RvbVN1cHBvcnRlZCIsICJkb2N1bWVudCIsICJfZ2V0UGFyZW50Tm9kZSIsICJkb21Ob2RlIiwgInBhcmVudE5vZGUiLCAiaG9zdCIsICJwYXJzZU1heFN0eWxlIiwgInN0eWxlVmFsdWUiLCAicGFyZW50UHJvcGVydHkiLCAidmFsdWVJblBpeGVscyIsICJpbmRleE9mIiwgImdldENvbXB1dGVkU3R5bGUiLCAiZWxlbWVudCIsICJvd25lckRvY3VtZW50IiwgImRlZmF1bHRWaWV3IiwgImdldFN0eWxlIiwgImVsIiwgInByb3BlcnR5IiwgImdldFByb3BlcnR5VmFsdWUiLCAicG9zaXRpb25zIiwgImdldFBvc2l0aW9uZWRTdHlsZSIsICJzdHlsZXMiLCAic3VmZml4IiwgInJlc3VsdCIsICJwb3MiLCAicGFyc2VGbG9hdCIsICJ1c2VPZmZzZXRQb3MiLCAic2hhZG93Um9vdCIsICJnZXRDYW52YXNQb3NpdGlvbiIsICJlIiwgInRvdWNoZXMiLCAic291cmNlIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJib3giLCAiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwgImNsaWVudFgiLCAiY2xpZW50WSIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgImV2ZW50IiwgImJvcmRlckJveCIsICJib3hTaXppbmciLCAicGFkZGluZ3MiLCAiYm9yZGVycyIsICJnZXRDb250YWluZXJTaXplIiwgIm1heEhlaWdodCIsICJjb250YWluZXIiLCAiY2xpZW50V2lkdGgiLCAiY2xpZW50SGVpZ2h0IiwgImNvbnRhaW5lclN0eWxlIiwgImNvbnRhaW5lckJvcmRlciIsICJjb250YWluZXJQYWRkaW5nIiwgIklORklOSVRZIiwgInJvdW5kMSIsICJnZXRNYXhpbXVtU2l6ZSIsICJiYldpZHRoIiwgImJiSGVpZ2h0IiwgImFzcGVjdFJhdGlvIiwgIm1hcmdpbnMiLCAiY29udGFpbmVyU2l6ZSIsICJtYWludGFpbkhlaWdodCIsICJyZXRpbmFTY2FsZSIsICJmb3JjZVJhdGlvIiwgImZvcmNlU3R5bGUiLCAicGl4ZWxSYXRpbyIsICJkZXZpY2VIZWlnaHQiLCAiZGV2aWNlV2lkdGgiLCAic2V0VHJhbnNmb3JtIiwgInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAicGFzc2l2ZVN1cHBvcnRlZCIsICJwYXNzaXZlIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAicmVtb3ZlRXZlbnRMaXN0ZW5lciIsICJyZWFkVXNlZFNpemUiLCAiX3BvaW50SW5MaW5lIiwgInAxIiwgInAyIiwgIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsICJfYmV6aWVySW50ZXJwb2xhdGlvbiIsICJjcDEiLCAiY3AyIiwgImEiLCAiYiIsICJjIiwgImdldFJpZ2h0VG9MZWZ0QWRhcHRlciIsICJyZWN0WCIsICJzZXRXaWR0aCIsICJ4UGx1cyIsICJsZWZ0Rm9yTHRyIiwgIml0ZW1XaWR0aCIsICJnZXRMZWZ0VG9SaWdodEFkYXB0ZXIiLCAiX2l0ZW1XaWR0aCIsICJnZXRSdGxBZGFwdGVyIiwgIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsICJkaXJlY3Rpb24iLCAib3JpZ2luYWwiLCAiZ2V0UHJvcGVydHlQcmlvcml0eSIsICJzZXRQcm9wZXJ0eSIsICJwcmV2VGV4dERpcmVjdGlvbiIsICJyZXN0b3JlVGV4dERpcmVjdGlvbiIsICJwcm9wZXJ0eUZuIiwgImJldHdlZW4iLCAiX2FuZ2xlQmV0d2VlbiIsICJjb21wYXJlIiwgIl9hbmdsZURpZmYiLCAibm9ybWFsaXplIiwgIl9ub3JtYWxpemVBbmdsZSIsICJfaXNCZXR3ZWVuIiwgIm5vcm1hbGl6ZVNlZ21lbnQiLCAiZ2V0U2VnbWVudCIsICJzZWdtZW50IiwgInN0YXJ0Qm91bmQiLCAiZW5kQm91bmQiLCAiX2JvdW5kU2VnbWVudCIsICJpbnNpZGUiLCAic3ViU3RhcnQiLCAicHJldlZhbHVlIiwgInN0YXJ0SXNCZWZvcmUiLCAiZW5kSXNCZWZvcmUiLCAic2hvdWxkU3RhcnQiLCAic2hvdWxkU3RvcCIsICJfYm91bmRTZWdtZW50cyIsICJzZWdtZW50cyIsICJzdWIiLCAiZmluZFN0YXJ0QW5kRW5kIiwgInNvbGlkU2VnbWVudHMiLCAibGFzdCIsICJjdXIiLCAic3RvcCIsICJfY29tcHV0ZVNlZ21lbnRzIiwgInNlZ21lbnRPcHRpb25zIiwgIl9sb29wIiwgInNwbGl0QnlTdHlsZXMiLCAiY29tcGxldGVMb29wIiwgIl9mdWxsTG9vcCIsICJkb1NwbGl0QnlTdHlsZXMiLCAiY2hhcnRDb250ZXh0IiwgIl9jaGFydCIsICJiYXNlU3R5bGUiLCAicmVhZFN0eWxlIiwgIl9kYXRhc2V0SW5kZXgiLCAiZGF0YXNldEluZGV4IiwgInByZXZTdHlsZSIsICJhZGRTdHlsZSIsICJsIiwgInN0IiwgImRpciIsICJwMCIsICJwMERhdGFJbmRleCIsICJwMURhdGFJbmRleCIsICJzdHlsZUNoYW5nZWQiLCAiYm9yZGVyQ2FwU3R5bGUiLCAiYm9yZGVyRGFzaCIsICJib3JkZXJEYXNoT2Zmc2V0IiwgImJvcmRlckpvaW5TdHlsZSIsICJyZXBsYWNlciIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiZm91bmQiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJtZXRhIiwgImlTY2FsZSIsICJ2U2NhbGUiLCAiaUF4aXNLZXkiLCAiYXhpcyIsICJ2QXhpc0tleSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAic3RhY2tlZCIsICJnZXRTdGFja0tleSIsICJpbmRleFNjYWxlIiwgInZhbHVlU2NhbGUiLCAiaWQiLCAiZ2V0VXNlckJvdW5kcyIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiTnVtYmVyIiwgIk5FR0FUSVZFX0lORklOSVRZIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImdldE9yQ3JlYXRlU3RhY2siLCAic3RhY2tzIiwgInN0YWNrS2V5IiwgImluZGV4VmFsdWUiLCAic3ViU3RhY2siLCAiZ2V0TGFzdEluZGV4SW5TdGFjayIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpQXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAiY3VycmVudFBhcnNlZCIsICJpU2NhbGVWYWx1ZSIsICJza2lwTnVsbCIsICJmaW5kIiwgInZhbCIsICJpc05hTiIsICJpbmRleE9mIiwgIl9nZXRTdGFja0NvdW50IiwgIl9nZXRTdGFja0luZGV4IiwgIm5hbWUiLCAiX3N0YXJ0UGl4ZWwiLCAiX2VuZFBpeGVsIiwgImJhc2VWYWx1ZSIsICJtaW5CYXJMZW5ndGgiLCAiZmxvYXRpbmciLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAic3RhcnRQaXhlbCIsICJnZXRQaXhlbEZvckRlY2ltYWwiLCAiZW5kUGl4ZWwiLCAiZ2V0VmFsdWVGb3JQaXhlbCIsICJoYWxmR3JpZCIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJtYXhCYXJUaGlja25lc3MiLCAiSW5maW5pdHkiLCAic3RhY2tJbmRleCIsICJyZWN0cyIsICJudW1iZXJzIiwgIm92ZXJyaWRlcyIsICJfaW5kZXhfIiwgIm9mZnNldCIsICJncmlkIiwgIl92YWx1ZV8iLCAiYmVnaW5BdFplcm8iLCAiQnViYmxlQ29udHJvbGxlciIsICJyYWRpdXMiLCAicG9pbnRzIiwgInBvaW50IiwgImlQaXhlbCIsICJ2UGl4ZWwiLCAic2tpcCIsICJnZXRSYXRpb0FuZE9mZnNldCIsICJyb3RhdGlvbiIsICJjaXJjdW1mZXJlbmNlIiwgImN1dG91dCIsICJyYXRpb1giLCAicmF0aW9ZIiwgIm9mZnNldFgiLCAib2Zmc2V0WSIsICJUQVUiLCAic3RhcnRBbmdsZSIsICJlbmRBbmdsZSIsICJzdGFydFgiLCAiY29zIiwgInN0YXJ0WSIsICJzaW4iLCAiZW5kWCIsICJlbmRZIiwgImNhbGNNYXgiLCAiYW5nbGUiLCAiX2FuZ2xlQmV0d2VlbiIsICJjYWxjTWluIiwgIm1heFgiLCAibWF4WSIsICJIQUxGX1BJIiwgIm1pblgiLCAiUEkiLCAibWluWSIsICJEb3VnaG51dENvbnRyb2xsZXIiLCAiaW5uZXJSYWRpdXMiLCAib3V0ZXJSYWRpdXMiLCAiZ2V0dGVyIiwgIl9nZXRSb3RhdGlvbiIsICJ0b1JhZGlhbnMiLCAiX2dldENpcmN1bWZlcmVuY2UiLCAiX2dldFJvdGF0aW9uRXh0ZW50cyIsICJpc0RhdGFzZXRWaXNpYmxlIiwgImFyY3MiLCAic3BhY2luZyIsICJnZXRNYXhCb3JkZXJXaWR0aCIsICJnZXRNYXhPZmZzZXQiLCAibWF4U2l6ZSIsICJ0b1BlcmNlbnRhZ2UiLCAiY2hhcnRXZWlnaHQiLCAiX2dldFJpbmdXZWlnaHQiLCAibWF4V2lkdGgiLCAibWF4SGVpZ2h0IiwgIm1heFJhZGl1cyIsICJ0b0RpbWVuc2lvbiIsICJyYWRpdXNMZW5ndGgiLCAiX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwiLCAidG90YWwiLCAiY2FsY3VsYXRlVG90YWwiLCAiX2dldFJpbmdXZWlnaHRPZmZzZXQiLCAiX2NpcmN1bWZlcmVuY2UiLCAiYW5pbWF0ZVJvdGF0ZSIsICJjYWxjdWxhdGVDaXJjdW1mZXJlbmNlIiwgImFuaW1hdGlvbk9wdHMiLCAiY2VudGVyWCIsICJjZW50ZXJZIiwgImFuaW1hdGVTY2FsZSIsICJhcmMiLCAibWV0YURhdGEiLCAiZm9ybWF0TnVtYmVyIiwgImxvY2FsZSIsICJib3JkZXJBbGlnbiIsICJib3JkZXJXaWR0aCIsICJob3ZlckJvcmRlcldpZHRoIiwgImhvdmVyT2Zmc2V0IiwgInJpbmdXZWlnaHRPZmZzZXQiLCAid2VpZ2h0IiwgImRlc2NyaXB0b3JzIiwgIl9zY3JpcHRhYmxlIiwgIl9pbmRleGFibGUiLCAic3RhcnRzV2l0aCIsICJhc3BlY3RSYXRpbyIsICJwbHVnaW5zIiwgImxlZ2VuZCIsICJnZW5lcmF0ZUxhYmVscyIsICJwb2ludFN0eWxlIiwgIm1hcCIsICJzdHlsZSIsICJ0ZXh0IiwgImZpbGxTdHlsZSIsICJiYWNrZ3JvdW5kQ29sb3IiLCAic3Ryb2tlU3R5bGUiLCAiYm9yZGVyQ29sb3IiLCAiZm9udENvbG9yIiwgImxpbmVXaWR0aCIsICJvbkNsaWNrIiwgImUiLCAibGVnZW5kSXRlbSIsICJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsICJMaW5lQ29udHJvbGxlciIsICJsaW5lIiwgIl9kYXRhc2V0IiwgImFuaW1hdGlvbnNEaXNhYmxlZCIsICJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsICJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwgIl9kYXRhc2V0SW5kZXgiLCAiX2RlY2ltYXRlZCIsICJzaG93TGluZSIsICJzZWdtZW50IiwgImFuaW1hdGVkIiwgInNwYW5HYXBzIiwgIm1heEdhcExlbmd0aCIsICJpc051bWJlciIsICJkaXJlY3RVcGRhdGUiLCAicG9pbnRzQ291bnQiLCAicHJldlBhcnNlZCIsICJudWxsRGF0YSIsICJib3JkZXIiLCAiZmlyc3RQb2ludCIsICJsYXN0UG9pbnQiLCAidXBkYXRlQ29udHJvbFBvaW50cyIsICJQb2xhckFyZWFDb250cm9sbGVyIiwgIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsICJiaW5kIiwgIl91cGRhdGVSYWRpdXMiLCAibWluU2l6ZSIsICJjdXRvdXRQZXJjZW50YWdlIiwgImdldFZpc2libGVEYXRhc2V0Q291bnQiLCAieENlbnRlciIsICJ5Q2VudGVyIiwgImRhdGFzZXRTdGFydEFuZ2xlIiwgImdldEluZGV4QW5nbGUiLCAiZGVmYXVsdEFuZ2xlIiwgImNvdW50VmlzaWJsZUVsZW1lbnRzIiwgIl9jb21wdXRlQW5nbGUiLCAiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCAiYW5nbGVMaW5lcyIsICJkaXNwbGF5IiwgImNpcmN1bGFyIiwgInBvaW50TGFiZWxzIiwgIlBpZUNvbnRyb2xsZXIiLCAiUmFkYXJDb250cm9sbGVyIiwgIl9mdWxsTG9vcCIsICJwb2ludFBvc2l0aW9uIiwgImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsICJTY2F0dGVyQ29udHJvbGxlciIsICJyZWdpc3RyeSIsICJnZXRFbGVtZW50IiwgImludGVyYWN0aW9uIiwgImFic3RyYWN0IiwgIkVycm9yIiwgIkRhdGVBZGFwdGVyQmFzZSIsICJvdmVycmlkZSIsICJtZW1iZXJzIiwgInByb3RvdHlwZSIsICJpbml0IiwgImZvcm1hdHMiLCAiZm9ybWF0IiwgImRpZmYiLCAic3RhcnRPZiIsICJlbmRPZiIsICJfZGF0ZSIsICJiaW5hcnlTZWFyY2giLCAibWV0YXNldCIsICJpbnRlcnNlY3QiLCAibG9va3VwTWV0aG9kIiwgIl9yZXZlcnNlUGl4ZWxzIiwgIl9ybG9va3VwQnlLZXkiLCAiX2xvb2t1cEJ5S2V5IiwgInJlc3VsdCIsICJkaXN0YW5jZVRvRGVmaW5lZExvIiwgInNsaWNlIiwgImxvIiwgImZpbmRJbmRleCIsICJkaXN0YW5jZVRvRGVmaW5lZEhpIiwgImhpIiwgImVsIiwgImdldFJhbmdlIiwgImV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyIsICJwb3NpdGlvbiIsICJoYW5kbGVyIiwgImdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMiLCAiaiIsICJnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMiLCAidXNlWCIsICJ1c2VZIiwgInB0MSIsICJwdDIiLCAiZGVsdGFYIiwgImRlbHRhWSIsICJzcXJ0IiwgInBvdyIsICJnZXRJbnRlcnNlY3RJdGVtcyIsICJ1c2VGaW5hbFBvc2l0aW9uIiwgImluY2x1ZGVJbnZpc2libGUiLCAiaXNQb2ludEluQXJlYSIsICJldmFsdWF0aW9uRnVuYyIsICJfaXNQb2ludEluQXJlYSIsICJpblJhbmdlIiwgImdldE5lYXJlc3RSYWRpYWxJdGVtcyIsICJnZXRQcm9wcyIsICJnZXRBbmdsZUZyb21Qb2ludCIsICJnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMiLCAiZGlzdGFuY2VNZXRyaWMiLCAibWluRGlzdGFuY2UiLCAiZ2V0Q2VudGVyUG9pbnQiLCAicG9pbnRJbkFyZWEiLCAiZGlzdGFuY2UiLCAiZ2V0TmVhcmVzdEl0ZW1zIiwgImdldEF4aXNJdGVtcyIsICJyYW5nZU1ldGhvZCIsICJpbnRlcnNlY3RzSXRlbSIsICJtb2RlcyIsICJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwgIm5lYXJlc3QiLCAiU1RBVElDX1BPU0lUSU9OUyIsICJmaWx0ZXJCeVBvc2l0aW9uIiwgImFycmF5IiwgInBvcyIsICJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCAiYm94IiwgInNvcnRCeVdlaWdodCIsICJ2MCIsICJ3cmFwQm94ZXMiLCAiYm94ZXMiLCAibGF5b3V0Qm94ZXMiLCAic3RhY2tXZWlnaHQiLCAiYnVpbGRTdGFja3MiLCAibGF5b3V0cyIsICJ3cmFwIiwgImluY2x1ZGVzIiwgIl9zdGFjayIsICJwbGFjZWQiLCAic2V0TGF5b3V0RGltcyIsICJwYXJhbXMiLCAidkJveE1heFdpZHRoIiwgImhCb3hNYXhIZWlnaHQiLCAibGF5b3V0IiwgImZ1bGxTaXplIiwgImF2YWlsYWJsZVdpZHRoIiwgImF2YWlsYWJsZUhlaWdodCIsICJidWlsZExheW91dEJveGVzIiwgImNlbnRlckhvcml6b250YWwiLCAiY2VudGVyVmVydGljYWwiLCAibGVmdEFuZFRvcCIsICJyaWdodEFuZEJvdHRvbSIsICJ2ZXJ0aWNhbCIsICJnZXRDb21iaW5lZE1heCIsICJtYXhQYWRkaW5nIiwgInVwZGF0ZU1heFBhZGRpbmciLCAiYm94UGFkZGluZyIsICJ1cGRhdGVEaW1zIiwgImdldFBhZGRpbmciLCAibmV3V2lkdGgiLCAib3V0ZXJXaWR0aCIsICJuZXdIZWlnaHQiLCAib3V0ZXJIZWlnaHQiLCAid2lkdGhDaGFuZ2VkIiwgInciLCAiaGVpZ2h0Q2hhbmdlZCIsICJoIiwgInNhbWUiLCAib3RoZXIiLCAiaGFuZGxlTWF4UGFkZGluZyIsICJ1cGRhdGVQb3MiLCAiY2hhbmdlIiwgImdldE1hcmdpbnMiLCAibWFyZ2luRm9yUG9zaXRpb25zIiwgInBvc2l0aW9ucyIsICJtYXJnaW4iLCAiZml0Qm94ZXMiLCAicmVmaXRCb3hlcyIsICJyZWZpdCIsICJjaGFuZ2VkIiwgInNldEJveERpbXMiLCAicGxhY2VCb3hlcyIsICJ1c2VyUGFkZGluZyIsICJwYWRkaW5nIiwgImFkZEJveCIsICJfbGF5ZXJzIiwgInoiLCAicmVtb3ZlQm94IiwgImxheW91dEl0ZW0iLCAibWluUGFkZGluZyIsICJ0b1BhZGRpbmciLCAidmVydGljYWxCb3hlcyIsICJob3Jpem9udGFsQm94ZXMiLCAiZWFjaCIsICJiZWZvcmVMYXlvdXQiLCAidmlzaWJsZVZlcnRpY2FsQm94Q291bnQiLCAiQmFzZVBsYXRmb3JtIiwgImFjcXVpcmVDb250ZXh0IiwgImNhbnZhcyIsICJyZWxlYXNlQ29udGV4dCIsICJhZGRFdmVudExpc3RlbmVyIiwgImxpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJnZXRNYXhpbXVtU2l6ZSIsICJpc0F0dGFjaGVkIiwgInVwZGF0ZUNvbmZpZyIsICJCYXNpY1BsYXRmb3JtIiwgIkVYUEFORE9fS0VZIiwgIkVWRU5UX1RZUEVTIiwgInRvdWNoc3RhcnQiLCAidG91Y2htb3ZlIiwgInRvdWNoZW5kIiwgInBvaW50ZXJlbnRlciIsICJwb2ludGVyZG93biIsICJwb2ludGVybW92ZSIsICJwb2ludGVydXAiLCAicG9pbnRlcmxlYXZlIiwgInBvaW50ZXJvdXQiLCAiaXNOdWxsT3JFbXB0eSIsICJpbml0Q2FudmFzIiwgInJlbmRlckhlaWdodCIsICJnZXRBdHRyaWJ1dGUiLCAicmVuZGVyV2lkdGgiLCAiYm94U2l6aW5nIiwgImRpc3BsYXlXaWR0aCIsICJyZWFkVXNlZFNpemUiLCAiZGlzcGxheUhlaWdodCIsICJldmVudExpc3RlbmVyT3B0aW9ucyIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmUiLCAiYWRkTGlzdGVuZXIiLCAibm9kZSIsICJyZW1vdmVMaXN0ZW5lciIsICJmcm9tTmF0aXZlRXZlbnQiLCAibmF0aXZlIiwgIm5vZGVMaXN0Q29udGFpbnMiLCAibm9kZUxpc3QiLCAiY29udGFpbnMiLCAiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCAib2JzZXJ2ZXIiLCAiTXV0YXRpb25PYnNlcnZlciIsICJlbnRyaWVzIiwgInRyaWdnZXIiLCAiYWRkZWROb2RlcyIsICJyZW1vdmVkTm9kZXMiLCAib2JzZXJ2ZSIsICJkb2N1bWVudCIsICJjaGlsZExpc3QiLCAic3VidHJlZSIsICJjcmVhdGVEZXRhY2hPYnNlcnZlciIsICJkcnBMaXN0ZW5pbmdDaGFydHMiLCAib2xkRGV2aWNlUGl4ZWxSYXRpbyIsICJvbldpbmRvd1Jlc2l6ZSIsICJkcHIiLCAiZGV2aWNlUGl4ZWxSYXRpbyIsICJyZXNpemUiLCAiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCAibGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCAidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsICJjcmVhdGVSZXNpemVPYnNlcnZlciIsICJjb250YWluZXIiLCAiX2dldFBhcmVudE5vZGUiLCAidGhyb3R0bGVkIiwgImNsaWVudFdpZHRoIiwgIlJlc2l6ZU9ic2VydmVyIiwgImNvbnRlbnRSZWN0IiwgInJlbGVhc2VPYnNlcnZlciIsICJkaXNjb25uZWN0IiwgImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwgInByb3h5IiwgIkRvbVBsYXRmb3JtIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJzZXRBdHRyaWJ1dGUiLCAicHJveGllcyIsICIkcHJveGllcyIsICJoYW5kbGVycyIsICJhdHRhY2giLCAiZGV0YWNoIiwgImlzQ29ubmVjdGVkIiwgIl9kZXRlY3RQbGF0Zm9ybSIsICJfaXNEb21TdXBwb3J0ZWQiLCAiT2Zmc2NyZWVuQ2FudmFzIiwgIkVsZW1lbnQiLCAidG9vbHRpcFBvc2l0aW9uIiwgImhhc1ZhbHVlIiwgImZpbmFsIiwgInJldCIsICJkZWZhdWx0Um91dGVzIiwgImF1dG9Ta2lwIiwgInRpY2tPcHRzIiwgImRldGVybWluZWRNYXhUaWNrcyIsICJkZXRlcm1pbmVNYXhUaWNrcyIsICJ0aWNrc0xpbWl0IiwgIm1heFRpY2tzTGltaXQiLCAibWFqb3JJbmRpY2VzIiwgIm1ham9yIiwgImVuYWJsZWQiLCAiZ2V0TWFqb3JJbmRpY2VzIiwgIm51bU1ham9ySW5kaWNlcyIsICJmaXJzdCIsICJuZXdUaWNrcyIsICJza2lwTWFqb3JzIiwgImNhbGN1bGF0ZVNwYWNpbmciLCAiYXZnTWFqb3JTcGFjaW5nIiwgInJvdW5kIiwgInRpY2tMZW5ndGgiLCAiX3RpY2tTaXplIiwgIm1heFNjYWxlIiwgIm1heENoYXJ0IiwgIl9tYXhMZW5ndGgiLCAiZXZlbk1ham9yU3BhY2luZyIsICJnZXRFdmVuU3BhY2luZyIsICJmYWN0b3JzIiwgIl9mYWN0b3JpemUiLCAiY2VpbCIsICJtYWpvclN0YXJ0IiwgIm1ham9yRW5kIiwgImxlbiIsICJyZXZlcnNlQWxpZ24iLCAiYWxpZ24iLCAib2Zmc2V0RnJvbUVkZ2UiLCAiZ2V0VGlja3NMaW1pdCIsICJ0aWNrc0xlbmd0aCIsICJzYW1wbGUiLCAibnVtSXRlbXMiLCAiaW5jcmVtZW50IiwgImdldFBpeGVsRm9yR3JpZExpbmUiLCAib2Zmc2V0R3JpZExpbmVzIiwgInZhbGlkSW5kZXgiLCAiZXBzaWxvbiIsICJsaW5lVmFsdWUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAiY2FjaGVzIiwgImdjIiwgImdjTGVuIiwgImdldFRpY2tNYXJrTGVuZ3RoIiwgImRyYXdUaWNrcyIsICJnZXRUaXRsZUhlaWdodCIsICJmYWxsYmFjayIsICJmb250IiwgInRvRm9udCIsICJsaW5lcyIsICJsaW5lSGVpZ2h0IiwgImNyZWF0ZVNjYWxlQ29udGV4dCIsICJjcmVhdGVUaWNrQ29udGV4dCIsICJ0aXRsZUFsaWduIiwgIl90b0xlZnRSaWdodENlbnRlciIsICJ0aXRsZUFyZ3MiLCAidGl0bGVYIiwgInRpdGxlWSIsICJfYWxpZ25TdGFydEVuZCIsICJwb3NpdGlvbkF4aXNJRCIsICJTY2FsZSIsICJfbWFyZ2lucyIsICJwYWRkaW5nVG9wIiwgInBhZGRpbmdCb3R0b20iLCAicGFkZGluZ0xlZnQiLCAicGFkZGluZ1JpZ2h0IiwgImxhYmVsUm90YXRpb24iLCAiX3JhbmdlIiwgIl9ncmlkTGluZUl0ZW1zIiwgIl9sYWJlbEl0ZW1zIiwgIl9sYWJlbFNpemVzIiwgIl9sb25nZXN0VGV4dENhY2hlIiwgIl91c2VyTWF4IiwgIl91c2VyTWluIiwgIl9zdWdnZXN0ZWRNYXgiLCAiX3N1Z2dlc3RlZE1pbiIsICJfdGlja3NMZW5ndGgiLCAiX2JvcmRlclZhbHVlIiwgIl9kYXRhTGltaXRzQ2FjaGVkIiwgInNldENvbnRleHQiLCAic3VnZ2VzdGVkTWluIiwgInN1Z2dlc3RlZE1heCIsICJmaW5pdGVPckRlZmF1bHQiLCAibWV0YXMiLCAiZ2V0VGlja3MiLCAieExhYmVscyIsICJ5TGFiZWxzIiwgImdldExhYmVsSXRlbXMiLCAiX2NvbXB1dGVMYWJlbEl0ZW1zIiwgImJlZm9yZVVwZGF0ZSIsICJtYXJnaW5zIiwgImdyYWNlIiwgInNhbXBsZVNpemUiLCAiYmVmb3JlU2V0RGltZW5zaW9ucyIsICJzZXREaW1lbnNpb25zIiwgImFmdGVyU2V0RGltZW5zaW9ucyIsICJiZWZvcmVEYXRhTGltaXRzIiwgImRldGVybWluZURhdGFMaW1pdHMiLCAiYWZ0ZXJEYXRhTGltaXRzIiwgIl9hZGRHcmFjZSIsICJiZWZvcmVCdWlsZFRpY2tzIiwgImJ1aWxkVGlja3MiLCAiYWZ0ZXJCdWlsZFRpY2tzIiwgInNhbXBsaW5nRW5hYmxlZCIsICJfY29udmVydFRpY2tzVG9MYWJlbHMiLCAiYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwgImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJzb3VyY2UiLCAiYWZ0ZXJBdXRvU2tpcCIsICJiZWZvcmVGaXQiLCAiZml0IiwgImFmdGVyRml0IiwgImFmdGVyVXBkYXRlIiwgInJldmVyc2VQaXhlbHMiLCAiX2FsaWduVG9QaXhlbHMiLCAiYWxpZ25Ub1BpeGVscyIsICJfY2FsbEhvb2tzIiwgIm5vdGlmeVBsdWdpbnMiLCAiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwgImdlbmVyYXRlVGlja0xhYmVscyIsICJjYWxsYmFjayIsICJhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJudW1UaWNrcyIsICJtaW5Sb3RhdGlvbiIsICJtYXhSb3RhdGlvbiIsICJ0aWNrV2lkdGgiLCAibWF4TGFiZWxEaWFnb25hbCIsICJfaXNWaXNpYmxlIiwgImxhYmVsU2l6ZXMiLCAiX2dldExhYmVsU2l6ZXMiLCAibWF4TGFiZWxXaWR0aCIsICJ3aWRlc3QiLCAibWF4TGFiZWxIZWlnaHQiLCAiaGlnaGVzdCIsICJfbGltaXRWYWx1ZSIsICJ0aXRsZSIsICJ0b0RlZ3JlZXMiLCAiYXNpbiIsICJ0aXRsZU9wdHMiLCAiZ3JpZE9wdHMiLCAidGl0bGVIZWlnaHQiLCAidGlja1BhZGRpbmciLCAiYW5nbGVSYWRpYW5zIiwgImxhYmVsSGVpZ2h0IiwgIm1pcnJvciIsICJsYWJlbFdpZHRoIiwgIl9jYWxjdWxhdGVQYWRkaW5nIiwgIl9oYW5kbGVNYXJnaW5zIiwgImlzUm90YXRlZCIsICJsYWJlbHNCZWxvd1RpY2tzIiwgIm9mZnNldExlZnQiLCAib2Zmc2V0UmlnaHQiLCAiaXNGdWxsU2l6ZSIsICJfY29tcHV0ZUxhYmVsU2l6ZXMiLCAid2lkdGhzIiwgImhlaWdodHMiLCAid2lkZXN0TGFiZWxTaXplIiwgImhpZ2hlc3RMYWJlbFNpemUiLCAiamxlbiIsICJ0aWNrRm9udCIsICJmb250U3RyaW5nIiwgIm5lc3RlZExhYmVsIiwgIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwgInN0cmluZyIsICJfbWVhc3VyZVRleHQiLCAidmFsdWVBdCIsICJpZHgiLCAicGl4ZWwiLCAiZGVjaW1hbCIsICJfaW50MTZSYW5nZSIsICJfYWxpZ25QaXhlbCIsICJnZXREZWNpbWFsRm9yUGl4ZWwiLCAiZ2V0QmFzZVZhbHVlIiwgIm9wdGlvblRpY2tzIiwgInJvdCIsICJhdXRvU2tpcFBhZGRpbmciLCAiX2NvbXB1dGVHcmlkTGluZUl0ZW1zIiwgInRsIiwgImJvcmRlck9wdHMiLCAiYXhpc1dpZHRoIiwgImF4aXNIYWxmV2lkdGgiLCAiYWxpZ25Cb3JkZXJWYWx1ZSIsICJib3JkZXJWYWx1ZSIsICJhbGlnbmVkTGluZVZhbHVlIiwgInR4MSIsICJ0eTEiLCAidHgyIiwgInR5MiIsICJ4MSIsICJ5MSIsICJ4MiIsICJ5MiIsICJsaW1pdCIsICJzdGVwIiwgIm9wdHNBdEluZGV4IiwgIm9wdHNBdEluZGV4Qm9yZGVyIiwgImxpbmVDb2xvciIsICJib3JkZXJEYXNoIiwgImRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJkYXNoT2Zmc2V0IiwgInRpY2tDb2xvciIsICJ0aWNrQm9yZGVyRGFzaCIsICJ0aWNrQm9yZGVyRGFzaE9mZnNldCIsICJjcm9zc0FsaWduIiwgInRpY2tBbmRQYWRkaW5nIiwgImhUaWNrQW5kUGFkZGluZyIsICJ0ZXh0QWxpZ24iLCAibGluZUNvdW50IiwgInRleHRPZmZzZXQiLCAidGV4dEJhc2VsaW5lIiwgIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50IiwgIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwgImxhYmVsT2Zmc2V0IiwgImhhbGZDb3VudCIsICJzdHJva2VDb2xvciIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAic3Ryb2tlV2lkdGgiLCAidGV4dFN0cm9rZVdpZHRoIiwgInRpY2tUZXh0QWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3AiLCAibGFiZWxQYWRkaW5nIiwgImJhY2tkcm9wUGFkZGluZyIsICJiYWNrZHJvcENvbG9yIiwgInRyYW5zbGF0aW9uIiwgIl9jb21wdXRlTGFiZWxBcmVhIiwgImRyYXdCYWNrZ3JvdW5kIiwgInNhdmUiLCAiZmlsbFJlY3QiLCAicmVzdG9yZSIsICJkcmF3R3JpZCIsICJkcmF3TGluZSIsICJwMSIsICJwMiIsICJzZXRMaW5lRGFzaCIsICJsaW5lRGFzaE9mZnNldCIsICJiZWdpblBhdGgiLCAibW92ZVRvIiwgImxpbmVUbyIsICJzdHJva2UiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdCb3JkZXIiLCAibGFzdExpbmVXaWR0aCIsICJkcmF3TGFiZWxzIiwgImNsaXBBcmVhIiwgInJlbmRlclRleHRPcHRpb25zIiwgInJlbmRlclRleHQiLCAidW5jbGlwQXJlYSIsICJkcmF3VGl0bGUiLCAidHoiLCAiZ3oiLCAiYnoiLCAiYXhpc0lEIiwgIl9tYXhEaWdpdHMiLCAiZm9udFNpemUiLCAiVHlwZWRSZWdpc3RyeSIsICJzY29wZSIsICJjcmVhdGUiLCAiaXNGb3JUeXBlIiwgImlzUHJvdG90eXBlT2YiLCAicmVnaXN0ZXIiLCAicHJvdG8iLCAiZ2V0UHJvdG90eXBlT2YiLCAicGFyZW50U2NvcGUiLCAiaXNJQ2hhcnRDb21wb25lbnQiLCAicmVnaXN0ZXJEZWZhdWx0cyIsICJ1bnJlZ2lzdGVyIiwgIml0ZW1EZWZhdWx0cyIsICJtZXJnZSIsICJyb3V0ZURlZmF1bHRzIiwgImRlc2NyaWJlIiwgInJvdXRlcyIsICJwcm9wZXJ0eSIsICJwcm9wZXJ0eVBhcnRzIiwgInNwbGl0IiwgInNvdXJjZU5hbWUiLCAic291cmNlU2NvcGUiLCAiam9pbiIsICJwYXJ0cyIsICJ0YXJnZXROYW1lIiwgInRhcmdldFNjb3BlIiwgInJvdXRlIiwgIlJlZ2lzdHJ5IiwgImNvbnRyb2xsZXJzIiwgIl90eXBlZFJlZ2lzdHJpZXMiLCAiX2VhY2giLCAiYWRkQ29udHJvbGxlcnMiLCAiYWRkUGx1Z2lucyIsICJhZGRTY2FsZXMiLCAiZ2V0Q29udHJvbGxlciIsICJfZ2V0IiwgImdldFBsdWdpbiIsICJnZXRTY2FsZSIsICJyZW1vdmVDb250cm9sbGVycyIsICJyZW1vdmVFbGVtZW50cyIsICJyZW1vdmVQbHVnaW5zIiwgInJlbW92ZVNjYWxlcyIsICJ0eXBlZFJlZ2lzdHJ5IiwgImFyZyIsICJyZWciLCAiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsICJfZXhlYyIsICJpdGVtUmVnIiwgImNvbXBvbmVudCIsICJjYW1lbE1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJQbHVnaW5TZXJ2aWNlIiwgIl9pbml0IiwgIm5vdGlmeSIsICJob29rIiwgIl9jcmVhdGVEZXNjcmlwdG9ycyIsICJfZGVzY3JpcHRvcnMiLCAiZGVzY3JpcHRvciIsICJwbHVnaW4iLCAiY2FsbENhbGxiYWNrIiwgImNhbmNlbGFibGUiLCAiaW52YWxpZGF0ZSIsICJfb2xkQ2FjaGUiLCAiX25vdGlmeVN0YXRlQ2hhbmdlcyIsICJhbGxQbHVnaW5zIiwgImNyZWF0ZURlc2NyaXB0b3JzIiwgInByZXZpb3VzRGVzY3JpcHRvcnMiLCAic29tZSIsICJsb2NhbElkcyIsICJsb2NhbCIsICJnZXRPcHRzIiwgInBsdWdpbk9wdHMiLCAicGx1Z2luU2NvcGVLZXlzIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgImFsbEtleXMiLCAiZ2V0SW5kZXhBeGlzIiwgImRhdGFzZXREZWZhdWx0cyIsICJkYXRhc2V0T3B0aW9ucyIsICJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwgImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCAiaWRNYXRjaGVzQXhpcyIsICJheGlzRnJvbVBvc2l0aW9uIiwgImRldGVybWluZUF4aXMiLCAic2NhbGVPcHRpb25zIiwgInRvTG93ZXJDYXNlIiwgImdldEF4aXNGcm9tRGF0YXNldCIsICJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCAiYm91bmREcyIsICJkIiwgIm1lcmdlU2NhbGVDb25maWciLCAiY2hhcnREZWZhdWx0cyIsICJjb25maWdTY2FsZXMiLCAiY2hhcnRJbmRleEF4aXMiLCAic2NhbGVDb25mIiwgImVycm9yIiwgIl9wcm94eSIsICJkZWZhdWx0SWQiLCAiZGVmYXVsdFNjYWxlT3B0aW9ucyIsICJtZXJnZUlmIiwgImRlZmF1bHRJRCIsICJpbml0T3B0aW9ucyIsICJpbml0RGF0YSIsICJpbml0Q29uZmlnIiwgImtleUNhY2hlIiwgImtleXNDYWNoZWQiLCAiU2V0IiwgImNhY2hlZEtleXMiLCAiZ2VuZXJhdGUiLCAiYWRkSWZGb3VuZCIsICJDb25maWciLCAiX2NvbmZpZyIsICJfc2NvcGVDYWNoZSIsICJfcmVzb2x2ZXJDYWNoZSIsICJwbGF0Zm9ybSIsICJjbGVhckNhY2hlIiwgImNsZWFyIiwgImRhdGFzZXRUeXBlIiwgImFkZGl0aW9uYWxPcHRpb25TY29wZXMiLCAiX2NhY2hlZFNjb3BlcyIsICJtYWluU2NvcGUiLCAicmVzZXRDYWNoZSIsICJrZXlMaXN0cyIsICJjaGFydE9wdGlvblNjb3BlcyIsICJyZXNvbHZlciIsICJzdWJQcmVmaXhlcyIsICJnZXRSZXNvbHZlciIsICJuZWVkQ29udGV4dCIsICJpc0Z1bmN0aW9uIiwgInN1YlJlc29sdmVyIiwgIl9hdHRhY2hDb250ZXh0IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJyZXNvbHZlckNhY2hlIiwgIl9jcmVhdGVSZXNvbHZlciIsICJwIiwgImhhc0Z1bmN0aW9uIiwgImlzU2NyaXB0YWJsZSIsICJpc0luZGV4YWJsZSIsICJLTk9XTl9QT1NJVElPTlMiLCAicG9zaXRpb25Jc0hvcml6b250YWwiLCAiY29tcGFyZTJMZXZlbCIsICJsMSIsICJsMiIsICJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsICJvbkNvbXBsZXRlIiwgIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCAib25Qcm9ncmVzcyIsICJnZXRDYW52YXMiLCAiZ2V0RWxlbWVudEJ5SWQiLCAiaW5zdGFuY2VzIiwgImdldENoYXJ0IiwgImMiLCAibW92ZU51bWVyaWNLZXlzIiwgImludEtleSIsICJkZXRlcm1pbmVMYXN0RXZlbnQiLCAibGFzdEV2ZW50IiwgImluQ2hhcnRBcmVhIiwgImlzQ2xpY2siLCAiZ2V0U2l6ZUZvckFyZWEiLCAiZmllbGQiLCAiZ2V0RGF0YXNldEFyZWEiLCAiQ2hhcnQiLCAiaW52YWxpZGF0ZVBsdWdpbnMiLCAidXNlckNvbmZpZyIsICJpbml0aWFsQ2FudmFzIiwgImV4aXN0aW5nQ2hhcnQiLCAidWlkIiwgIl9vcHRpb25zIiwgIl9hc3BlY3RSYXRpbyIsICJfbWV0YXNldHMiLCAiX2xhc3RFdmVudCIsICJfbGlzdGVuZXJzIiwgIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwgIl9zb3J0ZWRNZXRhc2V0cyIsICJfcGx1Z2lucyIsICJfaGlkZGVuSW5kaWNlcyIsICJhdHRhY2hlZCIsICJfZG9SZXNpemUiLCAiZGVib3VuY2UiLCAicmVzaXplRGVsYXkiLCAiX2luaXRpYWxpemUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJyZXNwb25zaXZlIiwgInJldGluYVNjYWxlIiwgImJpbmRFdmVudHMiLCAiY2xlYXJDYW52YXMiLCAiX3Jlc2l6ZSIsICJfcmVzaXplQmVmb3JlRHJhdyIsICJuZXdTaXplIiwgIm5ld1JhdGlvIiwgIm9uUmVzaXplIiwgInJlbmRlciIsICJlbnN1cmVTY2FsZXNIYXZlSURzIiwgInNjYWxlc09wdGlvbnMiLCAiYXhpc09wdGlvbnMiLCAiYnVpbGRPclVwZGF0ZVNjYWxlcyIsICJzY2FsZU9wdHMiLCAidXBkYXRlZCIsICJpc1JhZGlhbCIsICJkcG9zaXRpb24iLCAiZHR5cGUiLCAic2NhbGVUeXBlIiwgInNjYWxlQ2xhc3MiLCAiaGFzVXBkYXRlZCIsICJfdXBkYXRlTWV0YXNldHMiLCAiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsICJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCAiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwgIm5ld0NvbnRyb2xsZXJzIiwgIm9yZGVyIiwgInZpc2libGUiLCAiQ29udHJvbGxlckNsYXNzIiwgIl9yZXNldEVsZW1lbnRzIiwgImFuaW1zRGlzYWJsZWQiLCAiX3VwZGF0ZVNjYWxlcyIsICJfY2hlY2tFdmVudEJpbmRpbmdzIiwgIl91cGRhdGVIaWRkZW5JbmRpY2VzIiwgIl9taW5QYWRkaW5nIiwgImF1dG9QYWRkaW5nIiwgIl91cGRhdGVMYXlvdXQiLCAiX3VwZGF0ZURhdGFzZXRzIiwgIl9ldmVudEhhbmRsZXIiLCAiX3VwZGF0ZUhvdmVyU3R5bGVzIiwgImV4aXN0aW5nRXZlbnRzIiwgIm5ld0V2ZW50cyIsICJldmVudHMiLCAic2V0c0VxdWFsIiwgInVuYmluZEV2ZW50cyIsICJjaGFuZ2VzIiwgIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCAiZGF0YXNldENvdW50IiwgIm1ha2VTZXQiLCAiY2hhbmdlU2V0IiwgIm5vQXJlYSIsICJfaWR4IiwgIl91cGRhdGVEYXRhc2V0IiwgImxheWVycyIsICJfZHJhd0RhdGFzZXRzIiwgIl9kcmF3RGF0YXNldCIsICJ1c2VDbGlwIiwgImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCAiSW50ZXJhY3Rpb24iLCAic2V0RGF0YXNldFZpc2liaWxpdHkiLCAiX3VwZGF0ZVZpc2liaWxpdHkiLCAiaGlkZSIsICJzaG93IiwgIl9zdG9wIiwgImRlc3Ryb3kiLCAidG9CYXNlNjRJbWFnZSIsICJ0b0RhdGFVUkwiLCAiYmluZFVzZXJFdmVudHMiLCAiYmluZFJlc3BvbnNpdmVFdmVudHMiLCAiX2FkZCIsICJfcmVtb3ZlIiwgImRldGFjaGVkIiwgInVwZGF0ZUhvdmVyU3R5bGUiLCAicHJlZml4IiwgImdldEFjdGl2ZUVsZW1lbnRzIiwgInNldEFjdGl2ZUVsZW1lbnRzIiwgImFjdGl2ZUVsZW1lbnRzIiwgImxhc3RBY3RpdmUiLCAiX2VsZW1lbnRzRXF1YWwiLCAicGx1Z2luSWQiLCAicmVwbGF5IiwgImhvdmVyT3B0aW9ucyIsICJob3ZlciIsICJkZWFjdGl2YXRlZCIsICJhY3RpdmF0ZWQiLCAiZXZlbnRGaWx0ZXIiLCAiX2hhbmRsZUV2ZW50IiwgIl9nZXRBY3RpdmVFbGVtZW50cyIsICJfaXNDbGlja0V2ZW50IiwgIm9uSG92ZXIiLCAidmVyc2lvbiIsICJjbGlwQXJjIiwgInBpeGVsTWFyZ2luIiwgImFuZ2xlTWFyZ2luIiwgImNsb3NlUGF0aCIsICJ0b1JhZGl1c0Nvcm5lcnMiLCAiX3JlYWRWYWx1ZVRvUHJvcHMiLCAicGFyc2VCb3JkZXJSYWRpdXMiLCAiYW5nbGVEZWx0YSIsICJvIiwgImJvcmRlclJhZGl1cyIsICJoYWxmVGhpY2tuZXNzIiwgImlubmVyTGltaXQiLCAiY29tcHV0ZU91dGVyTGltaXQiLCAib3V0ZXJBcmNMaW1pdCIsICJvdXRlclN0YXJ0IiwgIm91dGVyRW5kIiwgImlubmVyU3RhcnQiLCAiaW5uZXJFbmQiLCAiclRoZXRhVG9YWSIsICJ0aGV0YSIsICJwYXRoQXJjIiwgImlubmVyUiIsICJzcGFjaW5nT2Zmc2V0IiwgImFscGhhIiwgIm5vU3BhY2luZ0lubmVyUmFkaXVzIiwgIm5vU3BhY2luZ091dGVyUmFkaXVzIiwgImF2Tm9nU3BhY2luZ1JhZGl1cyIsICJhZGp1c3RlZEFuZ2xlIiwgImJldGEiLCAiYW5nbGVPZmZzZXQiLCAib3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzIiwgIm91dGVyRW5kQWRqdXN0ZWRSYWRpdXMiLCAib3V0ZXJTdGFydEFkanVzdGVkQW5nbGUiLCAib3V0ZXJFbmRBZGp1c3RlZEFuZ2xlIiwgImlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsICJpbm5lckVuZEFkanVzdGVkUmFkaXVzIiwgImlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwgImlubmVyRW5kQWRqdXN0ZWRBbmdsZSIsICJvdXRlck1pZEFkanVzdGVkQW5nbGUiLCAicENlbnRlciIsICJwNCIsICJpbm5lck1pZEFkanVzdGVkQW5nbGUiLCAicDgiLCAib3V0ZXJTdGFydFgiLCAib3V0ZXJTdGFydFkiLCAib3V0ZXJFbmRYIiwgIm91dGVyRW5kWSIsICJkcmF3QXJjIiwgImZ1bGxDaXJjbGVzIiwgImJvcmRlckpvaW5TdHlsZSIsICJpbm5lciIsICJsaW5lSm9pbiIsICJBcmNFbGVtZW50IiwgImNoYXJ0WCIsICJjaGFydFkiLCAickFkanVzdCIsICJub25aZXJvQmV0d2VlbiIsICJiZXR3ZWVuQW5nbGVzIiwgIndpdGhpblJhZGl1cyIsICJfaXNCZXR3ZWVuIiwgImhhbGZBbmdsZSIsICJoYWxmUmFkaXVzIiwgInRyYW5zbGF0ZSIsICJmaXgiLCAicmFkaXVzT2Zmc2V0IiwgInNldFN0eWxlIiwgImxpbmVDYXAiLCAiYm9yZGVyQ2FwU3R5bGUiLCAicHJldmlvdXMiLCAiZ2V0TGluZU1ldGhvZCIsICJzdGVwcGVkIiwgIl9zdGVwcGVkTGluZVRvIiwgInRlbnNpb24iLCAiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsICJfYmV6aWVyQ3VydmVUbyIsICJwYXRoVmFycyIsICJwYXJhbXNTdGFydCIsICJwYXJhbXNFbmQiLCAic2VnbWVudFN0YXJ0IiwgInNlZ21lbnRFbmQiLCAib3V0c2lkZSIsICJwYXRoU2VnbWVudCIsICJsaW5lTWV0aG9kIiwgImZhc3RQYXRoU2VnbWVudCIsICJhdmdYIiwgImNvdW50WCIsICJwcmV2WCIsICJsYXN0WSIsICJwb2ludEluZGV4IiwgImRyYXdYIiwgInRydW5jWCIsICJfZ2V0U2VnbWVudE1ldGhvZCIsICJ1c2VGYXN0UGF0aCIsICJfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZCIsICJfc3RlcHBlZEludGVycG9sYXRpb24iLCAiX2JlemllckludGVycG9sYXRpb24iLCAiX3BvaW50SW5MaW5lIiwgInN0cm9rZVBhdGhXaXRoQ2FjaGUiLCAicGF0aCIsICJfcGF0aCIsICJQYXRoMkQiLCAic3Ryb2tlUGF0aERpcmVjdCIsICJzZWdtZW50cyIsICJzZWdtZW50TWV0aG9kIiwgInVzZVBhdGgyRCIsICJMaW5lRWxlbWVudCIsICJfcG9pbnRzIiwgIl9zZWdtZW50cyIsICJfcG9pbnRzVXBkYXRlZCIsICJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsICJfY29tcHV0ZVNlZ21lbnRzIiwgImludGVycG9sYXRlIiwgIl9ib3VuZFNlZ21lbnRzIiwgIl9pbnRlcnBvbGF0ZSIsICJpbnRlcnBvbGF0ZWQiLCAiY2FwQmV6aWVyUG9pbnRzIiwgImhpdFJhZGl1cyIsICJQb2ludEVsZW1lbnQiLCAibW91c2VYIiwgIm1vdXNlWSIsICJpblhSYW5nZSIsICJpbllSYW5nZSIsICJob3ZlclJhZGl1cyIsICJkcmF3UG9pbnQiLCAiZ2V0QmFyQm91bmRzIiwgImJhciIsICJoYWxmIiwgInNraXBPckxpbWl0IiwgInBhcnNlQm9yZGVyV2lkdGgiLCAibWF4VyIsICJtYXhIIiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgIm1heFIiLCAiZW5hYmxlQm9yZGVyIiwgInRvcExlZnQiLCAidG9wUmlnaHQiLCAiYm90dG9tTGVmdCIsICJib3R0b21SaWdodCIsICJib3VuZGluZ1JlY3RzIiwgImJvdW5kcyIsICJvdXRlciIsICJza2lwWCIsICJza2lwWSIsICJza2lwQm90aCIsICJoYXNSYWRpdXMiLCAiYWRkTm9ybWFsUmVjdFBhdGgiLCAicmVjdCIsICJpbmZsYXRlUmVjdCIsICJhbW91bnQiLCAicmVmUmVjdCIsICJCYXJFbGVtZW50IiwgImFkZFJlY3RQYXRoIiwgImFkZFJvdW5kZWRSZWN0UGF0aCIsICJCT1JERVJfQ09MT1JTIiwgIkJBQ0tHUk9VTkRfQ09MT1JTIiwgInJlcGxhY2UiLCAiZ2V0Qm9yZGVyQ29sb3IiLCAiZ2V0QmFja2dyb3VuZENvbG9yIiwgImNvbG9yaXplRGVmYXVsdERhdGFzZXQiLCAiY29sb3JpemVEb3VnaG51dERhdGFzZXQiLCAiY29sb3JpemVQb2xhckFyZWFEYXRhc2V0IiwgImdldENvbG9yaXplciIsICJjb250YWluc0NvbG9yc0RlZmluaXRpb25zIiwgImsiLCAiY29udGFpbnNDb2xvcnNEZWZpbml0aW9uIiwgImNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zIiwgImZvcmNlT3ZlcnJpZGUiLCAiX2FyZ3MiLCAiY2hhcnRPcHRpb25zIiwgImNvbnRhaW5zQ29sb3JEZWZlbml0aW9uIiwgImNvbG9yaXplciIsICJsdHRiRGVjaW1hdGlvbiIsICJzYW1wbGVzIiwgImRlY2ltYXRlZCIsICJidWNrZXRXaWR0aCIsICJzYW1wbGVkSW5kZXgiLCAiZW5kSW5kZXgiLCAibWF4QXJlYVBvaW50IiwgIm1heEFyZWEiLCAibmV4dEEiLCAiYXZnWSIsICJhdmdSYW5nZVN0YXJ0IiwgImF2Z1JhbmdlRW5kIiwgImF2Z1JhbmdlTGVuZ3RoIiwgInJhbmdlT2ZmcyIsICJyYW5nZVRvIiwgInBvaW50QXgiLCAicG9pbnRBeSIsICJtaW5NYXhEZWNpbWF0aW9uIiwgIm1pbkluZGV4IiwgIm1heEluZGV4IiwgInN0YXJ0SW5kZXgiLCAieE1pbiIsICJ4TWF4IiwgImR4IiwgImxhc3RJbmRleCIsICJpbnRlcm1lZGlhdGVJbmRleDEiLCAiaW50ZXJtZWRpYXRlSW5kZXgyIiwgImNsZWFuRGVjaW1hdGVkRGF0YXNldCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZW51bWVyYWJsZSIsICJ3cml0YWJsZSIsICJjbGVhbkRlY2ltYXRlZERhdGEiLCAiZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQiLCAicG9pbnRDb3VudCIsICJhbGdvcml0aG0iLCAiYmVmb3JlRWxlbWVudHNVcGRhdGUiLCAieEF4aXMiLCAidGhyZXNob2xkIiwgInRwb2ludHMiLCAiX2ZpbmRTZWdtZW50RW5kIiwgIl9nZXRCb3VuZHMiLCAidGFyZ2V0U2VnbWVudHMiLCAidGd0IiwgInN1YkJvdW5kcyIsICJmaWxsU291cmNlcyIsICJfYm91bmRTZWdtZW50IiwgImZpbGxTb3VyY2UiLCAiX2dldEVkZ2UiLCAiX25vcm1hbGl6ZUFuZ2xlIiwgIl9wb2ludHNGcm9tU2VnbWVudHMiLCAiYm91bmRhcnkiLCAibGluZVBvaW50cyIsICJfY3JlYXRlQm91bmRhcnlMaW5lIiwgIl9zaG91bGRBcHBseUZpbGwiLCAiX3Jlc29sdmVUYXJnZXQiLCAic291cmNlcyIsICJwcm9wYWdhdGUiLCAidmlzaXRlZCIsICJfZGVjb2RlRmlsbCIsICJwYXJzZUZpbGxPcHRpb24iLCAicGFyc2VGbG9hdCIsICJkZWNvZGVUYXJnZXRJbmRleCIsICJmaXJzdENoIiwgIl9nZXRUYXJnZXRQaXhlbCIsICJfZ2V0VGFyZ2V0VmFsdWUiLCAiZmlsbE9wdGlvbiIsICJfYnVpbGRTdGFja0xpbmUiLCAic291cmNlUG9pbnRzIiwgImxpbmVzQmVsb3ciLCAiZ2V0TGluZXNCZWxvdyIsICJhZGRQb2ludHNCZWxvdyIsICJiZWxvdyIsICJ1bnNoaWZ0IiwgInNvdXJjZVBvaW50IiwgInBvc3Rwb25lZCIsICJmaW5kUG9pbnQiLCAicG9pbnRWYWx1ZSIsICJmaXJzdFZhbHVlIiwgImxhc3RWYWx1ZSIsICJzaW1wbGVBcmMiLCAiX2dldFRhcmdldCIsICJnZXRMaW5lQnlJbmRleCIsICJjb21wdXRlQm91bmRhcnkiLCAiY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkiLCAiY29tcHV0ZUxpbmVhckJvdW5kYXJ5IiwgIl9kcmF3ZmlsbCIsICJsaW5lT3B0cyIsICJhYm92ZSIsICJkb0ZpbGwiLCAiY2xpcFZlcnRpY2FsIiwgImNsaXBZIiwgImxpbmVMb29wIiwgInNyYyIsICJub3RTaGFwZSIsICJjbGlwQm91bmRzIiwgImludGVycG9sYXRlZExpbmVUbyIsICJ0YXJnZXRMb29wIiwgImludGVycG9sYXRlZFBvaW50IiwgImFmdGVyRGF0YXNldHNVcGRhdGUiLCAiJGZpbGxlciIsICJiZWZvcmVEcmF3IiwgImRyYXdUaW1lIiwgImJlZm9yZURhdGFzZXRzRHJhdyIsICJiZWZvcmVEYXRhc2V0RHJhdyIsICJnZXRCb3hTaXplIiwgImxhYmVsT3B0cyIsICJib3hIZWlnaHQiLCAiYm94V2lkdGgiLCAidXNlUG9pbnRTdHlsZSIsICJwb2ludFN0eWxlV2lkdGgiLCAiaXRlbUhlaWdodCIsICJpdGVtc0VxdWFsIiwgIkxlZ2VuZCIsICJfYWRkZWQiLCAibGVnZW5kSGl0Qm94ZXMiLCAiX2hvdmVyZWRJdGVtIiwgImRvdWdobnV0TW9kZSIsICJsZWdlbmRJdGVtcyIsICJjb2x1bW5TaXplcyIsICJsaW5lV2lkdGhzIiwgImJ1aWxkTGFiZWxzIiwgImxhYmVsRm9udCIsICJfY29tcHV0ZVRpdGxlSGVpZ2h0IiwgIl9maXRSb3dzIiwgIl9maXRDb2xzIiwgImhpdGJveGVzIiwgInRvdGFsSGVpZ2h0IiwgInJvdyIsICJpdGVtV2lkdGgiLCAibWVhc3VyZVRleHQiLCAiX2l0ZW1IZWlnaHQiLCAiaGVpZ2h0TGltaXQiLCAidG90YWxXaWR0aCIsICJjdXJyZW50Q29sV2lkdGgiLCAiY3VycmVudENvbEhlaWdodCIsICJjb2wiLCAiY2FsY3VsYXRlSXRlbVNpemUiLCAiYWRqdXN0SGl0Qm94ZXMiLCAicnRsIiwgInJ0bEhlbHBlciIsICJnZXRSdGxBZGFwdGVyIiwgImhpdGJveCIsICJsZWZ0Rm9yTHRyIiwgIl9kcmF3IiwgImRlZmF1bHRDb2xvciIsICJoYWxmRm9udFNpemUiLCAiY3Vyc29yIiwgImRyYXdMZWdlbmRCb3giLCAibGluZURhc2giLCAiZHJhd09wdGlvbnMiLCAiU1FSVDIiLCAieFBsdXMiLCAiZHJhd1BvaW50TGVnZW5kIiwgInlCb3hUb3AiLCAieEJveExlZnQiLCAiZmlsbFRleHQiLCAic3RyaWtldGhyb3VnaCIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAidGV4dERpcmVjdGlvbiIsICJ0ZXh0V2lkdGgiLCAic2V0V2lkdGgiLCAicmVhbFgiLCAiX3RleHRYIiwgImZvbnRMaW5lSGVpZ2h0IiwgImNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCAicmVzdG9yZVRleHREaXJlY3Rpb24iLCAidGl0bGVGb250IiwgInRpdGxlUGFkZGluZyIsICJ0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSIsICJfZ2V0TGVnZW5kSXRlbUF0IiwgImhpdEJveCIsICJsaCIsICJoYW5kbGVFdmVudCIsICJpc0xpc3RlbmVkIiwgImhvdmVyZWRJdGVtIiwgInNhbWVJdGVtIiwgIm9uTGVhdmUiLCAiY2FsY3VsYXRlSXRlbVdpZHRoIiwgImNhbGN1bGF0ZUl0ZW1IZWlnaHQiLCAibGVnZW5kSXRlbVRleHQiLCAiX2VsZW1lbnQiLCAiYWZ0ZXJFdmVudCIsICJjaSIsICJ1c2VCb3JkZXJSYWRpdXMiLCAiVGl0bGUiLCAiX3BhZGRpbmciLCAidGV4dFNpemUiLCAiX2RyYXdBcmdzIiwgImZvbnRPcHRzIiwgImNyZWF0ZVRpdGxlIiwgInRpdGxlQmxvY2siLCAiV2Vha01hcCIsICJwb3NpdGlvbmVycyIsICJhdmVyYWdlIiwgInhTZXQiLCAieEF2ZXJhZ2UiLCAiZXZlbnRQb3NpdGlvbiIsICJuZWFyZXN0RWxlbWVudCIsICJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCAidHAiLCAicHVzaE9yQ29uY2F0IiwgInRvUHVzaCIsICJhcHBseSIsICJzcGxpdE5ld2xpbmVzIiwgInN0ciIsICJTdHJpbmciLCAiY3JlYXRlVG9vbHRpcEl0ZW0iLCAiZm9ybWF0dGVkVmFsdWUiLCAiZ2V0VG9vbHRpcFNpemUiLCAidG9vbHRpcCIsICJib2R5IiwgImZvb3RlciIsICJib2R5Rm9udCIsICJmb290ZXJGb250IiwgInRpdGxlTGluZUNvdW50IiwgImZvb3RlckxpbmVDb3VudCIsICJib2R5TGluZUl0ZW1Db3VudCIsICJjb21iaW5lZEJvZHlMZW5ndGgiLCAiYm9keUl0ZW0iLCAiYmVmb3JlIiwgImFmdGVyIiwgImJlZm9yZUJvZHkiLCAiYWZ0ZXJCb2R5IiwgInRpdGxlU3BhY2luZyIsICJ0aXRsZU1hcmdpbkJvdHRvbSIsICJib2R5TGluZUhlaWdodCIsICJkaXNwbGF5Q29sb3JzIiwgImJvZHlTcGFjaW5nIiwgImZvb3Rlck1hcmdpblRvcCIsICJmb290ZXJTcGFjaW5nIiwgIndpZHRoUGFkZGluZyIsICJtYXhMaW5lV2lkdGgiLCAiZGV0ZXJtaW5lWUFsaWduIiwgImRvZXNOb3RGaXRXaXRoQWxpZ24iLCAieEFsaWduIiwgImNhcmV0IiwgImNhcmV0U2l6ZSIsICJjYXJldFBhZGRpbmciLCAiZGV0ZXJtaW5lWEFsaWduIiwgInlBbGlnbiIsICJjaGFydFdpZHRoIiwgImRldGVybWluZUFsaWdubWVudCIsICJhbGlnblgiLCAiYWxpZ25ZIiwgInBhZGRpbmdBbmRTaXplIiwgImdldEJhY2tncm91bmRQb2ludCIsICJhbGlnbm1lbnQiLCAiY29ybmVyUmFkaXVzIiwgImdldEFsaWduZWRYIiwgImdldEJlZm9yZUFmdGVyQm9keUxpbmVzIiwgImNyZWF0ZVRvb2x0aXBDb250ZXh0IiwgInRvb2x0aXBJdGVtcyIsICJvdmVycmlkZUNhbGxiYWNrcyIsICJkZWZhdWx0Q2FsbGJhY2tzIiwgImJlZm9yZVRpdGxlIiwgIm5vb3AiLCAibGFiZWxDb3VudCIsICJhZnRlclRpdGxlIiwgImJlZm9yZUxhYmVsIiwgInRvb2x0aXBJdGVtIiwgImxhYmVsQ29sb3IiLCAibGFiZWxUZXh0Q29sb3IiLCAiYm9keUNvbG9yIiwgImxhYmVsUG9pbnRTdHlsZSIsICJhZnRlckxhYmVsIiwgImJlZm9yZUZvb3RlciIsICJhZnRlckZvb3RlciIsICJpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayIsICJUb29sdGlwIiwgIm9wYWNpdHkiLCAiX2V2ZW50UG9zaXRpb24iLCAiX3NpemUiLCAiX2NhY2hlZEFuaW1hdGlvbnMiLCAiX3Rvb2x0aXBJdGVtcyIsICJkYXRhUG9pbnRzIiwgImNhcmV0WCIsICJjYXJldFkiLCAibGFiZWxDb2xvcnMiLCAibGFiZWxQb2ludFN0eWxlcyIsICJsYWJlbFRleHRDb2xvcnMiLCAiZ2V0VGl0bGUiLCAiZ2V0QmVmb3JlQm9keSIsICJnZXRCb2R5IiwgImJvZHlJdGVtcyIsICJzY29wZWQiLCAiZ2V0QWZ0ZXJCb2R5IiwgImdldEZvb3RlciIsICJfY3JlYXRlSXRlbXMiLCAiaXRlbVNvcnQiLCAicG9zaXRpb25BbmRTaXplIiwgImJhY2tncm91bmRQb2ludCIsICJleHRlcm5hbCIsICJkcmF3Q2FyZXQiLCAidG9vbHRpcFBvaW50IiwgImNhcmV0UG9zaXRpb24iLCAiZ2V0Q2FyZXRQb3NpdGlvbiIsICJ4MyIsICJ5MyIsICJwdFgiLCAicHRZIiwgInB0IiwgInRpdGxlQ29sb3IiLCAiX2RyYXdDb2xvckJveCIsICJjb2xvclgiLCAicnRsQ29sb3JYIiwgInlPZmZTZXQiLCAiY29sb3JZIiwgIm11bHRpS2V5QmFja2dyb3VuZCIsICJvdXRlclgiLCAiaW5uZXJYIiwgInN0cm9rZVJlY3QiLCAiZHJhd0JvZHkiLCAiYm9keUFsaWduIiwgInhMaW5lUGFkZGluZyIsICJmaWxsTGluZU9mVGV4dCIsICJib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiIsICJ0ZXh0Q29sb3IiLCAiZHJhd0Zvb3RlciIsICJmb290ZXJBbGlnbiIsICJmb290ZXJDb2xvciIsICJ0b29sdGlwU2l6ZSIsICJxdWFkcmF0aWNDdXJ2ZVRvIiwgIl91cGRhdGVBbmltYXRpb25UYXJnZXQiLCAiYW5pbVgiLCAiYW5pbVkiLCAiX3dpbGxSZW5kZXIiLCAiaGFzVG9vbHRpcENvbnRlbnQiLCAiZ2xvYmFsQWxwaGEiLCAicG9zaXRpb25DaGFuZ2VkIiwgIl9wb3NpdGlvbkNoYW5nZWQiLCAiX2lnbm9yZVJlcGxheUV2ZW50cyIsICJhZnRlckluaXQiLCAiYWZ0ZXJEcmF3IiwgIl9mYWxsYmFjayIsICJhZGRJZlN0cmluZyIsICJhZGRlZExhYmVscyIsICJmaW5kT3JBZGRMYWJlbCIsICJsYXN0SW5kZXhPZiIsICJfZ2V0TGFiZWxGb3JWYWx1ZSIsICJDYXRlZ29yeVNjYWxlIiwgIl9zdGFydFZhbHVlIiwgIl92YWx1ZVJhbmdlIiwgIl9hZGRlZExhYmVscyIsICJhZGRlZCIsICJnZW5lcmF0ZVRpY2tzIiwgImdlbmVyYXRpb25PcHRpb25zIiwgImRhdGFSYW5nZSIsICJNSU5fU1BBQ0lORyIsICJwcmVjaXNpb24iLCAibWF4VGlja3MiLCAibWF4RGlnaXRzIiwgImluY2x1ZGVCb3VuZHMiLCAidW5pdCIsICJtYXhTcGFjZXMiLCAicm1pbiIsICJybWF4IiwgImNvdW50RGVmaW5lZCIsICJtaW5TcGFjaW5nIiwgIm5pY2VOdW0iLCAibmljZU1pbiIsICJuaWNlTWF4IiwgIm51bVNwYWNlcyIsICJhbG1vc3RXaG9sZSIsICJhbG1vc3RFcXVhbHMiLCAiZGVjaW1hbFBsYWNlcyIsICJfZGVjaW1hbFBsYWNlcyIsICJyZWxhdGl2ZUxhYmVsU2l6ZSIsICJ0aWNrVmFsdWUiLCAicmFkIiwgIkxpbmVhclNjYWxlQmFzZSIsICJfZW5kVmFsdWUiLCAiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsICJzZXRNaW4iLCAic2V0TWF4IiwgIm1pblNpZ24iLCAibWF4U2lnbiIsICJnZXRUaWNrTGltaXQiLCAic3RlcFNpemUiLCAiY29tcHV0ZVRpY2tMaW1pdCIsICJudW1lcmljR2VuZXJhdG9yT3B0aW9ucyIsICJfc2V0TWluQW5kTWF4QnlLZXkiLCAiTGluZWFyU2NhbGUiLCAiVGlja3MiLCAiZm9ybWF0dGVycyIsICJudW1lcmljIiwgImxvZzEwRmxvb3IiLCAibG9nMTAiLCAiY2hhbmdlRXhwb25lbnQiLCAibSIsICJpc01ham9yIiwgInRpY2tWYWwiLCAic3RlcHMiLCAicmFuZ2VFeHAiLCAicmFuZ2VTdGVwIiwgInN0YXJ0RXhwIiwgIm1pbkV4cCIsICJleHAiLCAic2lnbmlmaWNhbmQiLCAibGFzdFRpY2siLCAiTG9nYXJpdGhtaWNTY2FsZSIsICJfemVybyIsICJsb2dhcml0aG1pYyIsICJnZXRUaWNrQmFja2Ryb3BIZWlnaHQiLCAibWVhc3VyZUxhYmVsU2l6ZSIsICJfbG9uZ2VzdFRleHQiLCAiZGV0ZXJtaW5lTGltaXRzIiwgImZpdFdpdGhQb2ludExhYmVscyIsICJsaW1pdHMiLCAidmFsdWVDb3VudCIsICJfcG9pbnRMYWJlbHMiLCAicG9pbnRMYWJlbE9wdHMiLCAiYWRkaXRpb25hbEFuZ2xlIiwgImNlbnRlclBvaW50TGFiZWxzIiwgImdldFBvaW50TGFiZWxDb250ZXh0IiwgImdldFBvaW50UG9zaXRpb24iLCAiZHJhd2luZ0FyZWEiLCAicGxGb250IiwgImhMaW1pdHMiLCAidkxpbWl0cyIsICJ1cGRhdGVMaW1pdHMiLCAic2V0Q2VudGVyUG9pbnQiLCAiX3BvaW50TGFiZWxJdGVtcyIsICJidWlsZFBvaW50TGFiZWxJdGVtcyIsICJjcmVhdGVQb2ludExhYmVsSXRlbSIsICJpdGVtT3B0cyIsICJvdXRlckRpc3RhbmNlIiwgImV4dHJhIiwgInBvaW50TGFiZWxQb3NpdGlvbiIsICJ5Rm9yQW5nbGUiLCAiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCAibGVmdEZvclRleHRBbGlnbiIsICJpc05vdE92ZXJsYXBwZWQiLCAiYXBleGVzSW5BcmVhIiwgImRyYXdQb2ludExhYmVsQm94IiwgImJhY2tkcm9wTGVmdCIsICJiYWNrZHJvcFRvcCIsICJiYWNrZHJvcFdpZHRoIiwgImJhY2tkcm9wSGVpZ2h0IiwgImRyYXdQb2ludExhYmVscyIsICJwYXRoUmFkaXVzTGluZSIsICJkcmF3UmFkaXVzTGluZSIsICJncmlkTGluZU9wdHMiLCAiY3JlYXRlUG9pbnRMYWJlbENvbnRleHQiLCAiUmFkaWFsTGluZWFyU2NhbGUiLCAibGVmdE1vdmVtZW50IiwgInJpZ2h0TW92ZW1lbnQiLCAidG9wTW92ZW1lbnQiLCAiYm90dG9tTW92ZW1lbnQiLCAiYW5nbGVNdWx0aXBsaWVyIiwgInNjYWxpbmdGYWN0b3IiLCAiZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIiLCAic2NhbGVkRGlzdGFuY2UiLCAicG9pbnRMYWJlbCIsICJkaXN0YW5jZUZyb21DZW50ZXIiLCAiZ2V0QmFzZVBvc2l0aW9uIiwgImdldFBvaW50TGFiZWxQb3NpdGlvbiIsICJyb3RhdGUiLCAiYW5pbWF0ZSIsICJJTlRFUlZBTFMiLCAibWlsbGlzZWNvbmQiLCAiY29tbW9uIiwgInNlY29uZCIsICJtaW51dGUiLCAiaG91ciIsICJkYXkiLCAid2VlayIsICJtb250aCIsICJxdWFydGVyIiwgInllYXIiLCAiVU5JVFMiLCAic29ydGVyIiwgImlucHV0IiwgImFkYXB0ZXIiLCAiX2FkYXB0ZXIiLCAicGFyc2VyIiwgImlzb1dlZWtkYXkiLCAiX3BhcnNlT3B0cyIsICJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwgIm1pblVuaXQiLCAiY2FwYWNpdHkiLCAiaW50ZXJ2YWwiLCAiTUFYX1NBRkVfSU5URUdFUiIsICJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsICJkZXRlcm1pbmVNYWpvclVuaXQiLCAiYWRkVGljayIsICJ0aW1lIiwgInRpbWVzdGFtcHMiLCAiX2xvb2t1cCIsICJ0aW1lc3RhbXAiLCAic2V0TWFqb3JUaWNrcyIsICJtYWpvclVuaXQiLCAidGlja3NGcm9tVGltZXN0YW1wcyIsICJUaW1lU2NhbGUiLCAiX3VuaXQiLCAiX21ham9yVW5pdCIsICJfb2Zmc2V0cyIsICJfbm9ybWFsaXplZCIsICJhZGFwdGVycyIsICJkaXNwbGF5Rm9ybWF0cyIsICJub3JtYWxpemVkIiwgIl9hcHBseUJvdW5kcyIsICJfZ2V0TGFiZWxCb3VuZHMiLCAiZ2V0TGFiZWxUaW1lc3RhbXBzIiwgInRpbWVPcHRzIiwgIl9nZW5lcmF0ZSIsICJfZmlsdGVyQmV0d2VlbiIsICJfZ2V0TGFiZWxDYXBhY2l0eSIsICJpbml0T2Zmc2V0cyIsICJvZmZzZXRBZnRlckF1dG9za2lwIiwgImdldERlY2ltYWxGb3JWYWx1ZSIsICJtaW5vciIsICJ3ZWVrZGF5IiwgImhhc1dlZWtkYXkiLCAiZ2V0RGF0YVRpbWVzdGFtcHMiLCAidG9vbHRpcEZvcm1hdCIsICJkYXRldGltZSIsICJmbXQiLCAiX3RpY2tGb3JtYXRGdW5jdGlvbiIsICJmb3JtYXR0ZXIiLCAibWlub3JGb3JtYXQiLCAibWFqb3JGb3JtYXQiLCAib2Zmc2V0cyIsICJfZ2V0TGFiZWxTaXplIiwgInRpY2tzT3B0cyIsICJ0aWNrTGFiZWxXaWR0aCIsICJjb3NSb3RhdGlvbiIsICJzaW5Sb3RhdGlvbiIsICJ0aWNrRm9udFNpemUiLCAiZXhhbXBsZVRpbWUiLCAiZXhhbXBsZUxhYmVsIiwgIm5vcm1hbGl6ZSIsICJ0YWJsZSIsICJwcmV2U291cmNlIiwgIm5leHRTb3VyY2UiLCAicHJldlRhcmdldCIsICJuZXh0VGFyZ2V0IiwgInNwYW4iLCAiVGltZVNlcmllc1NjYWxlIiwgIl90YWJsZSIsICJfbWluUG9zIiwgIl90YWJsZVJhbmdlIiwgIl9nZXRUaW1lc3RhbXBzRm9yVGFibGUiLCAiYnVpbGRMb29rdXBUYWJsZSIsICJyZWdpc3RlcmFibGVzIiwgIkhvb2tzIiwgIm1hcCIsICJvcmRlcl9pdGVtcyIsICJ0b3BiYXIiXQp9Cg==
